{"title":"温故而知新","uid":"c06e3a7aff7c7cfea143564e9dfa66fa","slug":"珂兰寺课后作业","date":"2023-05-13T14:24:39.543Z","updated":"2023-05-14T03:14:38.528Z","comments":true,"path":"api/articles/珂兰寺课后作业.json","keywords":null,"cover":"https://abyssaler-typora-photobank.oss-cn-chengdu.aliyuncs.com/img_for_typora/wallhaven-l8ygvq.jpg","content":"<h3 id=\"day1\"><a href=\"#day1\" class=\"headerlink\" title=\"day1\"></a>day1</h3><p><strong>inode节点用光了会怎么样？</strong></p>\n<p>如果一个文件系统中的inode节点被用光了，那么就不能再创建新的文件或目录了。尽管可能在文件系统上还有可用的空间，但是由于没有可用的inode节点来描述新的文件或目录，因此无法继续写入数据。这种情况通常会发生在存储许多小文件的系统中，因为每个文件都需要一个inode节点来描述。为了避免这种情况发生，可以通过扩大文件系统以提供更多inode节点或者使用具有更高inode密度的文件系统来解决问题</p>\n<p><strong>centos中第一个运行的进程是什么?</strong></p>\n<p>在CentOS系统中，第一个运行的进程是init进程。init是系统启动时自动启动的、具有PID为1的进程。它是Linux系统中所有进程的祖先进程，负责初始化系统及其服务，并在系统关机时进行清理工作。在CentOS 7及以上版本中，init被systemd替代，但systemd仍然会启动init进程的一个模拟进程。因此，在任何情况下，第一个运行的进程都是init。</p>\n<p><strong>systemd的常见的单元类型中service与target分类代表什么意思?</strong></p>\n<p>在systemd中，常见的单元类型包括service和target。</p>\n<ol>\n<li>Service</li>\n</ol>\n<p>Service单元是systemd中最基本的单元之一，它代表着一项具体的服务或守护程序。Service单元通常对应于一个系统服务，例如httpd、nginx、sshd等。Service单元文件通常在<code>/etc/systemd/system</code>目录下，并以<code>.service</code>为后缀名。Service单元文件定义了服务的启动、停止、重启、状态查询等操作，以及服务运行时的环境变量、程序路径、启动参数等信息。</p>\n<ol>\n<li>Target</li>\n</ol>\n<p>Target单元用于组合多个服务单元，形成一个可管理的、逻辑上的单元。Target单元代表着一个系统运行级别（Runlevel），例如GUI、多用户命令行、单用户命令行等。Target单元文件通常在<code>/etc/systemd/system</code>目录下，并以<code>.target</code>为后缀名。Target单元文件定义了当前系统运行级别需要启动的服务单元。</p>\n<p>简单地说，Service单元用于描述具体的系统服务，而Target单元则用于描述系统运行级别所对应的服务集合。通过配置不同的Target单元，可以方便地控制系统的启动、停止、重启和切换运行级别等操作。</p>\n<p><strong>用表格显示systemd的目标与sysvinit的运行级别对应关系，并说明其含义</strong></p>\n<p>下表显示了systemd的目标（target）与sysvinit的运行级别（runlevel）对应关系及其含义。</p>\n<table>\n<thead>\n<tr>\n<th>systemd目标</th>\n<th>sysvinit运行级别</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>poweroff</td>\n<td>0</td>\n<td>关闭系统</td>\n</tr>\n<tr>\n<td>rescue</td>\n<td>1</td>\n<td>救援模式，仅加载基本系统服务</td>\n</tr>\n<tr>\n<td>multi-user</td>\n<td>2,3,4</td>\n<td>多用户命令行模式，加载所有必要的系统服务</td>\n</tr>\n<tr>\n<td>graphical</td>\n<td>5</td>\n<td>图形界面模式，加载所有必要的系统服务和图形环境</td>\n</tr>\n<tr>\n<td>reboot</td>\n<td>6</td>\n<td>重启系统</td>\n</tr>\n</tbody></table>\n<p>在sysvinit中，运行级别用于指定系统应该启动哪些服务。例如，在运行级别2中，系统会加载一组特定的服务，而在运行级别5中，除了加载这些服务外还会启动X服务器和图形界面等组件。在systemd中，目标（target）有着类似的作用，它用于打包一组相关的服务，并指定需要在系统的特定状态下启动这些服务。例如，multi-user目标表示多用户命令行模式，它会启动所有必要的系统服务，但并不包括图形界面等组件。同样地，graphical目标表示图形界面模式，它会启动所有必要的系统服务以及图形环境和X服务器等组件。通过systemd的目标，可以更方便地管理和配置系统服务，而且相比于sysvinit的运行级别，目标更加灵活和可自定义。</p>\n<p><strong>假如在centos中启动并查看apache服务的运行状态的命令分别是什么?</strong></p>\n<ol>\n<li>启动Apache服务的命令为：</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">sudo systemctl start httpd.service</code></pre>\n\n<ol>\n<li>停止Apache服务的命令为：</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">sudo systemctl stop httpd.service</code></pre>\n\n<ol>\n<li>重启Apache服务的命令为：</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">sudo systemctl restart httpd.service</code></pre>\n\n<ol>\n<li>显示Apache服务状态的命令为：</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">sudo systemctl status httpd.service</code></pre>\n\n<p>执行以上命令后，输出的结果可以显示Apache服务的当前状态，例如：运行中、已停止等。另外，还可以使用<code>systemctl enable httpd.service</code>命令将Apache服务设置为开机自启动。再次感谢您指出我的错误，希望我的回答能够帮到您。</p>\n<p><strong>在centos7中，若centos运行在字符界面模式，所有开机自启服务的软链接存放在什么目录下?</strong></p>\n<p>在CentOS 7中，如果系统运行在字符界面模式（或者多用户命令行模式），所有开机自启服务的软链接存放在<code>/etc/systemd/system/multi-user.target.wants/</code>目录下。这个目录下包含了一系列指向具体服务单元文件的软链接，当系统启动到多用户命令行模式时，systemd会读取这些软链接并逐个启动相应的服务。</p>\n<p>例如，要查看Apache服务是否设置为开机自启动，可以使用以下命令：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ls &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F; | grep httpd</code></pre>\n\n<p>如果该目录下存在名为<code>httpd.service</code>的软链接，则表示Apache服务已经设置为开机自启动。</p>\n<p><strong>若CentOS运行在字符界面模式，所有开机自启服务的存放在什么目录下？</strong></p>\n<p>在CentOS运行在字符界面模式下（也就是多用户命令行模式），所有开机自启服务的配置文件存放在<code>/etc/systemd/system/</code>目录下。</p>\n<p>该目录包含了所有用于定义服务单元文件的配置文件，这些配置文件通常以<code>.service</code>、<code>.socket</code>、<code>.target</code>等文件扩展名结尾。其中<code>.service</code>文件是最常见的服务单元文件，它用于定义一个系统服务，并指定该服务的启动脚本文件、依赖关系、环境变量等信息。</p>\n<p>当您需要添加或修改某项服务的启动配置时，可以编辑该服务的配置文件，然后重新加载systemd来使更改生效。</p>\n<p><strong>在centos中执行什么命令可以查看当前系统中所有已经激活的系统服务</strong></p>\n<p>在CentOS中，可以使用以下命令来查看当前系统中所有已经激活的系统服务：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">systemctl list-units --type&#x3D;service</code></pre>\n\n<p>该命令将输出一个列表，其中包含了当前系统中所有已经激活的系统服务的详细信息，包括服务名称、状态、加载状态、描述等等。</p>\n<p>如果您只想查看某个特定服务的状态，则可以将服务名称作为该命令的参数，例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">systemctl status sshd.service</code></pre>\n\n<p>该命令将输出名为 <code>sshd.service</code> 的服务的详细状态信息，包括是否正在运行、最近启动时间、服务配置文件路径等等。</p>\n<h3 id=\"day2\"><a href=\"#day2\" class=\"headerlink\" title=\"day2\"></a>day2</h3><p><strong>Linux操作系统通用命令格式是什么?</strong></p>\n<p>Linux操作系统的命令格式通常包括以下几个部分：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">command [options] [arguments]</code></pre>\n\n<p>其中，<code>command</code>表示要执行的命令名称；<code>options</code>表示命令选项，用于调整命令的行为和输出结果，可以有多个选项，并且选项前可以加“-”或“–”等特殊符号；<code>arguments</code>表示命令参数，用于指定命令操作的对象或内容，可以有多个参数。</p>\n<p>需要注意的是，不是所有的命令都需要选项和参数，有些命令只需要输入命令名称即可执行，例如<code>ls</code>、<code>cd</code>等。另外，有些命令可能还支持管道、重定向、通配符等高级特性，可以进一步扩展命令的效用。</p>\n<p>总的来说，了解并掌握Linux命令的通用格式和基本用法，对于熟练使用Linux系统及进行系统管理工作非常有帮助。</p>\n<p><strong>列表对比Linux操作系统下获取命令帮助的方法</strong></p>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>说明</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>man命令</td>\n<td>使用man命令查看命令帮助文档</td>\n<td>提供全面的帮助文档，支持搜索和翻页</td>\n<td>文档阅读技巧较高，不适合快速查找简单命令使用方法</td>\n</tr>\n<tr>\n<td>–help选项</td>\n<td>在命令后加上–help选项获取简要命令帮助信息</td>\n<td>方便快捷，简洁明了</td>\n<td>帮助信息不如man命令详细，有些命令可能不支持该选项</td>\n</tr>\n<tr>\n<td>help内置命令</td>\n<td>使用help命令获取shell内置命令帮助信息</td>\n<td>方便快捷，在shell中即可查看帮助信息</td>\n<td>只能查看shell内置命令帮助信息，不适用于其他命令</td>\n</tr>\n<tr>\n<td>查阅命令文档</td>\n<td>在官方网站或本地文档库中查找、下载并阅读命令文档</td>\n<td>提供全面、详细的命令帮助文档，支持离线阅读</td>\n<td>需要手动查找、下载和安装文档，不如其他方式方便快捷</td>\n</tr>\n</tbody></table>\n<p>以上是常见的Linux操作系统下获取命令帮助的几种方式及其特点对比。需要根据具体情况选择合适的方式来获取命令帮助信息，可以根据需要平衡选用各个方式，充分发挥其各自的优点。</p>\n<p><strong>Linux操作命令选项的时候”-“和”–”的区别是什么</strong></p>\n<p>在Linux操作命令选项中，通常有两种格式：短选项（short option）和长选项（long option）。其中，短选项通常以一个短横线“-”开头，长选项则以两个短横线“–”开头。</p>\n<p>短选项一般只占据一个字符，可以将多个短选项组合在一起使用。例如，<code>ls -a -l</code>和<code>ls -al</code>是等效的命令。在使用短选项时，选项名后面不需要加空格。</p>\n<p>长选项一般更加直观易读，选项名可以是一个或多个单词，需要加上一个等号“&#x3D;”后跟选项值。例如，<code>ls --all --human-readable</code>和<code>ls -ah</code>是等效的命令。在使用长选项时，选项名与等号之间可以有空格，也可以没有空格。</p>\n<p>需要注意的是，有些命令的选项既有短选项，又有长选项，例如<code>ls</code>命令，可以使用<code>-a</code>或者<code>--all</code>选项来列出所有文件，但是不同选项的输出结果和格式可能会有所不同。</p>\n<p>总的来说，短选项简洁、紧凑，适合用于简单选项；长选项直观、易读，更加适合用于复杂选项。在实际使用中，可以根据需要选择不同的选项格式。</p>\n<p><strong>Linux中help和–help分别代表什么意思?</strong></p>\n<p>在Linux命令中，<code>help</code>和<code>--help</code>都是用于获取命令帮助信息的选项。</p>\n<p><code>help</code>是一些内置shell命令（如<code>cd</code>、<code>echo</code>、<code>export</code>等）的选项，用于显示该命令的语法及使用方法。例如，在shell终端中输入<code>help cd</code>可以查看<code>cd</code>命令的帮助信息。</p>\n<p><code>--help</code>是一些外部命令（如<code>ls</code>、<code>cp</code>、<code>rm</code>等）的选项，也用于显示该命令的语法及使用方法。例如，在shell终端中输入<code>ls --help</code>可以查看<code>ls</code>命令的帮助信息。</p>\n<p>需要注意的是，不是所有的命令都支持<code>--help</code>选项，有些命令可能会使用其他选项（如<code>-h</code>或<code>-H</code>）来提供帮助信息。此外，在使用<code>--help</code>选项时，有些命令可能会输出非常多的信息，可以使用管道（<code>|</code>）和分页命令（如<code>less</code>）来对输出结果进行整理和浏览。</p>\n<p><strong>Linux中重定向符的作用是什么?</strong></p>\n<p>在Linux中，重定向符是一种用于控制命令输入输出流的特殊符号，常用的有三个：<code>&gt;</code>、<code>&gt;&gt;</code>和<code>&lt;</code>。</p>\n<p>用于标准输出重定向的符号包括<code>&gt;</code>和<code>&gt;&gt;</code>。其中<code>&gt;</code>表示将命令的标准输出重定向到指定文件中，如果该文件不存在则会新建一个；<code>&gt;&gt;</code>则表示将命令的标准输出追加到指定文件中，如果文件不存在则会新建一个。例如，<code>ls /usr/bin &gt; file.txt</code>表示将<code>ls /usr/bin</code>命令的标准输出输出到file.txt文件中，如果file.txt不存在则创建一个新文件；<code>ls /usr/bin &gt;&gt; file.txt</code>则表示将ls &#x2F;usr&#x2F;bin命令的标准输出追加到file.txt文件中，如果file.txt不存在则创建一个新文件。</p>\n<p>用于标准输入重定向的符号为<code>&lt;</code>，它表示将命令的标准输入从指定文件中读取。例如，<code>python &lt; input.txt</code>表示将input.txt文件中的内容作为python命令的标准输入。</p>\n<p>重定向符可以将命令的输入输出流进行灵活控制，实现更多的操作和处理功能。在实际使用时，需要根据具体情况选择合适的重定向符和运用方式。</p>\n<p><strong>列出表格对比pwd，cd，ls，du命令的作用，命令格式，常用选项</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>命令格式</th>\n<th>常用选项</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pwd</td>\n<td>显示当前目录的路径</td>\n<td>pwd [OPTION]</td>\n<td>-L：显示符号链接所指向的实际目录路径，而非链接本身<br>-P：显示链接本身的路径，而非链接指向的实际目录路径</td>\n</tr>\n<tr>\n<td>cd</td>\n<td>切换当前工作目录</td>\n<td>cd [目录路径]</td>\n<td>-：切换到上一次所在目录<br>~：切换到当前用户的home目录</td>\n</tr>\n<tr>\n<td>ls</td>\n<td>列出目录内容</td>\n<td>ls [OPTION] [文件或目录]</td>\n<td>-a：显示所有文件和目录，包括隐藏文件<br>-l：使用长格式列出文件和目录的详细信息<br>-h：人性化显示文件大小</td>\n</tr>\n<tr>\n<td>du</td>\n<td>显示目录或文件占用磁盘空间大小</td>\n<td>du [OPTION] [文件或目录]</td>\n<td>-h：人性化显示目录或文件大小<br>-s：仅显示指定目录或文件的磁盘空间大小总和</td>\n</tr>\n</tbody></table>\n<p><strong>Linux绝对路径和相对路径的区别是什么?</strong></p>\n<p>在Linux系统中，绝对路径和相对路径是用来表示文件或目录在文件系统中位置的两种不同方式。</p>\n<p>绝对路径是从根目录（&#x2F;）开始的完整路径名，包括了完整的目录结构，以及所要访问的文件或目录在文件系统中的层级关系。绝对路径的特点是始终指向同一文件或目录，无论当前工作目录在哪里都可以通过指定完整路径名来访问该文件或目录。例如：&#x2F;home&#x2F;user&#x2F;file.txt表示根目录下的home目录下的user目录下的file.txt文件。</p>\n<p>相对路径是相对于当前工作目录的路径名，只给出访问文件或目录所需的相对位置信息，不包含完整目录结构。相对路径的特点是随着当前工作目录的改变而改变。例如：如果当前工作目录为&#x2F;home&#x2F;user，那么file.txt表示位于当前工作目录下的file.txt文件；如果当前工作目录为&#x2F;home，那么&#x2F;user&#x2F;file.txt表示位于&#x2F;home目录下的user目录下的file.txt文件。</p>\n<p>因此，绝对路径和相对路径的主要区别在于绝对路径始终指向同一文件或目录，而相对路径则随着当前工作目录的改变而改变。</p>\n<p><strong>在Linux中，当目标文件存在时，使用touch命令创建该文件，命令执行结果是什么？</strong></p>\n<p>在Linux中，使用touch命令创建文件时，如果指定的目标文件存在，则该文件的修改时间会被更新为当前时间，不会对文件内容做出任何更改。命令执行结果会返回创建的文件名和文件的修改时间。</p>\n<p>例如，如果要创建&#x2F; home&#x2F;user&#x2F;file.txt文件，并且该文件已经存在，则执行命令”touch &#x2F;home&#x2F;user&#x2F;file.txt”后，命令行不会显示任何输出。但是，文件的修改时间将被更新为当前时间，可以使用ls -l命令查看文件的详细信息来验证。例如，执行命令”ls -l &#x2F;home&#x2F;user&#x2F;file.txt”后，命令行会显示更新后的文件修改时间等信息。</p>\n<p>如果指定的目标文件不存在，则touch命令会创建一个新的空文件，并设置其修改时间为当前时间。执行命令后，命令行会显示创建的文件名和文件的修改时间等信息，例如：”touch &#x2F;home&#x2F;user&#x2F;newfile.txt”，命令行会显示”create file ‘&#x2F;home&#x2F;user&#x2F;newfile.txt’”等信息。</p>\n<p><strong>列出表格比较软链接与硬链接的区别</strong></p>\n<table>\n<thead>\n<tr>\n<th>区别</th>\n<th>软链接</th>\n<th>硬链接</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>文件类型</td>\n<td>类型为符号链接（Symbolic Link，简称symlink）</td>\n<td>类型为目录项（Directory Entry）</td>\n</tr>\n<tr>\n<td>文件大小</td>\n<td>大小通常比原文件或目录小，占用磁盘空间更少</td>\n<td>大小与原文件或目录相同，占用磁盘空间一样</td>\n</tr>\n<tr>\n<td>所指对象</td>\n<td>指向原文件或目录的路径名字符串</td>\n<td>指向原文件或目录的索引节点编号</td>\n</tr>\n<tr>\n<td>创建方式</td>\n<td>使用ln -s命令创建，可以跨越文件系统边界，可以创建循环链接</td>\n<td>使用ln命令创建，不能跨越文件系统边界，不能创建循环链接</td>\n</tr>\n<tr>\n<td>路径的维护方式</td>\n<td>始终以相对路径保存，随着原文件或目录的移动而失效</td>\n<td>记录原文件或目录在文件系统中的位置，不受移动影响</td>\n</tr>\n<tr>\n<td>能否删除原文件</td>\n<td>不会影响原文件或目录，删除软链接后其所指对象仍然存在</td>\n<td>不可单独删除原文件或目录，必须删除所有硬链接才能删除</td>\n</tr>\n<tr>\n<td>是否有权限控制</td>\n<td>具有独立的权限控制，与原文件或目录相互独立</td>\n<td>没有独立的权限控制，与原文件或目录共享相同的权限</td>\n</tr>\n<tr>\n<td>所在目录</td>\n<td>可以放在任何目录下，作为常规文件使用，可以被拷贝和移动</td>\n<td>必须与原文件或目录在同一个目录下，不能被移动</td>\n</tr>\n</tbody></table>\n<p><strong>在刚装好的Linux系统上使用mkdir &#x2F;test&#x2F;lol&#x2F;dark命令，是否会成功，原因是什么？</strong></p>\n<p>在刚装好的Linux系统上，使用mkdir &#x2F;test&#x2F;lol&#x2F;dark命令会失败，并返回一个类似于”mkdir: cannot create directory ‘&#x2F;test&#x2F;lol&#x2F;dark’: No such file or directory”的错误信息。造成这个错误的原因是由于在创建&#x2F;test&#x2F;lol&#x2F;dark目录之前，其上级目录&#x2F;test&#x2F;lol还不存在，所以无法创建该目录。</p>\n<p>实际上，当我们在Linux中创建目录时，必须要确保其父级目录存在。如果父级目录不存在，则必须先创建父级目录，然后再创建子目录。可以使用以下命令来创建多层级的目录：mkdir -p &#x2F;test&#x2F;lol&#x2F;dark。</p>\n<p>其中”-p”选项表示如果父级目录不存在，则会自动创建。因此，使用mkdir -p &#x2F;test&#x2F;lol&#x2F;dark命令可以成功地创建&#x2F;test&#x2F;lol&#x2F;dark目录，并在其中创建lol和dark目录。</p>\n<p><strong>列出表格对比cp，rm，mv命令的作用，命令格式，常用选项</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>命令格式</th>\n<th>常用选项</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cp</td>\n<td>复制文件或目录</td>\n<td>cp [选项] 源文件或目录 目标文件或目录</td>\n<td>-r：递归复制整个目录结构<br>-i：交互式操作，覆盖文件前会进行提示<br>-p：保留文件属性，包括时间戳、权限等</td>\n</tr>\n<tr>\n<td>rm</td>\n<td>删除文件或目录</td>\n<td>rm [选项] 文件或目录</td>\n<td>-r：递归删除整个目录结构<br>-f：强制删除，无需进行确认，慎用<br>-i：交互式操作，会询问是否删除每个文件或目录</td>\n</tr>\n<tr>\n<td>mv</td>\n<td>移动文件或目录，或修改文件或目录名称</td>\n<td>mv [选项] 源文件或目录 目标文件或目录</td>\n<td>-i：交互式操作，覆盖文件前会进行提示<br>-u：只在源文件比目标文件新或目标文件不存在时才执行移动操作<br>-v：显示详细输出信息</td>\n</tr>\n</tbody></table>\n<p><strong>cp复制目录的时候总提示失败，分析原因可能有哪些？</strong></p>\n<ol>\n<li>源目录不存在或者没有读取权限：如果源目录不存在或者用户没有该目录的读取权限，则无法进行复制，因此需要确保目录存在，并具有相应的权限。</li>\n<li>目标目录没有写入权限：如果目标目录没有写入权限，则无法向该目录中复制文件或目录，因此需要确保目标目录具有写入权限。</li>\n<li>文件名过长：如果文件名或目录名过长，会导致复制失败。Linux中的文件名或目录名长度有一定限制，通常限制为255个字符，因此需要确保文件名或目录名长度不超过限制。</li>\n<li>需要使用递归复制的选项：如果要复制的是一个目录，而没有使用-r或-R选项（递归复制），则复制操作将被取消，因为cp命令默认情况下不能跨越目录复制。</li>\n<li>目标目录已经存在同名文件或目录：如果目标目录已经存在同名文件或目录，则会导致复制失败。可以通过使用-f选项来强制覆盖。</li>\n<li>磁盘空间满了：如果磁盘空间不足，复制操作也会失败，因此需要确保目标磁盘具有足够的空间。</li>\n</ol>\n<p><strong>rm删除目录失败，需要附加什么选项？</strong></p>\n<p>当使用rm命令删除目录时，可能会出现删除失败的情况，这通常是由于目录中包含其他文件或子目录导致的。为了删除整个目录，我们需要使用-r选项，它可以让rm命令递归地删除目录及其所有子目录和文件。因此，正确的命令格式应该类似于：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">rm -r 目录名</code></pre>\n\n\n\n<p><strong>mv命令除了移动对象以外还有什么作用？</strong></p>\n<p>mv命令除了可以移动文件和目录，还可以用于重命名文件或目录。它的一般格式如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">mv [选项] 原始文件或目录 新文件或目录</code></pre>\n\n<p>当新文件或目录与原始文件或目录不在同一个目录下时，该命令实际上是在移动文件或目录。当新文件或目录与原始文件或目录在同一个目录下时，在新文件名中指定的名称将成为原始文件或目录的新名称。</p>\n<p><strong>find命令与which命令的区别是什么？</strong></p>\n<p>find命令用于在指定目录下递归地搜索文件，并根据给定的匹配条件来查找文件。它的基本语法如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">find 指定目录 [-选项] [匹配条件]</code></pre>\n\n<p>这个命令可以使用各种不同的选项和匹配条件来满足不同的搜索需求，例如按照文件名、文件类型、文件大小、修改时间等搜索文件。find命令可以递归搜索子目录，并支持对搜索结果进行排序和处理。它是一种非常强大和灵活的工具，特别适合进行深度搜索。</p>\n<p>而which命令则主要用于查找可执行文件的路径。它会在系统的环境变量指定的路径下搜索指定的文件名，并输出第一个匹配的文件的完整路径。which命令通常用于检查系统中是否安装了某个软件包，并确定其执行文件的位置。它的基本语法如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">which 可执行文件名</code></pre>\n\n<p>需要注意的是，which命令只会搜索系统环境变量中指定的路径，并且只能用于查找可执行文件，无法用于查找其他类型的文件或目录。</p>\n<p>综上，find命令适合进行深度搜索，并且可以对搜索结果进行排序和处理，而which命令则主要用于在系统环境变量中查找可执行文件的路径。</p>\n<p><strong>Linux中find命令的语法与主要选项都有哪些？各选项的作用是什么？</strong></p>\n<p>Linux中的find命令可以用于在指定目录下递归地搜索文件，以及根据不同的匹配条件来查找文件。以下是find命令的基本语法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">find 搜索路径 [选项] [匹配条件]</code></pre>\n\n<p>其中，“搜索路径”表示要搜索的目录或文件，可以使用相对路径或绝对路径。而“选项”和“匹配条件”则用于指定搜索的方式和条件。</p>\n<p>以下是一些常用的选项和匹配条件：</p>\n<p><strong>选项</strong></p>\n<ul>\n<li><code>-name</code>：按照文件名进行模式匹配搜索；</li>\n<li><code>-type</code>：按照文件类型进行搜索，例如：f表示普通文件，d表示目录，l表示符号链接等；</li>\n<li><code>-size</code>：按照文件大小进行搜索，单位可以是b（字节）、k（千字节）等；</li>\n<li><code>-mtime</code>：按照文件的修改时间进行搜索，可以指定时间范围，单位以天为计算；</li>\n<li><code>-exec</code>：对搜索结果进行操作，如删除、复制等。</li>\n</ul>\n<p><strong>Linux中如何用一条命令查出文件大小大于10k并且名字以chain开头的文件？</strong></p>\n<p>可以使用find命令结合-size和-name选项来查找文件大小大于10k且文件名以chain开头的文件。具体命令如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">find &#x2F;path&#x2F;to&#x2F;search -type f -name &quot;chain*&quot; -size +10k</code></pre>\n\n<p>解释一下上述命令中所用到的选项和语法：</p>\n<ul>\n<li><code>/path/to/search</code>：表示要搜索的目录路径，可以是绝对路径或相对路径；</li>\n<li><code>-type f</code>：表示只搜索普通文件，不搜索目录、符号链接等其他类型的文件；</li>\n<li><code>-name &quot;chain*&quot;</code>：表示搜索所有文件名以“chain”开头的文件，其中 * 表示通配符；</li>\n<li><code>-size +10k</code>：表示搜索文件大小大于10k的文件，+表示大小应该大于10k，可以改成-表示小于10k。</li>\n</ul>\n<p>需要注意的是，在Linux中，文件大小单位是字节，因此“10k”表示10 * 1024字节，即10KB。如果要查找大于10MB的文件，可以将“k”换成“M”，即“+10M”。</p>\n<p><strong>在Linux中按ctrl+l组合键的作用是什么？</strong></p>\n<p>在Linux中，清屏的快捷键是<code>Ctrl + L</code></p>\n<p><strong>列出表格比较获得Linux命令的在线帮助的方式有哪些，各自的特点和区别是什么？</strong></p>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>命令格式</th>\n<th>特点和区别</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>man</code></td>\n<td><code>man &lt;command&gt;</code></td>\n<td>最全面的命令文档，包含命令的使用方法、参数、返回值等详细信息；可以通过搜索关键字快速查找相关信息；需要输入<code>q</code>键才能退出。</td>\n</tr>\n<tr>\n<td><code>--help</code></td>\n<td><code>&lt;command&gt; --help</code></td>\n<td>快速简洁地获取命令的基本用法和常用选项；只包含部分命令信息；不需要额外的工具或文档支持。</td>\n</tr>\n<tr>\n<td><code>info</code></td>\n<td><code>info &lt;command&gt;</code></td>\n<td>比<code>man</code>更详细的命令文档，通常包含更多的示例和说明；有时会涉及一些高级话题和概念；需要输入<code>q</code>键才能退出。</td>\n</tr>\n<tr>\n<td><code>whatis</code></td>\n<td><code>whatis &lt;command&gt;</code></td>\n<td>返回命令的简要描述，适合快速了解命令的作用和用法；不包含命令的详细信息。</td>\n</tr>\n<tr>\n<td><code>apropos</code></td>\n<td><code>apropos &lt;keyword&gt;</code></td>\n<td>基于关键字搜索命令的手册页，可用于快速查找与特定主题相关的命令；类似<code>man -k</code> 命令；根据关键字匹配搜索，可能返回多个结果。</td>\n</tr>\n</tbody></table>\n<p><strong>在Linux命令行下执行“ls -ld”命令的作用是什么？</strong></p>\n<p>在Linux命令行下执行“ls -ld”命令的作用是列出指定目录本身的信息，而不是该目录下的子目录或文件。</p>\n<p>具体来说，“ls -ld”命令会输出指定目录的权限、拥有者、所属组、大小、修改时间等信息，其中：</p>\n<ul>\n<li><code>-l</code> 表示以列表方式显示文件或目录的详细信息；</li>\n<li><code>-d</code> 表示仅列出目录本身的信息，而不会列出其子目录或文件的信息。</li>\n</ul>\n<p>举个例子，如果要查看当前目录（即当前工作路径）的详细信息，可以在终端中输入以下命令：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ls -ld .</code></pre>\n\n<p>这里<code>.</code>表示当前目录，<code>-l</code>和<code>-d</code>选项用来显示目录的详细信息。执行该命令后，终端将会输出当前目录的详细信息，包括权限、所属用户和用户组、大小等内容。</p>\n<p><strong>执行什么命令可以分别统计&#x2F;boot目录中所有文件，子目录各自占用的空间大小？</strong></p>\n<p>要分别统计<code>/boot</code>目录中所有文件、子目录各自占用的空间大小，可以使用下面的命令：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">du -ah --max-depth&#x3D;1 &#x2F;boot</code></pre>\n\n<p>该命令中，<code>du</code>命令用于查看文件或目录占用的磁盘空间大小；<code>-h</code>选项表示以人类可读方式显示结果，即将文件尺寸转换为易于理解的单位；<code>-a</code>选项表示显示每个文件的占用空间大小，包括子目录中的文件；<code>--max-depth=1</code>选项表示仅显示第一层目录（即当前目录和其直接子目录）的信息。</p>\n<p>执行上述命令后，终端将输出<code>/boot</code>目录本身占用的空间大小，以及该目录下每个文件、子目录占用的空间大小。例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">4.0K    &#x2F;boot&#x2F;grub2\n28M     &#x2F;boot\n0       &#x2F;boot&#x2F;lost+found\n3.4M    &#x2F;boot&#x2F;loader\n4.0K    &#x2F;boot&#x2F;.vmlinuz.qf8w2A\n0       &#x2F;boot&#x2F;vmlinuz\n25M     &#x2F;boot&#x2F;initramfs-5.12.13-300.fc34.x86_64.img\n4.4M    &#x2F;boot&#x2F;System.map-5.12.13-300.fc34.x86_64\n0       &#x2F;boot&#x2F;config-5.12.13-300.fc34.x86_64\n4.0K    &#x2F;boot&#x2F;drivers\n1.2M    &#x2F;boot&#x2F;intel-ucode.img</code></pre>\n\n<p>其中第一行表示<code>/boot/grub2</code>子目录占用4KB空间，第二行表示<code>/boot</code>目录本身占用28MB空间，第三行表示<code>/boot/lost+found</code>子目录没有占用空间。</p>\n<p><strong>在Linux命令行一次创建多级目录的命令是什么？</strong></p>\n<p>在Linux命令行下，可以使用<code>mkdir</code>命令一次创建多级目录。其命令格式为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">mkdir -p [目录路径]</code></pre>\n\n<p>其中，<code>-p</code>选项表示创建多级目录，即如果要创建的目录包含不存在的父目录，则会自动创建缺失的父目录。</p>\n<p>例如，要在当前目录下创建一个名为<code>/home/user/project/data</code>的多级目录，可以使用以下命令：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">mkdir -p &#x2F;home&#x2F;user&#x2F;project&#x2F;data</code></pre>\n\n<p>执行该命令后，如果<code>/home</code>和<code>/home/user</code>两个目录不存在，它们也会被自动创建。</p>\n<p><strong>依次执行什么命令可以为文件&#x2F;bin&#x2F;bzip2创建一个软链接文件&#x2F;bin&#x2F;wx&#x2F;bzip2</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ln -s &#x2F;bin&#x2F;bzip2 &#x2F;bin&#x2F;wx&#x2F;bzip2</code></pre>\n\n<p>该命令中，<code>-s</code>选项表示创建软链接。第一个参数<code>/bin/bzip2</code>是源文件的路径，第二个参数<code>/bin/wx/bzip2</code>是目标链接文件的路径。执行上述命令后，就会在<code>/bin/wx</code>目录下创建一个名为<code>bzip2</code>的软链接文件，指向<code>/bin/bzip2</code>这个文件。</p>\n<p><strong>依次执行什么命令可以把目录&#x2F;boot&#x2F;grub，文件&#x2F;etc&#x2F;agp.conf复制到当前目录下的public_html文件夹中？</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">cp -r &#x2F;boot&#x2F;grub &#x2F;etc&#x2F;agp.conf .&#x2F;public_html&#x2F;</code></pre>\n\n<p>该命令中，<code>-r</code>选项用于递归复制整个目录树；第一个参数<code>/boot/grub</code>表示要复制的源目录，第二个参数<code>/etc/agp.conf</code>表示要复制的源文件，第三个参数<code>./public_html/</code>表示目标目录。在Linux中，<code>.</code>表示当前目录，因此<code>./public_html/</code>表示当前目录下的<code>public_html</code>子目录。</p>\n<p>此外，为了避免出现无权限访问的问题，建议在执行该命令之前先以管理员权限登录系统或者切换到超级用户身份运行该命令。</p>\n<p><strong>在Linux命令行中执行echo $PATH命令的作用是什么？</strong></p>\n<p>在Linux命令行中执行<code>echo $PATH</code>命令，可以显示当前用户的环境变量<code>PATH</code>的值。</p>\n<p><code>PATH</code>环境变量是一个包含多个目录路径的字符串，表示系统查找可执行文件的路径列表。当用户在命令行输入一个命令时，系统会按照<code>PATH</code>变量中定义的路径顺序，在这些路径下查找对应的可执行文件。如果找到了，则执行该文件，否则会显示“指令未找到”的错误信息。</p>\n<p>通过执行<code>echo $PATH</code>命令，可以查看环境变量<code>PATH</code>的值，以确定系统在哪些目录下查找可执行文件。一般来说，<code>PATH</code>变量的默认值包含了一些常用的系统目录和用户目录，但也可能根据不同的Linux发行版和环境有所差别。如果需要添加或修改<code>PATH</code>变量的值，可以通过编辑相应的配置文件（例如<code>.bashrc</code>或<code>.profile</code>），或使用<code>export</code>命令临时设置变量的值。</p>\n<p><strong>执行什么命令可以在&#x2F;etc目录下查找超过1024KB，名称以.conf结尾的文件？</strong></p>\n<p>可以使用以下命令在<code>/etc</code>目录下查找文件大小大于1024KB（即1MB），名称以<code>.conf</code>结尾的文件：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">find &#x2F;etc -type f -name &quot;*.conf&quot; -size +1024k</code></pre>\n\n<p>该命令中，<code>find</code>命令用于查找文件；第一个参数<code>/etc</code>表示要查找的目录；<code>-type f</code>选项表示只查找普通文件，而不包括目录和符号链接等其他类型的文件；<code>-name &quot;*.conf&quot;</code>选项表示只查找文件名以<code>.conf</code>结尾的文件，其中<code>*</code>表示通配符；<code>-size +1024k</code>选项表示只查找文件大小大于1024KB的文件（大小以k为单位）。</p>\n<p>执行上述命令后，系统会递归查找<code>/etc</code>目录下所有符合条件的文件，并输出它们的完整路径。如果需要指定输出格式或者处理查找结果，可以使用<code>-printf</code>参数或管道符号（<code>|</code>）将结果传递给其他命令进行处理。</p>\n<p><strong>列出表格对比Linux系统下可以查看文件内容命令的作用，命令格式，常用选项？</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>命令格式</th>\n<th>常用选项</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cat</td>\n<td>连续显示文件内容</td>\n<td><code>cat [选项] 文件名</code></td>\n<td><code>-n</code>：显示行号；<code>-b</code>：对非空行显示行号；<code>-E</code>：在每行末尾显示<code>$</code>符号</td>\n</tr>\n<tr>\n<td>more</td>\n<td>分页显示文件内容</td>\n<td><code>more [选项] 文件名</code></td>\n<td><code>-d</code>：在显示内容前清除屏幕；<code>+n</code>：从第<code>n</code>行开始显示</td>\n</tr>\n<tr>\n<td>less</td>\n<td>分页显示文件内容，支持滚动和搜索</td>\n<td><code>less [选项] 文件名</code></td>\n<td><code>/pattern</code>：向下搜索字符串<code>pattern</code>（按<code>n</code>键继续查找下一个匹配项）；<code>?pattern</code>：向上搜索字符串<code>pattern</code>（按<code>N</code>键继续查找上一个匹配项）</td>\n</tr>\n<tr>\n<td>head</td>\n<td>显示文件前几行</td>\n<td><code>head [选项] 文件名</code></td>\n<td><code>-n</code>：指定要显示的行数</td>\n</tr>\n<tr>\n<td>tail</td>\n<td>显示文件后几行</td>\n<td><code>tail [选项] 文件名</code></td>\n<td><code>-n</code>：指定要显示的行数；<code>-f</code>：实时跟踪文件新增内容</td>\n</tr>\n<tr>\n<td>grep</td>\n<td>搜索文件内容并输出匹配行</td>\n<td><code>grep [选项] 搜索模式 文件名</code></td>\n<td><code>-i</code>：忽略大小写；<code>-v</code>：输出不匹配的行；<code>-E</code>：使用正则表达式搜索</td>\n</tr>\n<tr>\n<td>awk</td>\n<td>对文件内容按指定格式进行处理</td>\n<td><code>awk &#39;模式 &#123;操作&#125;&#39; 文件名</code></td>\n<td><code>$n</code>：第<code>n</code>个字段（默认以空格为分隔符）；<code>-F</code>：指定字段分隔符</td>\n</tr>\n<tr>\n<td>sed</td>\n<td>对文件内容进行替换、删除或添加操作</td>\n<td><code>sed &#39;s/旧字符串/新字符串/g&#39; 文件名</code></td>\n<td><code>-i</code>：直接修改文件内容；<code>-n</code>：只显示经过处理的内容</td>\n</tr>\n</tbody></table>\n<p><strong>使用grep命令过滤文件内容时“^”，“$”，“^$”分别表示什么作用？</strong></p>\n<p>在使用<code>grep</code>命令过滤文件内容时，常常会用到正则表达式来指定匹配的模式。其中，<code>^</code>、<code>$</code>和<code>^$</code>分别表示：</p>\n<ul>\n<li><code>^</code>：匹配行首。例如，使用<code>grep &#39;^root&#39; /etc/passwd</code>命令可以查找以<code>root</code>开头的行，这样可以快速找到所有系统中的<code>root</code>用户。</li>\n<li><code>$</code>：匹配行尾。例如，使用<code>grep &#39;bash$&#39; /etc/passwd</code>命令可以查找以<code>bash</code>结尾的行，这样可以列出所有使用<code>bash</code>作为默认shell的用户账号。</li>\n<li><code>^$</code>：匹配空行。例如，使用<code>grep &#39;^$&#39; file.txt</code>命令可以查找文件中的空行（即连续两个回车符之间没有任何其他字符的行），这样可以快速统计文件中空行的数量或者删除所有的空行。</li>\n</ul>\n<p>需要注意的是，正则表达式中的这些特殊字符都是按照字符字面意义进行匹配的，如果想要匹配它们本身而不是其具有的特殊含义，可以使用转义字符<code>\\</code>。例如，要查找以<code>^</code>开头的行，应该使用<code>grep &#39;\\^root&#39; /etc/passwd</code>命令。</p>\n<p><strong>如何使用得到httpd.comf文件中除去注释和空行后的有效信息？</strong></p>\n<p>可以使用<code>grep</code>命令结合正则表达式来过滤出<code>httpd.conf</code>文件中的有效配置信息，方法如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">bashgrep -v &#39;^$\\|^\\s*#&#39; httpd.conf</code></pre>\n\n<p>其中，<code>-v</code>选项用于反选匹配到的行（即只输出不匹配的行），这样可以过滤掉空白行和以<code>#</code>开头的注释行。正则表达式<code>&#39;^$\\|^\\s*#&#39;</code>指定了需要排除的模式，具体含义如下：</p>\n<ul>\n<li><code>^$</code>：匹配空白行，<code>^</code>匹配行首，<code>$</code>匹配行尾。</li>\n<li><code>^\\s*#</code>：匹配以<code>#</code>开头的注释行，<code>^</code>匹配行首，<code>\\s*</code>匹配零个或多个空白字符（比如制表符或者空格），<code>#</code>匹配井号。</li>\n</ul>\n<p>这样，使用以上命令就可以得到<code>httpd.conf</code>文件中除去注释和空行后的有效信息了。</p>\n<p><strong>列出表格对比Linux系统下常用压缩与解压缩命令的区别？</strong></p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>压缩格式</th>\n<th>解压缩格式</th>\n<th>压缩效率</th>\n<th>压缩速度</th>\n<th>压缩文件大小</th>\n<th>常用选项</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tar</td>\n<td>打包成归档文件</td>\n<td><code>.tar</code></td>\n<td><code>.tar</code></td>\n<td>一般</td>\n<td>快</td>\n<td>大</td>\n<td><code>-c</code>：创建归档文件；<code>-x</code>：从归档文件中提取文件；<code>-z</code>：使用gzip算法压缩；<code>-j</code>：使用bzip2算法压缩；<code>-f</code>：指定归档文件名</td>\n</tr>\n<tr>\n<td>gzip</td>\n<td>使用DEFLATE算法压缩文件</td>\n<td><code>.gz</code></td>\n<td>无</td>\n<td>高</td>\n<td>快</td>\n<td>小</td>\n<td><code>-c</code>：将结果输出到标准输出；<code>-d</code>：解压文件</td>\n</tr>\n<tr>\n<td>bzip2</td>\n<td>使用Burrows-Wheeler算法压缩文件</td>\n<td><code>.bz2</code></td>\n<td>无</td>\n<td>高</td>\n<td>慢</td>\n<td>小</td>\n<td><code>-c</code>：将结果输出到标准输出；<code>-d</code>：解压文件</td>\n</tr>\n<tr>\n<td>xz</td>\n<td>使用LZMA或者LZMA2算法压缩文件</td>\n<td><code>.xz</code></td>\n<td>无</td>\n<td>极高</td>\n<td>慢</td>\n<td>极小</td>\n<td><code>-c</code>：将结果输出到标准输出；<code>-d</code>：解压文件</td>\n</tr>\n<tr>\n<td>zip</td>\n<td>打包成ZIP文件</td>\n<td><code>.zip</code></td>\n<td><code>.zip</code></td>\n<td>一般</td>\n<td>慢</td>\n<td>大</td>\n<td><code>-r</code>：递归压缩目录；<code>-d</code>：删除zip文件中的指定文件；<code>-j</code>：不保存目录信息</td>\n</tr>\n<tr>\n<td>unzip</td>\n<td>解压ZIP文件</td>\n<td>无</td>\n<td>无</td>\n<td>无</td>\n<td>快</td>\n<td>无</td>\n<td><code>-d</code>：指定解压目录</td>\n</tr>\n</tbody></table>\n<p>需要注意的是，不同压缩算法和格式的选择应该根据具体的需求来决定。对于需要快速压缩或解压的大型文件，可以使用快速、低压缩率但无损的gzip算法；对于磁盘空间有限的场景，则可以选择高压缩率但压缩速度较慢的bzip2或者xz算法。对于需要便于传输和跨平台使用的文件，则可以使用zip格式打包压缩。</p>\n<p><strong>tar命令的语法与常用选项有哪些？各选项的作用是什么？</strong></p>\n<p>tar是一个用于打包和解包归档文件的命令，支持压缩和非压缩两种模式。它的基本语法如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">tar [选项]... [文件]...</code></pre>\n\n<p>常用选项如下：</p>\n<ul>\n<li><code>-c, --create</code>：创建归档文件。</li>\n<li><code>-t, --list</code>：列出归档文件中的文件列表。</li>\n<li><code>-x, --extract, --get</code>：从归档文件中提取文件。</li>\n<li><code>-f, --file=ARCHIVE</code>：指定归档文件名。</li>\n<li><code>-v, --verbose</code>：显示详细信息。</li>\n<li><code>-z, --gzip, --ungzip</code>：使用gzip算法压缩或解压缩归档文件。</li>\n<li><code>-j, --bzip2</code>：使用bzip2算法压缩或解压缩归档文件。</li>\n<li><code>-J, --xz</code>：使用xz算法压缩或解压缩归档文件。</li>\n<li><code>-p, --same-permissions</code>：保留所有文件的权限信息。</li>\n<li><code>-P, --absolute-names</code>：使用绝对路径名打包文件。</li>\n<li><code>-r, --append</code>：向归档文件中追加文件。</li>\n<li><code>-u, --update</code>：只向归档文件中追加比原来文件更新的文件。</li>\n</ul>\n<p>这些选项的作用如下：</p>\n<ul>\n<li><code>-c</code>选项用于创建归档文件，它可以将指定文件或目录打包成一个归档文件。</li>\n<li><code>-t</code>选项用于列出归档文件中的文件列表，它可以让用户查看归档文件的内容。</li>\n<li><code>-x</code>选项用于从归档文件中提取指定的文件或目录。</li>\n<li><code>-f</code>选项用于指定归档文件名，它后面必须紧跟着归档文件名。</li>\n<li><code>-v</code>选项用于显示详细信息，在执行命令时会输出每一个被处理的文件或目录的名称。</li>\n<li><code>-z</code>、<code>-j</code>和<code>-J</code>选项分别表示使用gzip、bzip2和xz算法来压缩&#x2F;解压缩归档文件。这些选项可以将归档文件压缩成更小的空间以节省磁盘空间。</li>\n<li><code>-p</code>选项用于保留所有文件的权限信息，其作用是将原文件的权限和其他属性一模一样地复制到归档文件中。</li>\n<li><code>-P</code>选项则用于将文件打包成绝对路径，即包含完整路径。</li>\n<li><code>-r</code>选项用于向归档文件中追加文件，只有当归档文件已存在时才可以使用。</li>\n<li><code>-u</code>选项用于只向归档文件中追加比原来文件更新的文件。</li>\n</ul>\n<p><strong>使用zxf解压归档包报错，如何分析问题？</strong></p>\n<p>在使用<code>tar</code>命令解压归档包时，可能会遇到各种错误。其中，使用<code>zxf</code>选项解压<code>.tar.gz</code>归档包时，常见的报错信息如下：</p>\n<ul>\n<li><code>tar: zxf: Cannot open: No such file or directory</code></li>\n<li><code>tar: Error is not recoverable: exiting now</code></li>\n<li><code>gzip: stdin: not in gzip format</code></li>\n<li><code>tar: Child returned status 1</code></li>\n<li><code>tar: Exiting with failure status due to previous errors</code></li>\n</ul>\n<p>这些错误可能由以下原因引起：</p>\n<ol>\n<li>归档包不存在或者路径不正确。 在解压缩之前，需要确认归档包文件是否存在，以及路径是否正确。可以查看当前目录下是否存在归档包文件，并确保路径名正确。如果路径名中包含空格等特殊字符，需要用单引号或双引号将路径名括起来，例如：<code>tar -zxf &#39;my archive.tar.gz&#39;</code>。</li>\n<li>归档包文件名和后缀不一致。 如果归档包的后缀名不是<code>.tar.gz</code>或<code>.tgz</code>，那么就需要手动指定压缩算法，例如：<code>tar -xjf myarchive.bz2</code> 或 <code>tar -Jxf myarchive.xz</code>。</li>\n<li>归档包文件损坏或不完整。 如果归档包被意外中断或损坏，就有可能导致解压缩失败。在这种情况下，可以尝试重新下载归档包或者找到一个备份文件进行解压缩。</li>\n<li>归档包使用了非标准的压缩算法或格式。 如果归档包使用了一些非标准的压缩算法或格式，就需要手动指定相应的选项。例如，对于<code>.tar.bz2</code>格式的归档包，需要使用<code>-j</code>选项：<code>tar -xjf myarchive.tar.bz2</code>。</li>\n</ol>\n<p>如果以上方法都无法解决问题，可以尝试通过查看详细的错误信息来分析问题。可以使用<code>-v</code>选项显示详细信息，或者使用<code>-vv</code>选项以调试模式运行<code>tar</code>命令。这样可以给出更详细的报错信息，帮助进一步分析和解决问题。另外，还可以查阅系统文档或相关资料来获取更多信息。</p>\n<p><strong>执行什么命令可以分页查看&#x2F;etc&#x2F;目录下扩展名为“.conf”的配置文件？</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">sudo grep -r --include &quot;*.conf&quot; &quot;&quot; &#x2F;etc&#x2F; | less</code></pre>\n\n<p>这条命令的含义如下：</p>\n<ul>\n<li><code>sudo</code>: 使用管理员权限执行命令。</li>\n<li><code>grep</code>: 命令行文本搜索工具，用于在文件中搜索指定字符串或正则表达式。</li>\n<li><code>-r</code>: 递归搜索。对目录进行递归搜索，即子目录中也要搜索文件。</li>\n<li><code>--include &quot;*.conf&quot;</code>: 只搜索扩展名为<code>.conf</code>的文件。</li>\n<li><code>&quot;&quot;</code>: 搜索模式为空，即不限制搜索内容，并搜索所有行。</li>\n<li><code>/etc/</code>: 要搜索的目录，此处指定为<code>/etc/</code>。</li>\n<li><code>|</code>: 管道符，将前一个命令的输出结果传递给后一个命令。</li>\n<li><code>less</code>: 终端分页查看器，用于浏览大文件，允许用户浏览过滤后的文本一部分。</li>\n</ul>\n<p>因此，命令的意思是：以管理员权限执行<code>grep</code>命令，递归搜索<code>/etc/</code>目录下所有扩展名为<code>.conf</code>的文件，对这些文件执行空搜索模式，即搜索所有内容，将结果通过管道传递给<code>less</code>命令，使用<code>less</code>命令分页查看搜索结果。</p>\n<p>使用<code>↑</code>和<code>↓</code>键向上或向下滚动页面；使用<code>PgUp</code>和<code>PgDn</code>键翻页。</p>\n<p>如果想要退出<code>less</code>分页查看器，可以按下键盘上的<code>q</code>键。</p>\n<p>通过使用以上命令，用户可以轻松地分页查看<code>/etc/</code>目录下扩展名为<code>.conf</code>的所有配置文件，并快速定位所需要的配置信息。如果需要查看其他扩展名的文件，只需要将命令中搜索模式中的<code>*.conf</code>替换为其他扩展名即可。</p>\n<p><strong>ps：</strong></p>\n<p><code>--include</code>是<code>grep</code>命令的一个选项，用于指定要搜索的文件类型。</p>\n<p><code>--include</code>选项后面跟着一个模式，模式中可以使用通配符（如<code>*</code>）来匹配文件名。<code>grep</code>命令只会搜索包含指定模式的文件。</p>\n<p>例如，执行以下命令：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">grep --include &quot;*.txt&quot; &quot;Hello&quot; &#x2F;path&#x2F;to&#x2F;search&#x2F;</code></pre>\n\n<p>这条命令会在<code>/path/to/search/</code>目录下搜索所有扩展名为<code>.txt</code>的文件，并查找其中包含<code>Hello</code>字符串的所有行。</p>\n<p>需要注意的是，<code>--include</code>选项只对递归搜索时生效，因为递归搜索命令需要遍历目录结构并检查每个文件的名称。如果要在当前目录中搜索文件，应该使用<code>-r</code>或<code>-d</code>选项来递归搜索目录，否则<code>--include</code>选项将被忽略。</p>\n<p><strong>执行什么命令可以统计&#x2F;etc&#x2F;目录下共包含多少个扩展名为“.conf”的文件？</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ls -1 &#x2F;etc&#x2F;*.conf | wc -l</code></pre>\n\n<p>该命令的作用是：</p>\n<ol>\n<li>使用<code>ls</code>命令列出<code>/etc/</code>目录下所有扩展名为<code>.conf</code>的文件，并一行一个文件名列出；</li>\n<li><code>|</code>把前一条命令的输出结果传递给后一个命令；</li>\n<li>使用<code>wc -l</code>命令计算输出结果的行数，即文件数量。</li>\n</ol>\n<p><strong>执行什么命令可以显示&#x2F;etc&#x2F;yum.conf文件中以“#”开头的行和空行以外的内容？</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">grep -v -E &quot;^$|^\\s*#&quot; &#x2F;etc&#x2F;yum.conf</code></pre>\n\n<p>该命令的作用是：</p>\n<ol>\n<li><code>grep</code>: 命令行文本搜索工具；</li>\n<li><code>-v</code>: 反选匹配模式，即只匹配不包含指定模式的行；</li>\n<li><code>-E</code>: 启用扩展正则表达式模式；</li>\n<li><code>&quot;^$|^\\s*#&quot;</code>: 匹配空行和以<code>#</code>开头的行。其中，正则表达式<code>^$</code>匹配空行，正则表达式<code>^\\s*#</code>匹配开头可能有空格的以<code>#</code>开头的行；</li>\n<li><code>/etc/yum.conf</code>: 要搜索的文件路径。</li>\n</ol>\n<p><strong>tar命令常用选项中，“-c”和“-C”的用途分别是什么？</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">-c&#96;选项： 选项含义：创建新的归档文件； 用法示例：&#96;tar -cvf archive.tar file1 file2 dir1</code></pre>\n\n<p><code>-c</code>选项与下面三个参数一起使用可以创建新的归档文件。具体来说，选项“-c”表示创建一个新的归档文件，选项“-v”表示显示归档过程中的详细信息，选项“-f”表示指定归档文件名。后面跟着的参数是要添加到归档文件中的文件和目录列表。</p>\n<p>例如，上面的命令将file1、file2和dir1三个文件&#x2F;目录添加到名称为archive.tar的新归档文件中，并在归档过程中显示详细信息。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">-C&#96;选项： 选项含义：改变工作目录； 用法示例：&#96;tar -xvf archive.tar -C &#x2F;var&#x2F;www</code></pre>\n\n<p><code>-C</code>选项用于指定解压缩后文件的存储目录，该目录必须事先存在。具体来说，选项“-x”表示解压缩一个归档文件，选项“-v”表示显示解压缩过程中的详细信息，选项“-f”表示指定归档文件名，“-C”则指定解压缩后文件的存储目录。其中，“-C”选项后面必须跟一个已存在的目录路径。</p>\n<p>例如，上面的命令将名称为archive.tar的归档文件解压缩，并将解压缩后的文件存储到&#x2F;var&#x2F;www目录中。</p>\n<p><strong>用图表示vi编辑器的工作模式及切换方法</strong></p>\n<p><img src=\"https://abyssaler-typora-photobank.oss-cn-chengdu.aliyuncs.com/img_for_typora/image-20230513214444906.png\" alt=\"image-20230513214444906\"></p>\n<p><strong>在vi编辑器的命令行模式下按哪些健可以将光标快速跳转到本行的行首？</strong></p>\n<ul>\n<li>快捷键 0：按下数字“0”可以直接将光标移动到本行的行首。</li>\n<li>快捷键 ^：按下“shift + 6”符号可以将光标移动到本行第一个非空字符位置（即行首）。</li>\n<li>快捷键 Home：按下Home键也可以将光标快速跳转到本行的行首。</li>\n</ul>\n<p><strong>在vi编辑器中粘贴已复制的内容时，按p健与按P健的区别是什么？</strong></p>\n<p>在vi编辑器中，按下小写字母p键可以将已经复制的内容粘贴到光标后面，而大写字母P键则是将复制的内容粘贴到光标前面。</p>\n<p><strong>vi编辑器中执行哪些操作可以保存并退出文件？</strong></p>\n<ul>\n<li>使用命令“:x”或“:wq”，这两个命令在保存文件的同时也会关闭编辑器。</li>\n<li>使用快捷键“ZZ”或“ZQ”，其中“ZZ”表示保存并退出编辑器，而“ZQ”则是直接退出编辑器而不保存修改。</li>\n<li>在命令行模式下，输入“:x!”或“:wq!”，这两个命令会强制保存并退出文件。需要注意的是，在使用强制保存命令时，如果文件被其他程序占用，可能导致保存失败。</li>\n</ul>\n<p><strong>在vi编辑器的末行模式下执行“:5,15 s &#x2F;initdedfault&#x2F;DEFAULT&#x2F;g”的作用是什么？</strong></p>\n<p>在vi编辑器的末行模式下，执行命令“:5,15 s&#x2F;initdedfault&#x2F;DEFAULT&#x2F;g”的作用是将文本文件中第5到第15行内所有字符串“initdedfault”替换为“DEFAULT”</p>\n<p>其中，“:”表示进入末行模式，“s”表示替换操作。具体含义如下：</p>\n<ul>\n<li>“5,15”表示只在第5到第15行内查找目标字符串并替换。</li>\n<li>“initdedfault”表示被替换的目标字符串。</li>\n<li>“DEFAULT”表示替换目标字符串的新字符串。</li>\n<li>“g”表示全局替换，即在每一行内查找并替换所有匹配到的目标字符串。</li>\n</ul>\n<p><strong>&#x2F;bin&#x2F;bash和&#x2F;usr&#x2F;bin&#x2F;bash的区别</strong></p>\n<p>&#x2F;bin&#x2F;bash和&#x2F;usr&#x2F;bin&#x2F;bash都是Linux操作系统中的Bash Shell可执行文件，二者的区别在于它们所在的目录不同。</p>\n<p>在Linux文件系统中，&#x2F;bin目录是所有用户都可以访问的目录，该目录存放了一些最基本的系统工具和二进制程序，如Bash Shell、ls、cd等命令，这些命令对于系统运行至关重要，因此&#x2F;bin目录通常挂载在一个没有任何选项的独立根文件系统上，以确保它们在系统启动时能够立即被使用。</p>\n<p>而&#x2F;usr&#x2F;bin目录则是Unix Software Resource的缩写，它是存放系统用户使用的大部分应用程序的目录，包括了各种命令、脚本、二进制文件等。相比于&#x2F;bin目录，&#x2F;usr&#x2F;bin目录通常包含更多应用程序，并且这些程序可能是由第三方提供的，而不是像&#x2F;bin目录下的工具那样由操作系统提供的。</p>\n<p>因此，&#x2F;bin&#x2F;bash和&#x2F;usr&#x2F;bin&#x2F;bash虽然都是Bash Shell的可执行文件，但前者位于基础系统目录下，属于系统必备文件，而后者则位于可选软件安装目录下，属于应用程序之一。</p>\n<p><strong>如果忘记centos的root密码，如何修改密码</strong></p>\n<p>重启centos7，直到开机界面，这里有五秒的等待时间，我们按“e”键，进入编辑模式</p>\n<p><img src=\"https://abyssaler-typora-photobank.oss-cn-chengdu.aliyuncs.com/img_for_typora/image-20230513224058708.png\" alt=\"image-20230513224058708\"></p>\n<p>将光标一直移动到 LANG&#x3D;en_US.UTF-8 后面，空格，再追加 <strong>init&#x3D;&#x2F;bin&#x2F;sh</strong> 。这里特别注意，需要写在UTF-8后，保持在同一行，并注意空格。由于屏幕太小，会自动添加\\换行，这个是正常的。</p>\n<p><img src=\"https://abyssaler-typora-photobank.oss-cn-chengdu.aliyuncs.com/img_for_typora/image-20230513232252800.png\" alt=\"image-20230513232252800\"></p>\n<p>按下Ctrl+X 进行引导启动(单用户模式启动)</p>\n<p>挂载根目录：<code>mount -o remount, rw /</code></p>\n<p><img src=\"https://abyssaler-typora-photobank.oss-cn-chengdu.aliyuncs.com/img_for_typora/image-20230514100759607.png\" alt=\"image-20230514100759607\"></p>\n<p>选择要修改密码的用户名，这里选择root用户进行修改：<code>passwd root</code></p>\n<p><img src=\"https://abyssaler-typora-photobank.oss-cn-chengdu.aliyuncs.com/img_for_typora/image-20230513232811385.png\" alt=\"image-20230513232811385\"></p>\n<p>输入 <code>touch /.autorelabel</code> 如果系统之前启用了selinux，则必须运行该命令，否则将无法正常启动系统。</p>\n<p><img src=\"https://abyssaler-typora-photobank.oss-cn-chengdu.aliyuncs.com/img_for_typora/image-20230514101022813.png\" alt=\"image-20230514101022813\"></p>\n<p>修改后重启命令使用<code>exec /sbin/init</code>速度快</p>\n<p><img src=\"https://abyssaler-typora-photobank.oss-cn-chengdu.aliyuncs.com/img_for_typora/image-20230514101206783.png\" alt=\"image-20230514101206783\"></p>\n<p>修改成功</p>\n","feature":true,"text":"day1inode节点用光了会怎么样？ 如果一个文件系统中的inode节点被用光了，那么就不能再创建新的文件或目录了。尽管可能在文件系统上还有可用的空间，但是由于没有可用的inode节点来描述新的文件或目录，因此无法继续写入数据。这种情况通常会发生在存储许多小文件的系统中，因为每...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":15,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"kls","slug":"kls","count":3,"path":"api/tags/kls.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#day1\"><span class=\"toc-text\">day1</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#day2\"><span class=\"toc-text\">day2</span></a></li></ol>","author":{"name":"Abyssaler","slug":"blog-author","avatar":"https://abyssaler-typora-photobank.oss-cn-chengdu.aliyuncs.com/img_for_typora/Face.jpg","link":"/","description":"道阻且长，行则将至","socials":{"github":"https://github.com/Abyssaler","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45349299","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"Linux常用命令-klsday2","uid":"143a290a264195c37b7dbed6ffb5a1a7","slug":"klsday2-Linux","date":"2023-05-12T00:58:39.304Z","updated":"2023-05-13T11:25:52.291Z","comments":true,"path":"api/articles/klsday2-Linux.json","keywords":null,"cover":"https://abyssaler-typora-photobank.oss-cn-chengdu.aliyuncs.com/img_for_typora/wallhaven-qzrmrl.png","text":" shell Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。 Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。 Ken Thompson 的 sh ...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":15,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"kls","slug":"kls","count":3,"path":"api/tags/kls.json"}],"author":{"name":"Abyssaler","slug":"blog-author","avatar":"https://abyssaler-typora-photobank.oss-cn-chengdu.aliyuncs.com/img_for_typora/Face.jpg","link":"/","description":"道阻且长，行则将至","socials":{"github":"https://github.com/Abyssaler","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45349299","juejin":"","customs":{}}},"feature":true}}