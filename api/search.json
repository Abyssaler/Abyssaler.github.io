[{"id":"a20d92fb383ca075baad3d4829985acb","title":"mysqlxu学习笔记","content":"这篇笔记是引用来方便自己学习的，原出处见此：\n\n\n\n\n\n\n\n\n\nhttps://gitee.com/yueliu2345/mysql\nmysql0.数据库常见概念0.1概念数据库：        英文单词DataBase，简称DB。按照一定格式存储数据的一些文件的组合。        顾名思义：存储数据的仓库，实际上就是一堆文件。这些文件中存储了        具有特定格式的数据。\n数据库管理系统：    DataBaseManagement，简称DBMS。    数据库管理系统是专门用来管理数据库中数据的，数据库管理系统可以    对数据库当中的数据进行增删改查。\n常见的数据库管理系统：    MySQL、Oracle、MS SqlServer、DB2、sybase等….\nSQL：结构化查询语言    程序员需要学习SQL语句，程序员通过编写SQL语句，然后DBMS负责执行SQL    语句，最终来完成数据库中数据的增删改查操作。\nSQL是一套标准，程序员主要学习的就是SQL语句，这个SQL在mysql中可以使用，同时在Oracle中也可以使用，在DB2中也可以使用。\n三者之间的关系？    DBMS–执行–&gt; SQL –操作–&gt; DB\n先安装数据库管理系统MySQL，然后学习SQL语句怎么写，编写SQL语句之后，DBMS对SQL语句进行执行，最终来完成数据库的数据管理。\n0.2 SQL语句分类DQL：        数据查询语言（凡是带有select关键字的都是查询语句）        select…\t\t\nDML：            数据操作语言（凡是对表当中的数据进行增删改的都是DML）            insert delete update            insert 增            delete 删            update 改\n​\t\t这个主要是操作表中的数据data。\nDDL：        数据定义语言        凡是带有create、drop、alter的都是DDL。        DDL主要操作的是表的结构。不是表中的数据。        create：新建，等同于增        drop：删除        alter：修改        这个增删改和DML不同，这个主要是对表结构进行操作。\nTCL：    不是王牌电视。    是事务控制语言    包括：        事务提交：commit;        事务回滚：rollback;\nDCL：    是数据控制语言。    例如：授权grant、撤销权限revoke….\n0.3MYSQL中的数据类型varchar(最长255)        可变长度的字符串，比较智能，节省空间。会根据实际的数据长度动态分配空间。\n​\t\t优点：节省空间​\t\t缺点：需要动态分配空间，速度慢。\nchar(最长255)        定长字符串，不管实际的数据长度是多少，分配固定长度的空间去存储数据。        使用不恰当的时候，可能会导致空间的浪费。\n​\t\t优点：不需要动态分配空间，速度快。​\t\t缺点：使用不当可能会导致空间的浪费。\n​\t\tvarchar和char我们应该怎么选择？​\t\t\t性别字段你选什么？因为性别是固定长度的字符串，所以选择char。​\t\t\t姓名字段你选什么？每一个人的名字长度不同，所以选择varchar。\nint(最长11)\n​\t\t数字中的整数型。等同于java的int。\nbigint        数字中的长整型。等同于java中的long。\nfloat        单精度浮点型数据\ndouble        双精度浮点型数据\ndate        短日期类型\ndatetime        长日期类型\nclob        字符大对象        最多可以存储4G的字符串。        比如：存储一篇文章，存储一个说明。        超过255个字符的都要采用CLOB字符大对象来存储。        Character Large OBject:CLOB\nblob        二进制大对象        Binary Large OBject        专门用来存储图片、声音、视频等流媒体数据。        往BLOB类型的字段上插入数据的时候，例如插入一个图片、视频等，        你需要使用IO流才行。\nt_movie 电影表（专门存储电影信息的）\n编号no(bigint)\t名字name(varchar)\t\t故事情节history(clob)\t\n上映日期playtime(date)\t\t时长time(double)\t\t海报image(blob)\n类型type(char)\t\t\t\t\t\t\t\n\n0.4SQL脚本的执行xxxx.sql这种文件被称为sql脚本文件。        sql脚本文件中编写了大量的sql语句。        我们执行sql脚本文件的时候，该文件中所有的sql语句会全部执行！        批量的执行SQL语句，可以使用sql脚本文件。\n\nmysql&gt; source D:\\course\\03-MySQL\\document\\vip.sql你在实际的工作中，第一天到了公司，项目经理会给你一个xxx.sql文件，你执行这个脚本文件，你电脑上的数据库数据就有了！\n\n0.5数据库和表的导入导出数据导出？\n\t注意：在windows的dos命令窗口中：\n\t\tmysqldump bjpowernode&gt;D:\\bjpowernode.sql -uroot -p123456\n\t可以导出指定的表吗？\n\t\tmysqldump bjpowernode emp&gt;D:\\bjpowernode.sql -uroot -p123456\n\n数据导入？\n\t注意：需要先登录到mysql数据库服务器上。\n\t然后创建数据库：create database bjpowernode;\n\t使用数据库：use bjpowernode\n\t然后初始化数据库：source D:\\bjpowernode.sql\n\n1.数据库操作show databases; \t查看mysql中有哪些数据库\n use test;\t表示正在使用一个名字叫做test的数据库。\n create database db01;\t创建数据库\nshow tables; \t查看某个数据库下有哪些表\n select version();\t查看mysql数据库的版本号\nselect database();\t查看当前使用的是哪个数据库\n\\c\t用来终止一条命令的输入。\n2.建表操作2.1创建一个表create学号、姓名、年龄、性别、邮箱地址\n\tcreate table t_student(\n\t\tno int,\n\t\tname varchar(32),\n\t\tsex char(1),\n\t\tage int(3),\n\t\temail varchar(255)\n\t);\n\n2.2删除一个表dropdrop table t_student; &#x2F;&#x2F; 当这张表不存在的时候会报错！\n&#x2F;&#x2F; 如果这张表存在的话，删除\ndrop table if exists t_student;\n\n\n对表结构的修改需要使用：alter属于DDL语句\ndesc t_student    查看表结构\n\n2.3插入数据insert\ninsert into 表名(字段名1,字段名2,字段名3…) values(值1,值2,值3);\n\ninsert into t_student(no,name,sex,age,email)\n\tvalues(1,&#39;zhangsan&#39;,&#39;m&#39;,20,&#39;zhangsan@123.com&#39;);\ninsert into t_student(email,name,sex,age,no)\n\tvalues(&#39;lisi@123.com&#39;,&#39;lisi&#39;,&#39;f&#39;,20,2);\ninsert into t_student(no) values(3);\n&#x2F;&#x2F;省略字段名\ninsert into t_student values(2, &#39;lisi&#39;, &#39;f&#39;, 20, &#39;lisi@123.com&#39;);\n\n\ninsert语句但凡是执行成功了，那么必然会多一条记录。没有给其它字段指定值的话，默认值是NULL。\n\n一次插入多条数据\n\ninsert into t_user(字段名1,字段名2) values(),(),(),();\n\ninsert into t_user(id,name,birth,create_time) values\n\t\t(1,&#39;zs&#39;,&#39;1980-10-11&#39;,now()), \n\t\t(2,&#39;lisi&#39;,&#39;1981-10-11&#39;,now()),\n\t\t(3,&#39;wangwu&#39;,&#39;1982-10-11&#39;,now());\n\n\n\n2.4修改数据update\nupdate 表名 set 字段名1&#x3D;值1,字段名2&#x3D;值2,字段名3&#x3D;值3… where 条件;\n\n没有条件限制会导致所有数据全部更新。\n\n\nupdate t_user set name &#x3D; &#39;jack&#39;, birth &#x3D; &#39;2000-10-11&#39; where id &#x3D; 2;\n\nupdate t_user set name &#x3D; &#39;jack&#39;, birth &#x3D; &#39;2000-10-11&#39;, create_time &#x3D; now() where id &#x3D; 2;\n\n2.5删除数据delete语句删除数据的原理？（delete属于DML语句！！！）\n\n表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放！！！\n这种删除缺点是：删除效率比较低。\n这种删除优点是：支持回滚，后悔了可以再恢复数据！！！\n\ntruncate语句删除数据的原理？\n\n这种删除效率比较高，表被一次截断，物理删除。\n这种删除缺点：不支持回滚。\n这种删除优点：快速。\n\n2.5.1delete\ndelete from 表名 where 条件;\n\n没有条件，整张表的数据会全部删除！\n\ndelete from t_user where id &#x3D; 2;\n\n\n2.5.2truncate\ntruncate table dept_bak; （这种操作属于DDL操作。）\n\n下列演示内容所用表\nemp 员工表\n\nsalgarde 工资等级表\n\ndept 部门表\n\n3.基础增删改3.单表查询3.1基础条件查询\nselect  字段1,字段2,字段3….  from   表名  where  条件;\n\n&#x3D; 等于\n查询薪资等于800的员工姓名和编号？\n\t\tselect empno,ename from emp where sal &#x3D; 800;\n\t查询SMITH的编号和薪资？\n\t\tselect empno,sal from emp where ename &#x3D; &#39;SMITH&#39;; &#x2F;&#x2F;字符串使用单引号\n\n&lt;&gt;或!&#x3D; 不等于\n查询薪资不等于800的员工姓名和编号？\n\tselect empno,ename from emp where sal !&#x3D; 800;\n\tselect empno,ename from emp where sal &lt;&gt; 800; &#x2F;&#x2F; 小于号和大于号组成的不等号\n\n&lt; 小于  &lt;&#x3D; 小于等于\n查询薪资小于等于3000的员工姓名和编号？\n\t\tselect empno,ename,sal from emp where sal &lt;&#x3D; 3000;\n\n(&gt;)大于 **  ** (&gt;&#x3D;) 大于等于\n查询薪资大于等于3000的员工姓名和编号？\nselect empno,ename,sal from emp where sal &gt;&#x3D; 3000;\n\nbetween … and …. 两个值之间, 等同于 &gt;&#x3D; and &lt;&#x3D;\n查询薪资在2450和3000之间的员工信息？包括2450和3000\n\t第一种方式：&gt;&#x3D; and &lt;&#x3D; （and是并且的意思。）\n\t\tselect empno,ename,sal from emp where sal &gt;&#x3D; 2450 and sal &lt;&#x3D; 3000;\t\n\nis null 为 null（is not null 不为空）\n查询哪些员工的津贴&#x2F;补助为null？\n\t\tmysql&gt; select empno,ename,sal,comm from emp where comm &#x3D; null;\n\n查询哪些员工的津贴&#x2F;补助不为null？\n\t\tselect empno,ename,sal,comm from emp where comm is not null;\n\nand 并且    or 或者\nselect  * from emp where sal &gt; 2500 and (deptno &#x3D; 10 or deptno &#x3D; 20);\n\nand和or同时出现，and优先级较高。如果想让or先执行，需要加“小括号”,以后在开发中，如果不确定优先级，就加小括号就行了。\n\nin 包含，相当于多个 or （not in 不在这个范围中）\n查询工作岗位是MANAGER和SALESMAN的员工？\nselect empno,ename,job from emp where job &#x3D; &#39;MANAGER&#39; or job &#x3D; &#39;SALESMAN&#39;;\nselect empno,ename,job from emp where job in(&#39;MANAGER&#39;, &#39;SALESMAN&#39;);\n\nnot 可以取非，主要用在 is 或 in 中\nis null\nis not null\nin\nnot in\n\nlike \t\n称为模糊查询，支持%或下划线匹配\n\n%匹配任意多个字符\n下划线：任意一个字符。\n（%是一个特殊的符号，_ 也是一个特殊符号）\n\n\t\n\n找出名字中含有O的？\n\tmysql&gt; select ename from emp where ename like &#39;%O%&#39;;\n\n找出名字中有“_”的？\n\tselect name from t_student where name like &#39;%_%&#39;; &#x2F;&#x2F;这样不行。\n\n\tmysql&gt; select name from t_student where name like &#39;%\\_%&#39;; &#x2F;&#x2F; \\转义字符。\n\ndistinct\n\n把查询结果去除重复记录【distinct】\n\ndistinct只能出现在所有字段的最前方。\n\ndistinct出现在job,deptno两个字段之前，表示两个字段联合起来去重。\n\nselect distinct job from emp;\n\nselect distinct job,deptno from emp;\n\n\n3.2排序查询所有员工薪资，排序？\n\nselect  ename,sal from emp order by sal; &#x2F;&#x2F; 默认是升序！！！\n\n指定降序：desc\n\nselect  ename,sal from emp order by sal desc;\n\n查询员工名字和薪资，要求按照薪资升序，如果薪资一样的话，\n\t再按照名字升序排列。\n\tselect \n\t\tename,sal\n\tfrom\n\t\temp\n\torder by\n\t\tsal asc, ename asc; &#x2F;&#x2F; sal在前，起主导，只有sal相等的时候，才会考虑启用ename排序。\n\n3.3分页\nlimit作用：将查询结果集的一部分取出来。通常使用在分页查询当中。\n完整用法：limit startIndex, length\t\tstartIndex是起始下标，length是长度。\n起始下标从0开始。\n缺省用法：limit 5; 这是取前5.\n\n\n\n按照薪资降序，取出排名在前5名的员工？\nselect \n\t\tename,sal\n\tfrom\n\t\temp\n\torder by \n\t\tsal desc\n\tlimit 5; &#x2F;&#x2F;取前5\tlimit 0,5;\nmysql当中limit在order by之后执行！！！！！！\n\n取出工资排名在[3-5]名的员工？\n\tselect \n\t\tename,sal\n\tfrom\n\t\temp\n\torder by\n\t\tsal desc\n\tlimit\n\t\t2, 3;\n2表示起始位置从下标2开始，就是第三条记录。\n3表示长度。\n\n\n每页显示3条记录\n\n第1页：limit 0,3\t\t[0 1 2]\n第2页：limit 3,3\t\t[3 4 5]\n第3页：limit 6,3\t\t[6 7 8]\n\n\n每页显示pageSize条记录\n\n第pageNo页：limit (pageNo - 1) * pageSize  , pageSize\n\n\n\n4.函数4.1单行处理函数\n单行处理函数的特点：一个输入对应一个输出。\n和单行处理函数相对的是：多行处理函数。（多行处理函数特点：多个输入，对应1个输出！）\n\n\n\nlower 转换小写\n\tmysql&gt; select lower(ename) as ename from emp;\nupper 转换大写\n\t\tmysql&gt; select * from t_student;\nsubstr 取子串（substr( 被截取的字符串, 起始下标,截取的长度)）\n\t\tselect substr(ename, 1, 1) as ename from emp;\n\t\t注意：起始下标从1开始，没有0.\n\t\t找出员工名字第一个字母是A的员工信息？\n\t\t\t第一种方式：模糊查询\n\t\t\t\tselect ename from emp where ename like &#39;A%&#39;;\n\t\t\t第二种方式：substr函数\n\t\t\t\tselect \n\t\t\t\t\tename \n\t\t\t\tfrom \n\t\t\t\t\temp \n\t\t\t\twhere \n\t\t\t\t\tsubstr(ename,1,1) &#x3D; &#39;A&#39;;\nconcat函数进行字符串的拼接\n\t\tselect concat(empno,ename) from emp;\nlength 取长度\n\t\tselect length(ename) enamelength from emp;\ntrim 去空格\n\t\tmysql&gt; select * from emp where ename &#x3D; &#39;  KING&#39;;\nstr_to_date 将字符串转换成日期\ndate_format 格式化日期\nformat 设置千分位\nround 四舍五入\n\t\tselect 字段 from 表名;\n\t\tselect ename from emp;\n\t\tselect &#39;abc&#39; from emp; &#x2F;&#x2F; select后面直接跟“字面量&#x2F;字面值”\n\n\t\tmysql&gt; select &#39;abc&#39; as bieming from emp;\n\t\tselect round(1236.567, 1) as result from emp; &#x2F;&#x2F;保留1个小数\n\t\tselect round(1236.567, 2) as result from emp; &#x2F;&#x2F;保留2个小数\n\t\tselect round(1236.567, -1) as result from emp; &#x2F;&#x2F; 保留到十位。\nrand() 生成随机数\n\t\tmysql&gt; select round(rand()*100,0) from emp; &#x2F;&#x2F; 100以内的随机数\nifnull 可以将 null 转换成一个具体值\n\t\tifnull是空处理函数。专门处理空的。\n\t\t在所有数据库当中，只要有NULL参与的数学运算，最终结果就是NULL。\n\t\tmysql&gt; select ename, sal + comm as salcomm from emp;\n\n4.2分组函数\n多行处理函数的特点：输入多行，最终输出一行。\ncount\t计数\nsum\t求和\navg\t平均值\nmax\t最大值\nmin\t最小值\n\n\n注意：分组函数在使用的时候必须先进行分组，然后才能用。如果你没有对数据进行分组，整张表默认为一组。\n\n\t\n找出最高工资？\n\t\tmysql&gt; select max(sal) from emp;\n找出最低工资？\n\t\tmysql&gt; select min(sal) from emp;\n计算工资和：\n\t\tmysql&gt; select sum(sal) from emp;\n计算平均工资：\n\t\tmysql&gt; select avg(sal) from emp;\n计算员工数量？\n\t\tmysql&gt; select count(ename) from emp;\n\n分组函数在使用的时候需要注意哪些？\t\n\n第一点：分组函数自动忽略NULL，你不需要提前对NULL进行处理。\n第二点：分组函数中count()和count(具体字段)有什么区别？\ncount(具体字段)：表示统计该字段下所有不为NULL的元素的总数。\ncount(*)：统计表当中的总行数。（只要有一行数据count则++）            因为每一行记录不可能都为NULL，一行数据中有一列不为NULL，则这行数据就是有效的。\n\n\n第三点：分组函数不能够直接使用在where子句中。        找出比最低工资高的员工信息。              select ename,sal from emp where sal &gt; min(sal);              表面上没问题，运行一下？                  ERROR 1111 (HY000): Invalid use of group function\n\n5.分组查询5.1 group by找出每个工作岗位的工资和？\n\t实现思路：按照工作岗位分组，然后对工资求和。\n\t\tselect \n\t\t\tjob,sum(sal)\n\t\tfrom\n\t\t\temp\n\t\tgroup by\n\t\t\tjob;\n以上这个语句的执行顺序？\n先从emp表中查询数据。根据job字段进行分组。然后对每一组的数据进行sum(sal)\n\n\n在一条select语句当中，如果有group by语句的话，select后面只能跟：参加分组的字段，以及分组函数。其它的一律不能跟。**\n\n找出每个部门的最高薪资\n实现思路:按照部门编号分组，求每一组的最大值。\n\tmysql&gt; select deptno,max(sal) from emp group by deptno;\n\n5.2 联合分组找出“每个部门，不同工作岗位”的最高薪资？\n技巧：两个字段联合成1个字段看。（两个字段联合分组）\n\t\tselect \n\t\t\tdeptno, job, max(sal)\n\t\tfrom\n\t\t\temp\n\t\tgroup by\n\t\t\tdeptno, job;\n\n\n\n5.3having\n使用having可以对分完组之后的数据进一步过滤。\n\nhaving不能单独使用，having不能代替where，having必须和group by联合使用。\n\n\n找出每个部门平均薪资，要求显示平均薪资高于2500的。\nselect \n\tdeptno,avg(sal) \nfrom \n\temp \ngroup by \n\tdeptno\nhaving\n\tavg(sal) &gt; 2500;\n\n\nwhere和having，优先选择where，where实在完成不了了，再选择having。\n\n5.4总结sql执行顺序\nselect  –&gt; from –&gt; where –&gt; group by –&gt; having –&gt; order by –&gt;以上关键字只能按照这个顺序来，不能颠倒。\n\n执行顺序？    1. from –&gt; where –&gt; group by –&gt; having –&gt; select –&gt; order by\n\n从某张表中查询数据，\n先经过where条件筛选出有价值的数据。\n对这些有价值的数据进行分组。\n分组之后可以使用having继续筛选。\nselect查询出来。\n最后排序输出！\n\n找出每个岗位的平均薪资，要求显示平均薪资大于1500的，除MANAGER岗位之外，\n要求按照平均薪资降序排。\n\tselect \n\t\tjob, avg(sal) as avgsal\n\tfrom\n\t\temp\n\twhere\n\t\tjob &lt;&gt; &#39;MANAGER&#39;\n\tgroup by\n\t\tjob\n\thaving\n\t\tavg(sal) &gt; 1500\n\torder by\n\t\tavgsal desc;\n\n6.连表查询\n从一张表中单独查询，称为单表查询\n\nemp表和dept表联合起来查询数据，从emp表中取员工名字，从dept表中取部门名字。\n\n这种跨表查询，多张表联合起来查询数据，被称为连接查询。\n\n\nselect ename,dname from emp, dept;\n\n当两张表进行连接查询，没有任何条件限制的时候，最终查询结果条数，是两张表条数的乘积，这种现象被称为：笛卡尔积现象。\n\n6.1内连接之等值连接查询每个员工所在部门名称，显示员工名和部门名？\n\nemp e和dept d表进行连接。条件是：e.deptno &#x3D; d.deptno\n\nSQL92语法：\n\tselect \n\t\te.ename,d.dname\n\tfrom\n\t\temp e, dept d\n\twhere\n\t\te.deptno &#x3D; d.deptno;\n\t\n\tsql92的缺点：结构不清晰，表的连接条件，和后期进一步筛选的条件，都放到了where后面。\n\t\nSQL99语法：\n\t&#x2F;&#x2F;inner可以省略（带着inner可读性更好！！！一眼就能看出来是内连接）\n\tselect \n\t\te.ename,d.dname\n\tfrom\n\t\temp e\n\tinner join\n\t\tdept d\n\ton\n\t\te.deptno &#x3D; d.deptno; &#x2F;&#x2F; 条件是等量关系，所以被称为等值连接。\n\tsql99优点：表连接的条件是独立的，连接之后，如果还需要进一步筛选，再往后继续添加where\n\n6.2内连接之非等值连接找出每个员工的薪资等级，要求显示员工名、薪资、薪资等级？\nselect \n\te.ename, e.sal, s.grade\nfrom\n\temp e\njoin\n\tsalgrade s\non\n\te.sal between s.losal and s.hisal; &#x2F;&#x2F; 条件不是一个等量关系，称为非等值连接。\n\n6.3内连接自己连接查询员工的上级领导，要求显示员工名和对应的领导名？\n技巧：一张表看成两张表。\nselect \n\ta.ename as &#39;员工名&#39;, b.ename as &#39;领导名&#39;\nfrom\n\temp a\njoin\n\temp b\non\n\ta.mgr &#x3D; b.empno; &#x2F;&#x2F;员工的领导编号 &#x3D; 领导的员工编号\n\n6.4外连接\n内连接：（A和B连接，AB两张表没有主次关系。平等的。）\n\n内连接的特点：完成能够匹配上ON后面的条件的数据查询出来。\n\n\n&#x2F;&#x2F; outer是可以省略的，带着可读性强。\nselect \n\te.ename,d.dname\nfrom\n\temp e \nright outer join \n\tdept d\non\n\te.deptno &#x3D; d.deptno;\n\n\nright代表什么：表示将join关键字右边的这张表看成主表，主要是为了将\n这张表的数据全部查询出来，捎带着关联查询左边的表。\n在外连接当中，两张表连接，产生了主次关系。\n\nselect \n\te.ename,d.dname\nfrom\n\tdept d \nleft outer join \n\temp e\non\n\te.deptno &#x3D; d.deptno;\n\n带有right的是右外连接，又叫做右连接。\n带有left的是左外连接，又叫做左连接。\n任何一个右连接都有左连接的写法。\n任何一个左连接都有右连接的写法。\n\n6.5多表连接三张表，四张表怎么连接？\n语法：\n\tselect \n\t\t...\n\tfrom\n\t\ta\n\tjoin\n\t\tb\n\ton\n\t\ta和b的连接条件\n\tjoin\n\t\tc\n\ton\n\t\ta和c的连接条件\n\tright join\n\t\td\n\ton\n\t\ta和d的连接条件\n\n找出每个员工的部门名称以及工资等级，要求显示员工名、部门名、薪资、薪资等级？\nselect \n\t\te.ename,e.sal,d.dname,s.grade\n\tfrom\n\t\temp e\n\tjoin\n\t\tdept d\n\ton \n\t\te.deptno &#x3D; d.deptno\n\tjoin\n\t\tsalgrade s\n\ton\n\t\te.sal between s.losal and s.hisal;\n\n找出每个员工的部门名称以及工资等级，还有上级领导，要求显示员工名、领导名、部门名、薪资、薪资等级？\nselect \n\te.ename,e.sal,d.dname,s.grade,l.ename\nfrom\n\temp e\njoin\n\tdept d\non \n\te.deptno &#x3D; d.deptno\njoin\n\tsalgrade s\non\n\te.sal between s.losal and s.hisal\nleft join\n\temp l\non\n\te.mgr &#x3D; l.empno;\n\n7.子查询\nselect语句中嵌套select语句，被嵌套的select语句称为子查询。\n\n子查询可以出现在 select后面，from 后面，where 后面。\n\n\n7.1where子句中的子查询找出比最低工资高的员工姓名和工资？\n\nselect ename,sal from emp where sal &gt; (select min(sal) from emp);\n\n7.2from子句中的子查询\nfrom后面的子查询，可以将子查询的查询结果当做一张临时表。（技巧）\n\n找出每个岗位的平均工资的薪资等级。\nselect \n\t\t\tt.*, s.grade\n\t\tfrom\n\t\t\t(select job,avg(sal) as avgsal from emp group by job) t\n\t\tjoin\n\t\t\tsalgrade s\n\t\ton\n\t\t\tt.avgsal between s.losal and s.hisal;\n\n8.约束\n在创建表的时候，我们可以给表中的字段加上一些约束，来保证这个表中数据的完整性、有效性！！！\n\n8.1约束类型\n非空约束：not null\n唯一性约束: unique\n主键约束: primary key （简称PK）\n外键约束：foreign key（简称FK）\n检查约束：check（mysql不支持，oracle支持）\n\n我们这里重点学习四个约束：not null，unique，primary key，foreign key。\n8.2not null\n非空约束not null约束的字段不能为NULL。\n\ndrop table if exists t_vip;\n\tcreate table t_vip(\n\t\tid int,\n\t\tname varchar(255) not null  &#x2F;&#x2F; not null只有列级约束，没有表级约束！\n\t);\ninsert into t_vip(id,name) values(1,&#39;zhangsan&#39;);\n\ninsert into t_vip(id) values(3);\n\tERROR 1364 (HY000): Field &#39;name&#39; doesn&#39;t have a default value\n\n\n\n8.3unique\n唯一性约束unique约束的字段不能重复，但是可以为NULL。\n\ndrop table if exists t_vip;\ncreate table t_vip(\n\tid int,\n\tname varchar(255) unique,\n\temail varchar(255)\n);\ninsert into t_vip(id,name,email) values(2,&#39;lisi&#39;,&#39;lisi@123.com&#39;);\ninsert into t_vip(id,name,email) values(3,&#39;wangwu&#39;,&#39;wangwu@123.com&#39;);\nselect * from t_vip;\n\ninsert into t_vip(id,name,email) values(4,&#39;wangwu&#39;,&#39;wangwu@sina.com&#39;);\nERROR 1062 (23000): Duplicate entry &#39;wangwu&#39; for key &#39;name&#39;\n\ninsert into t_vip(id) values(4);\ninsert into t_vip(id) values(5);\n+------+----------+------------------+\n| id   | name     | email            |\n+------+----------+------------------+\n|    1 | zhangsan | zhangsan@123.com |\n|    2 | lisi     | lisi@123.com     |\n|    3 | wangwu   | wangwu@123.com   |\n|    4 | NULL     | NULL             |\n|    5 | NULL     | NULL             |\n+------+----------+------------------+\nname字段虽然被unique约束了，但是可以为NULL。\n\n8.3.1联合唯一\nname和email两个字段联合起来具有唯一性！！！！\n\ndrop table if exists t_vip;\ncreate table t_vip(\n\tid int,\n\tname varchar(255),\n\temail varchar(255),\n\tunique(name,email) &#x2F;&#x2F; 约束没有添加在列的后面，这种约束被称为表级约束。\n);\ninsert into t_vip(id,name,email) values(1,&#39;zhangsan&#39;,&#39;zhangsan@123.com&#39;);\ninsert into t_vip(id,name,email) values(2,&#39;zhangsan&#39;,&#39;zhangsan@sina.com&#39;);\n\tname和email两个字段联合起来唯一！！！\n\t\ninsert into t_vip(id,name,email) values(3,&#39;zhangsan&#39;,&#39;zhangsan@sina.com&#39;);\n\tERROR 1062 (23000): Duplicate entry &#39;zhangsan-zhangsan@sina.com&#39; for key &#39;name&#39;\n\n\n在mysql当中，如果一个字段同时被not null和unique约束的话，该字段自动变成主键字段。（注意：oracle中不一样！）\n\n8.4primary key\n主键值是每一行记录的唯一标识。主键值是每一行记录的身份证号！！！\n\n主键的特征：not null + unique（主键值不能是NULL，同时也不能重复！）\n\n\ndrop table if exists t_vip;\n\t\t&#x2F;&#x2F; 1个字段做主键，叫做：单一主键\n\t\tcreate table t_vip(\n\t\t\tid int primary key,  &#x2F;&#x2F;列级约束\n\t\t\tname varchar(255),\n            primary key(id)  &#x2F;&#x2F; 表级约束\n\t\t);\n\t\tinsert into t_vip(id,name) values(1,&#39;zhangsan&#39;);\n\t\tinsert into t_vip(id,name) values(2,&#39;lisi&#39;);\n\n\t\t&#x2F;&#x2F;错误：不能重复\n\t\tinsert into t_vip(id,name) values(2,&#39;wangwu&#39;);\n\t\tERROR 1062 (23000): Duplicate entry &#39;2&#39; for key &#39;PRIMARY&#39;\n\n\t\t&#x2F;&#x2F;错误：不能为NULL\n\t\tinsert into t_vip(name) values(&#39;zhaoliu&#39;);\n\t\tERROR 1364 (HY000): Field &#39;id&#39; doesn&#39;t have a default value\n\n8.4.1复合主键drop table if exists t_vip;\n\t\t&#x2F;&#x2F; id和name联合起来做主键：复合主键！！！！\n\t\tcreate table t_vip(\n\t\t\tid int,\n\t\t\tname varchar(255),\n\t\t\temail varchar(255),\n\t\t\tprimary key(id,name)\n\t\t);\ninsert into t_vip(id,name,email) values(1,&#39;zhangsan&#39;,&#39;zhangsan@123.com&#39;);\ninsert into t_vip(id,name,email) values(1,&#39;lisi&#39;,&#39;lisi@123.com&#39;);\n\n&#x2F;&#x2F;错误：不能重复\ninsert into t_vip(id,name,email) values(1,&#39;lisi&#39;,&#39;lisi@123.com&#39;);\n\tERROR 1062 (23000): Duplicate entry &#39;1-lisi&#39; for key &#39;PRIMARY&#39;\n\n\n在实际开发中不建议使用：复合主键。建议使用单一主键！\n因为主键值存在的意义就是这行记录的身份证号，只要意义达到即可，单一主键可以做到。\n\n一个表中主键约束能加两个吗？\n\t\tdrop table if exists t_vip;\n\t\tcreate table t_vip(\n\t\t\tid int primary key,\n\t\t\tname varchar(255) primary key\n\t\t);\n\t\tERROR 1068 (42000): Multiple primary key defined\n\n\n结论：一张表，主键约束只能添加1个。（主键只能有1个。）\n\n主键分类\n\n自然主键：主键值是一个自然数，和业务没关系。\n\n业务主键：主键值和业务紧密关联，例如拿银行卡账号做主键值。这就是业务主键！\n\n\n8.4.2主键自增\n在mysql当中，有一种机制，可以帮助我们自动维护一个主键值\n\nrop table if exists t_vip;\ncreate table t_vip(\n\tid int primary key auto_increment, &#x2F;&#x2F;auto_increment表示自增，从1开始，以1递增！\n\tname varchar(255)\n);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\t\n\t\t+----+----------+\n\t\t| id | name     |\n\t\t+----+----------+\n\t\t|  1 | zhangsan |\n\t\t|  2 | zhangsan |\n\t\t|  3 | zhangsan |\n\t\t|  4 | zhangsan |\n\t\t|  5 | zhangsan |\n\n8.5foreign key\n如果一个实体的某个字段指向另一个实体的主键，就称为外键\n被指向的实体，称之为主实体（主表），也叫父实体（父表）。\n负责指向的实体，称之为从实体（从表），也叫子实体（子表）\n\ncreate table t_class(\n\tclassno int primary key,\n\tclassname varchar(255)\n);\ncreate table t_student(\n\tno int primary key auto_increment,\n\tname varchar(255),\n\tcno int,\n\tforeign key(cno) references t_class(classno)\n);\n\ninsert into t_class(classno, classname) values(100, &#39;北京市大兴区亦庄镇第二中学高三1班&#39;);\ninsert into t_class(classno, classname) values(101, &#39;北京市大兴区亦庄镇第二中学高三1班&#39;);\n\ninsert into t_student(name,cno) values(&#39;jack&#39;, 100);\ninsert into t_student(name,cno) values(&#39;lilei&#39;, 100);\ninsert into t_student(name,cno) values(&#39;hanmeimei&#39;, 100);\ninsert into t_student(name,cno) values(&#39;zhangsan&#39;, 101);\ninsert into t_student(name,cno) values(&#39;lisi&#39;, 101);\n\n\n外键可以为空，可以理解成 一名学生肯定会关联到一个存在的班级，但来了一个转校生，还没有分班，他现在属于学生子表，但还没有关联到班级主表中的任何一条记录。\n\nt_class是父表，t_student是子表\n​\t\t删除表的顺序？\t先删子，再删父。\n​\t\t创建表的顺序？\t先创建父，再创建子。\n​\t\t删除数据的顺序？先删子，再删父。\n​\t\t插入数据的顺序？先插入父，再插入子\n\n子表中的外键引用的父表中的某个字段，被引用的这个字段不一定是主键，但至少具有unique约束。\n\n9.存储引擎\n存储引擎是MySQL中特有的一个术语，其它数据库中没有。（Oracle中有，但是不叫这个名字）\n实际上存储引擎是一个表存储&#x2F;组织数据的方式。\n不同的存储引擎，表存储数据的方式不同。\n\nshow create table t_student;\n可以在建表的时候给表指定存储引擎。\nCREATE TABLE &#96;t_student&#96; (\n  &#96;no&#96; int(11) NOT NULL AUTO_INCREMENT,\n  &#96;name&#96; varchar(255) DEFAULT NULL,\n  &#96;cno&#96; int(11) DEFAULT NULL,\n  PRIMARY KEY (&#96;no&#96;),\n  KEY &#96;cno&#96; (&#96;cno&#96;),\n  CONSTRAINT &#96;t_student_ibfk_1&#96; FOREIGN KEY (&#96;cno&#96;) REFERENCES &#96;t_class&#96; (&#96;classno&#96;)\n) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;11 DEFAULT CHARSET&#x3D;utf8\n\n在建表的时候可以在最后小括号的”)”的右边使用：\n\nENGINE来指定存储引擎。\tmysql默认的存储引擎是：InnoDB\nCHARSET来指定这张表的字符编码方式。mysql默认的字符编码方式是：utf8\n\n9.1mysql支持的存储引擎\nshow engines \\G   查看mysql支持哪些存储引擎\nmysql支持九大存储引擎，当前5.5.36支持8个。版本不同支持情况不同。\n\n\n9.2MyISAM存储引擎\n使用三个文件表示每个表：\n\n格式文件 — 存储表结构的定义（mytable.frm）\n数据文件 — 存储表行的内容（mytable.MYD）\n索引文件 — 存储表上索引（mytable.MYI）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。\n\n\n可被转换为压缩、只读表来节省空间\n\nMyISAM存储引擎特点：\n\n可被转换为压缩、只读表来节省空间这是这种存储引擎的优势！！！！\nMyISAM不支持事务机制，安全性低。\n\n\n\n9.3InnoDB存储引擎\n这是mysql默认的存储引擎，同时也是一个重量级的存储引擎。\n\nInnoDB支持事务，支持数据库崩溃后自动恢复机制。\n\nInnoDB存储引擎最主要的特点是：非常安全。\n\n它管理的表具有下列主要特征：\n\n每个 InnoDB 表在数据库目录中以.frm 格式文件表示\nInnoDB 表空间 tablespace 被用于存储表的内容（表空间是一个逻辑名称。表空间存储数据+索引。）\n提供一组用来记录事务性活动的日志文件\n用 COMMIT(提交)、SAVEPOINT 及ROLLBACK(回滚)支持事务处理\n提供全 ACID 兼容\n在 MySQL 服务器崩溃后提供自动恢复\n多版本（MVCC）和行级锁定\n支持外键及引用的完整性，包括级联删除和更新\n\n\nInnoDB最大的特点就是支持事务：以保证数据的安全。效率不是很高，并且也不能压缩，不能转换为只读，\n\n不能很好的节省存储空间。\n\n\n9.4MEMORY存储引擎\n使用 MEMORY 存储引擎的表，其数据存储在内存中，且行的长度固定，这两个特点使得 MEMORY 存储引擎非常快。\n\nMEMORY 存储引擎管理的表具有下列特征：\n\n在数据库目录内，每个表均以.frm 格式的文件表示。\n表数据及索引被存储在内存中。（目的就是快，查询快！）\n表级锁机制。\n不能包含 TEXT 或 BLOB 字段。\n\n\nMEMORY 存储引擎以前被称为HEAP 引擎。\n\nMEMORY引擎优点：查询效率是最高的。不需要和硬盘交互。\n\nMEMORY引擎缺点：不安全，关机之后数据消失。因为数据和索引都是在内存当中。\n\n\n10.事务\n一个事务其实就是一个完整的业务逻辑。是一个最小的工作单元。不可再分。\n\n什么是一个完整的业务逻辑？    假设转账，从A账户向B账户中转账10000.      将A账户的钱减去10000（update语句）      将B账户的钱加上10000（update语句）      这就是一个完整的业务逻辑。\n\n以上的操作是一个最小的工作单元，要么同时成功，要么同时失败，不可再分。这两个update语句要求必须同时成功或者同时失败，这样才能保证钱是正确的。\n\ninsert   delete   update  只有以上的三个语句和事务有关系，其它都没有关系。\n\n事务：就是批量的DML语句同时成功，或者同时失败！\n\n\n10.1InnoDB实现事务\nInnoDB存储引擎：提供一组用来记录事务性活动的日志文件\n\n在事务的执行过程中，每一条DML的操作都会记录到“事务性活动的日志文件”中。\n\n在事务的执行过程中，我们可以提交事务，也可以回滚事务。\n\n提交事务   commit; 语句\n\n清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中。\n提交事务标志着，事务的结束。并且是一种全部成功的结束。\n\n\n回滚事务  rollback; 语句（回滚永远都是只能回滚到上一次的提交点！）\n\n将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件\n回滚事务标志着，事务的结束。并且是一种全部失败的结束。\n\n\n将mysql的自动提交机制关闭掉   start transaction;\n\n\n事务回滚\n\tmysql&gt; select * from dept_bak;\n\t\tEmpty set (0.00 sec)\n\tmysql&gt; start transaction;\n\tQuery OK, 0 rows affected (0.00 sec)\n\n\tmysql&gt; insert into dept_bak values(10,&#39;abc&#39;, &#39;tj&#39;);\n\tQuery OK, 1 row affected (0.00 sec)\n\n\tmysql&gt; insert into dept_bak values(10,&#39;abc&#39;, &#39;tj&#39;);\n\tQuery OK, 1 row affected (0.00 sec)\n\n\tmysql&gt; select * from dept_bak;\n\t+--------+-------+------+\n\t| DEPTNO | DNAME | LOC  |\n\t+--------+-------+------+\n\t|     10 | abc   | tj   |\n\t|     10 | abc   | tj   |\n\t+--------+-------+------+\n\t2 rows in set (0.00 sec)\n\n\tmysql&gt; rollback;\n\tQuery OK, 0 rows affected (0.00 sec)\n\n\tmysql&gt; select * from dept_bak;\n\tEmpty set (0.00 sec)\n\n10.2事物的四个特性A：原子性        说明事务是最小的工作单元。不可再分。\nC：一致性    所有事务要求，在同一个事务当中，所有操作必须同时成功，或者同时失败，    以保证数据的一致性。\nI：隔离性    A事务和B事务之间具有一定的隔离。    教室A和教室B之间有一道墙，这道墙就是隔离性。    A事务在操作一张表的时候，另一个事务B也操作这张表会那样？？？\nD：持久性    事务最终结束的一个保障。事务提交，就相当于将没有保存到硬盘上的数据    保存到硬盘上！\n10.3事务的隔离性10.3.1事务和事务之间四个隔离级别读未提交：read uncommitted（最低的隔离级别）《没有提交就读到了》\n\n事务A可以读取到事务B未提交的数据。\n这种隔离级别存在的问题就是：脏读现象！(Dirty Read)我们称读到了脏数据。\n这种隔离级别一般都是理论上的，大多数的数据库隔离级别都是二档起步！\n\n读已提交：read committed《提交之后才能读到》\n\n事务A只能读取到事务B提交之后的数据。\n这种隔离级别解决了解决了脏读的现象。\n这种隔离级别不可重复读取数据。\n在事务开启之后，第一次读到的数据是3条，当前事务还没有结束，可能第二次再读取的时候，读到的数据是4条，3不等于4称为不可重复读取。\n\n\n这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实。\noracle数据库默认的隔离级别是：read committed\n\n可重复读：repeatable read《提交之后也读不到，永远读取的都是刚开启事务时的数据》\n\n事务A开启之后，不管是多久，每一次在事务A中读取到的数据都是一致的。即使事务B将数据已经修改，并且提交了，事务A读取到的数据还是没有发生改变，这就是可重复读。\n\n可重复读可能会出现幻影读。每一次读取到的数据都是幻象。不够真实！\n\n早晨9点开始开启了事务，只要事务不结束，到晚上9点，读到的数据还是那样！读到的是假象。不够绝对的真实。\n\nmysql中默认的事务隔离级别就是这个！！！！！！！！！！！\n\n\n序列化&#x2F;串行化：serializable（最高的隔离级别）\n\n这是最高隔离级别，效率最低。解决了所有的问题。\n这种隔离级别表示事务排队，不能并发！\nsynchronized，线程同步（事务同步）每一次读取到的数据都是最真实的，并且效率是最低的。\n\n10.3.2验证各种隔离级别\nmysql 5 查看隔离级别：SELECT @@tx_isolation\nmysql 8 查看隔离级别：select @@transaction_isolation;\n\n验证：read uncommited\nmysql&gt; set global transaction isolation level read uncommitted;\n事务A\t\t\t\t\t\t\t\t\t\t\t\t\t事务B\n--------------------------------------------------------------------------------\nuse bjpowernode;\n\t\t\t\t\t\t\t\t\t\t\t\t\tuse bjpowernode;\nstart transaction;\nselect * from t_user;\n\t\t\t\t\t\t\t\t\t\t\t\t\tstart transaction;\n\t\t\t\t\t\t\t\t\t\t\t\t\tinsert into t_user values(&#39;zhangsan&#39;);\nselect * from t_user;\n\n验证：read commited\nmysql&gt; set global transaction isolation level read committed;\n事务A\t\t\t\t\t\t\t\t\t\t\t\t\t事务B\n--------------------------------------------------------------------------------\nuse bjpowernode;\n\t\t\t\t\t\t\t\t\t\t\t\t\tuse bjpowernode;\nstart transaction;\n\t\t\t\t\t\t\t\t\t\t\t\t\tstart transaction;\nselect * from t_user;\n\t\t\t\t\t\t\t\t\t\t\t\t\tinsert into t_user values(&#39;zhangsan&#39;);\nselect * from t_user;\n\t\t\t\t\t\t\t\t\t\t\t\t\tcommit;\nselect * from t_user;\n\n验证：repeatable read\nmysql&gt; set global transaction isolation level repeatable read;\n事务A\t\t\t\t\t\t\t\t\t\t\t\t\t事务B\n--------------------------------------------------------------------------------\nuse bjpowernode;\n\t\t\t\t\t\t\t\t\t\t\t\t\tuse bjpowernode;\nstart transaction;\n\t\t\t\t\t\t\t\t\t\t\t\t\tstart transaction;\nselect * from t_user;\n\t\t\t\t\t\t\t\t\t\t\t\t\tinsert into t_user values(&#39;lisi&#39;);\n\t\t\t\t\t\t\t\t\t\t\t\t\tinsert into t_user values(&#39;wangwu&#39;);\n\t\t\t\t\t\t\t\t\t\t\t\t\tcommit;\nselect * from t_user;\n\n验证：serializable\nmysql&gt; set global transaction isolation level serializable;\n事务A\t\t\t\t\t\t\t\t\t\t\t\t\t事务B\n--------------------------------------------------------------------------------\nuse bjpowernode;\n\t\t\t\t\t\t\t\t\t\t\t\t\tuse bjpowernode;\nstart transaction;\n\t\t\t\t\t\t\t\t\t\t\t\t\tstart transaction;\nselect * from t_user;\ninsert into t_user values(&#39;abc&#39;);\n\n11.索引\n索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。\n\n一张表的一个字段可以添加一个索引，当然，多个字段联合起来也可以添加索引。\n\n索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。\n\nMySQL在查询方面主要就是两种方式：全表扫描  ；根据索引检索。\n\n在mysql数据库当中索引也是需要排序的，并且这个所以的排序和TreeSet\n\n数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！在mysql当中索引是一个B-Tree数据结构。\n\n遵循左小又大原则存放。采用中序遍历方式遍历取数据。\n\n\n索引的实现原理？\n\n\n提醒1：在任何数据库当中主键上都会自动添加索引对象，id字段上自动有索引，因为id是PK。另外在mysql当中，一个字段上如果有unique约束的话，也会自动创建索引对象\n提醒2：在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号。\n提醒3：在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引擎中，索引存储在一个.MYI文件中。在InnoDB存储引擎中索引存储在一个逻辑名称叫做tablespace的当中。在MEMORY存储引擎当中索引被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式\n\n什么条件下，我们会考虑给字段添加索引呢？\n\n数据量庞大（到底有多么庞大算庞大，这个需要测试，因为每一个硬件环境不同）\n该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。\n该字段很少的DML(insert delete update)操作。（因为DML之后，索引需要重新排序。）\n\n\n建议不要随意添加索引，因为索引也是需要维护的，太多的话反而会降低系统的性能。\n建议通过主键查询，建议通过unique约束的字段进行查询，效率是比较高的。\n\n11.1索引的创建和删除创建索引：\n\tmysql&gt; create index emp_ename_index on emp(ename);\n\t给emp表的ename字段添加索引，起名：emp_ename_index\n删除索引：\n\tmysql&gt; drop index emp_ename_index on emp;\n\t将emp表上的emp_ename_index索引对象删除。\n\t\n\t\n\t查看一个SQL语句是否使用了索引进行检索？\n\tmysql&gt; explain select * from emp where ename &#x3D; &#39;KING&#39;;\n\t+----+-------------+-------+------+---------------+------+---------+--\n\t| id | select_type | table | type | possible_keys | key  | key_len | \n\t+----+-------------+-------+------+---------------+------+---------+-\n\t|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\t扫描14条记录：说明没有使用索引。type&#x3D;ALL\n\n\tmysql&gt; create index emp_ename_index on emp(ename);\n\n\tmysql&gt; explain select * from emp where ename &#x3D; &#39;KING&#39;;\n\t+----+-------------+-------+------+-----------------+-----------------\n\t| id | select_type | table | type | possible_keys   | key             \n\t+----+-------------+-------+------+-----------------+-----------------\n\t|  1 | SIMPLE      | emp   | ref  | emp_ename_index | emp_ename_index \n\t+----+-------------+-------+------+-----------------+-----------------\n\n11.2索引失效失效的第1种情况：\n\tselect * from emp where ename like &#39;%T&#39;;\n\tename上即使添加了索引，也不会走索引，为什么？\n\t\t原因是因为模糊匹配当中以“%”开头了！\n\t\t尽量避免模糊查询的时候以“%”开始。\n\t\t这是一种优化的手段&#x2F;策略。\n\tmyql&gt; explain select * from emp where ename like &#39;%T&#39;;\n\t+----+-------------+-------+------+---------------+------+---------+--\n\t| id | select_type | table | type | possible_keys | key  | key_len | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\t|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\n失效的第2种情况：\n\t使用or的时候会失效，如果使用or那么要求or两边的条件字段都要有\n\t索引，才会走索引，如果其中一边有一个字段没有索引，那么另一个\n\t字段上的索引也会实现。所以这就是为什么不建议使用or的原因。\n\n\tmysql&gt; explain select * from emp where ename &#x3D; &#39;KING&#39; or job &#x3D; &#39;MANAGER&#39;;\n\t+----+-------------+-------+------+-----------------+------+---------\n\t| id | select_type | table | type | possible_keys   | key  | key_len | \n\t+----+-------------+-------+------+-----------------+------+---------\n\t|  1 | SIMPLE      | emp   | ALL  | emp_ename_index | NULL | NULL    | \n\t+----+-------------+-------+------+-----------------+------+---------\n\n失效的第3种情况：\n\t使用复合索引的时候，没有使用左侧的列查找，索引失效\n\t什么是复合索引？\n\t\t两个字段，或者更多的字段联合起来添加一个索引，叫做复合索引。\n\t\n\tcreate index emp_job_sal_index on emp(job,sal);\n\t\n\tmysql&gt; explain select * from emp where job &#x3D; &#39;MANAGER&#39;;\n\t+----+-------------+-------+------+-------------------+---------------\n\t| id | select_type | table | type | possible_keys     | key           \n\t+----+-------------+-------+------+-------------------+---------------\n\t|  1 | SIMPLE      | emp   | ref  | emp_job_sal_index | \n\t+----+-------------+-------+------+-------------------+---------------\n\t\n\tmysql&gt; explain select * from emp where sal &#x3D; 800;\n\t+----+-------------+-------+------+---------------+------+---------+--\n\t| id | select_type | table | type | possible_keys | key  | key_len | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\t|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\n12.视图\n视图view:站在不同的角度去看待同一份数据。\n\n表复制：\n\tmysql&gt; create table dept2 as select * from dept;\ndept2表中的数据：\n\tmysql&gt; select * from dept2;\n+--------+------------+----------+\n| DEPTNO | DNAME      | LOC      |\n+--------+------------+----------+\n|     10 | ACCOUNTING | NEW YORK |\n|     20 | RESEARCH   | DALLAS   |\n|     30 | SALES      | CHICAGO  |\n|     40 | OPERATIONS | BOSTON   |\n+--------+------------+----------+\n\n创建视图对象：\n\tcreate view dept2_view as select * from dept2;\n\n删除视图对象：\n\tdrop view dept2_view;\n\n注意：只有DQL语句才能以view的形式创建。\n\tcreate view view_name as 这里的语句必须是DQL语句;\n\n12.1视图的作用\n我们可以面向视图对象进行增删改查，对视图对象的增删改查，会导致原表被操作！（视图的特点：通过对视图的操作，会影响到原表数据。）\n\n&#x2F;&#x2F;面向视图查询\nselect * from dept2_view; \n\n&#x2F;&#x2F; 面向视图插入\ninsert into dept2_view(deptno,dname,loc) values(60,&#39;SALES&#39;, &#39;BEIJING&#39;);\n\n&#x2F;&#x2F; 查询原表数据\nmysql&gt; select * from dept2;\n+--------+------------+----------+\n| DEPTNO | DNAME      | LOC      |\n+--------+------------+----------+\n|     10 | ACCOUNTING | NEW YORK |\n|     20 | RESEARCH   | DALLAS   |\n|     30 | SALES      | CHICAGO  |\n|     40 | OPERATIONS | BOSTON   |\n|     60 | SALES      | BEIJING  |\n+--------+------------+----------+\n\n&#x2F;&#x2F; 面向视图删除\nmysql&gt; delete from dept2_view;\n\n&#x2F;&#x2F; 查询原表数据\nmysql&gt; select * from dept2;\nEmpty set (0.00 sec)\n&#x2F;&#x2F; 创建视图对象\ncreate view \n\temp_dept_view\nas\n\tselect \n\t\te.ename,e.sal,d.dname\n\tfrom\n\t\temp e\n\tjoin\n\t\tdept d\n\ton\n\t\te.deptno &#x3D; d.deptno;\n\n&#x2F;&#x2F; 查询视图对象\nmysql&gt; select * from emp_dept_view;\n+--------+---------+------------+\n| ename  | sal     | dname      |\n+--------+---------+------------+\n| CLARK  | 2450.00 | ACCOUNTING |\n| KING   | 5000.00 | ACCOUNTING |\n| MILLER | 1300.00 | ACCOUNTING |\n| SMITH  |  800.00 | RESEARCH   |\n| JONES  | 2975.00 | RESEARCH   |\n| SCOTT  | 3000.00 | RESEARCH   |\n| ADAMS  | 1100.00 | RESEARCH   |\n| FORD   | 3000.00 | RESEARCH   |\n| ALLEN  | 1600.00 | SALES      |\n| WARD   | 1250.00 | SALES      |\n| MARTIN | 1250.00 | SALES      |\n| BLAKE  | 2850.00 | SALES      |\n| TURNER | 1500.00 | SALES      |\n| JAMES  |  950.00 | SALES      |\n+--------+---------+------------+\n\n&#x2F;&#x2F; 面向视图更新\nupdate emp_dept_view set sal &#x3D; 1000 where dname &#x3D; &#39;ACCOUNTING&#39;;\n\n&#x2F;&#x2F; 原表数据被更新\nmysql&gt; select * from emp;\n+-------+--------+-----------+------+------------+---------+---------+----\n| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | \n+-------+--------+-----------+------+------------+---------+---------+----\n|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     \n|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     \n|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     \n|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     \n|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     \n|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     \n|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 1000.00 |    NULL |     \n|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     \n|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 1000.00 |    NULL |     \n|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     \n|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     \n|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     \n|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     \n|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1000.00 |    NULL |     \n+-------+--------+-----------+------+------------+---------+---------+----\n\n12.2视图在开发中的作用\n假设有一条非常复杂的SQL语句，而这条SQL语句需要在不同的位置上反复使用。每一次使用这个sql语句的时候都需要重新编写，很长，很麻烦，怎么办？    可以把这条复杂的SQL语句以视图对象的形式新建。    在需要编写这条SQL语句的位置直接使用视图对象，可以大大简化开发。    并且利于后期的维护，因为修改的时候也只需要修改一个位置就行，只需要    修改视图对象所映射的SQL语句。\n\n我们以后面向视图开发的时候，使用视图的时候可以像使用table一样。\n\n可以对视图进行增删改查等操作。*视图不是在内存当中，视图对象也是存储在硬盘上的，不会消失。*\n\n\n13.数据库三范式第一范式：要求任何一张表必须有主键，每一个字段原子性不可再分。\n第二范式：建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，不要产生部分依赖。\n第三范式：建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，不要产生传递依赖。\n\n声明：三范式是面试官经常问的，所以一定要熟记在心！\n\n设计数据库表的时候，按照以上的范式进行，可以避免表中数据的冗余，空间的浪费。\n13.1第一范式学生编号 学生姓名 联系方式\n\t------------------------------------------\n\t1001\t\t张三\t\tzs@gmail.com,1359999999\n\t1002\t\t李四\t\tls@gmail.com,13699999999\n\t1001\t\t王五\t\tww@163.net,13488888888\n\t\n以上是学生表，满足第一范式吗？\n\t不满足，第一：没有主键。第二：联系方式可以分为邮箱地址和电话\n\n学生编号(pk) 学生姓名\t邮箱地址\t\t\t联系电话\n----------------------------------------------------\n1001\t\t\t\t张三\t\tzs@gmail.com\t1359999999\n1002\t\t\t\t李四\t\tls@gmail.com\t13699999999\n1003\t\t\t\t王五\t\tww@163.net\t\t13488888888\n\n13.2第二范式\t学生编号 \t\t学生姓名 \t教师编号 教师姓名\n\t----------------------------------------------------\n\t1001\t\t\t张三\t\t001\t\t王老师\n\t1002\t\t\t李四\t\t002\t\t赵老师\n\t1003\t\t\t王五\t\t001\t\t王老师\n\t1001\t\t\t张三\t\t002\t\t赵老师\n这张表描述了学生和老师的关系：（1个学生可能有多个老师，1个老师有多个学生）\n这是非常典型的：多对多关系！\n\n分析以上的表是否满足第一范式？\n\t不满足第一范式。\n\n怎么满足第一范式呢？修改\n\n学生编号+教师编号(pk)\t\t学生姓名  教师姓名\n----------------------------------------------------\n1001\t\t\t001\t\t\t\t张三\t\t\t王老师\n1002\t\t\t002\t\t\t\t李四\t\t\t赵老师\n1003\t\t\t001\t\t\t\t王五\t\t\t王老师\n1001\t\t\t002\t\t\t\t张三\t\t\t赵老师\n\n学生编号 教师编号，两个字段联合做主键，复合主键（PK: 学生编号+教师编号）\n经过修改之后，以上的表满足了第一范式。但是满足第二范式吗？\n\t不满足，“张三”依赖1001，“王老师”依赖001，显然产生了部分依赖。\n\t产生部分依赖有什么缺点？\n\t\t数据冗余了。空间浪费了。“张三”重复了，“王老师”重复了。\n\n为了让以上的表满足第二范式，你需要这样设计：\n\t使用三张表来表示多对多的关系！！！！\n\t学生表\n\t学生编号(pk)\t\t学生名字\n\t------------------------------------\n\t1001\t\t\t\t\t张三\n\t1002\t\t\t\t\t李四\n\t1003\t\t\t\t\t王五\n\t\n\t教师表\n\t教师编号(pk)\t\t教师姓名\n\t--------------------------------------\n\t001\t\t\t\t\t王老师\n\t002\t\t\t\t\t赵老师\n\n\t学生教师关系表\n\tid(pk)\t\t\t学生编号(fk)\t\t\t教师编号(fk)\n\t------------------------------------------------------\n\t1\t\t\t\t\t\t1001\t\t\t\t\t\t001\n\t2\t\t\t\t\t\t1002\t\t\t\t\t\t002\n\t3\t\t\t\t\t\t1003\t\t\t\t\t\t001\n\t4\t\t\t\t\t\t1001\t\t\t\t\t\t002\n\n\n多对多，三张表，关系表两个外键！！！！！！！！！！！！！！！\n\n13.3第三范式​\t\n\t学生编号（PK） \t\t\t学生姓名  班级编号  \t班级名称\n---------------------------------------------------------\n\n​\t\t1001\t\t\t\t张三\t\t01\t\t\t一年一班\n​\t\t1002\t\t\t\t李四\t\t02\t\t\t一年二班\n​\t\t1003\t\t\t\t王五\t\t03\t\t\t一年三班\n​\t\t1004\t\t\t\t赵六\t\t03\t\t\t一年三班\n\n以上表的设计是描述：班级和学生的关系。很显然是1对多关系！\n一个教室中有多个学生。\n\n分析以上表是否满足第一范式？\n\t满足第一范式，有主键。\n\n分析以上表是否满足第二范式？\n\t满足第二范式，因为主键不是复合主键，没有产生部分依赖。主键是单一主键。\n\n分析以上表是否满足第三范式？\n\t第三范式要求：不要产生传递依赖！\n\t一年一班依赖01，01依赖1001，产生了传递依赖。\n\t不符合第三范式的要求。产生了数据的冗余。\n\n那么应该怎么设计一对多呢？\n\n\t班级表：一\n\t班级编号(pk)\t\t\t\t班级名称\n\t----------------------------------------\n\t01\t\t\t\t\t\t\t\t一年一班\n\t02\t\t\t\t\t\t\t\t一年二班\n\t03\t\t\t\t\t\t\t\t一年三班\n\n\t学生表：多\n\n\t学生编号（PK） 学生姓名 班级编号(fk)\n\t-------------------------------------------\n\t1001\t\t\t\t张三\t\t\t01\t\t\t\n\t1002\t\t\t\t李四\t\t\t02\t\t\t\n\t1003\t\t\t\t王五\t\t\t03\t\t\t\n\t1004\t\t\t\t赵六\t\t\t03\t\t\n\n\n一对多，两张表，多的表加外键！！！！！！！！！！！！\n\n关于三范式的实际使用\n数据库设计三范式是理论上的，实践和理论有的时候有偏差。\n最终的目的都是为了满足客户的需求，有的时候会拿冗余换执行速度。\n因为在sql当中，表和表之间连接次数越多，效率越低。（笛卡尔积）\n有的时候可能会存在冗余，但是为了减少表的连接次数，这样做也是合理的，并且对于开发人员来说，sql语句的编写难度也会降低。\n面试的时候把这句话说上：他就不会认为你是初级程序员了！\n","slug":"MYSQL","date":"2022-11-15T11:59:13.443Z","categories_index":"学习笔记","tags_index":"mysql","author_index":"Abyssaler"},{"id":"d689efbf93d434acdbec39ba18988ad9","title":"如何为浏览器配置Burp Suite代理","content":"如何为各浏览器配置Burp Suite代理首先需要确定你的burp suite是否配置好了代理\n如图，这里我是配置好了\nGoogle配置安装Proxy SwitchyOmega插件\n\n插件配置新建一个burp suite模式\n\n配置参数，注意这里要与你burp suite配置中的一致\n\n保存\n\n以后你想用chrome抓包就直接在这里选了\n\n可能遇到的问题首次抓取HTTPS时，浏览器会报安全问题\n\n解决办法\n\n在此页面访问http://burp\n\n\n\n点右上角下载ca证书\n\n\n在chrome中导入证书\n\n\n\n找到之前下载的证书的位置（如果找不到，打开所有文件选项）\n\n然后一直下一步导入就成功了\n\n\n其他浏览器配置思路大致相同","slug":"如何为各浏览器配置Burp Suite代理","date":"2022-11-15T07:43:18.390Z","categories_index":"环境配置","tags_index":"burp suite","author_index":"Abyssaler"},{"id":"7ed8089baf30886b0aa7735f2db515b2","title":"php怎么通过url传参","content":"php怎么通过url传参​\t目前正在学php基础,遇到一个困扰我的问题,那就是通过使用_GET[]的方式获取url中所传的参数中?的用途,如下图:\n\n123.php页面代码如图\n\n为什么通过在127.0.0.1&#x2F;php.123后面输入?target&#x3D;import.php后var_dump函数会把target当成关联数组里面的key从而取出target被赋予的值呢?这其中?起了什么作用\n通过了解得知,?表示传参,拿127.0.0.1&#x2F;php.123?target&#x3D;import.php举例子,?表示对当前php.123页面进行传参,传参的内容为名为target,值为import.php的这样一个参数.这引起了我的好奇,因为?在php语法中是一个三元运算符\n错误思路:三元运算符?作为三元运算符的的语法格式是:(expr1) ? (expr2) : (expr3),对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3.\n当我顺着这个思路再看url&#x2F;?target&#x3D;import.php这串代码时,怎么看怎么抽象,于是乎,继续查\n正解:url&#x2F;?x&#x3D;是php中的一项基本技巧通过检索网上其他的文章,得知使用url传递参数是php中的一项基本技巧，一般格式为url&#x2F;?x&#x3D;,这其中?是一种url固定的格式 ，在url格式中表示传参，这里不应该用php的语法去理解它。\n举例，如果要通过url传递一个参数n&#x3D;5，那么url应当为url&#x2F;?n&#x3D;5，php页面中应当包含如下代码：\n$n &#x3D; $_GET[‘n’];\n\n这就是一种固定的格式,纯粹是自己想多了…\n不过既然都查到这里来了,就顺便再深入一下\n显而易见，这种方法将会把参数暴露出来，安全系数较低。因此，可以有一种 URL 的编码方式，对 URL 传递的参数进行编码。以此让参数不可见\nurlencode(string)urlencode()函数实现将字符串 string 进行 URL 编码。应用urlencode()函数对 URL 传递的参数值进行编码，显示的字符串是URL 编码后的字符串，其实现的代码如下所示：\n&lt;?php\n$url &#x3D; urlencode(&quot;你想传入的参数&quot;);&#x2F;&#x2F;对参数编码\necho&quot;123.php?id&#x3D;&quot;.$url;\n?&gt;\n\n在浏览器中输入运行地址，按回车键，得到如下所示的运行结果：\nindex.php?id&#x3D;PHP%E4%B8%AD%E6%96%87%E7%BD%91\n\n这同时说明了对于服务器而言，编码前后的字符串并没有什么区别，服务器能够自动识别.\n","slug":"php怎么通过url传参","date":"2022-11-13T15:58:26.107Z","categories_index":"踩坑记录","tags_index":"php","author_index":"Abyssaler"},{"id":"e2beb8c86086697d45d0d68d245fa991","title":"PHP基础","content":"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言\nPHP 是什么？\nPHP（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。\nPHP 脚本在服务器上执行。\nPHP 可免费下载使用。\n\nPHP 文件是什么？\nPHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码\nPHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器\nPHP 文件的默认文件扩展名是 “.php”\n\nPHP 能做什么？\nPHP 可以生成动态页面内容\nPHP 可以创建、打开、读取、写入、关闭服务器上的文件\nPHP 可以收集表单数据\nPHP 可以发送和接收 cookies\nPHP 可以添加、删除、修改您的数据库中的数据\nPHP 可以限制用户访问您的网站上的一些页面\nPHP 可以加密数据\n\n为什么使用 PHP？\nPHP 可在不同的平台上运行（Windows、Linux、Unix、Mac OS X 等）\nPHP 与目前几乎所有的正在被使用的服务器相兼容（Apache、IIS 等）\nPHP 提供了广泛的数据库支持\nPHP 易于学习，并可高效地运行在服务器端\n\nPHP语法PHP 脚本可以放在文档中的任何位置。\nPHP 脚本以  结束：\nPHP 文件的默认文件扩展名是 “.php”。\nPHP 文件通常包含 HTML 标签和一些 PHP 脚本代码。\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;h1&gt;My first PHP page&lt;&#x2F;h1&gt;\n\n&lt;?php\necho &quot;Hello World!&quot;;\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nPHP 中的每个代码行都必须以分号结束。分号是一种分隔符，用于把指令集区分开来。\n通过 PHP，有两种在浏览器输出文本的基础指令：echo 和 print。\nPHP 注释\n&#x2F;&#x2F;      单行注释\n&#x2F;*  *&#x2F;   多行注释\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n&#x2F;&#x2F; 这是 PHP 单行注释\n\n&#x2F;*\n这是\nPHP 多行\n注释\n*&#x2F;\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n变量变量是用于存储信息的”容器”\n&lt;?php\n$x&#x3D;5;\n$y&#x3D;6;\n$z&#x3D;$x+$y;\necho $z;\n?&gt;\n\n\n\nPHP 变量规则\n\n变量以 $ 符号开始，后面跟着变量的名称\n变量名必须以字母或者下划线字符开始\n变量名只能包含字母、数字以及下划线（A-z、0-9 和 _ ）\n变量名不能包含空格\n变量名是区分大小写的（$y 和 $Y 是两个不同的变量）\n\n创建PHP变量PHP 没有声明变量的命令。\n变量在您第一次赋值给它的时候被创建\n&lt;?php\n$txt&#x3D;&quot;Hello world!&quot;;\n$x&#x3D;5;\n$y&#x3D;10.5;\n?&gt;\n\n在上面的语句执行中，变量 txt 将保存值 **Hello world!**，且变量 x 将保存值 5。\n注释：当您赋一个文本值给变量时，请在文本值两侧加上引号。\nPHP 是一门弱类型语言PHP 会根据变量的值，自动把变量转换为正确的数据类型。\n在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。\necho 和 print 语句echo 和 print 区别:\n\necho - 可以输出一个或多个字符串\nprint - 只允许输出一个字符串，返回值总为 1\n\n提示：echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。\necho 是一个语言结构，使用的时候可以不用加括号，也可以加上括号： echo 或 echo()。\n显示字符串\n&lt;?php\necho &quot;&lt;h2&gt;PHP 很有趣!&lt;&#x2F;h2&gt;&quot;;\necho &quot;Hello world!&lt;br&gt;&quot;;\necho &quot;我要学 PHP!&lt;br&gt;&quot;;\necho &quot;这是一个&quot;, &quot;字符串，&quot;, &quot;使用了&quot;, &quot;多个&quot;, &quot;参数。&quot;;\n?&gt;\n\n\n\n显示变量\n&lt;?php\n$txt1&#x3D;&quot;学习 PHP&quot;;\n$txt2&#x3D;&quot;xbxaq.com&quot;;\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\n \necho $txt1;\necho &quot;&lt;br&gt;&quot;;\necho &quot;在 $txt2 学习 PHP &quot;;\necho &quot;&lt;br&gt;&quot;;\necho &quot;我车的品牌是 &#123;$cars[0]&#125;&quot;;\n?&gt;\n\n\n\nprint 同样是一个语言结构，可以使用括号，也可以不使用括号： print 或 print()。\n显示字符串\n&lt;?php\nprint &quot;&lt;h2&gt;PHP 很有趣!&lt;&#x2F;h2&gt;&quot;;\nprint &quot;Hello world!&lt;br&gt;&quot;;\nprint &quot;我要学习 PHP!&quot;;\n?&gt;\n\n\n\n显示变量\n&lt;?php\n$txt1&#x3D;&quot;学习 PHP&quot;;\n$txt2&#x3D;&quot;xbxaq.COM&quot;;\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\n \nprint $txt1;\nprint &quot;&lt;br&gt;&quot;;\nprint &quot;在 $txt2 学习 PHP &quot;;\nprint &quot;&lt;br&gt;&quot;;\nprint &quot;我车的品牌是 &#123;$cars[0]&#125;&quot;;\n?&gt;\n\n\n\n数据类型PHP 变量存储不同的类型的数据，不同的数据类型可以做不一样的事情。\nPHP 支持以下几种数据类型:\n\nString（字符串）\nInteger（整型）\nFloat（浮点型）\nBoolean（布尔型）\nArray（数组）\nObject（对象）\nNULL（空值）\nResource（资源类型）\n\n字符串一个字符串是一串字符的序列，就像 “Hello world!”。\n你可以将任何文本放在单引号和双引号中\n&lt;?php \n$x &#x3D; &quot;Hello world!&quot;;\necho $x;\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; &#39;Hello world!&#39;;\necho $x;\n?&gt;\n\n\n\n整型整数是一个没有小数的数字。\n整数规则:\n\n整数必须至少有一个数字 (0-9)\n整数不能包含逗号或空格\n整数是没有小数点的\n整数可以是正数或负数\n整型可以用三种格式来指定：十进制， 十六进制（ 以 0x 为前缀）或八进制（前缀为 0）。\n\nPHP var_dump() 函数返回变量的数据类型和值\n&lt;?php \n$x &#x3D; 5985;\nvar_dump($x);\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; -345; &#x2F;&#x2F; 负数 \nvar_dump($x);\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; 0x8C; &#x2F;&#x2F; 十六进制数\nvar_dump($x);\necho &quot;&lt;br&gt;&quot;;\n$x &#x3D; 047; &#x2F;&#x2F; 八进制数\nvar_dump($x);\n?&gt;\n\n\n\n浮点型浮点数是带小数部分的数字，或是指数形式\n&lt;?php \n$x &#x3D; 10.365;\nvar_dump($x);\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; 2.4e3;\nvar_dump($x);\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; 8E-5;\nvar_dump($x);\n?&gt;\n\n\n\n布尔型布尔型可以是 TRUE 或 FALSE\n布尔型通常用于条件判断\n数组数组可以在一个变量中存储多个值\n&lt;?php \n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\nvar_dump($cars);\n?&gt;\n\n\n\n对象对象数据类型也可以用于存储数据。\n在 PHP 中，对象必须声明。\n首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。\n然后我们在类中定义数据类型，然后在实例化的类中使用数据类型\n&lt;?php\nclass Car\n&#123;\n  var $color;\n  function __construct($color&#x3D;&quot;green&quot;) &#123;\n    $this-&gt;color &#x3D; $color;\n  &#125;\n  function what_color() &#123;\n    return $this-&gt;color;\n  &#125;\n&#125;\n?&gt;\n\n\n\nNULL 值NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。\nNULL 值指明一个变量是否为空值。 同样可用于数据空值和NULL值的区别。\n可以通过设置变量值为 NULL 来清空变量数据\n&lt;?php\n$x&#x3D;&quot;Hello world!&quot;;\n$x&#x3D;null;\nvar_dump($x);\n?&gt;\n\n\n\n类型比较虽然 PHP 是弱类型语言，但也需要明白变量类型及它们的意义，因为我们经常需要对 PHP 变量进行比较，包含松散和严格比较。\n\n松散比较：使用两个等号 &#x3D;&#x3D; 比较，只比较值，不比较类型。\n严格比较：用三个等号 &#x3D;&#x3D;&#x3D; 比较，除了比较值，也比较类型。\n\n例如，”42” 是一个字符串而 42 是一个整数。FALSE 是一个布尔值而 “FALSE” 是一个字符串。\n&lt;?php\nif(42 &#x3D;&#x3D; &quot;42&quot;) &#123;\n    echo &#39;1、值相等&#39;;\n&#125;\n \necho PHP_EOL; &#x2F;&#x2F; 换行符\n \nif(42 &#x3D;&#x3D;&#x3D; &quot;42&quot;) &#123;\n    echo &#39;2、类型相等&#39;;\n&#125; else &#123;\n    echo &#39;3、类型不相等&#39;;\n&#125;\n?&gt;\n\n\n\nPHP中 比较 0、false、null&lt;?php\necho &#39;0 &#x3D;&#x3D; false: &#39;;\nvar_dump(0 &#x3D;&#x3D; false);\necho &#39;0 &#x3D;&#x3D;&#x3D; false: &#39;;\nvar_dump(0 &#x3D;&#x3D;&#x3D; false);\necho PHP_EOL;\necho &#39;0 &#x3D;&#x3D; null: &#39;;\nvar_dump(0 &#x3D;&#x3D; null);\necho &#39;0 &#x3D;&#x3D;&#x3D; null: &#39;;\nvar_dump(0 &#x3D;&#x3D;&#x3D; null);\necho PHP_EOL;\necho &#39;false &#x3D;&#x3D; null: &#39;;\nvar_dump(false &#x3D;&#x3D; null);\necho &#39;false &#x3D;&#x3D;&#x3D; null: &#39;;\nvar_dump(false &#x3D;&#x3D;&#x3D; null);\necho PHP_EOL;\necho &#39;&quot;0&quot; &#x3D;&#x3D; false: &#39;;\nvar_dump(&quot;0&quot; &#x3D;&#x3D; false);\necho &#39;&quot;0&quot; &#x3D;&#x3D;&#x3D; false: &#39;;\nvar_dump(&quot;0&quot; &#x3D;&#x3D;&#x3D; false);\necho PHP_EOL;\necho &#39;&quot;0&quot; &#x3D;&#x3D; null: &#39;;\nvar_dump(&quot;0&quot; &#x3D;&#x3D; null);\necho &#39;&quot;0&quot; &#x3D;&#x3D;&#x3D; null: &#39;;\nvar_dump(&quot;0&quot; &#x3D;&#x3D;&#x3D; null);\necho PHP_EOL;\necho &#39;&quot;&quot; &#x3D;&#x3D; false: &#39;;\nvar_dump(&quot;&quot; &#x3D;&#x3D; false);\necho &#39;&quot;&quot; &#x3D;&#x3D;&#x3D; false: &#39;;\nvar_dump(&quot;&quot; &#x3D;&#x3D;&#x3D; false);\necho PHP_EOL;\necho &#39;&quot;&quot; &#x3D;&#x3D; null: &#39;;\nvar_dump(&quot;&quot; &#x3D;&#x3D; null);\necho &#39;&quot;&quot; &#x3D;&#x3D;&#x3D; null: &#39;;\nvar_dump(&quot;&quot; &#x3D;&#x3D;&#x3D; null);\n\n\n\n常量常量值被定义后，在脚本的其他任何地方都不能被改变\n常量是一个简单值的标识符。该值在脚本中不能改变。\n一个常量由英文字母、下划线、和数字组成,但数字不能作为首字母出现。 (常量名不需要加 $ 修饰符)。\n注意： 常量在整个脚本中都可以使用。\n设置常量，使用 define() 函数，函数语法如下\nbool define ( string $name , mixed $value [, bool $case_insensitive &#x3D; false ] )\n\n该函数有三个参数:\n\nname：必选参数，常量名称，即标志符。\nvalue：必选参数，常量的值。\ncase_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。\n\n创建一个 区分大小写的常量, 常量值为 “欢迎访问 xbxaq.com”\n&lt;?php\n&#x2F;&#x2F; 区分大小写的常量名\ndefine(&quot;GREETING&quot;, &quot;欢迎访问 xbxaq.com&quot;);\necho GREETING;    &#x2F;&#x2F; 输出 \necho &#39;&lt;br&gt;&#39;;\necho greeting;   &#x2F;&#x2F; 输出 &quot;greeting&quot;，但是有警告信息，表示该常量未定义\n?&gt;\n\n\n\n运算符 PHP 中，赋值运算符 &#x3D; 用于给变量赋值。\n在 PHP 中，算术运算符 + 用于把值加在一起。\n算术运算符&lt;?php \n$x&#x3D;10; \n$y&#x3D;6;\necho ($x + $y); &#x2F;&#x2F; 输出16\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho ($x - $y); &#x2F;&#x2F; 输出4\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho ($x * $y); &#x2F;&#x2F; 输出60\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho ($x &#x2F; $y); &#x2F;&#x2F; 输出1.6666666666667\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho ($x % $y); &#x2F;&#x2F; 输出4\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho -$x;\n?&gt;\n\n\n\n赋值运算符&lt;?php \n$x&#x3D;10; \necho $x; &#x2F;&#x2F; 输出10\n \n$y&#x3D;20; \n$y +&#x3D; 100;\necho $y; &#x2F;&#x2F; 输出120\n \n$z&#x3D;50;\n$z -&#x3D; 25;\necho $z; &#x2F;&#x2F; 输出25\n \n$i&#x3D;5;\n$i *&#x3D; 6;\necho $i; &#x2F;&#x2F; 输出30\n \n$j&#x3D;10;\n$j &#x2F;&#x3D; 5;\necho $j; &#x2F;&#x2F; 输出2\n \n$k&#x3D;15;\n$k %&#x3D; 4;\necho $k; &#x2F;&#x2F; 输出3\n?&gt;\n\n\n\n递增&#x2F;递减运算符&lt;?php\n$x&#x3D;10; \necho ++$x; &#x2F;&#x2F; 输出11\n \n$y&#x3D;10; \necho $y++; &#x2F;&#x2F; 输出10\n \n$z&#x3D;5;\necho --$z; &#x2F;&#x2F; 输出4\n \n$i&#x3D;5;\necho $i--; &#x2F;&#x2F; 输出5\n?&gt;\n\n\n\n比较运算符&lt;?php\n$x&#x3D;100; \n$y&#x3D;&quot;100&quot;;\n \nvar_dump($x &#x3D;&#x3D; $y);\necho &quot;&lt;br&gt;&quot;;\nvar_dump($x &#x3D;&#x3D;&#x3D; $y);\necho &quot;&lt;br&gt;&quot;;\nvar_dump($x !&#x3D; $y);\necho &quot;&lt;br&gt;&quot;;\nvar_dump($x !&#x3D;&#x3D; $y);\necho &quot;&lt;br&gt;&quot;;\n \n$a&#x3D;50;\n$b&#x3D;90;\n \nvar_dump($a &gt; $b);\necho &quot;&lt;br&gt;&quot;;\nvar_dump($a &lt; $b);\n?&gt;\n\n\n\n三元运算符语法格式(expr1) ? (expr2) : (expr3) \n\n对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3。\n条件语句您编写代码时，您常常需要为不同的判断执行不同的动作。您可以在代码中使用条件语句来完成此任务。\n在 PHP 中，提供了下列条件语句：\n\nif 语句 - 在条件成立时执行代码\nif…else 语句 - 在条件成立时执行一块代码，条件不成立时执行另一块代码\nif…elseif….else 语句 - 在若干条件之一成立时执行一个代码块\nswitch 语句 - 在若干条件之一成立时执行一个代码块\n\nif 语句用于仅当指定条件成立时执行代码\n语法if (条件)\n&#123;\n    条件成立时要执行的代码;\n&#125;\n\n&lt;?php\n$t&#x3D;date(&quot;H&quot;);\nif ($t&lt;&quot;20&quot;)\n&#123;\n    echo &quot;Have a good day!&quot;;\n&#125;\n?&gt;\n\n\n\nif…else 语句在条件成立时执行一块代码，条件不成立时执行另一块代码，请使用 if….else 语句。\n语法if (条件)\n&#123;\n条件成立时执行的代码;\n&#125;\nelse\n&#123;\n条件不成立时执行的代码;\n&#125;\n\n\n\n&lt;?php\n$t&#x3D;date(&quot;H&quot;);\nif ($t&lt;&quot;20&quot;)\n&#123;\n    echo &quot;Have a good day!&quot;;\n&#125;\nelse\n&#123;\n    echo &quot;Have a good night!&quot;;\n&#125;\n?&gt;\n\n\n\nif…elseif….else 语句在若干条件之一成立时执行一个代码块，请使用 if….elseif…else 语句。.\n语法if (条件)\n&#123;\n    if 条件成立时执行的代码;\n&#125;\nelseif (条件)\n&#123;\n    elseif 条件成立时执行的代码;\n&#125;\nelse\n&#123;\n    条件不成立时执行的代码;\n&#125;\n\n\n\n&lt;?php\n$t&#x3D;date(&quot;H&quot;);\nif ($t&lt;&quot;10&quot;)\n&#123;\n    echo &quot;Have a good morning!&quot;;\n&#125;\nelseif ($t&lt;&quot;20&quot;)\n&#123;\n    echo &quot;Have a good day!&quot;;\n&#125;\nelse\n&#123;\n    echo &quot;Have a good night!&quot;;\n&#125;\n?&gt;\n\n\n\nSwitch 语句switch 语句用于根据多个不同条件执行不同动作。\n如果您希望有选择地执行若干代码块之一，请使用 switch 语句。\n&lt;?php\n$favcolor&#x3D;&quot;red&quot;;\nswitch ($favcolor)\n&#123;\ncase &quot;red&quot;:\n    echo &quot;你喜欢的颜色是红色!&quot;;\n    break;\ncase &quot;blue&quot;:\n    echo &quot;你喜欢的颜色是蓝色!&quot;;\n    break;\ncase &quot;green&quot;:\n    echo &quot;你喜欢的颜色是绿色!&quot;;\n    break;\ndefault:\n    echo &quot;你喜欢的颜色不是 红, 蓝, 或绿色!&quot;;\n&#125;\n?&gt;\n\n\n\n数组数组能够在单个变量中存储多个值\n数组可以在单个变量中存储多个值，并且您可以根据键访问其中的值。\n&lt;?php\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\necho &quot;I like &quot; . $cars[0] . &quot;, &quot; . $cars[1] . &quot; and &quot; . $cars[2] . &quot;.&quot;;\n?&gt;\n\n\n\n创建数组在 PHP 中，array() 函数用于创建数组：\narray();\n\n\n\n在 PHP 中，有三种类型的数组：\n\n数值数组 - 带有数字 ID 键的数组\n关联数组 - 带有指定的键的数组，每个键关联一个值\n多维数组 - 包含一个或多个数组的数组\n\n数值数组这里有两种创建数值数组的方法：\n自动分配 ID 键（ID 键总是从 0 开始）：\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\n\n&lt;?php\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\necho &quot;I like &quot; . $cars[0] . &quot;, &quot; . $cars[1] . &quot; and &quot; . $cars[2] . &quot;.&quot;;\n?&gt;\n\n\n\n获取数组的长度 - count() 函数count() 函数用于返回数组的长度（元素的数量）\n&lt;?php\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\necho count($cars);\n?&gt;\n\n\n\n遍历数值数组遍历并打印数值数组中的所有值，您可以使用 for 循环\n&lt;?php\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\n$arrlength&#x3D;count($cars);\n \nfor($x&#x3D;0;$x&lt;$arrlength;$x++)\n&#123;\n    echo $cars[$x];\n    echo &quot;&lt;br&gt;&quot;;\n&#125;\n?&gt;\n\n\n\n关联数组关联数组是使用您分配给数组的指定的键的数组。\n这里有两种创建关联数组的方法\n$age&#x3D;array(&quot;Peter&quot;&#x3D;&gt;&quot;35&quot;,&quot;Ben&quot;&#x3D;&gt;&quot;37&quot;,&quot;Joe&quot;&#x3D;&gt;&quot;43&quot;);\n\nor\n\n$age[&#39;Peter&#39;]&#x3D;&quot;35&quot;;\n$age[&#39;Ben&#39;]&#x3D;&quot;37&quot;;\n$age[&#39;Joe&#39;]&#x3D;&quot;43&quot;;\n\n\n\n&lt;?php\n$age&#x3D;array(&quot;Peter&quot;&#x3D;&gt;&quot;35&quot;,&quot;Ben&quot;&#x3D;&gt;&quot;37&quot;,&quot;Joe&quot;&#x3D;&gt;&quot;43&quot;);\necho &quot;Peter is &quot; . $age[&#39;Peter&#39;] . &quot; years old.&quot;;\n?&gt;\n\n\n\n遍历关联数组遍历并打印关联数组中的所有值，您可以使用 foreach 循环\n&lt;?php\n$age&#x3D;array(&quot;Peter&quot;&#x3D;&gt;&quot;35&quot;,&quot;Ben&quot;&#x3D;&gt;&quot;37&quot;,&quot;Joe&quot;&#x3D;&gt;&quot;43&quot;);\n \nforeach($age as $x&#x3D;&gt;$x_value)\n&#123;\n    echo &quot;Key&#x3D;&quot; . $x . &quot;, Value&#x3D;&quot; . $x_value;\n    echo &quot;&lt;br&gt;&quot;;\n&#125;\n?&gt;\n\n\n\n循环循环执行代码块指定的次数，或者当指定的条件为真时循环执行代码块。\n在 PHP 中，提供了下列循环语句：\n\nwhile - 只要指定的条件成立，则循环执行代码块\ndo…while - 首先执行一次代码块，然后在指定的条件成立时重复这个循环\nfor - 循环执行代码块指定的次数\nforeach - 根据数组中每个元素来循环代码块\n\nwhile 循环while 循环将重复执行代码块，直到指定的条件不成立。\n语法while (条件)\n&#123;\n    要执行的代码;\n&#125;\n\n\n\n实例首先设置变量 i 的值为 1 ($i&#x3D;1;)。\n然后，只要 i 小于或者等于 5，while 循环将继续运行。循环每运行一次，i 就会递增 1：\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n$i&#x3D;1;\nwhile($i&lt;&#x3D;5)\n&#123;\n    echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;;\n    $i++;\n&#125;\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\ndo…while 语句do…while 语句会至少执行一次代码，然后检查条件，只要条件成立，就会重复进行循环。\n语法do\n&#123;\n    要执行的代码;\n&#125;\nwhile (条件);\n\n\n\n实例首先设置变量 i 的值为 1 ($i&#x3D;1;)。\n然后，开始 do…while 循环。循环将变量 i 的值递增 1，然后输出。先检查条件（i 小于或者等于 5），只要 i 小于或者等于 5，循环将继续运行\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n$i&#x3D;1;\ndo\n&#123;\n    $i++;\n    echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;;\n&#125;\nwhile ($i&lt;&#x3D;5);\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nFor 循环for 循环用于您预先知道脚本需要运行的次数的情况。\n语法for (初始值; 条件; 增量)\n&#123;\n    要执行的代码;\n&#125;\n\n参数：\n\n初始值：主要是初始化一个变量值，用于设置一个计数器（但可以是任何在循环的开始被执行一次的代码）。\n条件：循环执行的限制条件。如果为 TRUE，则循环继续。如果为 FALSE，则循环结束。\n增量：主要用于递增计数器（但可以是任何在循环的结束被执行的代码）。\n\n注释：上面的初始值和增量参数可为空，或者有多个表达式（用逗号分隔）。\n实例下面的实例定义一个初始值为 i&#x3D;1 的循环。只要变量 i 小于或者等于 5，循环将继续运行。循环每运行一次，变量 i 就会递增 1\n&lt;?php\nfor ($i&#x3D;1; $i&lt;&#x3D;5; $i++)\n&#123;\n    echo &quot;数字为 &quot; . $i;\n&#125;\n?&gt;\n\n\n\nforeach 循环foreach 循环用于遍历数组。\n语法foreach ($array as $value)\n&#123;\n    要执行代码;\n&#125;\n\n每进行一次循环，当前数组元素的值就会被赋值给 $value 变量（数组指针会逐一地移动），在进行下一次循环时，您将看到数组中的下一个值。\nforeach ($array as $key &#x3D;&gt; $value)\n&#123;\n    要执行代码;\n&#125;\n\n每一次循环，当前数组元素的键与值就都会被赋值给 $key 和 $value 变量（数字指针会逐一地移动），在进行下一次循环时，你将看到数组中的下一个键与值。\n&lt;?php\n$x&#x3D;array(&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;);\nforeach ($x as $value)\n&#123;\n    echo $value . PHP_EOL;\n&#125;\n?&gt;\n\n\n\n&lt;?php\n$x&#x3D;array(1&#x3D;&gt;&quot;Google&quot;, 2&#x3D;&gt;&quot;Runoob&quot;, 3&#x3D;&gt;&quot;Taobao&quot;);\nforeach ($x as $key &#x3D;&gt; $value)\n&#123;\n    echo &quot;key  为 &quot; . $key . &quot;，对应的 value 为 &quot;. $value . PHP_EOL;\n&#125;\n?&gt;\n\n\n\n函数创建 PHP 函数函数是通过调用函数来执行的。\n&lt;?php\nfunction functionName()\n&#123;\n    &#x2F;&#x2F; 要执行的代码\n&#125;\n?&gt;\n\n函数准则：\n\n函数的名称应该提示出它的功能\n函数名称以字母或下划线开头（不能以数字开头）\n\n&lt;?php\nfunction writeName()\n&#123;\n    echo &quot;Kai Jim Refsnes&quot;;\n&#125;\n \necho &quot;My name is &quot;;\nwriteName();\n?&gt;\n\n\n\n函数 - 添加参数为了给函数添加更多的功能，我们可以添加参数，参数类似变量。\n参数就在函数名称后面的一个括号内指定。\n&lt;?php\nfunction writeName($fname)\n&#123;\n    echo $fname . &quot; Refsnes.&lt;br&gt;&quot;;\n&#125;\n \necho &quot;My name is &quot;;\nwriteName(&quot;Kai Jim&quot;);\necho &quot;My sister&#39;s name is &quot;;\nwriteName(&quot;Hege&quot;);\necho &quot;My brother&#39;s name is &quot;;\nwriteName(&quot;Stale&quot;);\n?&gt;\n\n\n\n&lt;?php\nfunction writeName($fname,$punctuation)\n&#123;\n    echo $fname . &quot; Refsnes&quot; . $punctuation . &quot;&lt;br&gt;&quot;;\n&#125;\n \necho &quot;My name is &quot;;\nwriteName(&quot;Kai Jim&quot;,&quot;.&quot;);\necho &quot;My sister&#39;s name is &quot;;\nwriteName(&quot;Hege&quot;,&quot;!&quot;);\necho &quot;My brother&#39;s name is &quot;;\nwriteName(&quot;Ståle&quot;,&quot;?&quot;);\n?&gt;\n\n\n\n函数 - 返回值如需让函数返回一个值，请使用 return 语句\n&lt;?php\nfunction add($x,$y)\n&#123;\n    $total&#x3D;$x+$y;\n    return $total;\n&#125;\n \necho &quot;1 + 16 &#x3D; &quot; . add(1,16);\n?&gt;\n\n\n\n","slug":"01PHP基础","date":"2022-11-11T10:11:42.437Z","categories_index":"学习笔记","tags_index":"php","author_index":"Abyssaler"},{"id":"bd6f30a22217917d2172ab3a5accd3dc","title":"PHP正则表达式","content":"正则表达式正则表达式存在的意义：过滤和检索。\n正则表达式，又称规则表达式（Regular Expression ）常简写为regex，regexp，RE;\n作用正则表达式通常被用来检索、替换符合规则的文本\n特点\n灵活性、逻辑性和功能性强\n可以快速地用极简单的方式达到支付出的复杂控制\n\n用途\n判断字符串是否符合某规则\n从一个字符串中找出符合规则的所以子字符串\n\n常用字符\n\n\n说明\n符号\n\n\n\n数字\n\\d\n\n\n非字符\n\\D\n\n\n空白字符（空格、制表符、换页符等）\n\\s\n\n\n非空白字符\n\\S\n\n\n制表符\n\\t\n\n\n回车符\n\\r\n\n\n换行符\n\\n\n\n\n单词字符（26个英文字母+数字+下划线）\n\\w\n\n\n非单词字符\n\\W\n\n\n字符集合字符集合：[ 单个字符或字符区间] ，用于匹配集合内字符\n\n如：\n\n[a-z]    表示a-z   26个小写字母\n[ 0-9a-h] 表示0-9 10个数字和a-z 8个字母\n[134a-h] 表示包含数字1，3，5和字母a-h 8个字母\n\n注意：两个不同字符段间请勿使用逗号，隔开\n反选字符非集：[\\^单个字符或区间]，用于匹配非集合内字符]\n\n\n反选字符：^\t\n\n[^]  注意：中括号内^ 才是反选\n\n[^0-9]  表示匹配所有非数字字符\n\n[^a-zA-Z] 表示匹配所有非字母字符\n\n\n关键字\n\n\n关键字\n描述\n\n\n\n^\n匹配输入字符串的开始位置\n\n\n$\n匹配输入字符串的结尾位置\n\n\n（）\n标记一个子表达式的开始和结束位置\n\n\n*\n匹配前面的子表达式零次或多次\n\n\n+\n匹配前面的子表达式一次或多次\n\n\n.\n匹配除换行符\\n之外的任意单个字符\n\n\n[\n标记一个中括号表达式的开始\n\n\n？\n匹配前面的子表达式零次或一次\n\n\n\\\n将下一个字符标记为特殊字符原来的本意\n\n\n{\n标记限定符表达式的开始\n\n\n|\n指明两项之间的一项\n\n\n限定符\n\n\n字符\n描述\n\n\n\n{n}\nn为非负数，匹配连续的字符n次\n\n\n{n,}\nn为非负数，匹配连续的字符n次及以上\n\n\n{n，m}\nn、m均为非负数，n &lt;&#x3D;m,匹配连续的字符 至少n次，至多m次\n\n\n修饰符​\t\n\n\n\n修饰符\n描述\n\n\n\n&#x2F;i\n不区分大小写\n\n\n&#x2F;A\n匹配规则必须从头开始匹配\n\n\n&#x2F;s\n将匹配一切字符\n\n\n&#x2F;X\n正则表达式中的空白字符将会被忽略\n\n\n注意：写在正则表达式的“外面“    &#x2F;a&#x2F;i\n函数PHP中使用正则表达式一定要加&#x2F; 正则表达式内容  &#x2F;\n\npreg_match(正则表达式，匹配的字符串)\n匹配第一个匹配正则的子字符串，未找到返回0.找到返回1\n\npreg_grep()\n匹配第一个匹配正则的字符串数组，包含匹配的字符串和匹配的单元\n\npreg_match_all(正则表达式，匹配的字符串，输出的二维数组)\n能匹配所有的子字符串，返回子字符串匹配的数量\n\npre_replace(正则表达式，替换的字符串，匹配的字符串)\n将所有匹配正则表达式的字符串进行替换\n\n\n","slug":"06PHP正则表达式","date":"2022-11-11T09:18:48.428Z","categories_index":"学习笔记","tags_index":"php","author_index":"Abyssaler"},{"id":"768203e0c226cf15b0e3763fb1a90bc7","title":"暴力破解思路","content":"WEB漏洞：暴力破解密码爆破的本质：依赖字典，连续性的，自动化的尝试密码登陆爆破\n1）密码爆破思路方式一：尝试爆破：假设密码长度6，每位有126种可能。那么需要尝试126^6次。\n\n方式二：使用字典​     思考：字典从何而来？ \n参考泄露出来的最长使用的密码排名前200：\nhttps:&#x2F;&#x2F;nordpass.com&#x2F;most-common-passwords-list&#x2F;\n网络下载密码本\n密码生成器\n\n\n​      \n方式三：使用POC实现爆破POC实现爆破，python代码实现爆破：\n1、读取字典，加载密码\n2、发起http连接\n3、分析HTTP响应\n4、持续自动化爆破\n\n代码：\nreadpass.py\n# -*- coding: utf-8 -*-\n# python 3\n\npwds &#x3D; open(&quot;password.txt&quot;)\nfor pwd in pwds:\n    print(pwd)\n\npwds.close()\n\nhttpconn.py\n# -*- coding: utf-8 -*-\n# python 3\n\nimport requests\n\npwds &#x3D; open(&quot;password.txt&quot;)\nfor pwd in pwds:\n    url &#x3D; &quot;http:&#x2F;&#x2F;localhost&#x2F;DVWA-master&#x2F;vulnerabilities&#x2F;brute&#x2F;&quot;\n    # PHPSESSID务必替换为登录以后的PHPSESSID\n    resp &#x3D; requests.get(url &#x3D; url, params &#x3D; &#123;&quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:pwd.strip(), &quot;Login&quot;:&quot;Login&quot;&#125;, headers &#x3D; &#123;&quot;Cookie&quot;:&quot;security&#x3D;low; PHPSESSID&#x3D;0hhidoi7h1ln7jo9h2h0tgfnn6&quot;&#125;)\n    #print(resp.text)\n    if &#39;Username and&#x2F;or password incorrect.&#39; in resp.text:\n        print(&#39;破解失败：&#39;+pwd, end&#x3D;&#39;&#39;)\n    else:\n        print(&#39;破解成功：&#39;+pwd, end&#x3D;&#39;&#39;)\n        break;\npwds.close()\n\n2） DVWA靶场环境准备：下载代码： https://dvwa.co.uk/\n配置数据库：修改config&#x2F;config.inc.php\n部署到phpstudy\n注意是登录以后才可以使用暴破场景，而不是暴破首页的登录功能\n3）暴力破解实现使用python代码破解DVWA靶场使用工具BP实现爆破4）BP的攻击模式攻击模式一：狙击手\n发起爆破：\n\n攻击结果：\n\n攻击模式二：攻城锤Battering ram\n\n攻城锤模式，使用一个字典，两个节点的值一样：\n\n攻击模式三：草叉模式Pitchfork\n选择两个字典：\n\n\n攻击结果：一共发起10次请求，每一次请求使用第一个字典的第一个值和第二个字典的第一个值匹配，依次类推：\n\n攻击模式四：集束炸弹Cluster bomb\n使用两个字典：\n\n\n攻击结果：笛卡尔积，一共发起100次请求，爆破成功：\n\n5）防御DVWA-medium  ：sleep两秒\nDVWA-high: 随机sleep 0-3秒   ，  增加CSRF token（客户端请求伪造token）\nBP拦截：\n\n选择草叉模式：\n\n加载第一个字典：\n\n第二个参数，是需要从上一次请求中的token种得到：\n设置Options：匹配到前后的正则表达式，那么就是token：\n\n设置payloads：\n\n设置单线程：\n\n爆破结果：\n\n添加提示：\n\n点击Add：\n\n爆破结果：\n\nDvwa-impossible：限定次数：输错三次，锁定15分钟\n支付宝设置的防御机制：\n\n二次验证加固：\n\n人机识别加固：\n\n\n","slug":"暴力破解","date":"2022-11-11T01:21:04.000Z","categories_index":"学习笔记","tags_index":"密码破解","author_index":"Abyssaler"},{"id":"677084f9c18037c17104fff897e28f62","title":"Front-Meta属性","content":"Aurora中文章的Front-Meta属性新建文章配置\n\n\n配置选项\n默认值\n描述\n\n\n\ntitle\nMarkdown 的文件标题\n文章标题，强烈建议填写此选项\n\n\ndate\n文件创建时的日期时间\n发布时间，强烈建议填写此选项，且最好保证全局唯一\n\n\nauthor\n根 _config.yml 中的 author\n文章作者\n\n\nimg\nfeatureImages 中的某个值\n文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.\n\n\ntop\ntrue\n推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章\n\n\ncover\nfalse\nv1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中\n\n\ncoverImg\n无\nv1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片\n\n\npassword\n无\n文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项\n\n\ntoc\ntrue\n是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项\n\n\nmathjax\nfalse\n是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行\n\n\nsummary\n无\n文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要\n\n\ncategories\n无\n文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类\n\n\ntags\n无\n文章标签，一篇文章可以多个标签\n\n\n更多markdown语法参考:\n\n\n\n\n\n\n\n\n\nhttps://github.com/Sakiyary/Markdown-Typora-VSCode-Doc\n","slug":"文章开头格式","date":"2022-11-10T14:13:43.591Z","categories_index":"环境配置","tags_index":"markdown","author_index":"Abyssaler"},{"id":"e8eeb095a66f2218f43f6c5e63475a56","title":"PHP连接mysql数据库","content":"通过 PHP，您可以连接和操作数据库。\n连接 MySQL在我们访问 MySQL 数据库前，我们需要先连接到数据库服务器\n(MySQLi - 面向对象）&lt;?php\n$servername &#x3D; &quot;localhost&quot;;\n$username &#x3D; &quot;username&quot;;\n$password &#x3D; &quot;password&quot;;\n \n&#x2F;&#x2F; 创建连接\n$conn &#x3D; new mysqli($servername, $username, $password);\n \n&#x2F;&#x2F; 检测连接\nif ($conn-&gt;connect_error) &#123;\n    die(&quot;连接失败: &quot; . $conn-&gt;connect_error);\n&#125; \necho &quot;连接成功&quot;;\n?&gt;\n\n注意： 注意在以上面向对象的实例中 $connect_error 是在 PHP 5.2.9 和 5.3.0 中添加的。如果你需要兼容更早版本 请使用以下代码替换:  &#x2F;&#x2F; 检测连接 if (mysqli_connect_error()) {   die(“数据库连接失败: “ . mysqli_connect_error()); }\nMySQLi - 面向过程&lt;?php\n$servername &#x3D; &quot;localhost&quot;;\n$username &#x3D; &quot;username&quot;;\n$password &#x3D; &quot;password&quot;;\n \n&#x2F;&#x2F; 创建连接\n$conn &#x3D; mysqli_connect($servername, $username, $password);\n \n&#x2F;&#x2F; 检测连接\nif (!$conn) &#123;\n    die(&quot;Connection failed: &quot; . mysqli_connect_error());\n&#125;\necho &quot;连接成功&quot;;\n?&gt;\n\n\n\nPDO&lt;?php\n$servername &#x3D; &quot;localhost&quot;;\n$username &#x3D; &quot;username&quot;;\n$password &#x3D; &quot;password&quot;;\n \ntry &#123;\n    $conn &#x3D; new PDO(&quot;mysql:host&#x3D;$servername;&quot;, $username, $password);\n    echo &quot;连接成功&quot;; \n&#125;\ncatch(PDOException $e)\n&#123;\n    echo $e-&gt;getMessage();\n&#125;\n?&gt;\n\n\n\n\n\nMySQL基础知识链接\n连接数据库\n实例：&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    echo &quot;连接成功&quot;;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n\n创建数据库\n数据库存有一个或者多个表\n需要create 权限来创建或删除MySQL数据库\n创建数据库语句：create database name\n实例：&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    echo &quot;连接成功&quot;;\n    echo &quot;&lt;br&gt;&quot;;\n\n    &#x2F;&#x2F; 创建数据库语句\n    $sql &#x3D; &quot;CREATE DATABASE PHP&quot;; &#x2F;&#x2F; 创建一个PHP数据库\n\n    &#x2F;&#x2F; mysqli_query() 向MySQL数据库执行一条语句\n    if(mysqli_query($conn,$sql))&#123;\n        echo &quot;创建数据库 PHP成功&quot;;\n        &#125;\n    else&#123;\n        echo mysqli_error($conn);\n    &#125;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n运行后查看数据库是否添加\n\n创建数据表\n创建表的语句：create table \n实例：&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建数据表语句\n    $sql &#x3D; &quot;create table MyGuests (\n        id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, \n        firstname VARCHAR(30) NOT NULL,\n        lastname VARCHAR(30) NOT NULL,\n        email VARCHAR(50),\n        reg_date TIMESTAMP\n        )&quot;;\n     \n     &#x2F;&#x2F;向数据库执行sql语句\n     if(mysqli_query($conn,$sql))&#123;\n        echo &quot;创建数据表成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n     &#125; \n     else&#123;echo mysqli_error($conn);&#125;\n\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n运行截图数据库中的信息\n\n插入数据\n语法：insert into\n实例：&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建插入语句\n    $sql &#x3D; &quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES (&#39;John&#39;, &#39;Doe&#39;, &#39;john@example.com&#39;)&quot;;\n\n    &#x2F;&#x2F; 执行语句\n    if(mysqli_query($conn,$sql))&#123;\n        echo &quot;数据插入成功&quot;;\n    &#125;\n    else&#123;echo mysqli_error($conn);&#125;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n运行截图数据库中的信息\n\n插入多条数据\nmysqli_multi_query() 函数可用来执行多条SQL语句\n实例：&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建插入语句\n    $sql &#x3D; &quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES (&#39;pual&#39;, &#39;bei&#39;, &#39;pual@example.com&#39;);&quot;;\n    $sql .&#x3D; &quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES (&#39;Mary&#39;, &#39;Moe&#39;, &#39;mary@example.com&#39;);&quot;;\n    $sql .&#x3D; &quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES (&#39;Julie&#39;, &#39;Dooley&#39;, &#39;julie@example.com&#39;)&quot;;\n\n    &#x2F;&#x2F; 一次性插入多条语句\n    if(mysqli_multi_query($conn,$sql))&#123;\n        echo &quot;添加记录成功&quot;;\n    &#125;\n    else&#123;echo mysqli_connect_error;&#125;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n运行截图数据库中的信息\n\n读取数据\nmysqli_num_rows() ：返回sql语句查询到的总行数\n\nmysqli_fetch_assoc() 函数从结果集中取得一行作为关联数组\n\n实例：\n&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建查询语句\n    $sql &#x3D; &quot;select id, firstname, lastname from MyGuests&quot;;\n    \n    $res &#x3D; mysqli_query($conn,$sql);\n\n    &#x2F;&#x2F; 返回sql语句查询到的总行数\n    &#x2F;&#x2F; mysqli_num_rows($res)\n\n    if(mysqli_num_rows($res) &gt; 0)&#123;\n        while($row &#x3D; mysqli_fetch_assoc($res))&#123;\n            echo &quot;id:&quot; . $row[&quot;id&quot;] . &quot;-name:&quot; . $row[&quot;firstname&quot;] . &quot; &quot; .$row[&#39;lastname&#39;].&quot;&lt;br&gt;&quot;;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n运行截图\n\nmysqli_fetch_assoc()函数和mysqli_num_rows()函数的测试代码\n&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建查询语句\n    $sql &#x3D; &quot;select id, firstname, lastname from MyGuests&quot;;\n    \n    $res &#x3D; mysqli_query($conn,$sql);\n\n    &#x2F;&#x2F; 返回sql语句查询到的总行数\n    $row &#x3D; mysqli_num_rows($res) . &quot;&lt;br&gt;&quot;;\n\n    &#x2F;&#x2F; mysqli_fetch_assoc() 函数从结果集中取得一行作为关联数组\n\n    if($row &gt; 0)&#123;\n        while($i &#x3D; mysqli_fetch_assoc($res))&#123;\n            var_dump($i);\n            echo &quot;&lt;br&gt;&quot;;\n            \n            echo &quot;序列号为：&quot; . $i[&#39;id&#39;] . &quot;, firstname为：&quot; . $i[&#39;firstname&#39;] . &quot;, lastname为：&quot; . $i[&#39;lastname&#39;];\n            echo &quot;&lt;hr&gt;&quot;;\n        &#125;\n    &#125;\n\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n\n","slug":"04PHP连接MySQL数据库","date":"2022-11-10T11:28:27.559Z","categories_index":"学习笔记","tags_index":"php","author_index":"Abyssaler"},{"id":"e635c3e685c2a214ead8e396e5b6c265","title":"PHP文件","content":"文件处理fopen() 函数用于在 PHP 中打开文件。\n打开文件fopen() 函数用于在 PHP 中打开文件。\n此函数的第一个参数含有要打开的文件的名称，第二个参数规定了使用哪种模式来打开文件：\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n$file&#x3D;fopen(&quot;welcome.txt&quot;,&quot;r&quot;);\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n文件可能通过下列模式来打开：\n\n\n\n模式\n描述\n\n\n\nr\n只读。在文件的开头开始。\n\n\nr+\n读&#x2F;写。在文件的开头开始。\n\n\nw\n只写。打开并清空文件的内容；如果文件不存在，则创建新文件。\n\n\nw+\n读&#x2F;写。打开并清空文件的内容；如果文件不存在，则创建新文件。\n\n\na\n追加。打开并向文件末尾进行写操作，如果文件不存在，则创建新文件。\n\n\na+\n读&#x2F;追加。通过向文件末尾写内容，来保持文件内容。\n\n\nx\n只写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。\n\n\nx+\n读&#x2F;写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。\n\n\n注释：如果 fopen() 函数无法打开指定文件，则返回 0 (false)\n如果 fopen() 函数不能打开指定的文件，下面的实例会生成一段消息\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n$file&#x3D;fopen(&quot;welcome.txt&quot;,&quot;r&quot;) or exit(&quot;Unable to open file!&quot;);\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n关闭文件fclose() 函数用于关闭打开的文件\n&lt;?php\n$file &#x3D; fopen(&quot;test.txt&quot;,&quot;r&quot;);\n\n&#x2F;&#x2F;执行一些代码\n\nfclose($file);\n?&gt;\n\n\n\n逐行读取文件fgets() 函数用于从文件中逐行读取文件。\n注释：在调用该函数之后，文件指针会移动到下一行。\n&lt;?php\n$file &#x3D; fopen(&quot;welcome.txt&quot;, &quot;r&quot;) or exit(&quot;无法打开文件!&quot;);\n&#x2F;&#x2F; 读取文件每一行，直到文件结尾\nwhile(!feof($file))\n&#123;\n    echo fgets($file). &quot;&lt;br&gt;&quot;;\n&#125;\nfclose($file);\n?&gt;\n\n\n\n逐字符读取文件fgetc() 函数用于从文件中逐字符地读取文件。\n注释：在调用该函数之后，文件指针会移动到下一个字符。\n实例下面的实例逐字符地读取文件，直到文件末尾为止\n&lt;?php\n$file&#x3D;fopen(&quot;welcome.txt&quot;,&quot;r&quot;) or exit(&quot;无法打开文件!&quot;);\nwhile (!feof($file))\n&#123;\n    echo fgetc($file);\n&#125;\nfclose($file);\n?&gt;\n\n\n\n\n\n\n\n文件上传表单通过 PHP，可以把文件上传到服务器\ntest 项目下完成，目录结构为：\ntest\n|-----upload             # 文件上传的目录\n|-----form.html          # 表单文件\n|-----upload_file.php    # php 上传代码\n\n\n\n创建一个文件上传表单form.html\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n&lt;title&gt;表单&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n&lt;form action&#x3D;&quot;upload_file.php&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;\n    &lt;label for&#x3D;&quot;file&quot;&gt;文件名：&lt;&#x2F;label&gt;\n    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; id&#x3D;&quot;file&quot;&gt;&lt;br&gt;\n    &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n&lt;&#x2F;form&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n创建上传脚本“upload_file.php” 文件含有供上传文件的代码\n&lt;?php\nif ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0)\n&#123;\n    echo &quot;错误：&quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br&gt;&quot;;\n&#125;\nelse\n&#123;\n    echo &quot;上传文件名: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br&gt;&quot;;\n    echo &quot;文件类型: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br&gt;&quot;;\n    echo &quot;文件大小: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] &#x2F; 1024) . &quot; kB&lt;br&gt;&quot;;\n    echo &quot;文件临时存储的位置: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];\n&#125;\n?&gt;\n\n\n\n通过使用 PHP 的全局数组 $_FILES，你可以从客户计算机向远程服务器上传文件。\n第一个参数是表单的 input name，第二个下标可以是 “name”、”type”、”size”、”tmp_name” 或 “error”。如下所示：\n\n$_FILES[“file”][“name”] - 上传文件的名称\n$_FILES[“file”][“type”] - 上传文件的类型\n$_FILES[“file”][“size”] - 上传文件的大小，以字节计\n$_FILES[“file”][“tmp_name”] - 存储在服务器的文件的临时副本的名称\n$_FILES[“file”][“error”] - 由文件上传导致的错误代码\n\n这是一种非常简单文件上传方式。基于安全方面的考虑，您应当增加有关允许哪些用户上传文件的限制。\n","slug":"03PHP文件","date":"2022-11-10T11:28:27.558Z","categories_index":"学习笔记","tags_index":"php","author_index":"Abyssaler"},{"id":"befd9437c19ef7fdb68a823928ac2872","title":"PHP表单","content":"PHP 中的 $_GET 和 $_POST 变量用于检索表单中的信息，比如用户输入\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n&lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n \n&lt;form action&#x3D;&quot;welcome.php&quot; method&#x3D;&quot;post&quot;&gt;\n名字: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;fname&quot;&gt;\n年龄: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;age&quot;&gt;\n&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n&lt;&#x2F;form&gt;\n \n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n用户填写完上面的表单并点击提交按钮时，表单的数据会被送往名为 “welcome.php” 的 PHP 文件\n欢迎&lt;?php echo $_POST[&quot;fname&quot;]; ?&gt;!&lt;br&gt;\n你的年龄是 &lt;?php echo $_POST[&quot;age&quot;]; ?&gt;  岁。\n\n","slug":"02PHP表单","date":"2022-11-10T11:28:27.556Z","categories_index":"学习笔记","tags_index":"php","author_index":"Abyssaler"}]