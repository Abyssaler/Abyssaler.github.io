[{"id":"37e3720854a52996fd51ede25d9a35d3","title":"nmap扫描基础","content":"声明：此篇文章是引用来方便自己学习的，原出处在这里\n\n\n\n\n\n\n\n\n\nhttps://gitee.com/qianyongFeng/wiki/blob/master\n名称nmap — 网络探测工具和安全&#x2F;端口扫描器\n命令nmap [ &lt;扫描类型&gt; …] [ &lt;选项&gt; ] { &lt;扫描目标说明&gt; }\n描述注意:本文档描述了Nmap版本4.50。最新文档以英语 https://nmap.org/book/man.html提供。\nNmap (“Network Mapper(网络映射器)”) 是一款开放源代码的 网络探测和安全审核的工具。它的设计目标是快速地扫描大型网络，当然用它扫描单个 主机也没有问题。Nmap以新颖的方式使用原始IP报文来发现网络上有哪些主机，那些 主机提供什么服务(应用程序名和版本)，那些服务运行在什么操作系统(包括版本信息)， 它们使用什么类型的报文过滤器&#x2F;防火墙，以及一堆其它功能。虽然Nmap通常用于安全审核， 许多系统管理员和网络管理员也用它来做一些日常的工作，比如查看整个网络的信息， 管理服务升级计划，以及监视主机和服务的运行。\nNmap输出的是扫描目标的列表，以及每个目标的补充信息，至于是哪些信息则依赖于所使用的选项。 “所感兴趣的端口表格”是其中的关键。那张表列出端口号，协议，服务名称和状态。状态可能是 open(开放的)，filtered(被过滤的)， closed(关闭的)，或者unfiltered(未被过滤的)。 Open(开放的)意味着目标机器上的应用程序正在该端口监听连接&#x2F;报文。 filtered(被过滤的) 意味着防火墙，过滤器或者其它网络障碍阻止了该端口被访问，Nmap无法得知 它是 open(开放的) 还是 closed(关闭的)。 closed(关闭的) 端口没有应用程序在它上面监听，但是他们随时可能开放。 当端口对Nmap的探测做出响应，但是Nmap无法确定它们是关闭还是开放时，这些端口就被认为是 unfiltered(未被过滤的) 如果Nmap报告状态组合 open|filtered 和 closed|filtered时，那说明Nmap无法确定该端口处于两个状态中的哪一个状态。 当要求进行版本探测时，端口表也可以包含软件的版本信息。当要求进行IP协议扫描时 (-sO)，Nmap提供关于所支持的IP协议而不是正在监听的端口的信息。\n除了所感兴趣的端口表，Nmap还能提供关于目标机的进一步信息，包括反向域名，操作系统猜测，设备类型，和MAC地址。\n一个典型的Nmap扫描如例 1 “一个典型的Nmap扫描”所示。在这个例子中，唯一的选项是-A， 用来进行操作系统及其版本的探测，-T4 可以加快执行速度，接着是两个目标主机名。\n例 1. 一个典型的Nmap扫描\n# nmap -A -T4 scanme.nmap.org\n\nNmap scan report for scanme.nmap.org (74.207.244.221)\nHost is up (0.029s latency).\nrDNS record for 74.207.244.221: li86-221.members.linode.com\nNot shown: 995 closed ports\nPORT     STATE    SERVICE     VERSION\n22&#x2F;tcp   open     ssh         OpenSSH 5.3p1 Debian 3ubuntu7 (protocol 2.0)\n| ssh-hostkey: 1024 8d:60:f1:7c:ca:b7:3d:0a:d6:67:54:9d:69:d9:b9:dd (DSA)\n|_2048 79:f8:09:ac:d4:e2:32:42:10:49:d3:bd:20:82:85:ec (RSA)\n80&#x2F;tcp   open     http        Apache httpd 2.2.14 ((Ubuntu))\n|_http-title: Go ahead and ScanMe!\n646&#x2F;tcp  filtered ldp\n1720&#x2F;tcp filtered H.323&#x2F;Q.931\n9929&#x2F;tcp open     nping-echo  Nping echo\nDevice type: general purpose\nRunning: Linux 2.6.X\nOS CPE: cpe:&#x2F;o:linux:linux_kernel:2.6.39\nOS details: Linux 2.6.39\nNetwork Distance: 11 hops\nService Info: OS: Linux; CPE: cpe:&#x2F;o:linux:kernel\n\nTRACEROUTE (using port 53&#x2F;tcp)\nHOP RTT      ADDRESS\n[Cut first 10 hops for brevity]\n11  17.65 ms li86-221.members.linode.com (74.207.244.221)\n\nNmap done: 1 IP address (1 host up) scanned in 14.40 seconds\n\n选项概要当 Nmap 不带选项运行时，该选项概要会被输出，最新的版本在这里 http://www.insecure.org/nmap/data/nmap.usage.txt。它帮助人们记住最常用的选项，但不 能替代本手册其余深入的文档，一些晦涩的选项甚至不在这里。\nUsage: nmap [Scan Type(s)] [Options] &#123;target specification&#125;\nTARGET SPECIFICATION:\n    Can pass hostnames, IP addresses, networks, etc.\n    Ex: scanme.nmap.org, microsoft.com&#x2F;24, 192.168.0.1; 10.0-255.0-255.1-254\n    -iL &lt;inputfilename&gt;: Input from list of hosts&#x2F;networks\n    -iR &lt;num hosts&gt;: Choose random targets\n    --exclude &lt;host1[,host2][,host3],...&gt;: Exclude hosts&#x2F;networks\n    --excludefile &lt;exclude_file&gt;: Exclude list from file\nHOST DISCOVERY:\n    -sL: List Scan - simply list targets to scan\n    -sP: Ping Scan - go no further than determining if host is online\n    -P0: Treat all hosts as online -- skip host discovery\n    -PS&#x2F;PA&#x2F;PU [portlist]: TCP SYN&#x2F;ACK or UDP discovery probes to given ports\n    -PE&#x2F;PP&#x2F;PM: ICMP echo, timestamp, and netmask request discovery probes\n    -n&#x2F;-R: Never do DNS resolution&#x2F;Always resolve [default: sometimes resolve]\nSCAN TECHNIQUES:\n    -sS&#x2F;sT&#x2F;sA&#x2F;sW&#x2F;sM: TCP SYN&#x2F;Connect()&#x2F;ACK&#x2F;Window&#x2F;Maimon scans\n    -sN&#x2F;sF&#x2F;sX: TCP Null, FIN, and Xmas scans\n    --scanflags &lt;flags&gt;: Customize TCP scan flags\n    -sI &lt;zombie host[:probeport]&gt;: Idlescan\n    -sO: IP protocol scan\n    -b &lt;ftp relay host&gt;: FTP bounce scan\nPORT SPECIFICATION AND SCAN ORDER:\n    -p &lt;port ranges&gt;: Only scan specified ports\n    Ex: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080\n    -F: Fast - Scan only the ports listed in the nmap-services file)\n    -r: Scan ports consecutively - don&#39;t randomize\nSERVICE&#x2F;VERSION DETECTION:\n    -sV: Probe open ports to determine service&#x2F;version info\n    --version-light: Limit to most likely probes for faster identification\n    --version-all: Try every single probe for version detection\n    --version-trace: Show detailed version scan activity (for debugging)\nOS DETECTION:\n    -O: Enable OS detection\n    --osscan-limit: Limit OS detection to promising targets\n    --osscan-guess: Guess OS more aggressively\nTIMING AND PERFORMANCE:\n    -T[0-6]: Set timing template (higher is faster)\n    --min-hostgroup&#x2F;max-hostgroup &lt;msec&gt;: Parallel host scan group sizes\n    --min-parallelism&#x2F;max-parallelism &lt;msec&gt;: Probe parallelization\n    --min_rtt_timeout&#x2F;max-rtt-timeout&#x2F;initial-rtt-timeout &lt;msec&gt;: Specifies probe round trip time.\n    --host-timeout &lt;msec&gt;: Give up on target after this long\n    --scan-delay&#x2F;--max_scan-delay &lt;msec&gt;: Adjust delay between probes\nFIREWALL&#x2F;IDS EVASION AND SPOOFING:\n    -f; --mtu &lt;val&gt;: fragment packets (optionally w&#x2F;given MTU)\n    -D &lt;decoy1,decoy2[,ME],...&gt;: Cloak a scan with decoys\n    -S &lt;IP_Address&gt;: Spoof source address\n    -e &lt;iface&gt;: Use specified interface\n    -g&#x2F;--source-port &lt;portnum&gt;: Use given port number\n    --data-length &lt;num&gt;: Append random data to sent packets\n    --ttl &lt;val&gt;: Set IP time-to-live field\n    --spoof-mac &lt;mac address, prefix, or vendor name&gt;: Spoof your MAC address\nOUTPUT:\n    -oN&#x2F;-oX&#x2F;-oS&#x2F;-oG &lt;file&gt;: Output scan results in normal, XML, s|&lt;rIpt kIddi3, and Grepable format, respectively, to the given filename.\n    -oA &lt;basename&gt;: Output in the three major formats at once\n    -v: Increase verbosity level (use twice for more effect)\n    -d[level]: Set or increase debugging level (Up to 9 is meaningful)\n    --packet-trace: Show all packets sent and received\n    --iflist: Print host interfaces and routes (for debugging)\n    --append-output: Append to rather than clobber specified output files\n    --resume &lt;filename&gt;: Resume an aborted scan\n    --stylesheet &lt;path&#x2F;URL&gt;: XSL stylesheet to transform XML output to HTML\n    --no_stylesheet: Prevent Nmap from associating XSL stylesheet w&#x2F;XML output\nMISC:\n    -6: Enable IPv6 scanning\n    -A: Enables OS detection and Version detection\n    --datadir &lt;dirname&gt;: Specify custom Nmap data file location\n    --send-eth&#x2F;--send-ip: Send packets using raw ethernet frames or IP packets\n    --privileged: Assume that the user is fully privileged\n    -V: Print version number\n    -h: Print this help summary page.\nEXAMPLES:\n    nmap -v -A scanme.nmap.org\n    nmap -v -sP 192.168.0.0&#x2F;16 10.0.0.0&#x2F;8\n    nmap -v -iR 10000 -P0 -p 80\n\n目标说明除了选项，所有出现在Nmap命令行上的都被视为对目标主机的说明。 最简单的情况是指定一个目标IP地址或主机名。\n有时候您希望扫描整个网络的相邻主机。为此，Nmap支持CIDR风格的地址。您可以附加 一个&#x2F;在一个IP地址或主机名后面， Nmap将会扫描所有和该参考IP地址具有 相同比特的所有IP地址或主机。 例如，192.168.10.0&#x2F;24将会扫描192.168.10.0 (二进制格式: 11000000 10101000 00001010 00000000)和192.168.10.255 (二进制格式: 11000000 10101000 00001010 11111111)之间的256台主机。 192.168.10.40&#x2F;24 将会做同样的事情。假设主机 scanme.nmap.org的IP地址是205.217.153.62， scanme.nmap.org&#x2F;16 将扫描205.217.0.0和205.217.255.255之间的65,536 个IP地址。 所允许的最小值是&#x2F;1， 这将会扫描半个互联网。最大值是&#x2F;32，这将会扫描该主机或IP地址， 因为所有的比特都固定了。\nCIDR标志位很简洁但有时候不够灵活。例如，您也许想要扫描 192.168.0.0&#x2F;16，但略过任何以.0或者.255 结束的IP地址，因为它们通常是广播地址。 Nmap通过八位字节地址范围支持这样的扫描 您可以用逗号分开的数字或范围列表为IP地址的每个八位字节指定它的范围。 例如，192.168.0-255.1-254 将略过在该范围内以.0和.255结束的地址。 范围不必限于最后的8位：0-255.0-255.13.37 将在整个互联网范围内扫描所有以13.37结束的地址。 这种大范围的扫描对互联网调查研究也许有用。\nIPv6地址只能用规范的IPv6地址或主机名指定。 CIDR 和八位字节范围不支持IPv6，因为它们对于IPv6几乎没什么用。\nNmap命令行接受多个主机说明，它们不必是相同类型。命令nmap scanme.nmap.org 192.168.0.0&#x2F;8 10.0.0，1，3-7.0-255将和您预期的一样执行。\n虽然目标通常在命令行指定，下列选项也可用来控制目标的选择：\n-iL (从列表中输入)\n从 **中读取目标说明。在命令行输入 一堆主机名显得很笨拙，然而经常需要这样。 例如，您的DHCP服务器可能导出10,000个当前租约的列表，而您希望对它们进行 扫描。如果您不是使用未授权的静态IP来定位主机，或许您想要扫描所有IP地址。 只要生成要扫描的主机的列表，用-iL 把文件名作为选项传给Nmap。列表中的项可以是Nmap在 命令行上接受的任何格式(IP地址，主机名，CIDR，IPv6，或者八位字节范围)。 每一项必须以一个或多个空格，制表符或换行符分开。 如果您希望Nmap从标准输入而不是实际文件读取列表， 您可以用一个连字符(-)作为文件名。\n-iR (随机选择目标)\n对于互联网范围内的调查和研究， 您也许想随机地选择目标。 选项告诉 Nmap生成多少个IP。不合需要的IP如特定的私有，组播或者未分配的地址自动 略过。选项 0 意味着永无休止的扫描。记住，一些网管对于未授权的扫描可能会很感冒并加以抱怨。 使用该选项的后果自负! 如果在某个雨天的下午，您觉得实在无聊， 试试这个命令nmap -sS -PS80 -iR 0 -p 80随机地找一些网站浏览。\n–exclude &lt;host1[,host2][,host3],…&gt; (排除主机&#x2F;网络)\n如果在您指定的扫描范围有一些主机或网络不是您的目标， 那就用该选项加上以逗号分隔的列表排除它们。该列表用正常的Nmap语法， 因此它可以包括主机名，CIDR，八位字节范围等等。 当您希望扫描的网络包含执行关键任务的服务器，已知的对端口扫描反应强烈的 系统或者被其它人看管的子网时，这也许有用。\n–excludefile (排除文件中的列表)\n这和–exclude 选项的功能一样，只是所排除的目标是用以 换行符，空格，或者制表符分隔的 **提供的，而不是在命令行上输入的。\n主机发现任何网络探测任务的最初几个步骤之一就是把一组IP范围(有时该范围是巨大的)缩小为 一列活动的或者您感兴趣的主机。扫描每个IP的每个端口很慢，通常也没必要。当然，什么样的主机令您感兴趣主要依赖于扫描的目的。网管也许只对运行特定服务的 主机感兴趣，而从事安全的人士则可能对一个马桶都感兴趣，只要它有IP地址:-)。一个系统管理员 也许仅仅使用Ping来定位内网上的主机，而一个外部入侵测试人员则可能绞尽脑汁用各种方法试图突破防火墙的封锁。\n由于主机发现的需求五花八门，Nmap提供了一箩筐的选项来定制您的需求。 主机发现有时候也叫做ping扫描，但它远远超越用世人皆知的ping工具 发送简单的ICMP回声请求报文。用户完全可以通过使用列表扫描(-sL)或者 通过关闭ping (-P0)跳过ping的步骤，也可以使用多个端口把TCP SYN&#x2F;ACK，UDP和ICMP 任意组合起来玩一玩。这些探测的目的是获得响应以显示某个IP地址是否是活动的(正在被某 主机或者网络设备使用)。 在许多网络上，在给定的时间，往往只有小部分的IP地址是活动的。 这种情况在基于RFC1918的私有地址空间如10.0.0.0&#x2F;8尤其普遍。那个网络有16,000,000个IP，但我见过一些使用它的公司连1000台机器都没有。主机发现能够找到零星分布于IP地址海洋上的那些机器。\n如果没有给出主机发现的选项，Nmap 就发送一个TCP ACK报文到80端口和一个ICMP回声请求到每台目标机器。 一个例外是ARP扫描用于局域网上的任何目标机器。对于非特权UNIX shell用户，使用connect()系统调用会发送一个SYN报文而不是ACK 这些默认行为和使用-PA -PE选项的效果相同。 扫描局域网时，这种主机发现一般够用了，但是对于安全审核，建议进行 更加全面的探测。\n-P选项(用于选择 ping的类型)可以被结合使用。 您可以通过使用不同的TCP端口&#x2F;标志位和ICMP码发送许多探测报文 来增加穿透防守严密的防火墙的机会。另外要注意的是即使您指定了其它 -P*选项，ARP发现(-PR)对于局域网上的 目标而言是默认行为，因为它总是更快更有效。\n下列选项控制主机发现。\n-sL (列表扫描)\n列表扫描是主机发现的退化形式，它仅仅列出指定网络上的每台主机， 不发送任何报文到目标主机。默认情况下，Nmap仍然对主机进行反向域名解析以获取 它们的名字。简单的主机名能给出的有用信息常常令人惊讶。例如， fw.chi.playboy.com是花花公子芝加哥办公室的 防火墙。Nmap最后还会报告IP地址的总数。列表扫描可以很好的确保您拥有正确的目标IP。 如果主机的域名出乎您的意料，那么就值得进一步检查以防错误地扫描其它组织的网络。\n既然只是打印目标主机的列表，像其它一些高级功能如端口扫描，操作系统探测或者Ping扫描 的选项就没有了。如果您希望关闭ping扫描而仍然执行这样的高级功能，请继续阅读关于 -P0选项的介绍。\n-sP (Ping扫描)\n该选项告诉Nmap仅仅 进行ping扫描 (主机发现)，然后打印出对扫描做出响应的那些主机。 没有进一步的测试 (如端口扫描或者操作系统探测)。 这比列表扫描更积极，常常用于 和列表扫描相同的目的。它可以得到些许目标网络的信息而不被特别注意到。 对于攻击者来说，了解多少主机正在运行比列表扫描提供的一列IP和主机名往往更有价值。\n系统管理员往往也很喜欢这个选项。 它可以很方便地得出 网络上有多少机器正在运行或者监视服务器是否正常运行。常常有人称它为 地毯式ping，它比ping广播地址更可靠，因为许多主机对广播请求不响应。\n-sP选项在默认情况下， 发送一个ICMP回声请求和一个TCP报文到80端口。如果非特权用户执行，就发送一个SYN报文 (用connect()系统调用)到目标机的80端口。 当特权用户扫描局域网上的目标机时，会发送ARP请求(-PR)， ，除非使用了–send-ip选项。 -sP选项可以和除-P0)之外的任何发现探测类型-P* 选项结合使用以达到更大的灵活性。 一旦使用了任何探测类型和端口选项，默认的探测(ACK和回应请求)就被覆盖了。 当防守严密的防火墙位于运行Nmap的源主机和目标网络之间时， 推荐使用那些高级选项。否则，当防火墙捕获并丢弃探测包或者响应包时，一些主机就不能被探测到。\n-P0 (无ping)\n该选项完全跳过Nmap发现阶段。 通常Nmap在进行高强度的扫描时用它确定正在运行的机器。 默认情况下，Nmap只对正在运行的主机进行高强度的探测如 端口扫描，版本探测，或者操作系统探测。用-P0禁止 主机发现会使Nmap对每一个指定的目标IP地址 进行所要求的扫描。所以如果在命令行指定一个B类目标地址空间(&#x2F;16)， 所有 65,536 个IP地址都会被扫描。 -P0的第二个字符是数字0而不是字母O。 和列表扫描一样，跳过正常的主机发现，但不是打印一个目标列表， 而是继续执行所要求的功能，就好像每个IP都是活动的。\n-PS [portlist] (TCP SYN Ping)\n该选项发送一个设置了SYN标志位的空TCP报文。 默认目的端口为80 (可以通过改变nmap.h) 文件中的DEFAULT-TCP-PROBE-PORT值进行配置，但不同的端口也可以作为选项指定。 甚至可以指定一个以逗号分隔的端口列表(如 -PS22，23，25，80，113，1050，35000)， 在这种情况下，每个端口会被并发地扫描。\nSYN标志位告诉对方您正试图建立一个连接。 通常目标端口是关闭的，一个RST (复位) 包会发回来。 如果碰巧端口是开放的，目标会进行TCP三步握手的第二步，回应 一个SYN&#x2F;ACK TCP报文。然后运行Nmap的机器则会扼杀这个正在建立的连接， 发送一个RST而非ACK报文，否则，一个完全的连接将会建立。 RST报文是运行Nmap的机器而不是Nmap本身响应的，因为它对收到 的SYN&#x2F;ACK感到很意外。\nNmap并不关心端口开放还是关闭。 无论RST还是SYN&#x2F;ACK响应都告诉Nmap该主机正在运行。\n在UNIX机器上，通常只有特权用户 root 能否发送和接收 原始的TCP报文。因此作为一个变通的方法，对于非特权用户， Nmap会为每个目标主机进行系统调用connect()，它也会发送一个SYN 报文来尝试建立连接。如果connect()迅速返回成功或者一个ECONNREFUSED 失败，下面的TCP堆栈一定已经收到了一个SYN&#x2F;ACK或者RST，该主机将被 标志位为在运行。 如果连接超时了，该主机就标志位为down掉了。这种方法也用于IPv6 连接，因为Nmap目前还不支持原始的IPv6报文。\n-PA [portlist] (TCP ACK Ping)\nTCP ACK ping和刚才讨论的SYN ping相当类似。 也许您已经猜到了，区别就是设置TCP的ACK标志位而不是SYN标志位。 ACK报文表示确认一个建立连接的尝试，但该连接尚未完全建立。 所以远程主机应该总是回应一个RST报文， 因为它们并没有发出过连接请求到运行Nmap的机器，如果它们正在运行的话。\n-PA选项使用和SYN探测相同的默认端口(80)，也可以 用相同的格式指定目标端口列表。如果非特权用户尝试该功能， 或者指定的是IPv6目标，前面说过的connect()方法将被使用。 这个方法并不完美，因为它实际上发送的是SYN报文，而不是ACK报文。\n提供SYN和ACK两种ping探测的原因是使通过防火墙的机会尽可能大。 许多管理员会配置他们的路由器或者其它简单的防火墙来封锁SYN报文，除非 连接目标是那些公开的服务器像公司网站或者邮件服务器。 这可以阻止其它进入组织的连接，同时也允许用户访问互联网。 这种无状态的方法几乎不占用防火墙&#x2F;路由器的资源，因而被硬件和软件过滤器 广泛支持。Linux Netfilter&#x2F;iptables 防火墙软件提供方便的 –syn选项来实现这种无状态的方法。 当这样的无状态防火墙规则存在时，发送到关闭目标端口的SYN ping探测 (-PS) 很可能被封锁。这种情况下，ACK探测格外有闪光点，因为它正好利用了 这样的规则。\n另外一种常用的防火墙用有状态的规则来封锁非预期的报文。 这一特性已开始只存在于高端防火墙，但是这些年类它越来越普遍了。 Linux Netfilter&#x2F;iptables 通过 –state选项支持这一特性，它根据连接状态把报文 进行分类。SYN探测更有可能用于这样的系统，由于没头没脑的ACK报文 通常会被识别成伪造的而丢弃。解决这个两难的方法是通过即指定 -PS又指定-PA来即发送SYN又发送ACK。\n-PU [portlist] (UDP Ping)\n还有一个主机发现的选项是UDP ping，它发送一个空的(除非指定了–data-length UDP报文到给定的端口。端口列表的格式和前面讨论过的-PS和-PA选项还是一样。 如果不指定端口，默认是31338。该默认值可以通过在编译时改变nmap.h文件中的 DEFAULT-UDP-PROBE-PORT值进行配置。默认使用这样一个奇怪的端口是因为对开放端口 进行这种扫描一般都不受欢迎。\n如果目标机器的端口是关闭的，UDP探测应该马上得到一个ICMP端口无法到达的回应报文。 这对于Nmap意味着该机器正在运行。 许多其它类型的ICMP错误，像主机&#x2F;网络无法到达或者TTL超时则表示down掉的或者不可到达的主机。 没有回应也被这样解释。如果到达一个开放的端口，大部分服务仅仅忽略这个 空报文而不做任何回应。这就是为什么默认探测端口是31338这样一个 极不可能被使用的端口。少数服务如chargen会响应一个空的UDP报文， 从而向Nmap表明该机器正在运行。\n该扫描类型的主要优势是它可以穿越只过滤TCP的防火墙和过滤器。 例如。我曾经有过一个Linksys BEFW11S4无线宽带路由器。默认情况下， 该设备对外的网卡过滤所有TCP端口，但UDP探测仍然会引发一个端口不可到达 的消息，从而暴露了它自己。\n-PE; -PP; -PM (ICMP Ping Types)\n除了前面讨论的这些不常见的TCP和UDP主机发现类型， Nmap也能发送世人皆知的ping 程序所发送的报文。Nmap发送一个ICMP type 8 (回声请求)报文到目标IP地址， 期待从运行的主机得到一个type 0 (回声响应)报文。 对于网络探索者而言，不幸的是，许多主机和 防火墙现在封锁这些报文，而不是按期望的那样响应， 参见RFC 1122。因此，仅仅ICMP扫描对于互联网上的目标通常是不够的。 但对于系统管理员监视一个内部网络，它们可能是实际有效的途径。 使用-PE选项打开该回声请求功能。\n虽然回声请求是标准的ICMP ping查询， Nmap并不止于此。ICMP标准 (RFC 792)还规范了时间戳请求，信息请求 request，和地址掩码请求，它们的代码分别是13，15和17。 虽然这些查询的表面目的是获取信息如地址掩码和当前时间， 它们也可以很容易地用于主机发现。 很简单，回应的系统就是在运行的系统。Nmap目前没有实现信息请求报文， 因为它们还没有被广泛支持。RFC 1122 坚持 “主机不应该实现这些消息”。 时间戳和地址掩码查询可以分别用-PP和-PM选项发送。 时间戳响应(ICMP代码14)或者地址掩码响应(代码18)表示主机在运行。 当管理员特别封锁了回声请求报文而忘了其它ICMP查询可能用于 相同目的时，这两个查询可能很有价值。\n-PR (ARP Ping)\n最常见的Nmap使用场景之一是扫描一个以太局域网。在大部分局域网上，特别是那些使用基于 RFC1918私有地址范围的网络，在一个给定的时间绝大部分 IP地址都是不使用的。 当Nmap试图发送一个原始IP报文如ICMP回声请求时， 操作系统必须确定对应于目标IP的硬件地址(ARP)，这样它才能把以太帧送往正确的地址。 这一般比较慢而且会有些问题，因为操作系统设计者认为一般不会在短时间内 对没有运行的机器作几百万次的ARP请求。\n当进行ARP扫描时，Nmap用它优化的算法管理ARP请求。当它收到响应时，Nmap甚至不需要担心基于IP的ping报文，既然它已经知道该主机正在运行了。 这使得ARP扫描比基于IP的扫描更快更可靠。 所以默认情况下，如果Nmap发现目标主机就在它所在的局域网上，它会进行ARP扫描。即使指定了不同的ping类型(如 -PI或者 -PS) ，Nmap也会对任何相同局域网上的目标机使用ARP。 如果您真的不想要ARP扫描，指定 –send-ip。\n-n (不用域名解析)\n告诉Nmap 永不对它发现的活动IP地址进行反向域名解析。既然DNS一般比较慢，这可以让事情更快些。\n-R (为所有目标解析域名)\n告诉Nmap 永远 对目标IP地址作反向域名解析。 一般只有当发现机器正在运行时才进行这项操作。\n–system-dns (使用系统域名解析器)\n默认情况下，Nmap通过直接发送查询到您的主机上配置的域名服务器 来解析域名。为了提高性能，许多请求 (一般几十个 ) 并发执行。如果您希望使用系统自带的解析器，就指定该选项 (通过getnameinfo()调用一次解析一个IP)。除非Nmap的DNS代码有bug–如果是这样，请联系我们。 一般不使用该选项，因为它慢多了。系统解析器总是用于IPv6扫描。\n端口扫描基础虽然Nmap这些年来功能越来越多， 它也是从一个高效的端口扫描器开始的，并且那仍然是它的核心功能。 nmap 这个简单的命令扫描主机上的超过 1660个TCP端口。 。许多传统的端口扫描器只列出所有端口是开放还是关闭的， Nmap的信息粒度比它们要细得多。 它把端口分成六个状态: open(开放的)， closed(关闭的)，filtered(被过滤的)， unfiltered(未被过滤的)， open|filtered(开放或者被过滤的)，或者 closed|filtered(关闭或者被过滤的)。\n这些状态并非端口本身的性质，而是描述Nmap怎样看待它们。例如， 对于同样的目标机器的135&#x2F;tcp端口，从同网络扫描显示它是开放的，而跨网络作完全相同的扫描则可能显示它是 filtered(被过滤的)。\nNmap所识别的6个端口状态：\nopen(开放的)\n应用程序正在该端口接收TCP 连接或者UDP报文。发现这一点常常是端口扫描 的主要目标。安全意识强的人们知道每个开放的端口 都是攻击的入口。攻击者或者入侵测试者想要发现开放的端口。 而管理员则试图关闭它们或者用防火墙保护它们以免妨碍了合法用户。 非安全扫描可能对开放的端口也感兴趣，因为它们显示了网络上那些服务可供使用。\nclosed(关闭的)\n关闭的端口对于Nmap也是可访问的(它接受Nmap的探测报文并作出响应)， 但没有应用程序在其上监听。 它们可以显示该IP地址上(主机发现，或者ping扫描)的主机正在运行up 也对部分操作系统探测有所帮助。 因为关闭的关口是可访问的，也许过会儿值得再扫描一下，可能一些又开放了。 系统管理员可能会考虑用防火墙封锁这样的端口。 那样他们就会被显示为被过滤的状态，下面讨论。\nfiltered(被过滤的)\n由于包过滤阻止探测报文到达端口， Nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由器规则 或者主机上的软件防火墙。这样的端口让攻击者感觉很挫折，因为它们几乎不提供 任何信息。有时候它们响应ICMP错误消息如类型3代码13 (无法到达目标: 通信被管理员禁止)，但更普遍的是过滤器只是丢弃探测帧， 不做任何响应。 这迫使Nmap重试若干次以访万一探测包是由于网络阻塞丢弃的。 这使得扫描速度明显变慢。\nunfiltered(未被过滤的)\n未被过滤状态意味着端口可访问，但Nmap不能确定它是开放还是关闭。 只有用于映射防火墙规则集的ACK扫描才会把端口分类到这种状态。 用其它类型的扫描如窗口扫描，SYN扫描，或者FIN扫描来扫描未被过滤的端口可以帮助确定 端口是否开放。\nopen|filtered(开放或者被过滤的)\n当无法确定端口是开放还是被过滤的，Nmap就把该端口划分成 这种状态。开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃 了探测报文或者它引发的任何响应。因此Nmap无法确定该端口是开放的还是被过滤的。 UDP，IP协议， FIN，Null，和Xmas扫描可能把端口归入此类。\nclosed|filtered(关闭或者被过滤的)\n该状态用于Nmap不能确定端口是关闭的还是被过滤的。 它只可能出现在IPID Idle扫描中。\n端口扫描技术作为一个修车新手，我可能折腾几个小时来摸索怎样把基本工具(锤子，胶带，扳子等) 用于手头的任务。当我惨痛地失败，把我的老爷车拖到一个真正的技师那儿的时候 ，他总是在他的工具箱里翻来翻去，直到拽出一个完美的工具然后似乎不费吹灰之力搞定它。 端口扫描的艺术和这个类似。专家理解成打的扫描技术，选择最适合的一种 (或者组合)来完成给定的 任务。 另一方面，没有经验的用户和刚入门者总是用默认的SYN扫描解决每个问题。 既然Nmap是免费的，掌握端口扫描的唯一障碍就是知识。这当然是汽车世界所不能比的， 在那里，可能需要高超的技巧才能确定您需要一个压杆弹簧压缩机，接着您还得为它付数千美金。\n大部分扫描类型只对特权用户可用。 这是因为他们发送接收原始报文，这在Unix系统需要root权限。 在Windows上推荐使用administrator账户，但是当WinPcap已经被加载到操作系统时， 非特权用户也可以正常使用Nmap。当Nmap在1997年发布时，需要root权限是一个严重的 局限，因为很多用户只有共享的shell账户。现在，世界变了，计算机便宜了，更多人拥有互联网连接 ，桌面UNIX系统 (包括Linux和MAC OS X)很普遍了。Windows版本的Nmap现在也有了，这使它可以运行在更多的桌面上。 由于所有这些原因，用户不再需要用有限的共享shell账户运行Nmap。 这是很幸运的，因为特权选项让Nmap强大得多也灵活得多。\n虽然Nmap努力产生正确的结果，但请记住所有结果都是基于目标机器(或者它们前面的防火墙)返回的报文的。 。这些主机也许是不值得信任的，它们可能响应以迷惑或误导Nmap的报文。 更普遍的是非RFC兼容的主机以不正确的方式响应Nmap探测。FIN，Null和Xmas扫描 特别容易遇到这个问题。这些是特定扫描类型的问题，因此我们在个别扫描类型里讨论它们。\n这一节讨论Nmap支持的大约十几种扫描技术。 一般一次只用一种方法， 除了UDP扫描(-sU)可能和任何一种TCP扫描类型结合使用。 友情提示一下，端口扫描类型的选项格式是-s， 其中 是个显眼的字符，通常是第一个字符。 一个例外是deprecated FTP bounce扫描(-b)。默认情况下，Nmap执行一个 SYN扫描，但是如果用户没有权限发送原始报文(在UNIX上需要root权限)或者如果指定的是IPv6目标，Nmap调用connect()。 本节列出的扫描中，非特权用户只能执行connect()和ftp bounce扫描。\n-sS (TCP SYN扫描)\nSYN扫描作为默认的也是最受欢迎的扫描选项，是有充分理由的。 它执行得很快，在一个没有入侵防火墙的快速网络上，每秒钟可以扫描数千个 端口。 SYN扫描相对来说不张扬，不易被注意到，因为它从来不完成TCP连接。 它也不像Fin&#x2F;Null&#x2F;Xmas，Maimon和Idle扫描依赖于特定平台，而可以应对任何兼容的 TCP协议栈。 它还可以明确可靠地区分open(开放的)， closed(关闭的)，和filtered(被过滤的) 状态\n它常常被称为半开放扫描， 因为它不打开一个完全的TCP连接。它发送一个SYN报文， 就像您真的要打开一个连接，然后等待响应。 SYN&#x2F;ACK表示端口在监听 (开放)，而 RST (复位)表示没有监听者。如果数次重发后仍没响应， 该端口就被标记为被过滤。如果收到ICMP不可到达错误 (类型3，代码1，2，3，9，10，或者13)，该端口也被标记为被过滤。\n-sT (TCP connect()扫描)\n当SYN扫描不能用时，CP Connect()扫描就是默认的TCP扫描。 当用户没有权限发送原始报文或者扫描IPv6网络时，就是这种情况。 Instead of writing raw packets as most other scan types do，Nmap通过创建connect() 系统调用要求操作系统和目标机以及端口建立连接，而不像其它扫描类型直接发送原始报文。 这是和Web浏览器，P2P客户端以及大多数其它网络应用程序用以建立连接一样的 高层系统调用。它是叫做Berkeley Sockets API编程接口的一部分。Nmap用 该API获得每个连接尝试的状态信息，而不是读取响应的原始报文。\n当SYN扫描可用时，它通常是更好的选择。因为Nmap对高层的 connect()调用比对原始报文控制更少， 所以前者效率较低。 该系统调用完全连接到开放的目标端口而不是像SYN扫描进行 半开放的复位。这不仅花更长时间，需要更多报文得到同样信息，目标机也更可能 记录下连接。IDS(入侵检测系统)可以捕获两者，但大部分机器没有这样的警报系统。 当Nmap连接，然后不发送数据又关闭连接， 许多普通UNIX系统上的服务会在syslog留下记录，有时候是一条加密的错误消息。 此时，有些真正可怜的服务会崩溃，虽然这不常发生。如果管理员在日志里看到来自同一系统的 一堆连接尝试，她应该知道她的系统被扫描了。\n-sU (UDP扫描)\n虽然互联网上很多流行的服务运行在TCP 协议上，UDP服务也不少。 DNS，SNMP，和DHCP (注册的端口是53，161&#x2F;162，和67&#x2F;68)是最常见的三个。 因为UDP扫描一般较慢，比TCP更困难，一些安全审核人员忽略这些端口。 这是一个错误，因为可探测的UDP服务相当普遍，攻击者当然不会忽略整个协议。 所幸，Nmap可以帮助记录并报告UDP端口。\nUDP扫描用-sU选项激活。它可以和TCP扫描如 SYN扫描 (-sS)结合使用来同时检查两种协议。\nUDP扫描发送空的(没有数据)UDP报头到每个目标端口。 如果返回ICMP端口不可到达错误(类型3，代码3)， 该端口是closed(关闭的)。 其它ICMP不可到达错误(类型3， 代码1，2，9，10，或者13)表明该端口是filtered(被过滤的)。 偶尔地，某服务会响应一个UDP报文，证明该端口是open(开放的)。 如果几次重试后还没有响应，该端口就被认为是 open|filtered(开放|被过滤的)。 这意味着该端口可能是开放的，也可能包过滤器正在封锁通信。 可以用版本扫描(-sV)帮助区分真正的开放端口和被过滤的端口。\nUDP扫描的巨大挑战是怎样使它更快速。 开放的和被过滤的端口很少响应，让Nmap超时然后再探测，以防探测帧或者 响应丢失。关闭的端口常常是更大的问题。 它们一般发回一个ICMP端口无法到达错误。但是不像关闭的TCP端口响应SYN或者Connect 扫描所发送的RST报文，许多主机在默认情况下限制ICMP端口不可到达消息。 Linux和Solaris对此特别严格。例如， Linux 2.4.20内核限制一秒钟只发送一条目标不可到达消息 (见net&#x2F;ipv4&#x2F;icmp。c)。\nNmap探测速率限制并相应地减慢来避免用那些目标机会丢弃的无用报文来阻塞 网络。不幸的是，Linux式的一秒钟一个报文的限制使65,536个端口的扫描要花 18小时以上。加速UDP扫描的方法包括并发扫描更多的主机，先只对主要端口进行快速 扫描，从防火墙后面扫描，使用–host-timeout跳过慢速的 主机。\n-sN; -sF; -sX (TCP Null，FIN，and Xmas扫描)\n这三种扫描类型 (甚至用下一节描述的 –scanflags 选项的更多类型) 在TCP RFC中发掘了一个微妙的方法来区分open(开放的)和 closed(关闭的)端口。第65页说“如果 [目标]端口状态是关闭的…. 进入的不含RST的报文导致一个RST响应。” 接下来的一页 讨论不设置SYN，RST，或者ACK位的报文发送到开放端口: “理论上，这不应该发生，如果您确实收到了，丢弃该报文，返回。 ”\n如果扫描系统遵循该RFC，当端口关闭时，任何不包含SYN，RST，或者ACK位的报文会导致 一个RST返回，而当端口开放时，应该没有任何响应。只要不包含SYN，RST，或者ACK， 任何其它三种(FIN，PSH，and URG)的组合都行。Nmap有三种扫描类型利用这一点：\nNull扫描 (-sN)\n不设置任何标志位(tcp标志头是0)\nFIN扫描 (-sF)\n只设置TCP FIN标志位。\nXmas扫描 (-sX)\n设置FIN，PSH，和URG标志位，就像点亮圣诞树上所有的灯一样。\n除了探测报文的标志位不同，这三种扫描在行为上完全一致。 如果收到一个RST报文，该端口被认为是 closed(关闭的)，而没有响应则意味着 端口是open|filtered(开放或者被过滤的)。 如果收到ICMP不可到达错误(类型 3，代号 1，2，3，9，10，或者13)，该端口就被标记为 被过滤的。\n这些扫描的关键优势是它们能躲过一些无状态防火墙和报文过滤路由器。 另一个优势是这些扫描类型甚至比SYN扫描还要隐秘一些。但是别依赖它 – 多数 现代的IDS产品可以发现它们。一个很大的不足是并非所有系统都严格遵循RFC 793。 许多系统不管端口开放还是关闭，都响应RST。 这导致所有端口都标记为closed(关闭的)。 这样的操作系统主要有Microsoft Windows，许多Cisco设备，BSDI，以及IBM OS&#x2F;400。 但是这种扫描对多数UNIX系统都能工作。这些扫描的另一个不足是 它们不能辨别open(开放的)端口和一些特定的 filtered(被过滤的)端口，从而返回 open|filtered(开放或者被过滤的)。\n-sA (TCP ACK扫描)\n这种扫描与目前为止讨论的其它扫描的不同之处在于 它不能确定open(开放的)或者 open|filtered(开放或者过滤的))端口。 它用于发现防火墙规则，确定它们是有状态的还是无状态的，哪些端口是被过滤的。\nACK扫描探测报文只设置ACK标志位(除非您使用 –scanflags)。当扫描未被过滤的系统时， open(开放的)和closed(关闭的) 端口 都会返回RST报文。Nmap把它们标记为 unfiltered(未被过滤的)，意思是 ACK报文不能到达，但至于它们是open(开放的)或者 closed(关闭的) 无法确定。不响应的端口 或者发送特定的ICMP错误消息(类型3，代号1，2，3，9，10， 或者13)的端口，标记为 filtered(被过滤的)。\n-sW (TCP窗口扫描)\n除了利用特定系统的实现细节来区分开放端口和关闭端口，当收到RST时不总是打印unfiltered， 窗口扫描和ACK扫描完全一样。 它通过检查返回的RST报文的TCP窗口域做到这一点。 在某些系统上，开放端口用正数表示窗口大小(甚至对于RST报文) 而关闭端口的窗口大小为0。因此，当收到RST时，窗口扫描不总是把端口标记为 unfiltered， 而是根据TCP窗口值是正数还是0，分别把端口标记为open或者 closed\n该扫描依赖于互联网上少数系统的实现细节， 因此您不能永远相信它。不支持它的系统会通常返回所有端口closed。 当然，一台机器没有开放端口也是有可能的。 如果大部分被扫描的端口是 closed，而一些常见的端口 (如 22， 25，53) 是 filtered，该系统就非常可疑了。 偶尔地，系统甚至会显示恰恰相反的行为。 如果您的扫描显示1000个开放的端口和3个关闭的或者被过滤的端口， 那么那3个很可能也是开放的端口。\n-sM (TCP Maimon扫描)\nMaimon扫描是用它的发现者Uriel Maimon命名的。他在 Phrack Magazine issue #49 (November 1996)中描述了这一技术。 Nmap在两期后加入了这一技术。 这项技术和Null，FIN，以及Xmas扫描完全一样，除了探测报文是FIN&#x2F;ACK。 根据RFC 793 (TCP)，无论端口开放或者关闭，都应该对这样的探测响应RST报文。 然而，Uriel注意到如果端口开放，许多基于BSD的系统只是丢弃该探测报文。\n–scanflags (定制的TCP扫描)\n真正的Nmap高级用户不需要被这些现成的扫描类型束缚。 –scanflags选项允许您通过指定任意TCP标志位来设计您自己的扫描。 让您的创造力流动，躲开那些仅靠本手册添加规则的入侵检测系统！\n–scanflags选项可以是一个数字标记值如9 (PSH和FIN)， 但使用字符名更容易些。 只要是URG， ACK，PSH， RST，SYN，and FIN的任何组合就行。例如，–scanflags URGACKPSHRSTSYNFIN设置了所有标志位，但是这对扫描没有太大用处。 标志位的顺序不重要。\n除了设置需要的标志位，您也可以设置 TCP扫描类型(如-sA或者-sF)。 那个基本类型告诉Nmap怎样解释响应。例如， SYN扫描认为没有响应意味着 filtered端口，而FIN扫描则认为是 open|filtered。 除了使用您指定的TCP标记位，Nmap会和基本扫描类型一样工作。 如果您不指定基本类型，就使用SYN扫描。\n-sI &lt;zombie host[:probeport]&gt; (Idlescan)\n这种高级的扫描方法允许对目标进行真正的TCP端口盲扫描 (意味着没有报文从您的真实IP地址发送到目标)。相反，side-channel攻击 利用zombie主机上已知的IP分段ID序列生成算法来窥探目标上开放端口的信息。 IDS系统将显示扫描来自您指定的zombie机(必须运行并且符合一定的标准)。 这种奇妙的扫描类型太复杂了，不能在此完全描述，所以我写一篇非正式的论文， 发布在https://nmap.org/book/idlescan.html。\n除了极端隐蔽(由于它不从真实IP地址发送任何报文)， 该扫描类型可以建立机器间的基于IP的信任关系。 端口列表从zombie 主机的角度。显示开放的端口。 因此您可以尝试用您认为(通过路由器&#x2F;包过滤规则)可能被信任的 zombies扫描目标。\n如果您由于IPID改变希望探测zombie上的特定端口， 您可以在zombie 主机后加上一个冒号和端口号。 否则Nmap会使用默认端口(80)。\n-sO (IP协议扫描)\nIP 协议扫描可以让您确定目标机支持哪些IP协议 (TCP，ICMP，IGMP，等等)。从技术上说，这不是端口扫描 ，既然它遍历的是IP协议号而不是TCP或者UDP端口号。 但是它仍使用 -p选项选择要扫描的协议号， 用正常的端口表格式报告结果，甚至用和真正的端口扫描一样 的扫描引擎。因此它和端口扫描非常接近，也被放在这里讨论。\n除了本身很有用，协议扫描还显示了开源软件的力量。 尽管基本想法非常简单，我过去从没想过增加这一功能也没收到任何对它的请求。 在2000年夏天，Gerhard Rieger孕育了这个想法，写了一个很棒的补丁程序，发送到nmap-hackers邮件列表。 我把那个补丁加入了Nmap，第二天发布了新版本。 几乎没有商业软件会有用户有足够的热情设计并贡献他们的改进。\n协议扫描以和UDP扫描类似的方式工作。它不是在UDP报文的端口域上循环， 而是在IP协议域的8位上循环，发送IP报文头。 报文头通常是空的，不包含数据，甚至不包含所申明的协议的正确报文头 TCP，UDP，和ICMP是三个例外。它们三个会使用正常的协议头，因为否则某些系 统拒绝发送，而且Nmap有函数创建它们。协议扫描不是注意ICMP端口不可到达消息， 而是ICMP 协议不可到达消息。如果Nmap从目标主机收到 任何协议的任何响应，Nmap就把那个协议标记为open。 ICMP协议不可到达 错误(类型 3，代号 2) 导致协议被标记为 closed。其它ICMP不可到达协议(类型 3，代号 1，3，9，10，或者13) 导致协议被标记为 filtered (虽然同时他们证明ICMP是 open )。如果重试之后仍没有收到响应， 该协议就被标记为open|filtered\n-b (FTP弹跳扫描)\nFTP协议的一个有趣特征(RFC 959) 是支持所谓代理ftp连接。它允许用户连接到一台FTP服务器，然后要求文件送到一台第三方服务器。 这个特性在很多层次上被滥用，所以许多服务器已经停止支持它了。其中一种就是导致FTP服务器对其它主机端口扫描。 只要请求FTP服务器轮流发送一个文件到目标主机上的所感兴趣的端口。 错误消息会描述端口是开放还是关闭的。 这是绕过防火墙的好方法，因为FTP服务器常常被置于可以访问比Web主机更多其它内部主机的位置。 Nmap用-b选项支持ftp弹跳扫描。参数格式是 :@:。 是某个脆弱的FTP服务器的名字或者IP地址。 您也许可以省略:， 如果服务器上开放了匿名用户(user:anonymous password:-wwwuser@)。 端口号(以及前面的冒号) 也可以省略，如果使用默认的FTP端口(21)。\n当Nmap1997年发布时，这个弱点被广泛利用，但现在大部分已经被fix了。 脆弱的服务器仍然存在，所以如果其它都失败了，这也值得一试。 如果您的目标是绕过防火墙，扫描目标网络上的开放的21端口(或者 甚至任何ftp服务，如果您用版本探测扫描所有端口)， 然后对每个尝试弹跳扫描。Nmap会告诉您该主机脆弱与否。 如果您只是试着玩Nmap，您不必(事实上，不应该)限制您自己。 在您随机地在互联网上寻找脆弱的FTP服务器时，考虑一下系统管理员不太喜欢您这样滥用他们的服务器。\n端口说明和扫描顺序除了所有前面讨论的扫描方法， Nmap提供选项说明那些端口被扫描以及扫描是随机还是顺序进行。 默认情况下，Nmap用指定的协议对端口1到1024以及nmap-services 文件中列出的更高的端口在扫描。\n-p (只扫描指定的端口)\n该选项指明您想扫描的端口，覆盖默认值。 单个端口和用连字符表示的端口范围(如 1-1023)都可以。 范围的开始以及&#x2F;或者结束值可以被省略， 分别导致Nmap使用1和65535。所以您可以指定 -p-从端口1扫描到65535。 如果您特别指定，也可以扫描端口0。 对于IP协议扫描(-sO)，该选项指定您希望扫描的协议号 (0-255)。\n当既扫描TCP端口又扫描UDP端口时，您可以通过在端口号前加上T: 或者U:指定协议。 协议限定符一直有效您直到指定另一个。 例如，参数 -p U:53，111，137，T:21-25，80，139，8080 将扫描UDP 端口53，111，和137，同时扫描列出的TCP端口。注意，要既扫描 UDP又扫描TCP，您必须指定 -sU ，以及至少一个TCP扫描类型(如 -sS，-sF，或者 -sT)。如果没有给定协议限定符， 端口号会被加到所有协议列表。\n-F (快速 (有限的端口) 扫描)\n在nmap的nmap-services 文件中(对于-sO，是协议文件)指定您想要扫描的端口。 这比扫描所有65535个端口快得多。 因为该列表包含如此多的TCP端口(1200多)，这和默认的TCP扫描 scan (大约1600个端口)速度差别不是很大。如果您用–datadir选项指定您自己的 小小的nmap-services文件 ，差别会很惊人。\n-r (不要按随机顺序扫描端口)\n默认情况下，Nmap按随机顺序扫描端口 (除了出于效率的考虑，常用的端口前移)。这种随机化通常都是受欢迎的， 但您也可以指定-r来顺序端口扫描。\n服务和版本探测把Nmap指向一个远程机器，它可能告诉您 端口25&#x2F;tcp，80&#x2F;tcp，和53&#x2F;udp是开放的。使用包含大约2,200个著名的服务的 nmap-services数据库， Nmap可以报告那些端口可能分别对应于一个邮件服务器 (SMTP)，web服务器(HTTP)，和域名服务器(DNS)。 这种查询通常是正确的 – 事实上，绝大多数在TCP端口25监听的守护进程是邮件 服务器。然而，您不应该把赌注押在这上面! 人们完全可以在一些奇怪的端口上运行服务。\n即使Nmap是对的，假设运行服务的确实是 SMTP，HTTP和DNS，那也不是特别多的信息。 当为您的公司或者客户作安全评估(或者甚至简单的网络明细清单)时， 您确实想知道正在运行什么邮件和域名服务器以及它们的版本。 有一个精确的版本号对了解服务器有什么漏洞有巨大帮助。 版本探测可以帮您获得该信息。\n在用某种其它类型的扫描方法发现TCP 和&#x2F;或者UDP端口后， 版本探测会询问这些端口，确定到底什么服务正在运行。 nmap-service-probes 数据库包含查询不同服务的探测报文 和解析识别响应的匹配表达式。 Nmap试图确定服务协议 (如 ftp，ssh，telnet，http)，应用程序名(如ISC Bind，Apache httpd，Solaris telnetd)，版本号， 主机名，设备类型(如 打印机，路由器)，操作系统家族 (如Windows，Linux)以及其它的细节，如 如是否可以连接X server，SSH协议版本 ，或者KaZaA用户名)。当然，并非所有服务都提供所有这些信息。 如果Nmap被编译成支持OpenSSL， 它将连接到SSL服务器，推测什么服务在加密层后面监听。 当发现RPC服务时， Nmap RPC grinder (-sR)会自动被用于确定RPC程序和它的版本号。 如果在扫描某个UDP端口后仍然无法确定该端口是开放的还是被过滤的，那么该端口状态就 被标记为open|filtered。 版本探测将试图从这些端口引发一个响应(就像它对开放端口做的一样)， 如果成功，就把状态改为开放。 open|filtered TCP端口用同样的方法对待。 注意Nmap -A选项在其它情况下打开版本探测。 有一篇关于版本探测的原理，使用和定制的文章在http://www.insecure.org/nmap/vscan/。\n当Nmap从某个服务收到响应，但不能在数据库中找到匹配时， 它就打印一个特殊的fingerprint和一个URL给您提交，如果您确实知道什么服务运行在端口。 请花两分钟提交您的发现，让每个人受益。由于这些提交， Nmap有350种以上协议如smtp，ftp，http等的大约3，000条模式匹配。\n用下列的选项打开和控制版本探测：\n-sV (版本探测)\n打开版本探测。 您也可以用-A同时打开操作系统探测和版本探测。\n–allports (不为版本探测排除任何端口)\n默认情况下，Nmap版本探测会跳过9100 TCP端口，因为一些打印机简单地打印送到该端口的 任何数据，这回导致数十页HTTP get请求，二进制 SSL会话请求等等被打印出来。这一行为可以通过修改或删除nmap-service-probes 中的Exclude指示符改变， 您也可以不理会任何Exclude指示符，指定–allports扫描所有端口\n–version-intensity (设置 版本扫描强度)\n当进行版本扫描(-sV)时，nmap发送一系列探测报文 ，每个报文都被赋予一个1到9之间的值。 被赋予较低值的探测报文对大范围的常见服务有效，而被赋予较高值的报文 一般没什么用。强度水平说明了应该使用哪些探测报文。数值越高， 服务越有可能被正确识别。 然而，高强度扫描花更多时间。强度值必须在0和9之间。 默认是7。当探测报文通过nmap-service-probes ports指示符 注册到目标端口时，无论什么强度水平，探测报文都会被尝试。这保证了DNS 探测将永远在任何开放的53端口尝试， SSL探测将在443端口尝试，等等。\n–version-light (打开轻量级模式)\n这是 –version-intensity 2的方便的别名。轻量级模式使 版本扫描快许多，但它识别服务的可能性也略微小一点。\n–version-all (尝试每个探测)\n–version-intensity 9的别名， 保证对每个端口尝试每个探测报文。\n–version-trace (跟踪版本扫描活动)\n这导致Nmap打印出详细的关于正在进行的扫描的调试信息。 它是您用–packet-trace所得到的信息的子集。\n-sR (RPC扫描)\n这种方法和许多端口扫描方法联合使用。 它对所有被发现开放的TCP&#x2F;UDP端口执行SunRPC程序NULL命令，来试图 确定它们是否RPC端口，如果是， 是什么程序和版本号。因此您可以有效地获得和rpcinfo -p一样的信息， 即使目标的端口映射在防火墙后面(或者被TCP包装器保护)。Decoys目前不能和RPC scan一起工作。 这作为版本扫描(-sV)的一部分自动打开。 由于版本探测包括它并且全面得多，-sR很少被需要。\n操作系统探测Nmap最著名的功能之一是用TCP&#x2F;IP协议栈fingerprinting进行远程操作系统探测。 Nmap发送一系列TCP和UDP报文到远程主机，检查响应中的每一个比特。 在进行一打测试如TCP ISN采样，TCP选项支持和排序，IPID采样，和初始窗口大小检查之后， Nmap把结果和数据库nmap-os-fingerprints中超过 1500个已知的操作系统的fingerprints进行比较，如果有匹配，就打印出操作系统的详细信息。 每个fingerprint包括一个自由格式的关于OS的描述文本， 和一个分类信息，它提供供应商名称(如Sun)，下面的操作系统(如Solaris)，OS版本(如10)， 和设备类型(通用设备，路由器，switch，游戏控制台， 等)。\n如果Nmap不能猜出操作系统，并且有些好的已知条件(如 至少发现了一个开放端口和一个关闭端口)，Nmap会提供一个 URL，如果您确知运行的操作系统，您可以把fingerprint提交到那个URL。 这样您就扩大了Nmap的操作系统知识库，从而让每个Nmap用户都受益。\n操作系统检测可以进行其它一些测试，这些测试可以利用处理 过程中收集到的信息。例如运行时间检测，使用TCP时间戳选项(RFC 1323) 来估计主机上次重启的时间，这仅适用于提供这类信息的主机。另一种 是TCP序列号预测分类，用于测试针对远程主机建立一个伪造的TCP连接 的可能难度。这对于利用基于源IP地址的可信关系(rlogin，防火墙过滤等) 或者隐含源地址的攻击非常重要。这一类哄骗攻击现在很少见，但一些 主机仍然存在这方面的漏洞。实际的难度值基于统计采样，因此可能会有 一些波动。通常采用英国的分类较好，如“worthy challenge”或者 “trivial joke”。在详细模式(-v)下只以 普通的方式输出，如果同时使用-O，还报告IPID序列产生号。 很多主机的序列号是“增加”类别，即在每个发送包的IP头中 增加ID域值， 这对一些先进的信息收集和哄骗攻击来说是个漏洞。\nhttps://nmap.org/book/osdetect.html文档使用多种语言描述了版本检测的方式、使用和定制。\n采用下列选项启用和控制操作系统检测:\n-O (启用操作系统检测)\n也可以使用-A来同时启用操作系统检测和版本检测。\n–osscan-limit (针对指定的目标进行操作系统检测)\n如果发现一个打开和关闭的TCP端口时，操作系统检测会更有效。 采用这个选项，Nmap只对满足这个条件的主机进行操作系统检测，这样可以 节约时间，特别在使用-P0扫描多个主机时。这个选项仅在使用 -O或-A 进行操作系统检测时起作用。\n–osscan-guess; –fuzzy (推测操作系统检测结果)\n当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认 进行这种匹配，使用上述任一个选项使得Nmap的推测更加有效。\n时间和性能Nmap开发的最高优先级是性能。在本地网络对一个主机的默认扫描(nmap )需要1&#x2F;5秒。而仅仅眨眼的 时间，就需要扫描上万甚至几十万的主机。此外，一些特定的扫描选项会明显增 加扫描时间，如UDP扫描和版本检测。同样，防火墙配置以及特殊的响应速度限制也会 增加时间。Nmap使用了并行算法和许多先进的算法来加速扫描，用户对Nmap如何 工作有最终的控制权。高级用户可以仔细地调整Nmap命令，在满足时间要求的同时获得他们所关心的信息。\n改善扫描时间的技术有：忽略非关键的检测、升级最新版本的Nmap(性能增强不断改善)。 优化时间参数也会带来实质性的变化，这些参数如下。\n–min-hostgroup ; –max-hostgroup (调整并行扫描组的大小)\nNmap具有并行扫描多主机端口或版本的能力，Nmap将多个目标IP地址 空间分成组，然后在同一时间对一个组进行扫描。通常，大的组更有效。缺 点是只有当整个组扫描结束后才会提供主机的扫描结果。如果组的大小定义 为50，则只有当前50个主机扫描结束后才能得到报告(详细模式中的补充信息 除外)。\n默认方式下，Nmap采取折衷的方法。开始扫描时的组较小， 最小为5，这样便于尽快产生结果；随后增长组的大小，最大为1024。确切的 大小依赖于所给定的选项。为保证效率，针对UDP或少量端口的TCP扫描，Nmap 使用大的组。\n–max-hostgroup选项用于说明使用最大的组，Nmap不会超出这个大小。–min-hostgroup选项说明最小的组，Nmap 会保持组大于这个值。如果在指定的接口上没有足够的目标主机来满足所 指定的最小值，Nmap可能会采用比所指定的值小的组。这两个参数虽然很少使用， 但都用于保持组的大小在一个指定的范围之内。\n这些选项的主要用途是说明一个最小组的大小，使得整个扫描更加快速。通常 选择256来扫描C类网段。对于端口数较多的扫描，超出该值没有意义。对于 端口数较少的扫描，2048或更大的组大小是有帮助的。\n–min-parallelism ; –max-parallelism (调整探测报文的并行度)\n这些选项控制用于主机组的探测报文数量，可用于端口扫描和主机发现。默认状态下， Nmap基于网络性能计算一个理想的并行度，这个值经常改变。如果报文被丢弃， Nmap降低速度，探测报文数量减少。随着网络性能的改善，理想的探测报文数量会缓慢增加。 这些选项确定这个变量的大小范围。默认状态下，当网络不可靠时，理想的并行度值 可能为1，在好的条件下，可能会增长至几百。\n最常见的应用是–min-parallelism值大于1，以加快 性能不佳的主机或网络的扫描。这个选项具有风险，如果过高则影响准确度，同时 也会降低Nmap基于网络条件动态控制并行度的能力。这个值设为10较为合适， 这个值的调整往往作为最后的手段。\n–max-parallelism选项通常设为1，以防止Nmap在同一时间 向主机发送多个探测报文，和选择–scan-delay同时使用非常有用，虽然 这个选项本身的用途已经很好。\n–min-rtt-timeout ， –max-rtt-timeout ， –initial-rtt-timeout (调整探测报文超时)\nNmap使用一个运行超时值来确定等待探测报文响应的时间，随后会放弃或重新 发送探测报文。Nmap基于上一个探测报文的响应时间来计算超时值，如果网络延迟比较显著 和不定，这个超时值会增加几秒。初始值的比较保守(高)，而当Nmap扫描无响应 的主机时，这个保守值会保持一段时间。\n这些选项以毫秒为单位，采用小的–max-rtt-timeout值，使 –initial-rtt-timeout值大于默认值可以明显减少扫描时间，特别 是对不能ping通的扫描(-P0)以及具有严格过滤的网络。如果使用太 小的值，使得很多探测报文超时从而重新发送，而此时可能响应消息正在发送，这使得整个扫描的时 间会增加。\n如果所有的主机都在本地网络，对于–max-rtt-timeout值来 说，100毫秒比较合适。如果存在路由，首先使用ICMP ping工具ping主机，或使用其 它报文工具如hpings，可以更好地穿透防火墙。查看大约10个包的最大往返时间，然后将 –initial-rtt-timeout设成这个时间的2倍，–max-rtt-timeout 可设成这个时间值的3倍或4倍。通常，不管ping的时间是多少，最大的rtt值不得小于100ms， 不能超过1000ms。\n–min-rtt-timeout这个选项很少使用，当网络不可靠时， Nmap的默认值也显得过于强烈，这时这个选项可起作用。当网络看起来不可靠时，Nmap仅将 超时时间降至最小值，这个情况是不正常的，需要向nmap-dev邮件列表报告bug。\n–host-timeout (放弃低速目标主机)\n由于性能较差或不可靠的网络硬件或软件、带宽限制、严格的防火墙等原因， 一些主机需要很长的时间扫描。这些极少数的主机扫描往往占 据了大部分的扫描时间。因此，最好的办法是减少时间消耗并且忽略这些主机，使用 –host-timeout选项来说明等待的时间(毫秒)。通常使用1800000 来保证Nmap不会在单个主机上使用超过半小时的时间。需要注意的是，Nmap在这半小时中可以 同时扫描其它主机，因此并不是完全放弃扫描。超时的主机被忽略，因此也没有针对该主机的 端口表、操作系统检测或版本检测结果的输出。\n–scan-delay ; –max-scan-delay (调整探测报文的时间间隔)\n这个选项用于Nmap控制针对一个主机发送探测报文的等待时间(毫秒)，在带宽 控制的情况下这个选项非常有效。Solaris主机在响应UDP扫描探测报文报文时，每秒只发送一个ICMP消息，因此Nmap发送的很多数探测报文是浪费的。–scan-delay 设为1000，使Nmap低速运行。Nmap尝试检测带宽控制并相应地调整扫描的延迟，但 并不影响明确说明何种速度工作最佳。\n–scan-delay的另一个用途是躲闭基于阈值的入侵检测和预防 系统(IDS&#x2F;IPS)。\n-T &lt;Paranoid|Sneaky|Polite|Normal|Aggressive|Insane&gt; (设置时间模板)\n上述优化时间控制选项的功能很强大也很有效，但有些用户会被迷惑。此外， 往往选择合适参数的时间超过了所需优化的扫描时间。因此，Nmap提供了一些简单的 方法，使用6个时间模板，使用时采用-T选项及数字(0 - 5) 或名称。模板名称有paranoid (0)、sneaky (1)、polite (2)、normal(3)、 aggressive (4)和insane (5)。前两种模式用于IDS躲避，Polite模式降低了扫描 速度以使用更少的带宽和目标主机资源。默认模式为Normal，因此-T3 实际上是未做任何优化。Aggressive模式假设用户具有合适及可靠的网络从而加速 扫描。Insane模式假设用户具有特别快的网络或者愿意为获得速度而牺牲准确性。\n用户可以根据自己的需要选择不同的模板，由Nmap负责选择实际的时间值。 模板也会针对其它的优化控制选项进行速度微调。例如，-T4 针对TCP端口禁止动态扫描延迟超过10ms，-T5对应的值为5ms。 模板可以和优化调整控制选项组合使用，但模板必须首先指定，否则模板的标准值 会覆盖用户指定的值。建议在扫描可靠的网络时使用 -T4，即使 在自己要增加优化控制选项时也使用(在命令行的开始)，从而从这些额外的较小的优化 中获益。\n如果用于有足够的带宽或以太网连接，仍然建议使用-T4选项。 有些用户喜欢-T5选项，但这个过于强烈。有时用户考虑到避免使主机 崩溃或者希望更礼貌一些会采用-T2选项。他们并没意识到-T Polite选项是如何的慢，这种模式的扫描比默认方式实际上要多花10倍的时间。默认时间 选项(-T3)很少有主机崩溃和带宽问题，比较适合于谨慎的用户。不进行 版本检测比进行时间调整能更有效地解决这些问题。\n虽然-T0和-T1选项可能有助于避免IDS告警，但 在进行上千个主机或端口扫描时，会显著增加时间。对于这种长时间的扫描，宁可设定确切的时间 值，而不要去依赖封装的-T0和-T1选项。\nT0选项的主要影响是对于连续扫描，在一个时间只能扫描一个端口， 每个探测报文的发送间隔为5分钟。T1和T2选项比较类似， 探测报文间隔分别为15秒和0.4秒。T3是Nmap的默认选项，包含了并行扫描。 T4选项与 –max-rtt-timeout 1250 –initial-rtt-timeout 500 等价，最大TCP扫描延迟为10ms。T5等价于 –max-rtt-timeout 300 –min-rtt-timeout 50 –initial-rtt-timeout 250 –host-timeout 900000，最大TCP扫描延迟为5ms。\n防火墙&#x2F;IDS躲避和欺骗很多Internet先驱们设想了一个全球开放的网络，使用全局的IP 地址空间，使得任何两个节点之间都有虚拟连接。这使得主机间可以作为真 正的对等体，相互间提供服务和获取信息。人们可以在工作时访问家里所 有的系统、调节空调温度、为提前到来的客人开门。随后，这些全球连接的设想 受到了地址空间短缺和安全考虑的限制。在90年代早期，各种机构开始部 署防火墙来实现减少连接的目的，大型网络通过代理、NAT和包过滤器与未 过滤的Internet隔离。不受限的信息流被严格控制的可信通信通道信息流所替代。\n类似防火墙的网络隔离使得对网络的搜索更加困难，随意的搜 索变得不再简单。然而，Nmap提供了很多特性用于理解这些复杂的网 络，并且检验这些过滤器是否正常工作。此外，Nmap提供了绕过某些较弱的 防范机制的手段。检验网络安全状态最有效的方法之一是尝试哄骗网络，将 自己想象成一个攻击者，使用本节提供的技术来攻击自己的网络。如使用FTP bounce扫描、Idle扫描、分片攻击或尝试穿透自己的代理。\n除限止网络的行为外，使用入侵检测系统(IDS)的公司也不断增加。由于Nmap 常用于攻击前期的扫描，因此所有主流的IDS都包含了检测Nmap扫描的规则。 现在，这些产品变形为入侵预防系统(IPS)，可以主 动地阻止可疑的恶意行为。不幸的是，网络管理员和IDS厂商通过分析报文 来检测恶意行为是一个艰苦的工作，有耐心和技术的攻击者，在特定Nmap选项 的帮助下，常常可以不被IDS检测到。同时，管理员必须应付大量的误报结果， 正常的行为被误判而被改变或阻止。\n有时，人们建议Nmap不应该提供躲闭防火墙规则或哄骗IDS的功能， 这些功能可能会被攻击者滥用，然而管理员却可以利用这些功能来增强安全性。 实际上，攻击的方法仍可被攻击者利用，他们可以发现其它工具或Nmap的补丁程 序。同时，管理员发现攻击者的工作更加困难，相比较采取措施来预防执 行FTP Bounce攻击的工具而言，部署先进的、打过补丁的FTP服务器更 加有效。\nNmap不提供检测和破坏防火墙及IDS系统的魔弹(或Nmap选项)，它使用 的是技术和经验，这超出了本参考手册的范围，下面描述了相关的选项和 完成的工作。\n-f (报文分段); –mtu (使用指定的MTU)\n-f选项要求扫描时(包挺ping扫描)使用 小的IP包分段。其思路是将TCP头分段在几个包中，使得包过滤器、 IDS以及其它工具的检测更加困难。必须小心使用这个选项，有些系 统在处理这些小包时存在问题，例如旧的网络嗅探器Sniffit在接收 到第一个分段时会立刻出现分段错误。该选项使用一次，Nmap在IP 头后将包分成8个字节或更小。因此，一个20字节的TCP头会被分成3个 包，其中2个包分别有TCP头的8个字节，另1个包有TCP头的剩下4个字 节。当然，每个包都有一个IP头。再次使用-f可使用 16字节的分段(减少分段数量)。使用–mtu选项可 以自定义偏移的大小，使用时不需要-f，偏移量必须 是8的倍数。包过滤器和防火墙对所有的IP分段排队，如Linux核心中的 CONFIG-IP-ALWAYS-DEFRAG配置项，分段包不会直接使用。一些网络无法 承受这样所带来的性能冲击，会将这个配置禁止。其它禁止的原因有分段 包会通过不同的路由进入网络。一些源系统在内核中对发送的报文进行 分段，使用iptables连接跟踪模块的Linux就是一个例子。当使用类似Ethereal 的嗅探器时，扫描必须保证发送的报文要分段。如果主机操作系统会产 生问题，尝试使用–send-eth选项以避开IP层而直接 发送原始的以太网帧。\n-D &lt;decoy1 [，decoy2][，ME]，…&gt; (使用诱饵隐蔽扫描)\n为使诱饵扫描起作用，需要使远程主机认为是诱饵在扫描目标网络。 IDS可能会报个某个IP的5-10个端口扫描，但并不知道哪个IP在扫描以及 哪些不是诱饵。但这种方式可以通过路由跟踪、响应丢弃以及其它主动 机制在解决。这是一种常用的隐藏自身IP地址的有效技术。\n使用逗号分隔每个诱饵主机，也可用自己的真实IP作为诱饵，这时可使用 ME选项说明。如果在第6个位置或 更后的位置使用ME选项，一些常用 端口扫描检测器(如Solar Designer’s excellent scanlogd)就不会报告 这个真实IP。如果不使用ME选项，Nmap 将真实IP放在一个随机的位置\n注意，作为诱饵的主机须在工作状态，否则会导致目标主机的SYN洪水攻击。 如果在网络中只有一个主机在工作，那就很容易确定哪个主机在扫描。也可 使用IP地址代替主机名(被诱骗的网络就不可能在名字服务器日志中发现)。\n诱饵可用在初始的ping扫描(ICMP、SYN、ACK等)阶段或真正的端口扫描 阶段。诱饵也可以用于远程操作系统检测(-O)。在进行版 本检测或TCP连接扫描时，诱饵无效。\n使用过多的诱饵没有任何价值，反而导致扫描变慢并且结果不准确。 此外，一些ISP会过滤哄骗的报文，但很多对欺骗IP包没有任何限制。\n-S  (源地址欺骗)\n在某些情况下，Nmap可能无法确定你的源地址(如果这样，Nmap会给出 提示)。此时，使用-S选项并说明所需发送包的接口IP地址。\n这个标志的另一个用处是哄骗性的扫描，使得目标认为是另 一个地址在进行扫描。可以想象某一个竞争对手在不断扫描某个公司！ -e选项常在这种情况下使用，也可采用-P0选项。\n-e (使用指定的接口)\n告诉Nmap使用哪个接口发送和接收报文，Nmap可以进行自动检测， 如果检测不出会给出提示。\n–source-port ; -g (源端口欺骗)\n仅依赖于源端口号就信任数据流是一种常见的错误配置，这个问题非常 好理解。例如一个管理员部署了一个新的防火墙，但招来了很多用户的不满，因为 他们的应用停止工作了。可能是由于外部的UDP DNS服务器响应无法进入网络，而导致 DNS的崩溃。FTP是另一个常见的例子，在FTP传输时，远程服务器尝试和内部用 建立连接以传输数据。\n对这些问题有安全解决方案，通常是应用级代理或协议分析防火墙模块。 但也存在一些不安全的方案。注意到DNS响应来自于53端口，FTP连接 来自于20端口，很多管理员会掉入一个陷阱，即允许来自于这些端口的数据进入 网络。他们认为这些端口里不会有值得注意的攻击和漏洞利用。此外，管理员 或许认为这是一个短期的措施，直至他们采取更安全的方案。但他们忽视了安全的 升级。\n不仅仅是工作量过多的网络管理员掉入这种陷阱，很多产品本身也会有这类 不安全的隐患，甚至是微软的产品。Windows 2000和Windows XP中包含的IPsec过滤 器也包含了一些隐含规则，允许所有来自88端口(Kerberos)的TCP和UDP数据流。另 一个常见的例子是Zone Alarm个人防火墙到2.1.25版本仍然允许源端口53(DNS)或 67(DHCP)的UDP包进入。\nNmap提供了-g和–source-port选项(它们是 等价的)，用于利用上述弱点。只需要提供一个端口号，Nmap就可以从这些 端口发送数据。为使特定的操作系统正常工作，Nmap必须使用不同的端口号。 DNS请求会忽略–source-port选项，这是因为Nmap依靠系 统库来处理。大部分TCP扫描，包括SYN扫描，可以完全支持这些选项，UDP扫 描同样如此。\n–data-length (发送报文时附加随机数据)\n正常情况下，Nmap发送最少的报文，只含一个包头。因此TCP包通常 是40字节，ICMP ECHO请求只有28字节。这个选项告诉Nmap在发送的报文上 附加指定数量的随机字节。操作系统检测(-O)包不受影响， 但大部分ping和端口扫描包受影响，这会使处理变慢，但对扫描的影响较小。\n–ttl (设置IP time-to-live域)\n设置IPv4报文的time-to-live域为指定的值。\n–randomize-hosts (对目标主机的顺序随机排列)\n告诉Nmap在扫描主机前对每个组中的主机随机排列，最多可达 8096个主机。这会使得扫描针对不同的网络监控系统来说变得不是很 明显，特别是配合值较小的时间选项时更有效。如果需要对一个较大 的组进行随机排列，需要增大nmap.h文件中 PING-GROUP-SZ的值，并重新编译。另一种方法是使用列表扫描 (-sL -n -oN )，产生目标IP的列表， 使用Perl脚本进行随机化，然后使用-iL提供给Nmap。\n–spoof-mac &lt;mac address，prefix，or vendor name&gt; (MAC地址欺骗)\n要求Nmap在发送原以太网帧时使用指定的MAC地址，这个选项隐含了 –send-eth选项，以保证Nmap真正发送以太网包。MAC地址有几 种格式。如果简单地使用字符串“0”，Nmap选择一个完全随机的MAC 地址。如果给定的字符品是一个16进制偶数(使用:分隔)，Nmap将使用这个MAC地址。 如果是小于12的16进制数字，Nmap会随机填充剩下的6个字节。如果参数不是0或16进 制字符串，Nmap将通过nmap-mac-prefixes查找 厂商的名称(大小写区分)，如果找到匹配，Nmap将使用厂商的OUI(3字节前缀)，然后 随机填充剩余的3个节字。正确的–spoof-mac参数有， Apple， 0，01:02:03:04:05:06， deadbeefcafe，0020F2和Cisco。\n输出任何安全工具只有在输出结果时才是有价值的，如果没有通过组织和易于理解的方式来表达，复杂的测试和算法几乎没有意义。Nmap提供了一些方式供用户和其它软件使用，实际上，没有一种方式可以使所有人满意。 因此Nmap提供了一些格式，包含了方便直接查看的交互方式和方便软件处理的XML格式。\n除了提供输出格式外，Nmap还提供了选项来控制输出的细节以及调试 信息。输出内容可发送给标准输出或命名文件，可以追加或覆盖。输出文件还可 被用于继续中断的扫描。\nNmap提供5种不同的输出格式。默认的方式是interactive output， 发送给标准输出(stdout)。normal output方式类似于 interactive，但显示较少的运行时间信息 和告警信息，这是由于这些信息是在扫描完全结束后用于分析，而不是交互式的。\nXML输出是最重要的输出类型，可被转换成HTML，对于程序处理非常方便， 如用于Nmap图形用户接口或导入数据库。\n另两种输出类型比较简单，grepable output格式，在一行中包含目标主机最多的信息；sCRiPt KiDDi3 0utPUt 格式，用于考虑自己的用户 |&lt;-r4d。\n交互式输出是默认方式，没有相应的命令行选项，其它四种格式选项 使用相同的语法，采用一个参数，即存放结果的文件名。多种格式可同时 使用，但一种格式只能使用一次。例如，在标准输出用于查看的同时，可将结 果保存到XML文件用于程序分析，这时可以使用选项-oX myscan.xml -oN myscan.nmap。 为便于描述的简化，本章使用类似于myscan.xml的简单文件名， 建议采用更具有描述性的文件名。文件名的选择与个人喜好有关，建议增加 扫描日期以及一到两个单词来描述，并放置于一个目录中。\n在将结果输出到文件的同时，Nmap仍将结果发送给标准输出。例如， 命令nmap -oX myscan.xml target将 输出XML至myscan.xml，并在stdout 上打印相同的交互式结果，而此时-oX选项没有采用。可以 使用连字符作为选项来改变，这使得Nmap禁止交互式输出，而是将结果打印到 所指定的标准输出流中。因此，命令nmap -oX - target只 输出XML至标准输出stdout。严重错误仍然是输出到标准错误流stderr中。\n与其它Nmap参数不同，日志文件选项的空格(如-oX)和 文件名或连字符是必需的。如果省略了标记，例如-oG-或 -oXscan.xml，Nmap的向后兼容特点将建立 标准格式的输出文件，相应的文件名为G-和 Xscan.xml。\nNmap还提供了控制扫描细节以及输出文件的添加或覆盖的选项，这些选项如下所述。\nNmap输出格式：\n-oN (标准输出)\n要求将标准输出直接写入指定 的文件。如上所述，这个格式与交互式输出 略有不同。\n-oX (XML输出)\n要求XML输出直接写入指定 的文件。Nmap包含了一个文档类型定义(DTD)，使XML解析器有效地 进行XML输出。这主要是为了程序应用，同时也可以协助人工解释 Nmap的XML输出。DTD定义了合法的格式元素，列举可使用的属性和 值。最新的版本可在http://www.insecure.org/nmap/data/nmap.dtd获取。\nXML提供了可供软件解析的稳定格式输出，主要的计算机 语言都提供了免费的XML解析器，如C&#x2F;C++，Perl，Python和Java。 针对这些语言有一些捆绑代码用于处理Nmap的输出和特定的执行程序。 例如perl CPAN中的Nmap::Scanner和Nmap::Parser。 对几乎所有与Nmap有接口的主要应用来说，XML是首选的格式。\nXML输出引用了一个XSL样式表，用于格式化输出结果，类似于 HTML。最方便的方法是将XML输出加载到一个Web浏览器，如Firefox 或IE。由于nmap.xsl文件的绝对 路径，因此通常只能在运行了Nmap的机器上工作(或类似配置的机器)。 类似于任何支持Web机器的HTML文件，–stylesheet 选项可用于建立可移植的XML文件。\n-oS (ScRipT KIdd|3 oUTpuT)\n脚本小子输出类似于交互工具输出，这是一个事后处理，适合于 ‘l33t HaXXorZ， 由于原来全都是大写的Nmap输出。这个选项和脚本小子开了玩笑，看上去似乎是为了 “帮助他们”。\n-oG (Grep输出)\n这种方式最后介绍，因为不建议使用。XML输格式很强大，便于有经验 的用户使用。XML是一种标准，由许多解析器构成，而Grep输届更简化。XML 是可扩展的，以支持新发布的Nmap特点。使用Grep输出的目的是忽略这些 特点，因为没有足够的空间。\n然面，Grep输出仍然很常使用。它是一种简单格式，每行一个主机，可以 通过UNIX工具(如grep、awk、cut、sed、diff)和Perl方便地查找和分解。常可 用于在命令行上进行一次性测式。查找ssh端口打开或运行Sloaris的主机，只需 要一个简单的grep主机说明，使用通道并通过awk或cut命令打印所需的域。\nGrep输出可以包含注释(每行由#号开始)。每行由6个标记的域组成，由制表符及 冒号分隔。这些域有主机，端口， 协议，忽略状态， 操作系统，序列号， IPID和状态。\n这些域中最重要的是Ports，它提供 了所关注的端口的细节，端口项由逗号分隔。每个端口项代表一个所关注的端口， 每个子域由&#x2F;分隔。这些子域有：端口号， 状态，协议， 拥有者，服务， SunRPCinfo和版本信息。\n对于XML输出，本手册无法列举所有的格式，有关Nmap Grep输出的更详细信息可查阅http://www.unspecific.com/nmap-oG-output。\n-oA (输出至所有格式)\n为使用方便，利用-oA选项 可将扫描结果以标准格式、XML格式和Grep格式一次性输出。分别存放在 .nmap，.xml和 .gnmap文件中。也可以在文件名前 指定目录名，如在UNIX中，使用~&#x2F;nmaplogs&#x2F;foocorp&#x2F;， 在Window中，使用c:\\hacking\\sco on Windows。\n细节和调试选项\n-v (提高输出信息的详细度)\n通过提高详细度，Nmap可以输出扫描过程的更多信息。 输出发现的打开端口，若Nmap认为扫描需要更多时间会显示估计 的结束时间。这个选项使用两次，会提供更详细的信息。这个选 项使用两次以上不起作用。\n大部分的变化仅影响交互式输出，也有一些影响标准和脚本 小子输出。其它输出类型由机器处理，此时Nmap默认提供详细的信 息，不需要人工干预。然而，其它模式也会有一些变化，省略一些 细节可以减小输出大小。例如，Grep输出中的注释行提供所有扫描 端口列表，但由于这些信息过长，因此只能在细节模式中输出。\n-d [level] (提高或设置调试级别)\n当详细模式也不能为用户提供足够的数据时，使用调试可以得到更 多的信息。使用细节选项(-v)时，可启用命令行参数 (-d)，多次使用可提高调试级别。也可在-d 后面使用参数设置调试级别。例如，-d9设定级别9。这是 最高的级别，将会产生上千行的输出，除非只对很少的端口和目标进行简单扫描。\n如果Nmap因为Bug而挂起或者对Nmap的工作及原理有疑问，调试输出 非常有效。主要是开发人员用这个选项，调试行不具备自我解释的特点。 例如，Timeoutvals: srtt: -1 rttvar: -1 to: 1000000 delta 14987 &#x3D;&#x3D;&gt; srtt: 14987 rttvar: 14987 to: 100000。如果对某行输出不明白， 可以忽略、查看源代码或向开发列表(nmap-dev)求助。有些输出行会有自 我解释的特点，但随着调试级别的升高，会越来越含糊。\n–packet-trace (跟踪发送和接收的报文)\n要求Nmap打印发送和接收的每个报文的摘要，通常用于 调试，有助于新用户更好地理解Nmap的真正工作。为避免输出过 多的行，可以限制扫描的端口数，如-p20-30。 如果只需进行版本检测，使用–version-trace。\n–iflist (列举接口和路由)\n输出Nmap检测到的接口列表和系统路由，用于调试路由 问题或设备描述失误(如Nmap把PPP连接当作以太网对待)。\n其它输出选项：\n–append-output (在输出文件中添加)\n当使用文件作为输出格式，如-oX或-oN， 默认该文件被覆盖。如果希望文件保留现有内容，将结果添加在现 有文件后面，使用–append-output选项。所有指 定的输出文件都被添加。但对于XML(-oX)扫描输出 文件无效，无法正常解析，需要手工修改。\n–resume (继续中断的扫描)\n一些扩展的Nmap运行需要很长的时间 – 以天计算，这类扫描 往往不会结束。可以进行一些限制，禁止Nmap在工作时间运行，导致 网络中断、运行Nmap的主机计划或非计划地重启、或者Nmap自己中断。 运行Nmap的管理员可以因其它原因取消运行，按下ctrl-C 即可。从头开始启动扫描可能令人不快，幸运的是，如果标准扫描 (-oN)或Grep扫描(-oG)日志 被保留，用户可以要求Nmap恢复终止的扫描，只需要简单地使用选项 –resume并说明标准&#x2F;Grep扫描输出文件，不允许 使用其它参数，Nmap会解析输出文件并使用原来的格式输出。使用方式 如nmap –resume 。 Nmap将把新地结果添加到文件中，这种方式不支持XML输出格式，原因是 将两次运行结果合并至一个XML文件比较困难。\n–stylesheet (设置XSL样式表，转换XML输出)\nNmap提从了XSL样式表nmap.xsl，用于查看 或转换XML输出至HTML。XML输出包含了一个xml-stylesheet， 直接指向nmap.xml文件， 该文件由Nmap安装(或位于Windows当前工作目录)。在Web浏览器 中打开Nmap的XML输出时，将会在文件系统中寻找nmap.xsl文件， 并使用它输出结果。如果希望使用不同的样式表，将它作为 –stylesheet的参数，必段指明完整的路 径或URL，常见的调用方式是–stylesheet http://www.insecure.org/nmap/data/nmap.xsl。 这告诉浏览器从Insecire.Org中加载最新的样式表。这使得 没安装Nmap(和nmap.xsl) 的机器中可以方便地查看结果。因此，URL更方便使用，本地文件系统 的nmap.xsl用于默认方式。\n–no-stylesheet (忽略XML声明的XSL样式表)\n使用该选项禁止Nmap的XML输出关联任何XSL样式表。 xml-stylesheet指示被忽略。\n其它选项本节描述一些重要的(和并不重要)的选项，这些选项 不适合其它任何地方。\n-6 (启用IPv6扫描)\n从2002年起，Nmap提供对IPv6的一些主要特征的支持。ping扫描(TCP-only)、 连接扫描以及版本检测都支持IPv6。除增加-6选项外， 其它命令语法相同。当然，必须使用IPv6地址来替换主机名，如 3ffe:7501:4819:2000:210:f3ff:fe03:14d0。 除“所关注的端口”行的地址部分为IPv6地址。\nIPv6目前未在全球广泛采用，目前在一些国家(亚洲)应用较多， 一些高级操作系统支持IPv6。使用Nmap的IPv6功能，扫描的源和目 的都需要配置IPv6。如果ISP(大部分)不分配IPv6地址，Nmap可以采用 免费的隧道代理。一种较好的选择是BT Exact，位于https://tb.ipv6.btexact.com/。 此外，还有Hurricane Electric，位于http://ipv6tb.he.net/。6to4隧道是 另一种常用的免费方法。\n-A (激烈扫描模式选项)\n这个选项启用额外的高级和高强度选项，目前还未确定代表 的内容。目前，这个选项启用了操作系统检测(-O) 和版本扫描(-sV)，以后会增加更多的功能。 目的是启用一个全面的扫描选项集合，不需要用户记忆大量的 选项。这个选项仅仅启用功能，不包含用于可能所需要的 时间选项(如-T4)或细节选项(-v)。\n–datadir (说明用户Nmap数据文件位置)\nNmap在运行时从文件中获得特殊的数据，这些文件有 nmap-service-probes， nmap-services， nmap-protocols， nmap-rpc， nmap-mac-prefixes和 nmap-os-fingerprints。Nmap首先 在–datadir选项说明的目录中查找这些文件。 未找到的文件，将在BMAPDIR环境变量说明的目录中查找。 接下来是用于真正和有效UID的~&#x2F;.nmap 或Nmap可执行代码的位置(仅Win32)；然后是是编译位置， 如&#x2F;usr&#x2F;local&#x2F;share&#x2F;nmap 或&#x2F;usr&#x2F;share&#x2F;nmap。 Nmap查找的最后一个位置是当前目录。\n–send-eth (使用原以太网帧发送)\n要求Nmap在以太网(数据链路)层而不是IP(网络层)发送 报文。默认方式下，Nmap选择最适合其运行平台的方式，原套接 字(IP层)是UNIX主机最有效的方式，而以太网帧最适合Windows操作 系统，因为Microsoft禁用了原套接字支持。在UNIX中，如果没有其 它选择(如无以太网连接)，不管是否有该选项，Nmap都使用原IP包。\n–send-ip (在原IP层发送)\n要求Nmap通过原IP套接字发送报文，而不是低层的以 太网帧。这是–send-eth选项的补充。\n–privileged (假定用户具有全部权限)\n告诉Nmap假定其具有足够的权限进行源套接字包发送、 报文捕获和类似UNIX系统中根用户操作的权限。默认状态下， 如果由getuid()请求的类似操作不为0，Nmap将退出。 –privileged在具有Linux内核性能的类似 系统中使用非常有效，这些系统配置允许非特权用户可以进行 原报文扫描。需要明确的是，在其它选项之前使用这些需要权 限的选项(SYN扫描、操作系统检测等)。Nmap-PRIVILEGED变量 设置等价于–privileged选项。\n-V; –version (打印版本信息)\n打印Nmap版本号并退出。\n-h; –help (打印帮助摘要面)\n打印一个短的帮助屏幕，列出大部分常用的 命令选项，这个功能与不带参数运行Nmap是相同的。\n运行时交互Nmap目前还不具有这个功能，本节内容可能会增加或删除。\n在执行Nmap时，所有的键盘敲击都被记录。这使得用户可以与 程序交互而不需要终止或重启。特定的键可改变选项，其它键会输出 一个有关扫描的状态消息。约定如下，小写字母增加 打印量，大写字母减少打印量。\nv &#x2F; V 增加&#x2F;减少细节\nd &#x2F; D 提高&#x2F;降低调试级别\np &#x2F; P 打开&#x2F;关闭报文跟踪\n其它 打印的信息类似于：\nStats: 0:00:08 elapsed; 111 hosts completed (5 up)， 5 undergoing Service Scan\nService scan Timing: About 28.00% done; ETC: 16:18 (0:00:15 remaining)\n实例下面给出一些实例，简单的、复杂的到深奥的。为更具体，一 些例子使用了实际的IP地址和域名。在这些位置，可以使用你自己网络 的地址&#x2F;域名替换。注意，扫描其它网络不一定合法，一些网络管理员不愿看到 未申请过的扫描，会产生报怨。因此，先获得允许是最好的办法。\n如果是为了测试，scanme.nmap.org 允许被扫描。但仅允许使用Nmap扫描并禁止测试漏洞或进行DoS攻击。为 保证带宽，对该主机的扫描每天不要超过12次。如果这个免费扫描服务被 滥用，系统将崩溃而且Nmap将报告解析 指定的主机名&#x2F;IP地址失败：scanme.nmap.org。这些免 费扫描要求也适用于scanme2.nmap.org、 scanme3.nmap.org等等，虽然这些 主机目前还不存在。\nnmap -v scanme.nmap.org\n这个选项扫描主机scanme.nmap.org中 所有的保留TCP端口。选项-v启用细节模式。\nnmap -sS -O scanme.nmap.org&#x2F;24\n进行秘密SYN扫描，对象为主机Saznme所在的“C类”网段 的255台主机。同时尝试确定每台工作主机的操作系统类型。因为进行SYN扫描 和操作系统检测，这个扫描需要有根权限。\nnmap -sV -p 22，53，110，143，4564 198.116.0-255.1-127\n进行主机列举和TCP扫描，对象为B类188.116网段中255个8位子网。这 个测试用于确定系统是否运行了sshd、DNS、imapd或4564端口。如果这些端口 打开，将使用版本检测来确定哪种应用在运行。\nnmap -v -iR 100000 -P0 -p 80\n随机选择100000台主机扫描是否运行Web服务器(80端口)。由起始阶段 发送探测报文来确定主机是否工作非常浪费时间，而且只需探测主机的一个端口，因 此使用-P0禁止对主机列表。\nnmap -P0 -p80 -oX logs&#x2F;pb-port80scan.xml -oG logs&#x2F;pb-port80scan.gnmap 216.163.128.20&#x2F;20\n扫描4096个IP地址，查找Web服务器(不ping)，将结果以Grep和XML格式保存。\nhost -l company.com | cut -d -f 4 | nmap -v -iL\n进行DNS区域传输，以发现company.com中的主机，然后将IP地址提供给 Nmap。上述命令用于GNU&#x2F;Linux – 其它系统进行区域传输时有不同的命令。\nnmap nse脚本引擎Nmap是学习网络安全必备的一款工具，有着强大的信息收集能力。Nmap不仅仅是一个端口扫描器那么简单，它还有着一个强大的脚本引擎（NSE）可以通过编程来实现定制化。\n在nmap安装目录中,通常搜索路径为&#x2F;&#x2F;usr&#x2F;share&#x2F;nmap&#x2F;scripts目录存放着NSE脚本，而nselib目录存放各种库文件，通常使用–script来指定要使用的nmap脚本。比如：使用mysql-brute.nse这个脚本对目标地址进行mysql的口令爆破。命令：\nnmap --script&#x3D;mysql-brute  &lt;target&gt;,\n\n在Nmap的官方说明文档https://nmap.org/nsedoc/中有NSE脚本和库文件的详细使用说明。\nNSE编写demo文件:LUA语言基础打开任何一个NSE脚本或者是库文件，里面的代码功能通常由lua语言来实现。因此想要写自己的脚本或者库，前提是有一定的lua语言基础。lua是一个轻量化的脚本语言，有编程基础的同学学lua应该会比较轻松，在菜鸟教程花个把小时学习lua语言的基本使用，已经足够明白本篇的编程内容了。\nNSE脚本基本格式:一个完整的NSE脚本通常都有这么几个部分的代码字段：description 字段：本脚本的说明介绍。categories 字段：本脚本的分类。Nmap执行脚本除了指定单个脚本外，还可以指定某一类脚本，比如default类，我们没有使用–script参数时，默认会加载这一类的脚本。rule 字段：本脚本的执行规则，也即触发脚本执行的条件会在rule字段定义。一般执行规则是一个lua函数，返回值只有true和false两种。action字段：脚本执行的具体内容。rule字段返回true时会执行action字段定义的函数。\n-- 包含nselib中的包\nlocal shortport &#x3D; require &quot;shortport&quot;\n-- 描述\ndescription &#x3D; [[a demo nse file]]\nauthor &#x3D; &quot;reborn&quot;\nlicense &#x3D; &quot;Same as Nmap--See http:&#x2F;&#x2F;nmap.org&#x2F;book&#x2F;man-legal.html&quot;\ncategories &#x3D; &#123;&quot;default&quot;&#125;\n-- 在发现主机端口时,被调用\nportrule &#x3D; function( host, port )\n    return true\nend\n-- 当portrule返回true时action被执行\naction &#x3D; function(host, port)\nend\nNSE脚本的规则你可以发现上述rule字段是portrule，NSE脚本的执行规则是和nmap的扫描相结合的，两者执行的先后顺序目前有如下4种。\n\nprerule()：规则早于nmap的扫描，执行的顺序是先执行脚本，后nmap扫描。\nhostrule()：nmap完成了主机发现之后运行脚本。\nportrule()：nmap执行了端口扫描后运行脚本。\npostrule()：nmap完成所有的扫描后才执行脚本。\n\n编写简单的NSE脚本\n如：编写一个简单的脚本来探测目标是否开放了80端口，并且这个端口运行的是HTTP服务，如果是nmap输出“This is a WebServer”。那么在前面脚本demo代码的基础上，我们只需修改portrule函数的代码和让action函数来输出。代码逻辑先portrule判断条件是否成立：“目标是否开放了80端口，服务是否是HTTP”，是返回true不是返回false，代码实现：\nportrule &#x3D; function(host,port)\n    return port.protocol &#x3D;&#x3D; &quot;tcp&quot; and port.number &#x3D;&#x3D; 80 and port.service &#x3D;&#x3D;&quot;http&quot; and port.state &#x3D;&#x3D;&quot;open&quot;\nend\n\n如果返回true：执行action，输出“This is a WebServer”：\naction &#x3D; function(host, port)\nreturn &quot;This is a WebServer&quot;\nend\n\n完整的代码：\nlocal shortport &#x3D; require &quot;shortport&quot;\ndescription &#x3D; [[a http service detect test demo]]\n\nauthor &#x3D; &quot;reborn&quot;\nlicense &#x3D; &quot;Same as Nmap--See http:&#x2F;&#x2F;nmap.org&#x2F;book&#x2F;man-legal.html&quot;\ncategories &#x3D; &#123;&quot;default&quot;&#125;\n\nportrule &#x3D; function(host,port)\n    return port.protocol &#x3D;&#x3D; &quot;tcp&quot; and port.number &#x3D;&#x3D; 80 and port.service &#x3D;&#x3D;&quot;http&quot; and port.state &#x3D;&#x3D;&quot;open&quot;\nend\n\naction &#x3D; function(host, port)\nreturn &quot;This is a WebServer&quot;\nend\n\n将上述代码命名为http-detect-test.nse保存在scripts目录下，然后执行nmap --script-updatedb更新nse脚本。\n接着在nmap中执行http-detect-test.nse这个脚本：nmap -p 80 10.10.10.39 --script http-detect-test\nPORT   STATE SERVICE\n\n80&#x2F;tcp open  http\n\n|_http-detect-test: This is a WebServer\n\n另外，如果执行过程，脚本有错误，可以在nmap命令中加入-d来获得调试中的数据。其中-d后面可以添加数字1 2 3 4代表详细级别,可以看到程序的每一步执行过程;\nNSE中的API你可能会对上面脚本中portrule规则判断扫描结果的代码心存疑惑，实际上那个位置调用了nmap扫描结果的API。\nNmap中的API的核心功能就是向脚本提供关于主机和端口的信息，例如名字解析、主机和端口的状态、服务发现等内容。此处介绍一部分常用的的API调用和代码demo供给大家参考使用。\n两个Lua table 类型的参数\n\nhost table\nport table\n\nhost table1. host.os获取nmap扫描到的操作系统信息。\n\nvendor 供应商\nosfamily 所属系列\nosgen 具体型号\ntype 设备类型\nCPE\n\nlocal shortport &#x3D; require &quot;shortport&quot;\n\ndescription &#x3D; [[test api]]\n\nauthor &#x3D; &quot;reborn&quot;\nlicense &#x3D; &quot;Same as Nmap--See http:&#x2F;&#x2F;nmap.org&#x2F;book&#x2F;man-legal.html&quot;\ncategories &#x3D; &#123;&quot;default&quot;&#125;\n\nhostrule &#x3D; function( host, port )\n    return true\nend\n\naction &#x3D; function(host, port)\n    return host.os\nend\n\n扫描命令：nmap -O 10.10.10.39 --script my-api-test\nHost script results:\n| my-api-test:\n|\n|     name: Linux 2.6.13 - 2.6.32\n|     classes:\n|\n|         type: general purpose\n|         vendor: Linux\n|         osgen: 2.6.X\n|         osfamily: Linux\n|         cpe:\n|_          cpe:&#x2F;o:linux:linux_kernel:2.6\n\n2. host.ip将host.os那段脚本的第14行改为return host.ip。\n扫描命令：nmap www.baidu.com --script my-api-test\nHost script results:\n|_my-api-test: 14.215.177.38\n\n3.host.name将host.os那段脚本的第14行改为return host.name。\n扫描命令：nmap www.baidu.com --script my-api-test\nHost script results:\n|_my-api-test: 14.215.177.38\n\n4.host.targetname目标主机在命令行的名字。\n5.host.directly_connected表示目标计算机是否与我们同在一个子网。\n6.host.name将host.os那段脚本的第14行改为return host.mac_addr。\n扫描命令：nmap 10.10.10.39 --script my-api-test 必须是同一子网的设备这个命令才有效。\nHost script results:\n|_my-api-test: \\x00\\x0C)f\\xF4\\xDF\n\n7.host.traceroute将host.os那段脚本的第14行改为return host.traceroute。\n扫描命令：nmap --traceroute www.baidu.com --script my-api-test\nHost script results:\n| my-api-test:\n|\n|     times:\n|       srtt: 0.002\n|     ip: 192.168.1.1\n|\n|     times:\n|       srtt: 0.004\n|     ip: 192.168.12.1\n|\n|     times:\n|       srtt: 0.002\n|     ip: 192.168.200.1\n|\n|     name: 78.228.84.110.broad.fz.fj.dynamic.163data.com.cn\n|     ip: 110.84.228.78\n|     times:\n|       srtt: 0.002\n|\n|     times:\n|       srtt: 0.017\n|     ip: 113.96.4.70\n|\n|     times:\n|       srtt: 0.017\n|_    ip: 14.215.177.39\n\nport table1. port.numberlocal shortport &#x3D; require &quot;shortport&quot;\n\ndescription &#x3D; [[test api]]\n\nauthor &#x3D; &quot;reborn&quot;\nlicense &#x3D; &quot;Same as Nmap--See http:&#x2F;&#x2F;nmap.org&#x2F;book&#x2F;man-legal.html&quot;\ncategories &#x3D; &#123;&quot;default&quot;&#125;\nportrule &#x3D; function( host, port )\n    return true\nend\n\naction &#x3D; function(host, port)\n    return port.number\nend\n\n扫描命令：nmap www.baidu.com --script my-api-test\nPORT    STATE SERVICE\n80&#x2F;tcp  open  http\n|_my-api-test: 80\n443&#x2F;tcp open  https\n|_my-api-test: 443\n\n2. port.protocolPORT    STATE SERVICE\n80&#x2F;tcp  open  http\n|_my-api-test: tcp\n443&#x2F;tcp open  https\n|_my-api-test: tcp\n\n3. port.servicePORT    STATE SERVICE\n80&#x2F;tcp  open  http\n|_my-api-test: http\n443&#x2F;tcp open  https\n|_my-api-test: https\n\n4. port.versionPORT    STATE SERVICE\n80&#x2F;tcp  open  http\n| my-api-test:\n|   name_confidence: 3.0\n|   service_tunnel: none\n|   name: http\n|   service_dtype: table\n|_  cpe:\n443&#x2F;tcp open  https\n| my-api-test:\n|   name_confidence: 3.0\n|   service_tunnel: none\n|   name: https\n|   service_dtype: table\n|_  cpe:\n\n5.port.statePORT    STATE SERVICE\n80&#x2F;tcp  open  http\n|_my-api-test: open\n443&#x2F;tcp open  https\n|_my-api-test: open","slug":"Nmap扫描基础","date":"2022-11-16T14:30:24.497Z","categories_index":"学习笔记","tags_index":"nmap","author_index":"Abyssaler"},{"id":"062bc79d0208b49717a6cfcae1c08e22","title":"渗透测试之信息收集（持续更新）","content":"信息收集–渗透测试的灵魂信息收集需要收集哪些内容？为什么要收集这些？1.whois信息什么是whois？​\t whois 指的是域名注册时留下的信息，比如留下管理员的名字、电话号码、邮箱\n为什么要收集whois?​\t域名注册人可能就是网站管理员，可以尝试社工、套路，查询是不是注册了其他域名扩大功击范围。\n如何收集whois信息？\n\n\n\n\n\n\n\n\n\nhttp://whois.chinaz.com/ (站长之家)\nhttps://whois.com \nhttps://www.bugku.com/mima/\n如图,通过域名查询,发现了注册人的邮箱,通过这个邮箱我们可以进行进一步的社工等\n\n在搜索引擎搜索此邮箱\n\n没有发现有价值的信息,但可以确定查询目标的qq号,以后对该目标生成社工字典时也可以参考,同时还能借助qq号发起社工\n\n\n\n\n\n\n\n\n\nhttps://www.bugku.com/mima/ (社工密码生成)\n进一步查询企业的名字\n\n通过各种企业查询类app:\n\n\n\n\n\n\n\n\n\nhttps://www.qcc.com/\nhttps://www.qixin.com/\nhttps://aiqicha.baidu.com/\n2.子域名什么是子域名?顶级域名下的二级域名或者三级甚至更多级的域名都属于子域名，有一些直接ip访问的WEB站也归结于子域名收集范围\nxxx.com（顶级域名）\nxxx.xxx.com（二级域名）\nxxx.xxx.xxx.com（三级域名）\n为什么要收集?子域名可以扩大攻击范围，同一个域名下的二级域名都属于相同资产，一般而言都有相关的联系\n\n\n\n\n\n\n\n\n\n查子域名的网站\nhttps://chaziyu.com/ \nhttps://www.ipbuf.com/Subdomain.html\nhttps://www.dnsgrep.cn/\n\n其他工具\nlayer\n如何收集子域名？\nGoogle语法（见后面）\n网页蜘蛛爬虫\nDNS爆破法\n\n3.端口收集为什么要探测端口？ 有些危险端口开放了我们就可以尝试入侵，例如 445|3306|22|1433|6379 可以尝试爆破或者是使用某些端口存在漏洞的服务。而且有可能一台服务器上面不同端口代表着不同的Web网站\n如何探测端口？ 主要是Nmap扫描工具\n\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/weixin_42248871/article/details/120981520\nhttps://xbxaq.com/doc/99/\n或者站内搜索nmap\n","slug":"渗透测试之信息搜集（持续更新）","date":"2022-11-16T13:20:15.829Z","categories_index":"学习笔记","tags_index":"信息收集","author_index":"Abyssaler"},{"id":"3da5b418046b7895ffe91ec3b92eec28","title":"sql学习笔记","content":"声明：这篇笔记是引用来方便自己学习的，原出处见此：\n\n\n\n\n\n\n\n\n\nhttps://gitee.com/yueliu2345/mysql\nmysql0.数据库常见概念0.1概念数据库：        英文单词DataBase，简称DB。按照一定格式存储数据的一些文件的组合。        顾名思义：存储数据的仓库，实际上就是一堆文件。这些文件中存储了        具有特定格式的数据。\n数据库管理系统：    DataBaseManagement，简称DBMS。    数据库管理系统是专门用来管理数据库中数据的，数据库管理系统可以    对数据库当中的数据进行增删改查。\n常见的数据库管理系统：    MySQL、Oracle、MS SqlServer、DB2、sybase等….\nSQL：结构化查询语言    程序员需要学习SQL语句，程序员通过编写SQL语句，然后DBMS负责执行SQL    语句，最终来完成数据库中数据的增删改查操作。\nSQL是一套标准，程序员主要学习的就是SQL语句，这个SQL在mysql中可以使用，同时在Oracle中也可以使用，在DB2中也可以使用。\n三者之间的关系？    DBMS–执行–&gt; SQL –操作–&gt; DB\n先安装数据库管理系统MySQL，然后学习SQL语句怎么写，编写SQL语句之后，DBMS对SQL语句进行执行，最终来完成数据库的数据管理。\n0.2 SQL语句分类DQL：        数据查询语言（凡是带有select关键字的都是查询语句）        select…\t\t\nDML：            数据操作语言（凡是对表当中的数据进行增删改的都是DML）            insert delete update            insert 增            delete 删            update 改\n​\t\t这个主要是操作表中的数据data。\nDDL：        数据定义语言        凡是带有create、drop、alter的都是DDL。        DDL主要操作的是表的结构。不是表中的数据。        create：新建，等同于增        drop：删除        alter：修改        这个增删改和DML不同，这个主要是对表结构进行操作。\nTCL：    不是王牌电视。    是事务控制语言    包括：        事务提交：commit;        事务回滚：rollback;\nDCL：    是数据控制语言。    例如：授权grant、撤销权限revoke….\n0.3MYSQL中的数据类型varchar(最长255)        可变长度的字符串，比较智能，节省空间。会根据实际的数据长度动态分配空间。\n​\t\t优点：节省空间​\t\t缺点：需要动态分配空间，速度慢。\nchar(最长255)        定长字符串，不管实际的数据长度是多少，分配固定长度的空间去存储数据。        使用不恰当的时候，可能会导致空间的浪费。\n​\t\t优点：不需要动态分配空间，速度快。​\t\t缺点：使用不当可能会导致空间的浪费。\n​\t\tvarchar和char我们应该怎么选择？​\t\t\t性别字段你选什么？因为性别是固定长度的字符串，所以选择char。​\t\t\t姓名字段你选什么？每一个人的名字长度不同，所以选择varchar。\nint(最长11)\n​\t\t数字中的整数型。等同于java的int。\nbigint        数字中的长整型。等同于java中的long。\nfloat        单精度浮点型数据\ndouble        双精度浮点型数据\ndate        短日期类型\ndatetime        长日期类型\nclob        字符大对象        最多可以存储4G的字符串。        比如：存储一篇文章，存储一个说明。        超过255个字符的都要采用CLOB字符大对象来存储。        Character Large OBject:CLOB\nblob        二进制大对象        Binary Large OBject        专门用来存储图片、声音、视频等流媒体数据。        往BLOB类型的字段上插入数据的时候，例如插入一个图片、视频等，        你需要使用IO流才行。\nt_movie 电影表（专门存储电影信息的）\n编号no(bigint)\t名字name(varchar)\t\t故事情节history(clob)\t\n上映日期playtime(date)\t\t时长time(double)\t\t海报image(blob)\n类型type(char)\t\t\t\t\t\t\t\n\n0.4SQL脚本的执行xxxx.sql这种文件被称为sql脚本文件。        sql脚本文件中编写了大量的sql语句。        我们执行sql脚本文件的时候，该文件中所有的sql语句会全部执行！        批量的执行SQL语句，可以使用sql脚本文件。\n\nmysql&gt; source D:\\course\\03-MySQL\\document\\vip.sql你在实际的工作中，第一天到了公司，项目经理会给你一个xxx.sql文件，你执行这个脚本文件，你电脑上的数据库数据就有了！\n\n0.5数据库和表的导入导出数据导出？\n\t注意：在windows的dos命令窗口中：\n\t\tmysqldump bjpowernode&gt;D:\\bjpowernode.sql -uroot -p123456\n\t可以导出指定的表吗？\n\t\tmysqldump bjpowernode emp&gt;D:\\bjpowernode.sql -uroot -p123456\n\n数据导入？\n\t注意：需要先登录到mysql数据库服务器上。\n\t然后创建数据库：create database bjpowernode;\n\t使用数据库：use bjpowernode\n\t然后初始化数据库：source D:\\bjpowernode.sql\n\n1.数据库操作show databases; \t查看mysql中有哪些数据库\n use test;\t表示正在使用一个名字叫做test的数据库。\n create database db01;\t创建数据库\nshow tables; \t查看某个数据库下有哪些表\n select version();\t查看mysql数据库的版本号\nselect database();\t查看当前使用的是哪个数据库\n\\c\t用来终止一条命令的输入。\n2.建表操作2.1创建一个表create学号、姓名、年龄、性别、邮箱地址\n\tcreate table t_student(\n\t\tno int,\n\t\tname varchar(32),\n\t\tsex char(1),\n\t\tage int(3),\n\t\temail varchar(255)\n\t);\n\n2.2删除一个表dropdrop table t_student; &#x2F;&#x2F; 当这张表不存在的时候会报错！\n&#x2F;&#x2F; 如果这张表存在的话，删除\ndrop table if exists t_student;\n\n\n对表结构的修改需要使用：alter属于DDL语句\ndesc t_student    查看表结构\n\n2.3插入数据insert\ninsert into 表名(字段名1,字段名2,字段名3…) values(值1,值2,值3);\n\ninsert into t_student(no,name,sex,age,email)\n\tvalues(1,&#39;zhangsan&#39;,&#39;m&#39;,20,&#39;zhangsan@123.com&#39;);\ninsert into t_student(email,name,sex,age,no)\n\tvalues(&#39;lisi@123.com&#39;,&#39;lisi&#39;,&#39;f&#39;,20,2);\ninsert into t_student(no) values(3);\n&#x2F;&#x2F;省略字段名\ninsert into t_student values(2, &#39;lisi&#39;, &#39;f&#39;, 20, &#39;lisi@123.com&#39;);\n\n\ninsert语句但凡是执行成功了，那么必然会多一条记录。没有给其它字段指定值的话，默认值是NULL。\n\n一次插入多条数据\n\ninsert into t_user(字段名1,字段名2) values(),(),(),();\n\ninsert into t_user(id,name,birth,create_time) values\n\t\t(1,&#39;zs&#39;,&#39;1980-10-11&#39;,now()), \n\t\t(2,&#39;lisi&#39;,&#39;1981-10-11&#39;,now()),\n\t\t(3,&#39;wangwu&#39;,&#39;1982-10-11&#39;,now());\n\n\n\n2.4修改数据update\nupdate 表名 set 字段名1&#x3D;值1,字段名2&#x3D;值2,字段名3&#x3D;值3… where 条件;\n\n没有条件限制会导致所有数据全部更新。\n\n\nupdate t_user set name &#x3D; &#39;jack&#39;, birth &#x3D; &#39;2000-10-11&#39; where id &#x3D; 2;\n\nupdate t_user set name &#x3D; &#39;jack&#39;, birth &#x3D; &#39;2000-10-11&#39;, create_time &#x3D; now() where id &#x3D; 2;\n\n2.5删除数据delete语句删除数据的原理？（delete属于DML语句！！！）\n\n表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放！！！\n这种删除缺点是：删除效率比较低。\n这种删除优点是：支持回滚，后悔了可以再恢复数据！！！\n\ntruncate语句删除数据的原理？\n\n这种删除效率比较高，表被一次截断，物理删除。\n这种删除缺点：不支持回滚。\n这种删除优点：快速。\n\n2.5.1delete\ndelete from 表名 where 条件;\n\n没有条件，整张表的数据会全部删除！\n\ndelete from t_user where id &#x3D; 2;\n\n\n2.5.2truncate\ntruncate table dept_bak; （这种操作属于DDL操作。）\n\n下列演示内容所用表\nemp 员工表\n\nsalgarde 工资等级表\n\ndept 部门表\n\n3.基础增删改3.单表查询3.1基础条件查询\nselect  字段1,字段2,字段3….  from   表名  where  条件;\n\n&#x3D; 等于\n查询薪资等于800的员工姓名和编号？\n\t\tselect empno,ename from emp where sal &#x3D; 800;\n\t查询SMITH的编号和薪资？\n\t\tselect empno,sal from emp where ename &#x3D; &#39;SMITH&#39;; &#x2F;&#x2F;字符串使用单引号\n\n&lt;&gt;或!&#x3D; 不等于\n查询薪资不等于800的员工姓名和编号？\n\tselect empno,ename from emp where sal !&#x3D; 800;\n\tselect empno,ename from emp where sal &lt;&gt; 800; &#x2F;&#x2F; 小于号和大于号组成的不等号\n\n&lt; 小于  &lt;&#x3D; 小于等于\n查询薪资小于等于3000的员工姓名和编号？\n\t\tselect empno,ename,sal from emp where sal &lt;&#x3D; 3000;\n\n(&gt;)大于 **  ** (&gt;&#x3D;) 大于等于\n查询薪资大于等于3000的员工姓名和编号？\nselect empno,ename,sal from emp where sal &gt;&#x3D; 3000;\n\nbetween … and …. 两个值之间, 等同于 &gt;&#x3D; and &lt;&#x3D;\n查询薪资在2450和3000之间的员工信息？包括2450和3000\n\t第一种方式：&gt;&#x3D; and &lt;&#x3D; （and是并且的意思。）\n\t\tselect empno,ename,sal from emp where sal &gt;&#x3D; 2450 and sal &lt;&#x3D; 3000;\t\n\nis null 为 null（is not null 不为空）\n查询哪些员工的津贴&#x2F;补助为null？\n\t\tmysql&gt; select empno,ename,sal,comm from emp where comm &#x3D; null;\n\n查询哪些员工的津贴&#x2F;补助不为null？\n\t\tselect empno,ename,sal,comm from emp where comm is not null;\n\nand 并且    or 或者\nselect  * from emp where sal &gt; 2500 and (deptno &#x3D; 10 or deptno &#x3D; 20);\n\nand和or同时出现，and优先级较高。如果想让or先执行，需要加“小括号”,以后在开发中，如果不确定优先级，就加小括号就行了。\n\nin 包含，相当于多个 or （not in 不在这个范围中）\n查询工作岗位是MANAGER和SALESMAN的员工？\nselect empno,ename,job from emp where job &#x3D; &#39;MANAGER&#39; or job &#x3D; &#39;SALESMAN&#39;;\nselect empno,ename,job from emp where job in(&#39;MANAGER&#39;, &#39;SALESMAN&#39;);\n\nnot 可以取非，主要用在 is 或 in 中\nis null\nis not null\nin\nnot in\n\nlike \t\n称为模糊查询，支持%或下划线匹配\n\n%匹配任意多个字符\n下划线：任意一个字符。\n（%是一个特殊的符号，_ 也是一个特殊符号）\n\n\t\n\n找出名字中含有O的？\n\tmysql&gt; select ename from emp where ename like &#39;%O%&#39;;\n\n找出名字中有“_”的？\n\tselect name from t_student where name like &#39;%_%&#39;; &#x2F;&#x2F;这样不行。\n\n\tmysql&gt; select name from t_student where name like &#39;%\\_%&#39;; &#x2F;&#x2F; \\转义字符。\n\ndistinct\n\n把查询结果去除重复记录【distinct】\n\ndistinct只能出现在所有字段的最前方。\n\ndistinct出现在job,deptno两个字段之前，表示两个字段联合起来去重。\n\nselect distinct job from emp;\n\nselect distinct job,deptno from emp;\n\n\n3.2排序查询所有员工薪资，排序？\n\nselect  ename,sal from emp order by sal; &#x2F;&#x2F; 默认是升序！！！\n\n指定降序：desc\n\nselect  ename,sal from emp order by sal desc;\n\n查询员工名字和薪资，要求按照薪资升序，如果薪资一样的话，\n\t再按照名字升序排列。\n\tselect \n\t\tename,sal\n\tfrom\n\t\temp\n\torder by\n\t\tsal asc, ename asc; &#x2F;&#x2F; sal在前，起主导，只有sal相等的时候，才会考虑启用ename排序。\n\n3.3分页\nlimit作用：将查询结果集的一部分取出来。通常使用在分页查询当中。\n完整用法：limit startIndex, length\t\tstartIndex是起始下标，length是长度。\n起始下标从0开始。\n缺省用法：limit 5; 这是取前5.\n\n\n\n按照薪资降序，取出排名在前5名的员工？\nselect \n\t\tename,sal\n\tfrom\n\t\temp\n\torder by \n\t\tsal desc\n\tlimit 5; &#x2F;&#x2F;取前5\tlimit 0,5;\nmysql当中limit在order by之后执行！！！！！！\n\n取出工资排名在[3-5]名的员工？\n\tselect \n\t\tename,sal\n\tfrom\n\t\temp\n\torder by\n\t\tsal desc\n\tlimit\n\t\t2, 3;\n2表示起始位置从下标2开始，就是第三条记录。\n3表示长度。\n\n\n每页显示3条记录\n\n第1页：limit 0,3\t\t[0 1 2]\n第2页：limit 3,3\t\t[3 4 5]\n第3页：limit 6,3\t\t[6 7 8]\n\n\n每页显示pageSize条记录\n\n第pageNo页：limit (pageNo - 1) * pageSize  , pageSize\n\n\n\n4.函数4.1单行处理函数\n单行处理函数的特点：一个输入对应一个输出。\n和单行处理函数相对的是：多行处理函数。（多行处理函数特点：多个输入，对应1个输出！）\n\n\n\nlower 转换小写\n\tmysql&gt; select lower(ename) as ename from emp;\nupper 转换大写\n\t\tmysql&gt; select * from t_student;\nsubstr 取子串（substr( 被截取的字符串, 起始下标,截取的长度)）\n\t\tselect substr(ename, 1, 1) as ename from emp;\n\t\t注意：起始下标从1开始，没有0.\n\t\t找出员工名字第一个字母是A的员工信息？\n\t\t\t第一种方式：模糊查询\n\t\t\t\tselect ename from emp where ename like &#39;A%&#39;;\n\t\t\t第二种方式：substr函数\n\t\t\t\tselect \n\t\t\t\t\tename \n\t\t\t\tfrom \n\t\t\t\t\temp \n\t\t\t\twhere \n\t\t\t\t\tsubstr(ename,1,1) &#x3D; &#39;A&#39;;\nconcat函数进行字符串的拼接\n\t\tselect concat(empno,ename) from emp;\nlength 取长度\n\t\tselect length(ename) enamelength from emp;\ntrim 去空格\n\t\tmysql&gt; select * from emp where ename &#x3D; &#39;  KING&#39;;\nstr_to_date 将字符串转换成日期\ndate_format 格式化日期\nformat 设置千分位\nround 四舍五入\n\t\tselect 字段 from 表名;\n\t\tselect ename from emp;\n\t\tselect &#39;abc&#39; from emp; &#x2F;&#x2F; select后面直接跟“字面量&#x2F;字面值”\n\n\t\tmysql&gt; select &#39;abc&#39; as bieming from emp;\n\t\tselect round(1236.567, 1) as result from emp; &#x2F;&#x2F;保留1个小数\n\t\tselect round(1236.567, 2) as result from emp; &#x2F;&#x2F;保留2个小数\n\t\tselect round(1236.567, -1) as result from emp; &#x2F;&#x2F; 保留到十位。\nrand() 生成随机数\n\t\tmysql&gt; select round(rand()*100,0) from emp; &#x2F;&#x2F; 100以内的随机数\nifnull 可以将 null 转换成一个具体值\n\t\tifnull是空处理函数。专门处理空的。\n\t\t在所有数据库当中，只要有NULL参与的数学运算，最终结果就是NULL。\n\t\tmysql&gt; select ename, sal + comm as salcomm from emp;\n\n4.2分组函数\n多行处理函数的特点：输入多行，最终输出一行。\ncount\t计数\nsum\t求和\navg\t平均值\nmax\t最大值\nmin\t最小值\n\n\n注意：分组函数在使用的时候必须先进行分组，然后才能用。如果你没有对数据进行分组，整张表默认为一组。\n\n\t\n找出最高工资？\n\t\tmysql&gt; select max(sal) from emp;\n找出最低工资？\n\t\tmysql&gt; select min(sal) from emp;\n计算工资和：\n\t\tmysql&gt; select sum(sal) from emp;\n计算平均工资：\n\t\tmysql&gt; select avg(sal) from emp;\n计算员工数量？\n\t\tmysql&gt; select count(ename) from emp;\n\n分组函数在使用的时候需要注意哪些？\t\n\n第一点：分组函数自动忽略NULL，你不需要提前对NULL进行处理。\n第二点：分组函数中count()和count(具体字段)有什么区别？\ncount(具体字段)：表示统计该字段下所有不为NULL的元素的总数。\ncount(*)：统计表当中的总行数。（只要有一行数据count则++）            因为每一行记录不可能都为NULL，一行数据中有一列不为NULL，则这行数据就是有效的。\n\n\n第三点：分组函数不能够直接使用在where子句中。        找出比最低工资高的员工信息。              select ename,sal from emp where sal &gt; min(sal);              表面上没问题，运行一下？                  ERROR 1111 (HY000): Invalid use of group function\n\n5.分组查询5.1 group by找出每个工作岗位的工资和？\n\t实现思路：按照工作岗位分组，然后对工资求和。\n\t\tselect \n\t\t\tjob,sum(sal)\n\t\tfrom\n\t\t\temp\n\t\tgroup by\n\t\t\tjob;\n以上这个语句的执行顺序？\n先从emp表中查询数据。根据job字段进行分组。然后对每一组的数据进行sum(sal)\n\n\n在一条select语句当中，如果有group by语句的话，select后面只能跟：参加分组的字段，以及分组函数。其它的一律不能跟。**\n\n找出每个部门的最高薪资\n实现思路:按照部门编号分组，求每一组的最大值。\n\tmysql&gt; select deptno,max(sal) from emp group by deptno;\n\n5.2 联合分组找出“每个部门，不同工作岗位”的最高薪资？\n技巧：两个字段联合成1个字段看。（两个字段联合分组）\n\t\tselect \n\t\t\tdeptno, job, max(sal)\n\t\tfrom\n\t\t\temp\n\t\tgroup by\n\t\t\tdeptno, job;\n\n\n\n5.3having\n使用having可以对分完组之后的数据进一步过滤。\n\nhaving不能单独使用，having不能代替where，having必须和group by联合使用。\n\n\n找出每个部门平均薪资，要求显示平均薪资高于2500的。\nselect \n\tdeptno,avg(sal) \nfrom \n\temp \ngroup by \n\tdeptno\nhaving\n\tavg(sal) &gt; 2500;\n\n\nwhere和having，优先选择where，where实在完成不了了，再选择having。\n\n5.4总结sql执行顺序\nselect  –&gt; from –&gt; where –&gt; group by –&gt; having –&gt; order by –&gt;以上关键字只能按照这个顺序来，不能颠倒。\n\n执行顺序？    1. from –&gt; where –&gt; group by –&gt; having –&gt; select –&gt; order by\n\n从某张表中查询数据，\n先经过where条件筛选出有价值的数据。\n对这些有价值的数据进行分组。\n分组之后可以使用having继续筛选。\nselect查询出来。\n最后排序输出！\n\n找出每个岗位的平均薪资，要求显示平均薪资大于1500的，除MANAGER岗位之外，\n要求按照平均薪资降序排。\n\tselect \n\t\tjob, avg(sal) as avgsal\n\tfrom\n\t\temp\n\twhere\n\t\tjob &lt;&gt; &#39;MANAGER&#39;\n\tgroup by\n\t\tjob\n\thaving\n\t\tavg(sal) &gt; 1500\n\torder by\n\t\tavgsal desc;\n\n6.连表查询\n从一张表中单独查询，称为单表查询\n\nemp表和dept表联合起来查询数据，从emp表中取员工名字，从dept表中取部门名字。\n\n这种跨表查询，多张表联合起来查询数据，被称为连接查询。\n\n\nselect ename,dname from emp, dept;\n\n当两张表进行连接查询，没有任何条件限制的时候，最终查询结果条数，是两张表条数的乘积，这种现象被称为：笛卡尔积现象。\n\n6.1内连接之等值连接查询每个员工所在部门名称，显示员工名和部门名？\n\nemp e和dept d表进行连接。条件是：e.deptno &#x3D; d.deptno\n\nSQL92语法：\n\tselect \n\t\te.ename,d.dname\n\tfrom\n\t\temp e, dept d\n\twhere\n\t\te.deptno &#x3D; d.deptno;\n\t\n\tsql92的缺点：结构不清晰，表的连接条件，和后期进一步筛选的条件，都放到了where后面。\n\t\nSQL99语法：\n\t&#x2F;&#x2F;inner可以省略（带着inner可读性更好！！！一眼就能看出来是内连接）\n\tselect \n\t\te.ename,d.dname\n\tfrom\n\t\temp e\n\tinner join\n\t\tdept d\n\ton\n\t\te.deptno &#x3D; d.deptno; &#x2F;&#x2F; 条件是等量关系，所以被称为等值连接。\n\tsql99优点：表连接的条件是独立的，连接之后，如果还需要进一步筛选，再往后继续添加where\n\n6.2内连接之非等值连接找出每个员工的薪资等级，要求显示员工名、薪资、薪资等级？\nselect \n\te.ename, e.sal, s.grade\nfrom\n\temp e\njoin\n\tsalgrade s\non\n\te.sal between s.losal and s.hisal; &#x2F;&#x2F; 条件不是一个等量关系，称为非等值连接。\n\n6.3内连接自己连接查询员工的上级领导，要求显示员工名和对应的领导名？\n技巧：一张表看成两张表。\nselect \n\ta.ename as &#39;员工名&#39;, b.ename as &#39;领导名&#39;\nfrom\n\temp a\njoin\n\temp b\non\n\ta.mgr &#x3D; b.empno; &#x2F;&#x2F;员工的领导编号 &#x3D; 领导的员工编号\n\n6.4外连接\n内连接：（A和B连接，AB两张表没有主次关系。平等的。）\n\n内连接的特点：完成能够匹配上ON后面的条件的数据查询出来。\n\n\n&#x2F;&#x2F; outer是可以省略的，带着可读性强。\nselect \n\te.ename,d.dname\nfrom\n\temp e \nright outer join \n\tdept d\non\n\te.deptno &#x3D; d.deptno;\n\n\nright代表什么：表示将join关键字右边的这张表看成主表，主要是为了将\n这张表的数据全部查询出来，捎带着关联查询左边的表。\n在外连接当中，两张表连接，产生了主次关系。\n\nselect \n\te.ename,d.dname\nfrom\n\tdept d \nleft outer join \n\temp e\non\n\te.deptno &#x3D; d.deptno;\n\n带有right的是右外连接，又叫做右连接。\n带有left的是左外连接，又叫做左连接。\n任何一个右连接都有左连接的写法。\n任何一个左连接都有右连接的写法。\n\n6.5多表连接三张表，四张表怎么连接？\n语法：\n\tselect \n\t\t...\n\tfrom\n\t\ta\n\tjoin\n\t\tb\n\ton\n\t\ta和b的连接条件\n\tjoin\n\t\tc\n\ton\n\t\ta和c的连接条件\n\tright join\n\t\td\n\ton\n\t\ta和d的连接条件\n\n找出每个员工的部门名称以及工资等级，要求显示员工名、部门名、薪资、薪资等级？\nselect \n\t\te.ename,e.sal,d.dname,s.grade\n\tfrom\n\t\temp e\n\tjoin\n\t\tdept d\n\ton \n\t\te.deptno &#x3D; d.deptno\n\tjoin\n\t\tsalgrade s\n\ton\n\t\te.sal between s.losal and s.hisal;\n\n找出每个员工的部门名称以及工资等级，还有上级领导，要求显示员工名、领导名、部门名、薪资、薪资等级？\nselect \n\te.ename,e.sal,d.dname,s.grade,l.ename\nfrom\n\temp e\njoin\n\tdept d\non \n\te.deptno &#x3D; d.deptno\njoin\n\tsalgrade s\non\n\te.sal between s.losal and s.hisal\nleft join\n\temp l\non\n\te.mgr &#x3D; l.empno;\n\n7.子查询\nselect语句中嵌套select语句，被嵌套的select语句称为子查询。\n\n子查询可以出现在 select后面，from 后面，where 后面。\n\n\n7.1where子句中的子查询找出比最低工资高的员工姓名和工资？\n\nselect ename,sal from emp where sal &gt; (select min(sal) from emp);\n\n7.2from子句中的子查询\nfrom后面的子查询，可以将子查询的查询结果当做一张临时表。（技巧）\n\n找出每个岗位的平均工资的薪资等级。\nselect \n\t\t\tt.*, s.grade\n\t\tfrom\n\t\t\t(select job,avg(sal) as avgsal from emp group by job) t\n\t\tjoin\n\t\t\tsalgrade s\n\t\ton\n\t\t\tt.avgsal between s.losal and s.hisal;\n\n8.约束\n在创建表的时候，我们可以给表中的字段加上一些约束，来保证这个表中数据的完整性、有效性！！！\n\n8.1约束类型\n非空约束：not null\n唯一性约束: unique\n主键约束: primary key （简称PK）\n外键约束：foreign key（简称FK）\n检查约束：check（mysql不支持，oracle支持）\n\n我们这里重点学习四个约束：not null，unique，primary key，foreign key。\n8.2not null\n非空约束not null约束的字段不能为NULL。\n\ndrop table if exists t_vip;\n\tcreate table t_vip(\n\t\tid int,\n\t\tname varchar(255) not null  &#x2F;&#x2F; not null只有列级约束，没有表级约束！\n\t);\ninsert into t_vip(id,name) values(1,&#39;zhangsan&#39;);\n\ninsert into t_vip(id) values(3);\n\tERROR 1364 (HY000): Field &#39;name&#39; doesn&#39;t have a default value\n\n\n\n8.3unique\n唯一性约束unique约束的字段不能重复，但是可以为NULL。\n\ndrop table if exists t_vip;\ncreate table t_vip(\n\tid int,\n\tname varchar(255) unique,\n\temail varchar(255)\n);\ninsert into t_vip(id,name,email) values(2,&#39;lisi&#39;,&#39;lisi@123.com&#39;);\ninsert into t_vip(id,name,email) values(3,&#39;wangwu&#39;,&#39;wangwu@123.com&#39;);\nselect * from t_vip;\n\ninsert into t_vip(id,name,email) values(4,&#39;wangwu&#39;,&#39;wangwu@sina.com&#39;);\nERROR 1062 (23000): Duplicate entry &#39;wangwu&#39; for key &#39;name&#39;\n\ninsert into t_vip(id) values(4);\ninsert into t_vip(id) values(5);\n+------+----------+------------------+\n| id   | name     | email            |\n+------+----------+------------------+\n|    1 | zhangsan | zhangsan@123.com |\n|    2 | lisi     | lisi@123.com     |\n|    3 | wangwu   | wangwu@123.com   |\n|    4 | NULL     | NULL             |\n|    5 | NULL     | NULL             |\n+------+----------+------------------+\nname字段虽然被unique约束了，但是可以为NULL。\n\n8.3.1联合唯一\nname和email两个字段联合起来具有唯一性！！！！\n\ndrop table if exists t_vip;\ncreate table t_vip(\n\tid int,\n\tname varchar(255),\n\temail varchar(255),\n\tunique(name,email) &#x2F;&#x2F; 约束没有添加在列的后面，这种约束被称为表级约束。\n);\ninsert into t_vip(id,name,email) values(1,&#39;zhangsan&#39;,&#39;zhangsan@123.com&#39;);\ninsert into t_vip(id,name,email) values(2,&#39;zhangsan&#39;,&#39;zhangsan@sina.com&#39;);\n\tname和email两个字段联合起来唯一！！！\n\t\ninsert into t_vip(id,name,email) values(3,&#39;zhangsan&#39;,&#39;zhangsan@sina.com&#39;);\n\tERROR 1062 (23000): Duplicate entry &#39;zhangsan-zhangsan@sina.com&#39; for key &#39;name&#39;\n\n\n在mysql当中，如果一个字段同时被not null和unique约束的话，该字段自动变成主键字段。（注意：oracle中不一样！）\n\n8.4primary key\n主键值是每一行记录的唯一标识。主键值是每一行记录的身份证号！！！\n\n主键的特征：not null + unique（主键值不能是NULL，同时也不能重复！）\n\n\ndrop table if exists t_vip;\n\t\t&#x2F;&#x2F; 1个字段做主键，叫做：单一主键\n\t\tcreate table t_vip(\n\t\t\tid int primary key,  &#x2F;&#x2F;列级约束\n\t\t\tname varchar(255),\n            primary key(id)  &#x2F;&#x2F; 表级约束\n\t\t);\n\t\tinsert into t_vip(id,name) values(1,&#39;zhangsan&#39;);\n\t\tinsert into t_vip(id,name) values(2,&#39;lisi&#39;);\n\n\t\t&#x2F;&#x2F;错误：不能重复\n\t\tinsert into t_vip(id,name) values(2,&#39;wangwu&#39;);\n\t\tERROR 1062 (23000): Duplicate entry &#39;2&#39; for key &#39;PRIMARY&#39;\n\n\t\t&#x2F;&#x2F;错误：不能为NULL\n\t\tinsert into t_vip(name) values(&#39;zhaoliu&#39;);\n\t\tERROR 1364 (HY000): Field &#39;id&#39; doesn&#39;t have a default value\n\n8.4.1复合主键drop table if exists t_vip;\n\t\t&#x2F;&#x2F; id和name联合起来做主键：复合主键！！！！\n\t\tcreate table t_vip(\n\t\t\tid int,\n\t\t\tname varchar(255),\n\t\t\temail varchar(255),\n\t\t\tprimary key(id,name)\n\t\t);\ninsert into t_vip(id,name,email) values(1,&#39;zhangsan&#39;,&#39;zhangsan@123.com&#39;);\ninsert into t_vip(id,name,email) values(1,&#39;lisi&#39;,&#39;lisi@123.com&#39;);\n\n&#x2F;&#x2F;错误：不能重复\ninsert into t_vip(id,name,email) values(1,&#39;lisi&#39;,&#39;lisi@123.com&#39;);\n\tERROR 1062 (23000): Duplicate entry &#39;1-lisi&#39; for key &#39;PRIMARY&#39;\n\n\n在实际开发中不建议使用：复合主键。建议使用单一主键！\n因为主键值存在的意义就是这行记录的身份证号，只要意义达到即可，单一主键可以做到。\n\n一个表中主键约束能加两个吗？\n\t\tdrop table if exists t_vip;\n\t\tcreate table t_vip(\n\t\t\tid int primary key,\n\t\t\tname varchar(255) primary key\n\t\t);\n\t\tERROR 1068 (42000): Multiple primary key defined\n\n\n结论：一张表，主键约束只能添加1个。（主键只能有1个。）\n\n主键分类\n\n自然主键：主键值是一个自然数，和业务没关系。\n\n业务主键：主键值和业务紧密关联，例如拿银行卡账号做主键值。这就是业务主键！\n\n\n8.4.2主键自增\n在mysql当中，有一种机制，可以帮助我们自动维护一个主键值\n\nrop table if exists t_vip;\ncreate table t_vip(\n\tid int primary key auto_increment, &#x2F;&#x2F;auto_increment表示自增，从1开始，以1递增！\n\tname varchar(255)\n);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\tinsert into t_vip(name) values(&#39;zhangsan&#39;);\n\t\t\n\t\t+----+----------+\n\t\t| id | name     |\n\t\t+----+----------+\n\t\t|  1 | zhangsan |\n\t\t|  2 | zhangsan |\n\t\t|  3 | zhangsan |\n\t\t|  4 | zhangsan |\n\t\t|  5 | zhangsan |\n\n8.5foreign key\n如果一个实体的某个字段指向另一个实体的主键，就称为外键\n被指向的实体，称之为主实体（主表），也叫父实体（父表）。\n负责指向的实体，称之为从实体（从表），也叫子实体（子表）\n\ncreate table t_class(\n\tclassno int primary key,\n\tclassname varchar(255)\n);\ncreate table t_student(\n\tno int primary key auto_increment,\n\tname varchar(255),\n\tcno int,\n\tforeign key(cno) references t_class(classno)\n);\n\ninsert into t_class(classno, classname) values(100, &#39;北京市大兴区亦庄镇第二中学高三1班&#39;);\ninsert into t_class(classno, classname) values(101, &#39;北京市大兴区亦庄镇第二中学高三1班&#39;);\n\ninsert into t_student(name,cno) values(&#39;jack&#39;, 100);\ninsert into t_student(name,cno) values(&#39;lilei&#39;, 100);\ninsert into t_student(name,cno) values(&#39;hanmeimei&#39;, 100);\ninsert into t_student(name,cno) values(&#39;zhangsan&#39;, 101);\ninsert into t_student(name,cno) values(&#39;lisi&#39;, 101);\n\n\n外键可以为空，可以理解成 一名学生肯定会关联到一个存在的班级，但来了一个转校生，还没有分班，他现在属于学生子表，但还没有关联到班级主表中的任何一条记录。\n\nt_class是父表，t_student是子表\n​\t\t删除表的顺序？\t先删子，再删父。\n​\t\t创建表的顺序？\t先创建父，再创建子。\n​\t\t删除数据的顺序？先删子，再删父。\n​\t\t插入数据的顺序？先插入父，再插入子\n\n子表中的外键引用的父表中的某个字段，被引用的这个字段不一定是主键，但至少具有unique约束。\n\n9.存储引擎\n存储引擎是MySQL中特有的一个术语，其它数据库中没有。（Oracle中有，但是不叫这个名字）\n实际上存储引擎是一个表存储&#x2F;组织数据的方式。\n不同的存储引擎，表存储数据的方式不同。\n\nshow create table t_student;\n可以在建表的时候给表指定存储引擎。\nCREATE TABLE &#96;t_student&#96; (\n  &#96;no&#96; int(11) NOT NULL AUTO_INCREMENT,\n  &#96;name&#96; varchar(255) DEFAULT NULL,\n  &#96;cno&#96; int(11) DEFAULT NULL,\n  PRIMARY KEY (&#96;no&#96;),\n  KEY &#96;cno&#96; (&#96;cno&#96;),\n  CONSTRAINT &#96;t_student_ibfk_1&#96; FOREIGN KEY (&#96;cno&#96;) REFERENCES &#96;t_class&#96; (&#96;classno&#96;)\n) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;11 DEFAULT CHARSET&#x3D;utf8\n\n在建表的时候可以在最后小括号的”)”的右边使用：\n\nENGINE来指定存储引擎。\tmysql默认的存储引擎是：InnoDB\nCHARSET来指定这张表的字符编码方式。mysql默认的字符编码方式是：utf8\n\n9.1mysql支持的存储引擎\nshow engines \\G   查看mysql支持哪些存储引擎\nmysql支持九大存储引擎，当前5.5.36支持8个。版本不同支持情况不同。\n\n\n9.2MyISAM存储引擎\n使用三个文件表示每个表：\n\n格式文件 — 存储表结构的定义（mytable.frm）\n数据文件 — 存储表行的内容（mytable.MYD）\n索引文件 — 存储表上索引（mytable.MYI）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。\n\n\n可被转换为压缩、只读表来节省空间\n\nMyISAM存储引擎特点：\n\n可被转换为压缩、只读表来节省空间这是这种存储引擎的优势！！！！\nMyISAM不支持事务机制，安全性低。\n\n\n\n9.3InnoDB存储引擎\n这是mysql默认的存储引擎，同时也是一个重量级的存储引擎。\n\nInnoDB支持事务，支持数据库崩溃后自动恢复机制。\n\nInnoDB存储引擎最主要的特点是：非常安全。\n\n它管理的表具有下列主要特征：\n\n每个 InnoDB 表在数据库目录中以.frm 格式文件表示\nInnoDB 表空间 tablespace 被用于存储表的内容（表空间是一个逻辑名称。表空间存储数据+索引。）\n提供一组用来记录事务性活动的日志文件\n用 COMMIT(提交)、SAVEPOINT 及ROLLBACK(回滚)支持事务处理\n提供全 ACID 兼容\n在 MySQL 服务器崩溃后提供自动恢复\n多版本（MVCC）和行级锁定\n支持外键及引用的完整性，包括级联删除和更新\n\n\nInnoDB最大的特点就是支持事务：以保证数据的安全。效率不是很高，并且也不能压缩，不能转换为只读，\n\n不能很好的节省存储空间。\n\n\n9.4MEMORY存储引擎\n使用 MEMORY 存储引擎的表，其数据存储在内存中，且行的长度固定，这两个特点使得 MEMORY 存储引擎非常快。\n\nMEMORY 存储引擎管理的表具有下列特征：\n\n在数据库目录内，每个表均以.frm 格式的文件表示。\n表数据及索引被存储在内存中。（目的就是快，查询快！）\n表级锁机制。\n不能包含 TEXT 或 BLOB 字段。\n\n\nMEMORY 存储引擎以前被称为HEAP 引擎。\n\nMEMORY引擎优点：查询效率是最高的。不需要和硬盘交互。\n\nMEMORY引擎缺点：不安全，关机之后数据消失。因为数据和索引都是在内存当中。\n\n\n10.事务\n一个事务其实就是一个完整的业务逻辑。是一个最小的工作单元。不可再分。\n\n什么是一个完整的业务逻辑？    假设转账，从A账户向B账户中转账10000.      将A账户的钱减去10000（update语句）      将B账户的钱加上10000（update语句）      这就是一个完整的业务逻辑。\n\n以上的操作是一个最小的工作单元，要么同时成功，要么同时失败，不可再分。这两个update语句要求必须同时成功或者同时失败，这样才能保证钱是正确的。\n\ninsert   delete   update  只有以上的三个语句和事务有关系，其它都没有关系。\n\n事务：就是批量的DML语句同时成功，或者同时失败！\n\n\n10.1InnoDB实现事务\nInnoDB存储引擎：提供一组用来记录事务性活动的日志文件\n\n在事务的执行过程中，每一条DML的操作都会记录到“事务性活动的日志文件”中。\n\n在事务的执行过程中，我们可以提交事务，也可以回滚事务。\n\n提交事务   commit; 语句\n\n清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中。\n提交事务标志着，事务的结束。并且是一种全部成功的结束。\n\n\n回滚事务  rollback; 语句（回滚永远都是只能回滚到上一次的提交点！）\n\n将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件\n回滚事务标志着，事务的结束。并且是一种全部失败的结束。\n\n\n将mysql的自动提交机制关闭掉   start transaction;\n\n\n事务回滚\n\tmysql&gt; select * from dept_bak;\n\t\tEmpty set (0.00 sec)\n\tmysql&gt; start transaction;\n\tQuery OK, 0 rows affected (0.00 sec)\n\n\tmysql&gt; insert into dept_bak values(10,&#39;abc&#39;, &#39;tj&#39;);\n\tQuery OK, 1 row affected (0.00 sec)\n\n\tmysql&gt; insert into dept_bak values(10,&#39;abc&#39;, &#39;tj&#39;);\n\tQuery OK, 1 row affected (0.00 sec)\n\n\tmysql&gt; select * from dept_bak;\n\t+--------+-------+------+\n\t| DEPTNO | DNAME | LOC  |\n\t+--------+-------+------+\n\t|     10 | abc   | tj   |\n\t|     10 | abc   | tj   |\n\t+--------+-------+------+\n\t2 rows in set (0.00 sec)\n\n\tmysql&gt; rollback;\n\tQuery OK, 0 rows affected (0.00 sec)\n\n\tmysql&gt; select * from dept_bak;\n\tEmpty set (0.00 sec)\n\n10.2事物的四个特性A：原子性        说明事务是最小的工作单元。不可再分。\nC：一致性    所有事务要求，在同一个事务当中，所有操作必须同时成功，或者同时失败，    以保证数据的一致性。\nI：隔离性    A事务和B事务之间具有一定的隔离。    教室A和教室B之间有一道墙，这道墙就是隔离性。    A事务在操作一张表的时候，另一个事务B也操作这张表会那样？？？\nD：持久性    事务最终结束的一个保障。事务提交，就相当于将没有保存到硬盘上的数据    保存到硬盘上！\n10.3事务的隔离性10.3.1事务和事务之间四个隔离级别读未提交：read uncommitted（最低的隔离级别）《没有提交就读到了》\n\n事务A可以读取到事务B未提交的数据。\n这种隔离级别存在的问题就是：脏读现象！(Dirty Read)我们称读到了脏数据。\n这种隔离级别一般都是理论上的，大多数的数据库隔离级别都是二档起步！\n\n读已提交：read committed《提交之后才能读到》\n\n事务A只能读取到事务B提交之后的数据。\n这种隔离级别解决了解决了脏读的现象。\n这种隔离级别不可重复读取数据。\n在事务开启之后，第一次读到的数据是3条，当前事务还没有结束，可能第二次再读取的时候，读到的数据是4条，3不等于4称为不可重复读取。\n\n\n这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实。\noracle数据库默认的隔离级别是：read committed\n\n可重复读：repeatable read《提交之后也读不到，永远读取的都是刚开启事务时的数据》\n\n事务A开启之后，不管是多久，每一次在事务A中读取到的数据都是一致的。即使事务B将数据已经修改，并且提交了，事务A读取到的数据还是没有发生改变，这就是可重复读。\n\n可重复读可能会出现幻影读。每一次读取到的数据都是幻象。不够真实！\n\n早晨9点开始开启了事务，只要事务不结束，到晚上9点，读到的数据还是那样！读到的是假象。不够绝对的真实。\n\nmysql中默认的事务隔离级别就是这个！！！！！！！！！！！\n\n\n序列化&#x2F;串行化：serializable（最高的隔离级别）\n\n这是最高隔离级别，效率最低。解决了所有的问题。\n这种隔离级别表示事务排队，不能并发！\nsynchronized，线程同步（事务同步）每一次读取到的数据都是最真实的，并且效率是最低的。\n\n10.3.2验证各种隔离级别\nmysql 5 查看隔离级别：SELECT @@tx_isolation\nmysql 8 查看隔离级别：select @@transaction_isolation;\n\n验证：read uncommited\nmysql&gt; set global transaction isolation level read uncommitted;\n事务A\t\t\t\t\t\t\t\t\t\t\t\t\t事务B\n--------------------------------------------------------------------------------\nuse bjpowernode;\n\t\t\t\t\t\t\t\t\t\t\t\t\tuse bjpowernode;\nstart transaction;\nselect * from t_user;\n\t\t\t\t\t\t\t\t\t\t\t\t\tstart transaction;\n\t\t\t\t\t\t\t\t\t\t\t\t\tinsert into t_user values(&#39;zhangsan&#39;);\nselect * from t_user;\n\n验证：read commited\nmysql&gt; set global transaction isolation level read committed;\n事务A\t\t\t\t\t\t\t\t\t\t\t\t\t事务B\n--------------------------------------------------------------------------------\nuse bjpowernode;\n\t\t\t\t\t\t\t\t\t\t\t\t\tuse bjpowernode;\nstart transaction;\n\t\t\t\t\t\t\t\t\t\t\t\t\tstart transaction;\nselect * from t_user;\n\t\t\t\t\t\t\t\t\t\t\t\t\tinsert into t_user values(&#39;zhangsan&#39;);\nselect * from t_user;\n\t\t\t\t\t\t\t\t\t\t\t\t\tcommit;\nselect * from t_user;\n\n验证：repeatable read\nmysql&gt; set global transaction isolation level repeatable read;\n事务A\t\t\t\t\t\t\t\t\t\t\t\t\t事务B\n--------------------------------------------------------------------------------\nuse bjpowernode;\n\t\t\t\t\t\t\t\t\t\t\t\t\tuse bjpowernode;\nstart transaction;\n\t\t\t\t\t\t\t\t\t\t\t\t\tstart transaction;\nselect * from t_user;\n\t\t\t\t\t\t\t\t\t\t\t\t\tinsert into t_user values(&#39;lisi&#39;);\n\t\t\t\t\t\t\t\t\t\t\t\t\tinsert into t_user values(&#39;wangwu&#39;);\n\t\t\t\t\t\t\t\t\t\t\t\t\tcommit;\nselect * from t_user;\n\n验证：serializable\nmysql&gt; set global transaction isolation level serializable;\n事务A\t\t\t\t\t\t\t\t\t\t\t\t\t事务B\n--------------------------------------------------------------------------------\nuse bjpowernode;\n\t\t\t\t\t\t\t\t\t\t\t\t\tuse bjpowernode;\nstart transaction;\n\t\t\t\t\t\t\t\t\t\t\t\t\tstart transaction;\nselect * from t_user;\ninsert into t_user values(&#39;abc&#39;);\n\n11.索引\n索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。\n\n一张表的一个字段可以添加一个索引，当然，多个字段联合起来也可以添加索引。\n\n索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。\n\nMySQL在查询方面主要就是两种方式：全表扫描  ；根据索引检索。\n\n在mysql数据库当中索引也是需要排序的，并且这个所以的排序和TreeSet\n\n数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！在mysql当中索引是一个B-Tree数据结构。\n\n遵循左小又大原则存放。采用中序遍历方式遍历取数据。\n\n\n索引的实现原理？\n\n\n提醒1：在任何数据库当中主键上都会自动添加索引对象，id字段上自动有索引，因为id是PK。另外在mysql当中，一个字段上如果有unique约束的话，也会自动创建索引对象\n提醒2：在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号。\n提醒3：在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引擎中，索引存储在一个.MYI文件中。在InnoDB存储引擎中索引存储在一个逻辑名称叫做tablespace的当中。在MEMORY存储引擎当中索引被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式\n\n什么条件下，我们会考虑给字段添加索引呢？\n\n数据量庞大（到底有多么庞大算庞大，这个需要测试，因为每一个硬件环境不同）\n该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。\n该字段很少的DML(insert delete update)操作。（因为DML之后，索引需要重新排序。）\n\n\n建议不要随意添加索引，因为索引也是需要维护的，太多的话反而会降低系统的性能。\n建议通过主键查询，建议通过unique约束的字段进行查询，效率是比较高的。\n\n11.1索引的创建和删除创建索引：\n\tmysql&gt; create index emp_ename_index on emp(ename);\n\t给emp表的ename字段添加索引，起名：emp_ename_index\n删除索引：\n\tmysql&gt; drop index emp_ename_index on emp;\n\t将emp表上的emp_ename_index索引对象删除。\n\t\n\t\n\t查看一个SQL语句是否使用了索引进行检索？\n\tmysql&gt; explain select * from emp where ename &#x3D; &#39;KING&#39;;\n\t+----+-------------+-------+------+---------------+------+---------+--\n\t| id | select_type | table | type | possible_keys | key  | key_len | \n\t+----+-------------+-------+------+---------------+------+---------+-\n\t|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\t扫描14条记录：说明没有使用索引。type&#x3D;ALL\n\n\tmysql&gt; create index emp_ename_index on emp(ename);\n\n\tmysql&gt; explain select * from emp where ename &#x3D; &#39;KING&#39;;\n\t+----+-------------+-------+------+-----------------+-----------------\n\t| id | select_type | table | type | possible_keys   | key             \n\t+----+-------------+-------+------+-----------------+-----------------\n\t|  1 | SIMPLE      | emp   | ref  | emp_ename_index | emp_ename_index \n\t+----+-------------+-------+------+-----------------+-----------------\n\n11.2索引失效失效的第1种情况：\n\tselect * from emp where ename like &#39;%T&#39;;\n\tename上即使添加了索引，也不会走索引，为什么？\n\t\t原因是因为模糊匹配当中以“%”开头了！\n\t\t尽量避免模糊查询的时候以“%”开始。\n\t\t这是一种优化的手段&#x2F;策略。\n\tmyql&gt; explain select * from emp where ename like &#39;%T&#39;;\n\t+----+-------------+-------+------+---------------+------+---------+--\n\t| id | select_type | table | type | possible_keys | key  | key_len | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\t|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\n失效的第2种情况：\n\t使用or的时候会失效，如果使用or那么要求or两边的条件字段都要有\n\t索引，才会走索引，如果其中一边有一个字段没有索引，那么另一个\n\t字段上的索引也会实现。所以这就是为什么不建议使用or的原因。\n\n\tmysql&gt; explain select * from emp where ename &#x3D; &#39;KING&#39; or job &#x3D; &#39;MANAGER&#39;;\n\t+----+-------------+-------+------+-----------------+------+---------\n\t| id | select_type | table | type | possible_keys   | key  | key_len | \n\t+----+-------------+-------+------+-----------------+------+---------\n\t|  1 | SIMPLE      | emp   | ALL  | emp_ename_index | NULL | NULL    | \n\t+----+-------------+-------+------+-----------------+------+---------\n\n失效的第3种情况：\n\t使用复合索引的时候，没有使用左侧的列查找，索引失效\n\t什么是复合索引？\n\t\t两个字段，或者更多的字段联合起来添加一个索引，叫做复合索引。\n\t\n\tcreate index emp_job_sal_index on emp(job,sal);\n\t\n\tmysql&gt; explain select * from emp where job &#x3D; &#39;MANAGER&#39;;\n\t+----+-------------+-------+------+-------------------+---------------\n\t| id | select_type | table | type | possible_keys     | key           \n\t+----+-------------+-------+------+-------------------+---------------\n\t|  1 | SIMPLE      | emp   | ref  | emp_job_sal_index | \n\t+----+-------------+-------+------+-------------------+---------------\n\t\n\tmysql&gt; explain select * from emp where sal &#x3D; 800;\n\t+----+-------------+-------+------+---------------+------+---------+--\n\t| id | select_type | table | type | possible_keys | key  | key_len | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\t|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | \n\t+----+-------------+-------+------+---------------+------+---------+--\n\n12.视图\n视图view:站在不同的角度去看待同一份数据。\n\n表复制：\n\tmysql&gt; create table dept2 as select * from dept;\ndept2表中的数据：\n\tmysql&gt; select * from dept2;\n+--------+------------+----------+\n| DEPTNO | DNAME      | LOC      |\n+--------+------------+----------+\n|     10 | ACCOUNTING | NEW YORK |\n|     20 | RESEARCH   | DALLAS   |\n|     30 | SALES      | CHICAGO  |\n|     40 | OPERATIONS | BOSTON   |\n+--------+------------+----------+\n\n创建视图对象：\n\tcreate view dept2_view as select * from dept2;\n\n删除视图对象：\n\tdrop view dept2_view;\n\n注意：只有DQL语句才能以view的形式创建。\n\tcreate view view_name as 这里的语句必须是DQL语句;\n\n12.1视图的作用\n我们可以面向视图对象进行增删改查，对视图对象的增删改查，会导致原表被操作！（视图的特点：通过对视图的操作，会影响到原表数据。）\n\n&#x2F;&#x2F;面向视图查询\nselect * from dept2_view; \n\n&#x2F;&#x2F; 面向视图插入\ninsert into dept2_view(deptno,dname,loc) values(60,&#39;SALES&#39;, &#39;BEIJING&#39;);\n\n&#x2F;&#x2F; 查询原表数据\nmysql&gt; select * from dept2;\n+--------+------------+----------+\n| DEPTNO | DNAME      | LOC      |\n+--------+------------+----------+\n|     10 | ACCOUNTING | NEW YORK |\n|     20 | RESEARCH   | DALLAS   |\n|     30 | SALES      | CHICAGO  |\n|     40 | OPERATIONS | BOSTON   |\n|     60 | SALES      | BEIJING  |\n+--------+------------+----------+\n\n&#x2F;&#x2F; 面向视图删除\nmysql&gt; delete from dept2_view;\n\n&#x2F;&#x2F; 查询原表数据\nmysql&gt; select * from dept2;\nEmpty set (0.00 sec)\n&#x2F;&#x2F; 创建视图对象\ncreate view \n\temp_dept_view\nas\n\tselect \n\t\te.ename,e.sal,d.dname\n\tfrom\n\t\temp e\n\tjoin\n\t\tdept d\n\ton\n\t\te.deptno &#x3D; d.deptno;\n\n&#x2F;&#x2F; 查询视图对象\nmysql&gt; select * from emp_dept_view;\n+--------+---------+------------+\n| ename  | sal     | dname      |\n+--------+---------+------------+\n| CLARK  | 2450.00 | ACCOUNTING |\n| KING   | 5000.00 | ACCOUNTING |\n| MILLER | 1300.00 | ACCOUNTING |\n| SMITH  |  800.00 | RESEARCH   |\n| JONES  | 2975.00 | RESEARCH   |\n| SCOTT  | 3000.00 | RESEARCH   |\n| ADAMS  | 1100.00 | RESEARCH   |\n| FORD   | 3000.00 | RESEARCH   |\n| ALLEN  | 1600.00 | SALES      |\n| WARD   | 1250.00 | SALES      |\n| MARTIN | 1250.00 | SALES      |\n| BLAKE  | 2850.00 | SALES      |\n| TURNER | 1500.00 | SALES      |\n| JAMES  |  950.00 | SALES      |\n+--------+---------+------------+\n\n&#x2F;&#x2F; 面向视图更新\nupdate emp_dept_view set sal &#x3D; 1000 where dname &#x3D; &#39;ACCOUNTING&#39;;\n\n&#x2F;&#x2F; 原表数据被更新\nmysql&gt; select * from emp;\n+-------+--------+-----------+------+------------+---------+---------+----\n| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | \n+-------+--------+-----------+------+------------+---------+---------+----\n|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     \n|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     \n|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     \n|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     \n|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     \n|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     \n|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 1000.00 |    NULL |     \n|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     \n|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 1000.00 |    NULL |     \n|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     \n|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     \n|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     \n|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     \n|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1000.00 |    NULL |     \n+-------+--------+-----------+------+------------+---------+---------+----\n\n12.2视图在开发中的作用\n假设有一条非常复杂的SQL语句，而这条SQL语句需要在不同的位置上反复使用。每一次使用这个sql语句的时候都需要重新编写，很长，很麻烦，怎么办？    可以把这条复杂的SQL语句以视图对象的形式新建。    在需要编写这条SQL语句的位置直接使用视图对象，可以大大简化开发。    并且利于后期的维护，因为修改的时候也只需要修改一个位置就行，只需要    修改视图对象所映射的SQL语句。\n\n我们以后面向视图开发的时候，使用视图的时候可以像使用table一样。\n\n可以对视图进行增删改查等操作。*视图不是在内存当中，视图对象也是存储在硬盘上的，不会消失。*\n\n\n13.数据库三范式第一范式：要求任何一张表必须有主键，每一个字段原子性不可再分。\n第二范式：建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，不要产生部分依赖。\n第三范式：建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，不要产生传递依赖。\n\n声明：三范式是面试官经常问的，所以一定要熟记在心！\n\n设计数据库表的时候，按照以上的范式进行，可以避免表中数据的冗余，空间的浪费。\n13.1第一范式学生编号 学生姓名 联系方式\n\t------------------------------------------\n\t1001\t\t张三\t\tzs@gmail.com,1359999999\n\t1002\t\t李四\t\tls@gmail.com,13699999999\n\t1001\t\t王五\t\tww@163.net,13488888888\n\t\n以上是学生表，满足第一范式吗？\n\t不满足，第一：没有主键。第二：联系方式可以分为邮箱地址和电话\n\n学生编号(pk) 学生姓名\t邮箱地址\t\t\t联系电话\n----------------------------------------------------\n1001\t\t\t\t张三\t\tzs@gmail.com\t1359999999\n1002\t\t\t\t李四\t\tls@gmail.com\t13699999999\n1003\t\t\t\t王五\t\tww@163.net\t\t13488888888\n\n13.2第二范式\t学生编号 \t\t学生姓名 \t教师编号 教师姓名\n\t----------------------------------------------------\n\t1001\t\t\t张三\t\t001\t\t王老师\n\t1002\t\t\t李四\t\t002\t\t赵老师\n\t1003\t\t\t王五\t\t001\t\t王老师\n\t1001\t\t\t张三\t\t002\t\t赵老师\n这张表描述了学生和老师的关系：（1个学生可能有多个老师，1个老师有多个学生）\n这是非常典型的：多对多关系！\n\n分析以上的表是否满足第一范式？\n\t不满足第一范式。\n\n怎么满足第一范式呢？修改\n\n学生编号+教师编号(pk)\t\t学生姓名  教师姓名\n----------------------------------------------------\n1001\t\t\t001\t\t\t\t张三\t\t\t王老师\n1002\t\t\t002\t\t\t\t李四\t\t\t赵老师\n1003\t\t\t001\t\t\t\t王五\t\t\t王老师\n1001\t\t\t002\t\t\t\t张三\t\t\t赵老师\n\n学生编号 教师编号，两个字段联合做主键，复合主键（PK: 学生编号+教师编号）\n经过修改之后，以上的表满足了第一范式。但是满足第二范式吗？\n\t不满足，“张三”依赖1001，“王老师”依赖001，显然产生了部分依赖。\n\t产生部分依赖有什么缺点？\n\t\t数据冗余了。空间浪费了。“张三”重复了，“王老师”重复了。\n\n为了让以上的表满足第二范式，你需要这样设计：\n\t使用三张表来表示多对多的关系！！！！\n\t学生表\n\t学生编号(pk)\t\t学生名字\n\t------------------------------------\n\t1001\t\t\t\t\t张三\n\t1002\t\t\t\t\t李四\n\t1003\t\t\t\t\t王五\n\t\n\t教师表\n\t教师编号(pk)\t\t教师姓名\n\t--------------------------------------\n\t001\t\t\t\t\t王老师\n\t002\t\t\t\t\t赵老师\n\n\t学生教师关系表\n\tid(pk)\t\t\t学生编号(fk)\t\t\t教师编号(fk)\n\t------------------------------------------------------\n\t1\t\t\t\t\t\t1001\t\t\t\t\t\t001\n\t2\t\t\t\t\t\t1002\t\t\t\t\t\t002\n\t3\t\t\t\t\t\t1003\t\t\t\t\t\t001\n\t4\t\t\t\t\t\t1001\t\t\t\t\t\t002\n\n\n多对多，三张表，关系表两个外键！！！！！！！！！！！！！！！\n\n13.3第三范式​\t\n\t学生编号（PK） \t\t\t学生姓名  班级编号  \t班级名称\n---------------------------------------------------------\n\n​\t\t1001\t\t\t\t张三\t\t01\t\t\t一年一班\n​\t\t1002\t\t\t\t李四\t\t02\t\t\t一年二班\n​\t\t1003\t\t\t\t王五\t\t03\t\t\t一年三班\n​\t\t1004\t\t\t\t赵六\t\t03\t\t\t一年三班\n\n以上表的设计是描述：班级和学生的关系。很显然是1对多关系！\n一个教室中有多个学生。\n\n分析以上表是否满足第一范式？\n\t满足第一范式，有主键。\n\n分析以上表是否满足第二范式？\n\t满足第二范式，因为主键不是复合主键，没有产生部分依赖。主键是单一主键。\n\n分析以上表是否满足第三范式？\n\t第三范式要求：不要产生传递依赖！\n\t一年一班依赖01，01依赖1001，产生了传递依赖。\n\t不符合第三范式的要求。产生了数据的冗余。\n\n那么应该怎么设计一对多呢？\n\n\t班级表：一\n\t班级编号(pk)\t\t\t\t班级名称\n\t----------------------------------------\n\t01\t\t\t\t\t\t\t\t一年一班\n\t02\t\t\t\t\t\t\t\t一年二班\n\t03\t\t\t\t\t\t\t\t一年三班\n\n\t学生表：多\n\n\t学生编号（PK） 学生姓名 班级编号(fk)\n\t-------------------------------------------\n\t1001\t\t\t\t张三\t\t\t01\t\t\t\n\t1002\t\t\t\t李四\t\t\t02\t\t\t\n\t1003\t\t\t\t王五\t\t\t03\t\t\t\n\t1004\t\t\t\t赵六\t\t\t03\t\t\n\n\n一对多，两张表，多的表加外键！！！！！！！！！！！！\n\n关于三范式的实际使用\n数据库设计三范式是理论上的，实践和理论有的时候有偏差。\n最终的目的都是为了满足客户的需求，有的时候会拿冗余换执行速度。\n因为在sql当中，表和表之间连接次数越多，效率越低。（笛卡尔积）\n有的时候可能会存在冗余，但是为了减少表的连接次数，这样做也是合理的，并且对于开发人员来说，sql语句的编写难度也会降低。\n面试的时候把这句话说上：他就不会认为你是初级程序员了！\n","slug":"MYSQL","date":"2022-11-15T11:59:13.443Z","categories_index":"学习笔记","tags_index":"mysql","author_index":"Abyssaler"},{"id":"d689efbf93d434acdbec39ba18988ad9","title":"如何为浏览器配置Burp Suite代理","content":"如何为各浏览器配置Burp Suite代理首先需要确定你的burp suite是否配置好了代理\n如图，这里我是配置好了\nGoogle配置安装Proxy SwitchyOmega插件\n\n插件配置新建一个burp suite模式\n\n配置参数，注意这里要与你burp suite配置中的一致\n\n保存\n\n以后你想用chrome抓包就直接在这里选了\n\n可能遇到的问题首次抓取HTTPS时，浏览器会报安全问题\n\n解决办法\n\n在此页面访问http://burp\n\n\n\n点右上角下载ca证书\n\n\n在chrome中导入证书\n\n\n\n找到之前下载的证书的位置（如果找不到，打开所有文件选项）\n\n然后一直下一步导入就成功了\n\n\n其他浏览器配置思路大致相同","slug":"如何为各浏览器配置Burp Suite代理","date":"2022-11-15T07:43:18.390Z","categories_index":"环境配置","tags_index":"burp suite","author_index":"Abyssaler"},{"id":"7ed8089baf30886b0aa7735f2db515b2","title":"php怎么通过url传参","content":"php怎么通过url传参​\t目前正在学php基础,遇到一个困扰我的问题,那就是通过使用_GET[]的方式获取url中所传的参数中?的用途,如下图:\n\n123.php页面代码如图\n\n为什么通过在127.0.0.1&#x2F;php.123后面输入?target&#x3D;import.php后var_dump函数会把target当成关联数组里面的key从而取出target被赋予的值呢?这其中?起了什么作用\n通过了解得知,?表示传参,拿127.0.0.1&#x2F;php.123?target&#x3D;import.php举例子,?表示对当前php.123页面进行传参,传参的内容为名为target,值为import.php的这样一个参数.这引起了我的好奇,因为?在php语法中是一个三元运算符\n错误思路:三元运算符?作为三元运算符的的语法格式是:(expr1) ? (expr2) : (expr3),对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3.\n当我顺着这个思路再看url&#x2F;?target&#x3D;import.php这串代码时,怎么看怎么抽象,于是乎,继续查\n正解:url&#x2F;?x&#x3D;是php中的一项基本技巧通过检索网上其他的文章,得知使用url传递参数是php中的一项基本技巧，一般格式为url&#x2F;?x&#x3D;,这其中?是一种url固定的格式 ，在url格式中表示传参，这里不应该用php的语法去理解它。\n举例，如果要通过url传递一个参数n&#x3D;5，那么url应当为url&#x2F;?n&#x3D;5，php页面中应当包含如下代码：\n$n &#x3D; $_GET[‘n’];\n\n这就是一种固定的格式,纯粹是自己想多了…\n不过既然都查到这里来了,就顺便再深入一下\n显而易见，这种方法将会把参数暴露出来，安全系数较低。因此，可以有一种 URL 的编码方式，对 URL 传递的参数进行编码。以此让参数不可见\nurlencode(string)urlencode()函数实现将字符串 string 进行 URL 编码。应用urlencode()函数对 URL 传递的参数值进行编码，显示的字符串是URL 编码后的字符串，其实现的代码如下所示：\n&lt;?php\n$url &#x3D; urlencode(&quot;你想传入的参数&quot;);&#x2F;&#x2F;对参数编码\necho&quot;123.php?id&#x3D;&quot;.$url;\n?&gt;\n\n在浏览器中输入运行地址，按回车键，得到如下所示的运行结果：\nindex.php?id&#x3D;PHP%E4%B8%AD%E6%96%87%E7%BD%91\n\n这同时说明了对于服务器而言，编码前后的字符串并没有什么区别，服务器能够自动识别.\n","slug":"php怎么通过url传参","date":"2022-11-13T15:58:26.107Z","categories_index":"踩坑记录","tags_index":"php","author_index":"Abyssaler"},{"id":"e2beb8c86086697d45d0d68d245fa991","title":"PHP基础","content":"PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言\nPHP 是什么？\nPHP（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。\nPHP 脚本在服务器上执行。\nPHP 可免费下载使用。\n\nPHP 文件是什么？\nPHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码\nPHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器\nPHP 文件的默认文件扩展名是 “.php”\n\nPHP 能做什么？\nPHP 可以生成动态页面内容\nPHP 可以创建、打开、读取、写入、关闭服务器上的文件\nPHP 可以收集表单数据\nPHP 可以发送和接收 cookies\nPHP 可以添加、删除、修改您的数据库中的数据\nPHP 可以限制用户访问您的网站上的一些页面\nPHP 可以加密数据\n\n为什么使用 PHP？\nPHP 可在不同的平台上运行（Windows、Linux、Unix、Mac OS X 等）\nPHP 与目前几乎所有的正在被使用的服务器相兼容（Apache、IIS 等）\nPHP 提供了广泛的数据库支持\nPHP 易于学习，并可高效地运行在服务器端\n\nPHP语法PHP 脚本可以放在文档中的任何位置。\nPHP 脚本以  结束：\nPHP 文件的默认文件扩展名是 “.php”。\nPHP 文件通常包含 HTML 标签和一些 PHP 脚本代码。\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;h1&gt;My first PHP page&lt;&#x2F;h1&gt;\n\n&lt;?php\necho &quot;Hello World!&quot;;\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nPHP 中的每个代码行都必须以分号结束。分号是一种分隔符，用于把指令集区分开来。\n通过 PHP，有两种在浏览器输出文本的基础指令：echo 和 print。\nPHP 注释\n&#x2F;&#x2F;      单行注释\n&#x2F;*  *&#x2F;   多行注释\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n&#x2F;&#x2F; 这是 PHP 单行注释\n\n&#x2F;*\n这是\nPHP 多行\n注释\n*&#x2F;\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n变量变量是用于存储信息的”容器”\n&lt;?php\n$x&#x3D;5;\n$y&#x3D;6;\n$z&#x3D;$x+$y;\necho $z;\n?&gt;\n\n\n\nPHP 变量规则\n\n变量以 $ 符号开始，后面跟着变量的名称\n变量名必须以字母或者下划线字符开始\n变量名只能包含字母、数字以及下划线（A-z、0-9 和 _ ）\n变量名不能包含空格\n变量名是区分大小写的（$y 和 $Y 是两个不同的变量）\n\n创建PHP变量PHP 没有声明变量的命令。\n变量在您第一次赋值给它的时候被创建\n&lt;?php\n$txt&#x3D;&quot;Hello world!&quot;;\n$x&#x3D;5;\n$y&#x3D;10.5;\n?&gt;\n\n在上面的语句执行中，变量 txt 将保存值 **Hello world!**，且变量 x 将保存值 5。\n注释：当您赋一个文本值给变量时，请在文本值两侧加上引号。\nPHP 是一门弱类型语言PHP 会根据变量的值，自动把变量转换为正确的数据类型。\n在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。\necho 和 print 语句echo 和 print 区别:\n\necho - 可以输出一个或多个字符串\nprint - 只允许输出一个字符串，返回值总为 1\n\n提示：echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。\necho 是一个语言结构，使用的时候可以不用加括号，也可以加上括号： echo 或 echo()。\n显示字符串\n&lt;?php\necho &quot;&lt;h2&gt;PHP 很有趣!&lt;&#x2F;h2&gt;&quot;;\necho &quot;Hello world!&lt;br&gt;&quot;;\necho &quot;我要学 PHP!&lt;br&gt;&quot;;\necho &quot;这是一个&quot;, &quot;字符串，&quot;, &quot;使用了&quot;, &quot;多个&quot;, &quot;参数。&quot;;\n?&gt;\n\n\n\n显示变量\n&lt;?php\n$txt1&#x3D;&quot;学习 PHP&quot;;\n$txt2&#x3D;&quot;xbxaq.com&quot;;\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\n \necho $txt1;\necho &quot;&lt;br&gt;&quot;;\necho &quot;在 $txt2 学习 PHP &quot;;\necho &quot;&lt;br&gt;&quot;;\necho &quot;我车的品牌是 &#123;$cars[0]&#125;&quot;;\n?&gt;\n\n\n\nprint 同样是一个语言结构，可以使用括号，也可以不使用括号： print 或 print()。\n显示字符串\n&lt;?php\nprint &quot;&lt;h2&gt;PHP 很有趣!&lt;&#x2F;h2&gt;&quot;;\nprint &quot;Hello world!&lt;br&gt;&quot;;\nprint &quot;我要学习 PHP!&quot;;\n?&gt;\n\n\n\n显示变量\n&lt;?php\n$txt1&#x3D;&quot;学习 PHP&quot;;\n$txt2&#x3D;&quot;xbxaq.COM&quot;;\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\n \nprint $txt1;\nprint &quot;&lt;br&gt;&quot;;\nprint &quot;在 $txt2 学习 PHP &quot;;\nprint &quot;&lt;br&gt;&quot;;\nprint &quot;我车的品牌是 &#123;$cars[0]&#125;&quot;;\n?&gt;\n\n\n\n数据类型PHP 变量存储不同的类型的数据，不同的数据类型可以做不一样的事情。\nPHP 支持以下几种数据类型:\n\nString（字符串）\nInteger（整型）\nFloat（浮点型）\nBoolean（布尔型）\nArray（数组）\nObject（对象）\nNULL（空值）\nResource（资源类型）\n\n字符串一个字符串是一串字符的序列，就像 “Hello world!”。\n你可以将任何文本放在单引号和双引号中\n&lt;?php \n$x &#x3D; &quot;Hello world!&quot;;\necho $x;\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; &#39;Hello world!&#39;;\necho $x;\n?&gt;\n\n\n\n整型整数是一个没有小数的数字。\n整数规则:\n\n整数必须至少有一个数字 (0-9)\n整数不能包含逗号或空格\n整数是没有小数点的\n整数可以是正数或负数\n整型可以用三种格式来指定：十进制， 十六进制（ 以 0x 为前缀）或八进制（前缀为 0）。\n\nPHP var_dump() 函数返回变量的数据类型和值\n&lt;?php \n$x &#x3D; 5985;\nvar_dump($x);\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; -345; &#x2F;&#x2F; 负数 \nvar_dump($x);\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; 0x8C; &#x2F;&#x2F; 十六进制数\nvar_dump($x);\necho &quot;&lt;br&gt;&quot;;\n$x &#x3D; 047; &#x2F;&#x2F; 八进制数\nvar_dump($x);\n?&gt;\n\n\n\n浮点型浮点数是带小数部分的数字，或是指数形式\n&lt;?php \n$x &#x3D; 10.365;\nvar_dump($x);\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; 2.4e3;\nvar_dump($x);\necho &quot;&lt;br&gt;&quot;; \n$x &#x3D; 8E-5;\nvar_dump($x);\n?&gt;\n\n\n\n布尔型布尔型可以是 TRUE 或 FALSE\n布尔型通常用于条件判断\n数组数组可以在一个变量中存储多个值\n&lt;?php \n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\nvar_dump($cars);\n?&gt;\n\n\n\n对象对象数据类型也可以用于存储数据。\n在 PHP 中，对象必须声明。\n首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。\n然后我们在类中定义数据类型，然后在实例化的类中使用数据类型\n&lt;?php\nclass Car\n&#123;\n  var $color;\n  function __construct($color&#x3D;&quot;green&quot;) &#123;\n    $this-&gt;color &#x3D; $color;\n  &#125;\n  function what_color() &#123;\n    return $this-&gt;color;\n  &#125;\n&#125;\n?&gt;\n\n\n\nNULL 值NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。\nNULL 值指明一个变量是否为空值。 同样可用于数据空值和NULL值的区别。\n可以通过设置变量值为 NULL 来清空变量数据\n&lt;?php\n$x&#x3D;&quot;Hello world!&quot;;\n$x&#x3D;null;\nvar_dump($x);\n?&gt;\n\n\n\n类型比较虽然 PHP 是弱类型语言，但也需要明白变量类型及它们的意义，因为我们经常需要对 PHP 变量进行比较，包含松散和严格比较。\n\n松散比较：使用两个等号 &#x3D;&#x3D; 比较，只比较值，不比较类型。\n严格比较：用三个等号 &#x3D;&#x3D;&#x3D; 比较，除了比较值，也比较类型。\n\n例如，”42” 是一个字符串而 42 是一个整数。FALSE 是一个布尔值而 “FALSE” 是一个字符串。\n&lt;?php\nif(42 &#x3D;&#x3D; &quot;42&quot;) &#123;\n    echo &#39;1、值相等&#39;;\n&#125;\n \necho PHP_EOL; &#x2F;&#x2F; 换行符\n \nif(42 &#x3D;&#x3D;&#x3D; &quot;42&quot;) &#123;\n    echo &#39;2、类型相等&#39;;\n&#125; else &#123;\n    echo &#39;3、类型不相等&#39;;\n&#125;\n?&gt;\n\n\n\nPHP中 比较 0、false、null&lt;?php\necho &#39;0 &#x3D;&#x3D; false: &#39;;\nvar_dump(0 &#x3D;&#x3D; false);\necho &#39;0 &#x3D;&#x3D;&#x3D; false: &#39;;\nvar_dump(0 &#x3D;&#x3D;&#x3D; false);\necho PHP_EOL;\necho &#39;0 &#x3D;&#x3D; null: &#39;;\nvar_dump(0 &#x3D;&#x3D; null);\necho &#39;0 &#x3D;&#x3D;&#x3D; null: &#39;;\nvar_dump(0 &#x3D;&#x3D;&#x3D; null);\necho PHP_EOL;\necho &#39;false &#x3D;&#x3D; null: &#39;;\nvar_dump(false &#x3D;&#x3D; null);\necho &#39;false &#x3D;&#x3D;&#x3D; null: &#39;;\nvar_dump(false &#x3D;&#x3D;&#x3D; null);\necho PHP_EOL;\necho &#39;&quot;0&quot; &#x3D;&#x3D; false: &#39;;\nvar_dump(&quot;0&quot; &#x3D;&#x3D; false);\necho &#39;&quot;0&quot; &#x3D;&#x3D;&#x3D; false: &#39;;\nvar_dump(&quot;0&quot; &#x3D;&#x3D;&#x3D; false);\necho PHP_EOL;\necho &#39;&quot;0&quot; &#x3D;&#x3D; null: &#39;;\nvar_dump(&quot;0&quot; &#x3D;&#x3D; null);\necho &#39;&quot;0&quot; &#x3D;&#x3D;&#x3D; null: &#39;;\nvar_dump(&quot;0&quot; &#x3D;&#x3D;&#x3D; null);\necho PHP_EOL;\necho &#39;&quot;&quot; &#x3D;&#x3D; false: &#39;;\nvar_dump(&quot;&quot; &#x3D;&#x3D; false);\necho &#39;&quot;&quot; &#x3D;&#x3D;&#x3D; false: &#39;;\nvar_dump(&quot;&quot; &#x3D;&#x3D;&#x3D; false);\necho PHP_EOL;\necho &#39;&quot;&quot; &#x3D;&#x3D; null: &#39;;\nvar_dump(&quot;&quot; &#x3D;&#x3D; null);\necho &#39;&quot;&quot; &#x3D;&#x3D;&#x3D; null: &#39;;\nvar_dump(&quot;&quot; &#x3D;&#x3D;&#x3D; null);\n\n\n\n常量常量值被定义后，在脚本的其他任何地方都不能被改变\n常量是一个简单值的标识符。该值在脚本中不能改变。\n一个常量由英文字母、下划线、和数字组成,但数字不能作为首字母出现。 (常量名不需要加 $ 修饰符)。\n注意： 常量在整个脚本中都可以使用。\n设置常量，使用 define() 函数，函数语法如下\nbool define ( string $name , mixed $value [, bool $case_insensitive &#x3D; false ] )\n\n该函数有三个参数:\n\nname：必选参数，常量名称，即标志符。\nvalue：必选参数，常量的值。\ncase_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。\n\n创建一个 区分大小写的常量, 常量值为 “欢迎访问 xbxaq.com”\n&lt;?php\n&#x2F;&#x2F; 区分大小写的常量名\ndefine(&quot;GREETING&quot;, &quot;欢迎访问 xbxaq.com&quot;);\necho GREETING;    &#x2F;&#x2F; 输出 \necho &#39;&lt;br&gt;&#39;;\necho greeting;   &#x2F;&#x2F; 输出 &quot;greeting&quot;，但是有警告信息，表示该常量未定义\n?&gt;\n\n\n\n运算符 PHP 中，赋值运算符 &#x3D; 用于给变量赋值。\n在 PHP 中，算术运算符 + 用于把值加在一起。\n算术运算符&lt;?php \n$x&#x3D;10; \n$y&#x3D;6;\necho ($x + $y); &#x2F;&#x2F; 输出16\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho ($x - $y); &#x2F;&#x2F; 输出4\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho ($x * $y); &#x2F;&#x2F; 输出60\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho ($x &#x2F; $y); &#x2F;&#x2F; 输出1.6666666666667\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho ($x % $y); &#x2F;&#x2F; 输出4\necho &#39;&lt;br&gt;&#39;;  &#x2F;&#x2F; 换行\n \necho -$x;\n?&gt;\n\n\n\n赋值运算符&lt;?php \n$x&#x3D;10; \necho $x; &#x2F;&#x2F; 输出10\n \n$y&#x3D;20; \n$y +&#x3D; 100;\necho $y; &#x2F;&#x2F; 输出120\n \n$z&#x3D;50;\n$z -&#x3D; 25;\necho $z; &#x2F;&#x2F; 输出25\n \n$i&#x3D;5;\n$i *&#x3D; 6;\necho $i; &#x2F;&#x2F; 输出30\n \n$j&#x3D;10;\n$j &#x2F;&#x3D; 5;\necho $j; &#x2F;&#x2F; 输出2\n \n$k&#x3D;15;\n$k %&#x3D; 4;\necho $k; &#x2F;&#x2F; 输出3\n?&gt;\n\n\n\n递增&#x2F;递减运算符&lt;?php\n$x&#x3D;10; \necho ++$x; &#x2F;&#x2F; 输出11\n \n$y&#x3D;10; \necho $y++; &#x2F;&#x2F; 输出10\n \n$z&#x3D;5;\necho --$z; &#x2F;&#x2F; 输出4\n \n$i&#x3D;5;\necho $i--; &#x2F;&#x2F; 输出5\n?&gt;\n\n\n\n比较运算符&lt;?php\n$x&#x3D;100; \n$y&#x3D;&quot;100&quot;;\n \nvar_dump($x &#x3D;&#x3D; $y);\necho &quot;&lt;br&gt;&quot;;\nvar_dump($x &#x3D;&#x3D;&#x3D; $y);\necho &quot;&lt;br&gt;&quot;;\nvar_dump($x !&#x3D; $y);\necho &quot;&lt;br&gt;&quot;;\nvar_dump($x !&#x3D;&#x3D; $y);\necho &quot;&lt;br&gt;&quot;;\n \n$a&#x3D;50;\n$b&#x3D;90;\n \nvar_dump($a &gt; $b);\necho &quot;&lt;br&gt;&quot;;\nvar_dump($a &lt; $b);\n?&gt;\n\n\n\n三元运算符语法格式(expr1) ? (expr2) : (expr3) \n\n对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3。\n条件语句您编写代码时，您常常需要为不同的判断执行不同的动作。您可以在代码中使用条件语句来完成此任务。\n在 PHP 中，提供了下列条件语句：\n\nif 语句 - 在条件成立时执行代码\nif…else 语句 - 在条件成立时执行一块代码，条件不成立时执行另一块代码\nif…elseif….else 语句 - 在若干条件之一成立时执行一个代码块\nswitch 语句 - 在若干条件之一成立时执行一个代码块\n\nif 语句用于仅当指定条件成立时执行代码\n语法if (条件)\n&#123;\n    条件成立时要执行的代码;\n&#125;\n\n&lt;?php\n$t&#x3D;date(&quot;H&quot;);\nif ($t&lt;&quot;20&quot;)\n&#123;\n    echo &quot;Have a good day!&quot;;\n&#125;\n?&gt;\n\n\n\nif…else 语句在条件成立时执行一块代码，条件不成立时执行另一块代码，请使用 if….else 语句。\n语法if (条件)\n&#123;\n条件成立时执行的代码;\n&#125;\nelse\n&#123;\n条件不成立时执行的代码;\n&#125;\n\n\n\n&lt;?php\n$t&#x3D;date(&quot;H&quot;);\nif ($t&lt;&quot;20&quot;)\n&#123;\n    echo &quot;Have a good day!&quot;;\n&#125;\nelse\n&#123;\n    echo &quot;Have a good night!&quot;;\n&#125;\n?&gt;\n\n\n\nif…elseif….else 语句在若干条件之一成立时执行一个代码块，请使用 if….elseif…else 语句。.\n语法if (条件)\n&#123;\n    if 条件成立时执行的代码;\n&#125;\nelseif (条件)\n&#123;\n    elseif 条件成立时执行的代码;\n&#125;\nelse\n&#123;\n    条件不成立时执行的代码;\n&#125;\n\n\n\n&lt;?php\n$t&#x3D;date(&quot;H&quot;);\nif ($t&lt;&quot;10&quot;)\n&#123;\n    echo &quot;Have a good morning!&quot;;\n&#125;\nelseif ($t&lt;&quot;20&quot;)\n&#123;\n    echo &quot;Have a good day!&quot;;\n&#125;\nelse\n&#123;\n    echo &quot;Have a good night!&quot;;\n&#125;\n?&gt;\n\n\n\nSwitch 语句switch 语句用于根据多个不同条件执行不同动作。\n如果您希望有选择地执行若干代码块之一，请使用 switch 语句。\n&lt;?php\n$favcolor&#x3D;&quot;red&quot;;\nswitch ($favcolor)\n&#123;\ncase &quot;red&quot;:\n    echo &quot;你喜欢的颜色是红色!&quot;;\n    break;\ncase &quot;blue&quot;:\n    echo &quot;你喜欢的颜色是蓝色!&quot;;\n    break;\ncase &quot;green&quot;:\n    echo &quot;你喜欢的颜色是绿色!&quot;;\n    break;\ndefault:\n    echo &quot;你喜欢的颜色不是 红, 蓝, 或绿色!&quot;;\n&#125;\n?&gt;\n\n\n\n数组数组能够在单个变量中存储多个值\n数组可以在单个变量中存储多个值，并且您可以根据键访问其中的值。\n&lt;?php\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\necho &quot;I like &quot; . $cars[0] . &quot;, &quot; . $cars[1] . &quot; and &quot; . $cars[2] . &quot;.&quot;;\n?&gt;\n\n\n\n创建数组在 PHP 中，array() 函数用于创建数组：\narray();\n\n\n\n在 PHP 中，有三种类型的数组：\n\n数值数组 - 带有数字 ID 键的数组\n关联数组 - 带有指定的键的数组，每个键关联一个值\n多维数组 - 包含一个或多个数组的数组\n\n数值数组这里有两种创建数值数组的方法：\n自动分配 ID 键（ID 键总是从 0 开始）：\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\n\n&lt;?php\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\necho &quot;I like &quot; . $cars[0] . &quot;, &quot; . $cars[1] . &quot; and &quot; . $cars[2] . &quot;.&quot;;\n?&gt;\n\n\n\n获取数组的长度 - count() 函数count() 函数用于返回数组的长度（元素的数量）\n&lt;?php\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\necho count($cars);\n?&gt;\n\n\n\n遍历数值数组遍历并打印数值数组中的所有值，您可以使用 for 循环\n&lt;?php\n$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);\n$arrlength&#x3D;count($cars);\n \nfor($x&#x3D;0;$x&lt;$arrlength;$x++)\n&#123;\n    echo $cars[$x];\n    echo &quot;&lt;br&gt;&quot;;\n&#125;\n?&gt;\n\n\n\n关联数组关联数组是使用您分配给数组的指定的键的数组。\n这里有两种创建关联数组的方法\n$age&#x3D;array(&quot;Peter&quot;&#x3D;&gt;&quot;35&quot;,&quot;Ben&quot;&#x3D;&gt;&quot;37&quot;,&quot;Joe&quot;&#x3D;&gt;&quot;43&quot;);\n\nor\n\n$age[&#39;Peter&#39;]&#x3D;&quot;35&quot;;\n$age[&#39;Ben&#39;]&#x3D;&quot;37&quot;;\n$age[&#39;Joe&#39;]&#x3D;&quot;43&quot;;\n\n\n\n&lt;?php\n$age&#x3D;array(&quot;Peter&quot;&#x3D;&gt;&quot;35&quot;,&quot;Ben&quot;&#x3D;&gt;&quot;37&quot;,&quot;Joe&quot;&#x3D;&gt;&quot;43&quot;);\necho &quot;Peter is &quot; . $age[&#39;Peter&#39;] . &quot; years old.&quot;;\n?&gt;\n\n\n\n遍历关联数组遍历并打印关联数组中的所有值，您可以使用 foreach 循环\n&lt;?php\n$age&#x3D;array(&quot;Peter&quot;&#x3D;&gt;&quot;35&quot;,&quot;Ben&quot;&#x3D;&gt;&quot;37&quot;,&quot;Joe&quot;&#x3D;&gt;&quot;43&quot;);\n \nforeach($age as $x&#x3D;&gt;$x_value)\n&#123;\n    echo &quot;Key&#x3D;&quot; . $x . &quot;, Value&#x3D;&quot; . $x_value;\n    echo &quot;&lt;br&gt;&quot;;\n&#125;\n?&gt;\n\n\n\n循环循环执行代码块指定的次数，或者当指定的条件为真时循环执行代码块。\n在 PHP 中，提供了下列循环语句：\n\nwhile - 只要指定的条件成立，则循环执行代码块\ndo…while - 首先执行一次代码块，然后在指定的条件成立时重复这个循环\nfor - 循环执行代码块指定的次数\nforeach - 根据数组中每个元素来循环代码块\n\nwhile 循环while 循环将重复执行代码块，直到指定的条件不成立。\n语法while (条件)\n&#123;\n    要执行的代码;\n&#125;\n\n\n\n实例首先设置变量 i 的值为 1 ($i&#x3D;1;)。\n然后，只要 i 小于或者等于 5，while 循环将继续运行。循环每运行一次，i 就会递增 1：\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n$i&#x3D;1;\nwhile($i&lt;&#x3D;5)\n&#123;\n    echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;;\n    $i++;\n&#125;\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\ndo…while 语句do…while 语句会至少执行一次代码，然后检查条件，只要条件成立，就会重复进行循环。\n语法do\n&#123;\n    要执行的代码;\n&#125;\nwhile (条件);\n\n\n\n实例首先设置变量 i 的值为 1 ($i&#x3D;1;)。\n然后，开始 do…while 循环。循环将变量 i 的值递增 1，然后输出。先检查条件（i 小于或者等于 5），只要 i 小于或者等于 5，循环将继续运行\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n$i&#x3D;1;\ndo\n&#123;\n    $i++;\n    echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;;\n&#125;\nwhile ($i&lt;&#x3D;5);\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nFor 循环for 循环用于您预先知道脚本需要运行的次数的情况。\n语法for (初始值; 条件; 增量)\n&#123;\n    要执行的代码;\n&#125;\n\n参数：\n\n初始值：主要是初始化一个变量值，用于设置一个计数器（但可以是任何在循环的开始被执行一次的代码）。\n条件：循环执行的限制条件。如果为 TRUE，则循环继续。如果为 FALSE，则循环结束。\n增量：主要用于递增计数器（但可以是任何在循环的结束被执行的代码）。\n\n注释：上面的初始值和增量参数可为空，或者有多个表达式（用逗号分隔）。\n实例下面的实例定义一个初始值为 i&#x3D;1 的循环。只要变量 i 小于或者等于 5，循环将继续运行。循环每运行一次，变量 i 就会递增 1\n&lt;?php\nfor ($i&#x3D;1; $i&lt;&#x3D;5; $i++)\n&#123;\n    echo &quot;数字为 &quot; . $i;\n&#125;\n?&gt;\n\n\n\nforeach 循环foreach 循环用于遍历数组。\n语法foreach ($array as $value)\n&#123;\n    要执行代码;\n&#125;\n\n每进行一次循环，当前数组元素的值就会被赋值给 $value 变量（数组指针会逐一地移动），在进行下一次循环时，您将看到数组中的下一个值。\nforeach ($array as $key &#x3D;&gt; $value)\n&#123;\n    要执行代码;\n&#125;\n\n每一次循环，当前数组元素的键与值就都会被赋值给 $key 和 $value 变量（数字指针会逐一地移动），在进行下一次循环时，你将看到数组中的下一个键与值。\n&lt;?php\n$x&#x3D;array(&quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;);\nforeach ($x as $value)\n&#123;\n    echo $value . PHP_EOL;\n&#125;\n?&gt;\n\n\n\n&lt;?php\n$x&#x3D;array(1&#x3D;&gt;&quot;Google&quot;, 2&#x3D;&gt;&quot;Runoob&quot;, 3&#x3D;&gt;&quot;Taobao&quot;);\nforeach ($x as $key &#x3D;&gt; $value)\n&#123;\n    echo &quot;key  为 &quot; . $key . &quot;，对应的 value 为 &quot;. $value . PHP_EOL;\n&#125;\n?&gt;\n\n\n\n函数创建 PHP 函数函数是通过调用函数来执行的。\n&lt;?php\nfunction functionName()\n&#123;\n    &#x2F;&#x2F; 要执行的代码\n&#125;\n?&gt;\n\n函数准则：\n\n函数的名称应该提示出它的功能\n函数名称以字母或下划线开头（不能以数字开头）\n\n&lt;?php\nfunction writeName()\n&#123;\n    echo &quot;Kai Jim Refsnes&quot;;\n&#125;\n \necho &quot;My name is &quot;;\nwriteName();\n?&gt;\n\n\n\n函数 - 添加参数为了给函数添加更多的功能，我们可以添加参数，参数类似变量。\n参数就在函数名称后面的一个括号内指定。\n&lt;?php\nfunction writeName($fname)\n&#123;\n    echo $fname . &quot; Refsnes.&lt;br&gt;&quot;;\n&#125;\n \necho &quot;My name is &quot;;\nwriteName(&quot;Kai Jim&quot;);\necho &quot;My sister&#39;s name is &quot;;\nwriteName(&quot;Hege&quot;);\necho &quot;My brother&#39;s name is &quot;;\nwriteName(&quot;Stale&quot;);\n?&gt;\n\n\n\n&lt;?php\nfunction writeName($fname,$punctuation)\n&#123;\n    echo $fname . &quot; Refsnes&quot; . $punctuation . &quot;&lt;br&gt;&quot;;\n&#125;\n \necho &quot;My name is &quot;;\nwriteName(&quot;Kai Jim&quot;,&quot;.&quot;);\necho &quot;My sister&#39;s name is &quot;;\nwriteName(&quot;Hege&quot;,&quot;!&quot;);\necho &quot;My brother&#39;s name is &quot;;\nwriteName(&quot;Ståle&quot;,&quot;?&quot;);\n?&gt;\n\n\n\n函数 - 返回值如需让函数返回一个值，请使用 return 语句\n&lt;?php\nfunction add($x,$y)\n&#123;\n    $total&#x3D;$x+$y;\n    return $total;\n&#125;\n \necho &quot;1 + 16 &#x3D; &quot; . add(1,16);\n?&gt;\n\n\n\n","slug":"01PHP基础","date":"2022-11-11T10:11:42.437Z","categories_index":"学习笔记","tags_index":"php","author_index":"Abyssaler"},{"id":"bd6f30a22217917d2172ab3a5accd3dc","title":"PHP正则表达式","content":"正则表达式正则表达式存在的意义：过滤和检索。\n正则表达式，又称规则表达式（Regular Expression ）常简写为regex，regexp，RE;\n作用正则表达式通常被用来检索、替换符合规则的文本\n特点\n灵活性、逻辑性和功能性强\n可以快速地用极简单的方式达到支付出的复杂控制\n\n用途\n判断字符串是否符合某规则\n从一个字符串中找出符合规则的所以子字符串\n\n常用字符\n\n\n说明\n符号\n\n\n\n数字\n\\d\n\n\n非字符\n\\D\n\n\n空白字符（空格、制表符、换页符等）\n\\s\n\n\n非空白字符\n\\S\n\n\n制表符\n\\t\n\n\n回车符\n\\r\n\n\n换行符\n\\n\n\n\n单词字符（26个英文字母+数字+下划线）\n\\w\n\n\n非单词字符\n\\W\n\n\n字符集合字符集合：[ 单个字符或字符区间] ，用于匹配集合内字符\n\n如：\n\n[a-z]    表示a-z   26个小写字母\n[ 0-9a-h] 表示0-9 10个数字和a-z 8个字母\n[134a-h] 表示包含数字1，3，5和字母a-h 8个字母\n\n注意：两个不同字符段间请勿使用逗号，隔开\n反选字符非集：[\\^单个字符或区间]，用于匹配非集合内字符]\n\n\n反选字符：^\t\n\n[^]  注意：中括号内^ 才是反选\n\n[^0-9]  表示匹配所有非数字字符\n\n[^a-zA-Z] 表示匹配所有非字母字符\n\n\n关键字\n\n\n关键字\n描述\n\n\n\n^\n匹配输入字符串的开始位置\n\n\n$\n匹配输入字符串的结尾位置\n\n\n（）\n标记一个子表达式的开始和结束位置\n\n\n*\n匹配前面的子表达式零次或多次\n\n\n+\n匹配前面的子表达式一次或多次\n\n\n.\n匹配除换行符\\n之外的任意单个字符\n\n\n[\n标记一个中括号表达式的开始\n\n\n？\n匹配前面的子表达式零次或一次\n\n\n\\\n将下一个字符标记为特殊字符原来的本意\n\n\n{\n标记限定符表达式的开始\n\n\n|\n指明两项之间的一项\n\n\n限定符\n\n\n字符\n描述\n\n\n\n{n}\nn为非负数，匹配连续的字符n次\n\n\n{n,}\nn为非负数，匹配连续的字符n次及以上\n\n\n{n，m}\nn、m均为非负数，n &lt;&#x3D;m,匹配连续的字符 至少n次，至多m次\n\n\n修饰符​\t\n\n\n\n修饰符\n描述\n\n\n\n&#x2F;i\n不区分大小写\n\n\n&#x2F;A\n匹配规则必须从头开始匹配\n\n\n&#x2F;s\n将匹配一切字符\n\n\n&#x2F;X\n正则表达式中的空白字符将会被忽略\n\n\n注意：写在正则表达式的“外面“    &#x2F;a&#x2F;i\n函数PHP中使用正则表达式一定要加&#x2F; 正则表达式内容  &#x2F;\n\npreg_match(正则表达式，匹配的字符串)\n匹配第一个匹配正则的子字符串，未找到返回0.找到返回1\n\npreg_grep()\n匹配第一个匹配正则的字符串数组，包含匹配的字符串和匹配的单元\n\npreg_match_all(正则表达式，匹配的字符串，输出的二维数组)\n能匹配所有的子字符串，返回子字符串匹配的数量\n\npre_replace(正则表达式，替换的字符串，匹配的字符串)\n将所有匹配正则表达式的字符串进行替换\n\n\n","slug":"06PHP正则表达式","date":"2022-11-11T09:18:48.428Z","categories_index":"学习笔记","tags_index":"php","author_index":"Abyssaler"},{"id":"768203e0c226cf15b0e3763fb1a90bc7","title":"暴力破解思路","content":"WEB漏洞：暴力破解密码爆破的本质：依赖字典，连续性的，自动化的尝试密码登陆爆破\n1）密码爆破思路方式一：尝试爆破：假设密码长度6，每位有126种可能。那么需要尝试126^6次。\n\n方式二：使用字典​     思考：字典从何而来？ \n参考泄露出来的最长使用的密码排名前200：\nhttps:&#x2F;&#x2F;nordpass.com&#x2F;most-common-passwords-list&#x2F;\n网络下载密码本\n密码生成器\n\n\n​      \n方式三：使用POC实现爆破POC实现爆破，python代码实现爆破：\n1、读取字典，加载密码\n2、发起http连接\n3、分析HTTP响应\n4、持续自动化爆破\n\n代码：\nreadpass.py\n# -*- coding: utf-8 -*-\n# python 3\n\npwds &#x3D; open(&quot;password.txt&quot;)\nfor pwd in pwds:\n    print(pwd)\n\npwds.close()\n\nhttpconn.py\n# -*- coding: utf-8 -*-\n# python 3\n\nimport requests\n\npwds &#x3D; open(&quot;password.txt&quot;)\nfor pwd in pwds:\n    url &#x3D; &quot;http:&#x2F;&#x2F;localhost&#x2F;DVWA-master&#x2F;vulnerabilities&#x2F;brute&#x2F;&quot;\n    # PHPSESSID务必替换为登录以后的PHPSESSID\n    resp &#x3D; requests.get(url &#x3D; url, params &#x3D; &#123;&quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:pwd.strip(), &quot;Login&quot;:&quot;Login&quot;&#125;, headers &#x3D; &#123;&quot;Cookie&quot;:&quot;security&#x3D;low; PHPSESSID&#x3D;0hhidoi7h1ln7jo9h2h0tgfnn6&quot;&#125;)\n    #print(resp.text)\n    if &#39;Username and&#x2F;or password incorrect.&#39; in resp.text:\n        print(&#39;破解失败：&#39;+pwd, end&#x3D;&#39;&#39;)\n    else:\n        print(&#39;破解成功：&#39;+pwd, end&#x3D;&#39;&#39;)\n        break;\npwds.close()\n\n2） DVWA靶场环境准备：下载代码： https://dvwa.co.uk/\n配置数据库：修改config&#x2F;config.inc.php\n部署到phpstudy\n注意是登录以后才可以使用暴破场景，而不是暴破首页的登录功能\n3）暴力破解实现使用python代码破解DVWA靶场使用工具BP实现爆破4）BP的攻击模式攻击模式一：狙击手\n发起爆破：\n\n攻击结果：\n\n攻击模式二：攻城锤Battering ram\n\n攻城锤模式，使用一个字典，两个节点的值一样：\n\n攻击模式三：草叉模式Pitchfork\n选择两个字典：\n\n\n攻击结果：一共发起10次请求，每一次请求使用第一个字典的第一个值和第二个字典的第一个值匹配，依次类推：\n\n攻击模式四：集束炸弹Cluster bomb\n使用两个字典：\n\n\n攻击结果：笛卡尔积，一共发起100次请求，爆破成功：\n\n5）防御DVWA-medium  ：sleep两秒\nDVWA-high: 随机sleep 0-3秒   ，  增加CSRF token（客户端请求伪造token）\nBP拦截：\n\n选择草叉模式：\n\n加载第一个字典：\n\n第二个参数，是需要从上一次请求中的token种得到：\n设置Options：匹配到前后的正则表达式，那么就是token：\n\n设置payloads：\n\n设置单线程：\n\n爆破结果：\n\n添加提示：\n\n点击Add：\n\n爆破结果：\n\nDvwa-impossible：限定次数：输错三次，锁定15分钟\n支付宝设置的防御机制：\n\n二次验证加固：\n\n人机识别加固：\n\n\n","slug":"暴力破解","date":"2022-11-11T01:21:04.000Z","categories_index":"学习笔记","tags_index":"密码破解","author_index":"Abyssaler"},{"id":"677084f9c18037c17104fff897e28f62","title":"Front-Meta属性","content":"Aurora中文章的Front-Meta属性新建文章配置\n\n\n配置选项\n默认值\n描述\n\n\n\ntitle\nMarkdown 的文件标题\n文章标题，强烈建议填写此选项\n\n\ndate\n文件创建时的日期时间\n发布时间，强烈建议填写此选项，且最好保证全局唯一\n\n\nauthor\n根 _config.yml 中的 author\n文章作者\n\n\nimg\nfeatureImages 中的某个值\n文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.\n\n\ntop\ntrue\n推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章\n\n\ncover\nfalse\nv1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中\n\n\ncoverImg\n无\nv1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片\n\n\npassword\n无\n文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项\n\n\ntoc\ntrue\n是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项\n\n\nmathjax\nfalse\n是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行\n\n\nsummary\n无\n文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要\n\n\ncategories\n无\n文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类\n\n\ntags\n无\n文章标签，一篇文章可以多个标签\n\n\n更多markdown语法参考:\n\n\n\n\n\n\n\n\n\nhttps://github.com/Sakiyary/Markdown-Typora-VSCode-Doc\n","slug":"文章开头格式","date":"2022-11-10T14:13:43.591Z","categories_index":"环境配置","tags_index":"markdown","author_index":"Abyssaler"},{"id":"e8eeb095a66f2218f43f6c5e63475a56","title":"PHP连接mysql数据库","content":"通过 PHP，您可以连接和操作数据库。\n连接 MySQL在我们访问 MySQL 数据库前，我们需要先连接到数据库服务器\n(MySQLi - 面向对象）&lt;?php\n$servername &#x3D; &quot;localhost&quot;;\n$username &#x3D; &quot;username&quot;;\n$password &#x3D; &quot;password&quot;;\n \n&#x2F;&#x2F; 创建连接\n$conn &#x3D; new mysqli($servername, $username, $password);\n \n&#x2F;&#x2F; 检测连接\nif ($conn-&gt;connect_error) &#123;\n    die(&quot;连接失败: &quot; . $conn-&gt;connect_error);\n&#125; \necho &quot;连接成功&quot;;\n?&gt;\n\n注意： 注意在以上面向对象的实例中 $connect_error 是在 PHP 5.2.9 和 5.3.0 中添加的。如果你需要兼容更早版本 请使用以下代码替换:  &#x2F;&#x2F; 检测连接 if (mysqli_connect_error()) {   die(“数据库连接失败: “ . mysqli_connect_error()); }\nMySQLi - 面向过程&lt;?php\n$servername &#x3D; &quot;localhost&quot;;\n$username &#x3D; &quot;username&quot;;\n$password &#x3D; &quot;password&quot;;\n \n&#x2F;&#x2F; 创建连接\n$conn &#x3D; mysqli_connect($servername, $username, $password);\n \n&#x2F;&#x2F; 检测连接\nif (!$conn) &#123;\n    die(&quot;Connection failed: &quot; . mysqli_connect_error());\n&#125;\necho &quot;连接成功&quot;;\n?&gt;\n\n\n\nPDO&lt;?php\n$servername &#x3D; &quot;localhost&quot;;\n$username &#x3D; &quot;username&quot;;\n$password &#x3D; &quot;password&quot;;\n \ntry &#123;\n    $conn &#x3D; new PDO(&quot;mysql:host&#x3D;$servername;&quot;, $username, $password);\n    echo &quot;连接成功&quot;; \n&#125;\ncatch(PDOException $e)\n&#123;\n    echo $e-&gt;getMessage();\n&#125;\n?&gt;\n\n\n\n\n\nMySQL基础知识链接\n连接数据库\n实例：&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    echo &quot;连接成功&quot;;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n\n创建数据库\n数据库存有一个或者多个表\n需要create 权限来创建或删除MySQL数据库\n创建数据库语句：create database name\n实例：&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    echo &quot;连接成功&quot;;\n    echo &quot;&lt;br&gt;&quot;;\n\n    &#x2F;&#x2F; 创建数据库语句\n    $sql &#x3D; &quot;CREATE DATABASE PHP&quot;; &#x2F;&#x2F; 创建一个PHP数据库\n\n    &#x2F;&#x2F; mysqli_query() 向MySQL数据库执行一条语句\n    if(mysqli_query($conn,$sql))&#123;\n        echo &quot;创建数据库 PHP成功&quot;;\n        &#125;\n    else&#123;\n        echo mysqli_error($conn);\n    &#125;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n运行后查看数据库是否添加\n\n创建数据表\n创建表的语句：create table \n实例：&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建数据表语句\n    $sql &#x3D; &quot;create table MyGuests (\n        id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, \n        firstname VARCHAR(30) NOT NULL,\n        lastname VARCHAR(30) NOT NULL,\n        email VARCHAR(50),\n        reg_date TIMESTAMP\n        )&quot;;\n     \n     &#x2F;&#x2F;向数据库执行sql语句\n     if(mysqli_query($conn,$sql))&#123;\n        echo &quot;创建数据表成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n     &#125; \n     else&#123;echo mysqli_error($conn);&#125;\n\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n运行截图数据库中的信息\n\n插入数据\n语法：insert into\n实例：&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建插入语句\n    $sql &#x3D; &quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES (&#39;John&#39;, &#39;Doe&#39;, &#39;john@example.com&#39;)&quot;;\n\n    &#x2F;&#x2F; 执行语句\n    if(mysqli_query($conn,$sql))&#123;\n        echo &quot;数据插入成功&quot;;\n    &#125;\n    else&#123;echo mysqli_error($conn);&#125;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n运行截图数据库中的信息\n\n插入多条数据\nmysqli_multi_query() 函数可用来执行多条SQL语句\n实例：&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建插入语句\n    $sql &#x3D; &quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES (&#39;pual&#39;, &#39;bei&#39;, &#39;pual@example.com&#39;);&quot;;\n    $sql .&#x3D; &quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES (&#39;Mary&#39;, &#39;Moe&#39;, &#39;mary@example.com&#39;);&quot;;\n    $sql .&#x3D; &quot;INSERT INTO MyGuests (firstname, lastname, email) VALUES (&#39;Julie&#39;, &#39;Dooley&#39;, &#39;julie@example.com&#39;)&quot;;\n\n    &#x2F;&#x2F; 一次性插入多条语句\n    if(mysqli_multi_query($conn,$sql))&#123;\n        echo &quot;添加记录成功&quot;;\n    &#125;\n    else&#123;echo mysqli_connect_error;&#125;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n运行截图数据库中的信息\n\n读取数据\nmysqli_num_rows() ：返回sql语句查询到的总行数\n\nmysqli_fetch_assoc() 函数从结果集中取得一行作为关联数组\n\n实例：\n&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建查询语句\n    $sql &#x3D; &quot;select id, firstname, lastname from MyGuests&quot;;\n    \n    $res &#x3D; mysqli_query($conn,$sql);\n\n    &#x2F;&#x2F; 返回sql语句查询到的总行数\n    &#x2F;&#x2F; mysqli_num_rows($res)\n\n    if(mysqli_num_rows($res) &gt; 0)&#123;\n        while($row &#x3D; mysqli_fetch_assoc($res))&#123;\n            echo &quot;id:&quot; . $row[&quot;id&quot;] . &quot;-name:&quot; . $row[&quot;firstname&quot;] . &quot; &quot; .$row[&#39;lastname&#39;].&quot;&lt;br&gt;&quot;;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n运行截图\n\nmysqli_fetch_assoc()函数和mysqli_num_rows()函数的测试代码\n&lt;?php\n    &#x2F;&#x2F; 创建连接\n&#x2F;&#x2F; $conn &#x3D; mysqli_connect($servername, $username, $password);\n    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;,&#39;root&#39;,&#39;PHP&#39;);\n\n    &#x2F;&#x2F; 检测连接\n    if(!$conn)&#123;\n        die(mysqli_connect_error());\n    &#125;\n    else&#123;\n        echo &quot;连接成功&quot;;\n        echo &quot;&lt;br&gt;&quot;;\n    &#125;\n\n    &#x2F;&#x2F; 创建查询语句\n    $sql &#x3D; &quot;select id, firstname, lastname from MyGuests&quot;;\n    \n    $res &#x3D; mysqli_query($conn,$sql);\n\n    &#x2F;&#x2F; 返回sql语句查询到的总行数\n    $row &#x3D; mysqli_num_rows($res) . &quot;&lt;br&gt;&quot;;\n\n    &#x2F;&#x2F; mysqli_fetch_assoc() 函数从结果集中取得一行作为关联数组\n\n    if($row &gt; 0)&#123;\n        while($i &#x3D; mysqli_fetch_assoc($res))&#123;\n            var_dump($i);\n            echo &quot;&lt;br&gt;&quot;;\n            \n            echo &quot;序列号为：&quot; . $i[&#39;id&#39;] . &quot;, firstname为：&quot; . $i[&#39;firstname&#39;] . &quot;, lastname为：&quot; . $i[&#39;lastname&#39;];\n            echo &quot;&lt;hr&gt;&quot;;\n        &#125;\n    &#125;\n\n\n    &#x2F;&#x2F;关闭连接\n    mysqli_close($conn); \n?&gt;\n\n","slug":"04PHP连接MySQL数据库","date":"2022-11-10T11:28:27.559Z","categories_index":"学习笔记","tags_index":"php","author_index":"Abyssaler"},{"id":"e635c3e685c2a214ead8e396e5b6c265","title":"PHP文件","content":"文件处理fopen() 函数用于在 PHP 中打开文件。\n打开文件fopen() 函数用于在 PHP 中打开文件。\n此函数的第一个参数含有要打开的文件的名称，第二个参数规定了使用哪种模式来打开文件：\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n$file&#x3D;fopen(&quot;welcome.txt&quot;,&quot;r&quot;);\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n文件可能通过下列模式来打开：\n\n\n\n模式\n描述\n\n\n\nr\n只读。在文件的开头开始。\n\n\nr+\n读&#x2F;写。在文件的开头开始。\n\n\nw\n只写。打开并清空文件的内容；如果文件不存在，则创建新文件。\n\n\nw+\n读&#x2F;写。打开并清空文件的内容；如果文件不存在，则创建新文件。\n\n\na\n追加。打开并向文件末尾进行写操作，如果文件不存在，则创建新文件。\n\n\na+\n读&#x2F;追加。通过向文件末尾写内容，来保持文件内容。\n\n\nx\n只写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。\n\n\nx+\n读&#x2F;写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。\n\n\n注释：如果 fopen() 函数无法打开指定文件，则返回 0 (false)\n如果 fopen() 函数不能打开指定的文件，下面的实例会生成一段消息\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;?php\n$file&#x3D;fopen(&quot;welcome.txt&quot;,&quot;r&quot;) or exit(&quot;Unable to open file!&quot;);\n?&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n关闭文件fclose() 函数用于关闭打开的文件\n&lt;?php\n$file &#x3D; fopen(&quot;test.txt&quot;,&quot;r&quot;);\n\n&#x2F;&#x2F;执行一些代码\n\nfclose($file);\n?&gt;\n\n\n\n逐行读取文件fgets() 函数用于从文件中逐行读取文件。\n注释：在调用该函数之后，文件指针会移动到下一行。\n&lt;?php\n$file &#x3D; fopen(&quot;welcome.txt&quot;, &quot;r&quot;) or exit(&quot;无法打开文件!&quot;);\n&#x2F;&#x2F; 读取文件每一行，直到文件结尾\nwhile(!feof($file))\n&#123;\n    echo fgets($file). &quot;&lt;br&gt;&quot;;\n&#125;\nfclose($file);\n?&gt;\n\n\n\n逐字符读取文件fgetc() 函数用于从文件中逐字符地读取文件。\n注释：在调用该函数之后，文件指针会移动到下一个字符。\n实例下面的实例逐字符地读取文件，直到文件末尾为止\n&lt;?php\n$file&#x3D;fopen(&quot;welcome.txt&quot;,&quot;r&quot;) or exit(&quot;无法打开文件!&quot;);\nwhile (!feof($file))\n&#123;\n    echo fgetc($file);\n&#125;\nfclose($file);\n?&gt;\n\n\n\n\n\n\n\n文件上传表单通过 PHP，可以把文件上传到服务器\ntest 项目下完成，目录结构为：\ntest\n|-----upload             # 文件上传的目录\n|-----form.html          # 表单文件\n|-----upload_file.php    # php 上传代码\n\n\n\n创建一个文件上传表单form.html\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n&lt;title&gt;表单&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n&lt;form action&#x3D;&quot;upload_file.php&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;\n    &lt;label for&#x3D;&quot;file&quot;&gt;文件名：&lt;&#x2F;label&gt;\n    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; id&#x3D;&quot;file&quot;&gt;&lt;br&gt;\n    &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n&lt;&#x2F;form&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n创建上传脚本“upload_file.php” 文件含有供上传文件的代码\n&lt;?php\nif ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0)\n&#123;\n    echo &quot;错误：&quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br&gt;&quot;;\n&#125;\nelse\n&#123;\n    echo &quot;上传文件名: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br&gt;&quot;;\n    echo &quot;文件类型: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br&gt;&quot;;\n    echo &quot;文件大小: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] &#x2F; 1024) . &quot; kB&lt;br&gt;&quot;;\n    echo &quot;文件临时存储的位置: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];\n&#125;\n?&gt;\n\n\n\n通过使用 PHP 的全局数组 $_FILES，你可以从客户计算机向远程服务器上传文件。\n第一个参数是表单的 input name，第二个下标可以是 “name”、”type”、”size”、”tmp_name” 或 “error”。如下所示：\n\n$_FILES[“file”][“name”] - 上传文件的名称\n$_FILES[“file”][“type”] - 上传文件的类型\n$_FILES[“file”][“size”] - 上传文件的大小，以字节计\n$_FILES[“file”][“tmp_name”] - 存储在服务器的文件的临时副本的名称\n$_FILES[“file”][“error”] - 由文件上传导致的错误代码\n\n这是一种非常简单文件上传方式。基于安全方面的考虑，您应当增加有关允许哪些用户上传文件的限制。\n","slug":"03PHP文件","date":"2022-11-10T11:28:27.558Z","categories_index":"学习笔记","tags_index":"php","author_index":"Abyssaler"},{"id":"befd9437c19ef7fdb68a823928ac2872","title":"PHP表单","content":"PHP 中的 $_GET 和 $_POST 变量用于检索表单中的信息，比如用户输入\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n&lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n \n&lt;form action&#x3D;&quot;welcome.php&quot; method&#x3D;&quot;post&quot;&gt;\n名字: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;fname&quot;&gt;\n年龄: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;age&quot;&gt;\n&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;\n&lt;&#x2F;form&gt;\n \n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n用户填写完上面的表单并点击提交按钮时，表单的数据会被送往名为 “welcome.php” 的 PHP 文件\n欢迎&lt;?php echo $_POST[&quot;fname&quot;]; ?&gt;!&lt;br&gt;\n你的年龄是 &lt;?php echo $_POST[&quot;age&quot;]; ?&gt;  岁。\n\n","slug":"02PHP表单","date":"2022-11-10T11:28:27.556Z","categories_index":"学习笔记","tags_index":"php","author_index":"Abyssaler"}]